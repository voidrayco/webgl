{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap bda8d42c38c8045a3118","webpack:///external \"three\"","webpack:///./src/webgl-surface/util/buffer-util.ts","webpack:///./src/webgl-surface/buffers/base-buffer.ts","webpack:///external \"ramda\"","webpack:///./src/webgl-surface/primitives/bounds.ts","webpack:///./node_modules/debug/src/browser.js","webpack:///./src/webgl-surface/primitives/point.ts","webpack:///./src/webgl-surface/primitives/line.ts","webpack:///./src/webgl-surface/util/interpolation.ts","webpack:///./src/webgl-surface/drawing/shape/curved-line-shape.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-texture.ts","webpack:///./src/webgl-surface/util/frame-info.ts","webpack:///./src/webgl-surface/util/webgl-stat.ts","webpack:///./src/webgl-surface/util/easing.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-manager.ts","webpack:///./src/webgl-surface/util/pack-node.ts","webpack:///./src/webgl-surface/drawing/shape/label.ts","webpack:///./src/webgl-surface/primitives/rotateable-quad.ts","webpack:///./src/webgl-surface/drawing/texture/sprite.ts","webpack:///./src/webgl-surface/util/mouse.ts","webpack:///./src/webgl-surface/util/quad-tree.ts","webpack:///./src/webgl-surface/primitives/curved-line.ts","webpack:///./src/webgl-surface/primitives/circle.ts","webpack:///./src/webgl-surface/drawing/shape/line-shape.ts","webpack:///./src/webgl-surface/util/multi-shape-buffer-cache.ts","webpack:///./src/webgl-surface/util/shape-buffer-cache.ts","webpack:///./src/index.ts","webpack:///./src/webgl-surface/webgl-surface.tsx","webpack:///external \"react\"","webpack:///external \"d3-color\"","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/debug/src/debug.js","webpack:///./node_modules/ms/index.js","webpack:///external \"bowser\"","webpack:///./src/webgl-surface/buffers/index.ts","webpack:///./src/webgl-surface/buffers/animated/shared-control-curved-line-buffer-ants.ts","webpack:///./src/webgl-surface/buffers/animated/shared-control-curved-line-colors-buffer.ts","webpack:///./src/webgl-surface/buffers/animated/uniform-instance-arc-buffer-ants.ts","webpack:///./src/webgl-surface/buffers/static/shared-control-curved-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-bezier-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-circle-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-label-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-straight-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/uniform-instance-arc-buffer.ts","webpack:///./src/webgl-surface/buffers/static/uniform-instance-edge-buffer.ts","webpack:///./src/webgl-surface/buffers/static/uniform-ribbon-buffer.ts","webpack:///./src/webgl-surface/drawing/index.ts","webpack:///./src/webgl-surface/drawing/reference/reference-color.ts","webpack:///./src/webgl-surface/drawing/animation/animated-curved-line-shape.ts","webpack:///./src/webgl-surface/drawing/shape/circle-shape.ts","webpack:///./src/webgl-surface/drawing/shape/curved-edge-shape.ts","webpack:///./src/webgl-surface/drawing/shape/edge-shape.ts","webpack:///./src/webgl-surface/drawing/shape/image-shape.ts","webpack:///./src/webgl-surface/drawing/shape/quad-shape.ts","webpack:///./src/webgl-surface/drawing/shape/ribbon-shape.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-color.ts","webpack:///./src/webgl-surface/primitives/index.ts","webpack:///./src/webgl-surface/util/index.ts","webpack:///./src/webgl-surface/util/animate.ts","webpack:///./src/webgl-surface/util/animated-shape-buffer-cache.ts","webpack:///./src/webgl-surface/util/custom-selection.ts","webpack:///./src/webgl-surface/util/get-font-metrics.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_28__","__WEBPACK_EXTERNAL_MODULE_29__","__WEBPACK_EXTERNAL_MODULE_33__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","applyAttributeRegisters","attributeBuffers","incrementValues","attrRegister0","attrRegister1","attrRegister2","attrRegister3","attrRegister4","attrRegister5","attrRegister6","attrRegister7","attrRegister8","attrRegister9","attrRegister10","attrIndexIncr0","attrIndexIncr1","attrIndexIncr2","attrIndexIncr3","attrIndexIncr4","attrIndexIncr5","attrIndexIncr6","attrIndexIncr7","attrIndexIncr8","attrIndexIncr9","attrIndexIncr10","updateBuffer1","numBatches","updateAccessor","lastBatchRegister","attrIndex0","updateBuffer2","attrIndex1","updateBuffer3","attrIndex2","updateBuffer4","attrIndex3","updateBuffer5","attrIndex4","updateBuffer6","attrIndex5","updateBuffer7","attrIndex6","updateBuffer8","attrIndex7","updateBuffer9","attrIndex8","updateBuffer10","attrIndex9","updateBuffer11","attrIndex10","applyDefaultsHolders","defaults","defaultsHolder0","defaultsHolder1","defaultsHolder2","defaultsHolder3","fillSize1","buffer","start","fillSize2","fillSize3","fillSize4","isList","val","Array","isArray","value","three_1","webgl_stat_1","debugGenerator","debug","TriangleOrientation","AttributeSize","UniformAttributeSize","isStreamUpdatingRegister","fillMethodLookUp","_a","ONE","TWO","THREE","FOUR","updateBufferLookUp","1","2","3","4","5","6","7","8","9","10","11","BufferUtil","beginUpdates","dispose","buffers","forEach","bufferItems","attributes","currentData","geometry","system","endUpdates","totalBatches","examineBuffer","message","debugNamespace","debugBuffer","enabled","bufferAttributes","map","attr","array","triangles","drawMode","TrianglesDrawMode","currentVertex_1","attrSize_1","currentIndex_1","length_1","drawRange","count","tri","vertex_0","vertex_1","vertex_2","index","size","slice","push","TriangleStripDrawMode","currentVertex_2","attrSize_2","currentIndex_2","length_2","material","uniforms","flattenMultiBuffers","multiShapeBuffers","all","multiBuffer","getBuffers","concat","updateMultiBuffer","multiShapeBuffer","init","update","forceUpdates","shapeBuffers","didUpdate","reduce","flat","toFlatten","bufferLookup","Map","set","needsBuffer","shapes","delete","length","shift","shapeBuffer","vertexBuffer","vertexBuffers_1","from","values","setDrawRange","makeBuffer","numVertices","iMax","BufferGeometry","totalAttributeSize","foundPosition","attribute","attributeSize","name_1","injectBuffer","Float32Array","fillMethod","customFill","k","BufferAttribute","setDynamic","addAttribute","console","warn","shareBuffer","sharedBuffer","newBuffer","_i","attributes_1","shareAttribute","makeUniformBuffer","maxBlock","uniformBufferBlockMax","WebGLStat","MAX_VERTEX_INSTANCE_DATA","sizeCheck","uniform","Math","max","block","Vector4","blocksPerInstance","maxInstances","floor","updateBuffer","newData","vertexBatch","force","testPerformed","undefined","updateMethod","updateRange","offset","itemSize","needsUpdate","updateUniformBuffer","instanceBatchSize","instanceData","type","uniformBuffer","uniformAttributes","currentInstance","currentInstanceStartBlock","updateArguments","attributes_2","apply","makeBufferItems","buffer_util_1","BaseBuffer","unitCount","Bounds","left","right","top","bottom","height","width","x","y","arguments","containsPoint","point","copyBounds","b","encapsulate","bounds","encapsulateBounds","sizeToFirst","minX","Number","MAX_VALUE","maxX","minY","maxY","encapsulatePoint","encapsulatePoints","points","fits","inner","hitBounds","pointInside","isBounds","isInside","maxBounds","MIN_VALUE","process","useColors","window","document","documentElement","style","WebkitAppearance","firebug","exception","table","navigator","userAgent","toLowerCase","match","parseInt","RegExp","$1","formatArgs","args","namespace","humanize","diff","color","splice","lastC","replace","log","Function","save","namespaces","storage","removeItem","e","load","r","env","DEBUG","chrome","local","localStorage","colors","formatters","j","v","JSON","stringify","err","enable","squareDistance","p1","p2","dx","dy","Point","add","out","getClosest","testPoint","distance","closestDistance","closestPoint","findClosest","getClosestIndex","getDirection","normalize","magnitude","sqrt","getDistance","squared","getMidpoint","direction","make","scale","zero","__extends","extendStatics","setPrototypeOf","__proto__","__","constructor","create","bounds_1","Line","_super","_this","setPoints","directionTo","vector","perpendicular","distanceTo","abs","lines","closestLine","line","slope","mag","bezier2","t","c1","t2","mt","mt2","bezier3","c2","t3","mt3","circular","radiusEasing","direction1","point_1","theta1","atan2","direction2","theta2","PI","dTheta","radius1","radius2","radius","easing_1","linear","cos","sin","InterpolationMethod","pickInterpolation","BEZIER2","BEZIER3","CIRCULAR","getAngle","center","atan","curved_line_1","line_1","CurvedLineShape","options","depth","lineWidth","cachesQuadSegments","cacheSegments","getTriangleStrip","startColor","endColor","marchingAnts","clone","cachesSegments","controlPoints","end","resolution","cachedQuadSegments","strip","normal","lineStrip","getLineStrip","lineWidthHalf","scaledPoint","temp","previous","current","CurveType","CircularCW","CircularCCW","radiusSquare","pow","distanceSquare","lineWidthSquare","angle","startAngle","endAngle","Bezier","CurvedLine","AtlasTexture","path","label","aspectRatio","imagePath","rasterizedLabel","getAttributeCurrentTime","time","FrameInfo","lastFrameTime","Date","now","nextFrameTime","framesPlayed","getProgramInfo","gl","program","result","attributeCount","uniformCount","activeUniforms","getProgramParameter","ACTIVE_UNIFORMS","activeAttributes","ACTIVE_ATTRIBUTES","enums","35664","35665","35666","35667","35668","35669","35670","35671","35672","35673","35674","35675","35676","35678","35680","5120","5121","5122","5123","5124","5125","5126","blocks","getActiveUniform","typeName","getActiveAttrib","printCurrentProgramInfo","surface","info","getParameter","CURRENT_PROGRAM","MAX_VERTEX_UNIFORMS","MAX_FRAGMENT_UNIFORMS","MAX_ATTRIBUTES","WEBGL_SUPPORTED","canvas","createElement","WebGLRenderingContext","getContext","MAX_VERTEX_UNIFORM_VECTORS","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_VERTEX_ATTRIBS","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","a","asin","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","done","then","__generator","body","verb","op","f","TypeError","_","ops","pop","trys","g","sent","throw","return","Symbol","iterator","d3_color_1","pack_node_1","label_1","atlas_texture_1","debugLabels","ZERO_IMAGE","atlasBL","atlasBR","atlasTL","atlasTR","Label","text","pixelHeight","pixelWidth","AtlasManager","atlasImages","atlasMap","atlasTexture","textureWidth","textureHeight","createAtlas","atlasName","images","images_1","image","texture","_b","PackNode","draw","drawColors","Texture","premultiplyAlpha","generateMipmaps","destroyAtlas","destroy","none_1","atlasReferenceID","isValidImage","isValid","setDefaultImage","assign","loadedImage","rect","dimensions","node","insertedNode","ux","uy","uw","uh","atlasDimensions","loadImage","first","second","insert","nodeImage","nodeDimensions","drawImage","error","colorWidth","colorHeight","maxPerRow","rowWidth","rowCount","colCount","renderHeight","renderSpace","startX","startY","nextX","nextY","beginX","beginY","col","row","colors_1","min","ceil","colorIndex","colorsPerRow","firstColor","nextColor","fillStyle","round","opacity","fillRect","Error","getAtlasTexture","Image","onload","onerror","src","labelSize","getSize","ctx","rasterizationOffset","fontSize","rgb","base","font","makeCSSFont","textAlign","textBaseline","toString","fillText","truncatedText","image_1","setSize","toDataURL","child","isLeaf","hasChild","newNode","fitFlag","imgWidth","imgHeight","dWidth","dHeight","remove","removed","ramda_1","rotateable_quad_1","sprite_1","measurement","Sprite","AnchorPosition","TopLeft","fontWeight","maxWidth","id","allowScaling","rasterizationPadding","setFontSize","_baseLabel","baseLabel","_rasterizedLabel","copyLabel","omit","setText","getText","position","lbl","baseSize","context","size_1","measureText","threeDotsWide","str","truncatedWidth","beyondMax","substring","RotateableQuad","anchorCalculations","BottomLeft","quad","BottomRight","Custom","Middle","MiddleBottom","MiddleLeft","MiddleRight","MiddleTop","TopRight","location","rotation","anchor","setAnchor","setLocation","setRotation","calculateAnchor","custom","anchorType","getAnchor","getAnchorType","getLocation","getRotation","anchorMat","Matrix4","makeTranslation","rotationMat","makeRotationZ","locationMat","transform","multiply","TL","applyMatrix4","TR","BL","BR","w","h","contentScaleX","contentScaleY","scaleX","scaleY","getContentScale","getContentSize","getWidth","getHeight","normalizeFirefoxWheel","wheel","nativeEvent","deltaX","deltaY","sign","lowPassY","MAX_FIREFOX_WHEELDELTA","LOW_PASS_U0","LOW_PASS_U1","LOW_PASS_U2","LOW_PASS_U3","unshift","Vector2","normalizeChromeWheel","normalizeIE11Wheel","wheelDeltaX","IE_ADJUSTMENT","wheelDeltaY","wheelDelta","detail","OLD_IE_ADJUSTMENT","normalizeIE12Wheel","multiplyScalar","eventElementPosition","relative","mouseX","mouseY","eventX","eventY","target","event","pageX","pageY","clientX","clientY","scrollLeft","scrollTop","offsetParent","offsetLeft","offsetTop","normalizeWheel","browser","firefox","msie","version","msedge","filterQuery","queryValues","filtered","obj","find","Quadrants","mid","Node","children","childrenProps","nodes","props","doAdd","cover","addAll","allChildren","gatherChildren","split","isNaN","area","list","gatherProps","query","visit","queryBounds","queryPoint","cb","finished","Boolean","QuadTree","bezierDistance","straightLine","closestIndex","circularDistance","straightDistance","makeBezier2Segments","cachedSegments","segments","dt","lineEnd","interpolation_1","makeBezier3Segments","makeCircularCWSegments","circleCenter","midPoint","minRadius","makeCircularCCWSegments","makeStraightSegments","pickSegmentMethod","Straight","pickDistanceMethod","distanceMethod","segmentMethod","segmentMethods","numControlPoints","UID","Circle","_id","_radius","_centerX","_centerY","centerX","centerY","updateBounds","boundsInside","r2","dy2","dx2","notSquared","circles","closestCircle","circle","hitCircle","totalDistance","hitPoint","LineShape","thickness","newProperties","getIDProp","item","evenRoundRobinBufferAdd","smallest","found","some","tracker","noop","echoBuffer","shape_buffer_cache_1","multiBufferSelectionPrefix","multiBufferSelectionKeyUID","MultiShapeBufferCache","numBuffers","methods","selectionUID","addMethod","idMethod","initMethod","removeMethod","addShape","shape","store","allBuffers","idToItem","itemToBuffer","flagBuffersDirty","selection","clearSelection","containsId","containsShape","isDirty","generate","getStorage","processDirtyBuffers","getBuffer","getNumBuffers","getShapeById","getSelection","select","removeShape","indexOf","updateShape","ShapeBufferCache","bustCache","buildCache","__export","isAnimatedWithOptions","isAnimated","BaseApplyPropsMethods","React","atlas_manager_1","frame_info_1","mouse_1","quad_tree_1","debugCam","debugColors","BaseAnimatedMethods","BACKGROUND_COLOR","Color","setRGB","Vector3","WebGLSurface","atlasManager","atlasNames","labels","animatedMethodList","animatedMethodBreak","camera","OrthographicCamera","colorsCurrentLoadedId","colorsLoadId","disableMouseInteraction","sizeCamera","currentZoom","destinationX","destinationY","destinationZoom","isPanning","lastMousePosition","propsMethodList","inertia","inertiaBuild","inertiaDecay","inertiaMax","quadTree","shiftIsDown","stop","currentX","currentY","targetZoom","previousZoomToFit","zoomTargetX","zoomTargetY","animating","labelsReady","labelsCurrentLoadedId","labelsLoadId","colorsReady","isRenderReady","currentHoverItems","dragOver","animate","requestAnimationFrame","response","doDraw","method","break","updateCameraUniforms","forceDraw","emitViewport","applyProps","el","scene","renderEl","heightHalf","widthHalf","initCamera","Scene","initBuffers","renderer","WebGLRenderer","alpha","backgroundColor","antialias","preserveDrawingBuffer","setPixelRatio","devicePixelRatio","setClearColor","setFaceCulling","CullFaceNone","appendChild","domElement","makeDraggable","getElementById","viewSize","viewport","far","near","z","resizeContext","renderSize","zoom","updateProjectionMatrix","tl","screenToWorld","br","updateMatrixWorld","visible","onViewport","projection","handleMouseDown","onMouseDown","handleMouseOut","onMouseOut","handleMouseUp","mouse","world","hitInside","hitItems","hitItems_1","onMouseUp","handleMouseMove","onMouse","xDistance","yDistance","pan","willPan","maxInertia","hitItems_2","onMouseHover","onMouseLeave","applyRef","animatedMethods","baseAnimatedMethods","orderedBaseAnimatedMethods","animatedMethodsBase","CONTEXT","INERTIA","POSITION","positionCamera","ZOOM","destZoom","dZoom","screenZoomTarget","worldToScreen","zoomCamera","newScreenZoomTarget","zoomDX","zoomDY","applyColorBufferChanges","applyLabelBufferChanges","applyPropsMethods","basePropsMethods","orderedBasePropsMethods","applyPropsMethodsBase","INITIALIZE","oldColor","LABELS","textures","COLORS","BUFFERCHANGES","applyBufferChanges","CAMERA","appliedViewport","zoomToFitViewH","zoomToFitViewV","zoomToFit","onZoomRequest","componentDidMount","componentWillMount","screenSizeToWorld","bind","worldSizeToScreen","componentWillReceiveProps","componentWillUnmount","render","onRender","imageData","element","stage","onmousedown","onmousemove","distanceX","distanceY","onmouseup","onmouseover","onselectstart","unproject","project","merge","shouldComponentUpdate","nextProps","onMouseMove","onDoubleClick","ref","Component","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","nextTick","title","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","selectColor","hash","charCodeAt","createDebug","self","curr","ms","prevTime","prev","coerce","format","formatter","names","skips","substr","disable","test","stack","parse","String","exec","parseFloat","fmtShort","fmtLong","plural","long","isCluster","base_buffer_1","SharedControlCurvedLineBufferAnts","numQuads","Mesh","frustumCulled","controlPointSource","flatten","controlUniform","controlReference","colorRef","colorBase","atlas","colorAtlas","colorStart","colorEnd","antLength","antGap","antSpeed","controlPoint","controlRef","halfWidthSize","this_1","buffer_1","curvedLine","gapLength","speed","strokeLength","controlLength","positions","ppos","scpos","ecpos","normals","npos","endPoints","epos","halfWidth","wpos","marching","mpos","controlPick","cpos","SharedControlCurvedLineColorsBuffer","colorStartStop","colorEndStop","startTime","duration","shapeBuffer_1","endColorStop","startColorStop","currentStart","currentEnd","colorPicks","ctpos","timing","tpos","UniformInstanceArcBufferAnts","shared","VERTICES_PER_SEGMENT","instance","halfLineWidth","maxResolution","endpoints","curve","SharedControlCurvedLineBuffer","SimpleStaticBezierLineBuffer","copos","SimpleStaticCircleBuffer","Points","outerColor","rpos","innerRadius","irpos","innerColor","icpos","SimpleStaticLabelBuffer","startFade","endFade","labelMaxSize","labelBase","texture_1","anisotropy","maxLabelSize","updated","texCoords","sizes","spos","anchors","apos","SimpleStaticLineBuffer","stripPos","SimpleStaticStraightLineBuffer","UniformInstanceArcBuffer","UniformInstanceEdgeBuffer","startWidth","endWidth","UniformRibbonBuffer","endPoints1","endPoints2","centers","threshold","ribbon","start2","end2","center1","center2","ReferenceColor","curved_line_shape_1","AnimatedCurvedLineShape","easing","_startColorChange","_endColorChange","startStop","endStop","_currentStartColor","_currentEndColor","_startColorStop","startBase","newBase","_endColorStop","endBase","easedTime","circle_1","CircleShape","CurvedEdgeShape","line_shape_1","EdgeShape","bl","tr","testx","testy","numberVertices","isClockwise","p1Dx","p2Dx","p1DeltaX","p1DeltaY","p2DeltaX","p2DeltaY","topEdge","bottomEdge","ImageShape","centerOn","QuadShape","RibbonShape","getRibbonStrip","nvert","AtlasColor","PlayState","Animate","playState","PLAY","propToItem","cancel","container","prop","ease","multi_shape_buffer_cache_1","AnimatedShapeBufferCache","INIT","doAnimate","STOP","boolMapToArray","filter","CustomSelection","cachedSelection","selections","_didSelectionChange","clearAllSelections","keys","key","category","deselect","selectionMap","didSelectionCategoryChange","didSelectionChange","finalizeUpdate","theSelection","toggleSelect","getFontMetrics","bboxHeight","canvasHeight","baseline","flip","drawBaseline","fontFamily","textWidth","offsetx","offsety","cwidth","cheight","getImageData","data","pos","realBottom","restore"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"ramda\", \"react\", \"d3-color\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"voidgl\"] = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse\n\t\troot[\"voidgl\"] = factory(root[\"three\"], root[\"ramda\"], root[\"react\"], root[\"d3-color\"], root[\"bowser\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_33__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"ramda\", \"react\", \"d3-color\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"voidgl\"] = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse\n\t\troot[\"voidgl\"] = factory(root[\"three\"], root[\"ramda\"], root[\"react\"], root[\"d3-color\"], root[\"bowser\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_33__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * This class and set of methods is provided to attempt to create as efficient as possible\n * methods for updating large vertex buffers with values. The first portion of the file is\n * a list of methods and registers. This is to prevent any instantiation needed for the methods\n * and registers to exist. Also, the methods have no useable parent scope to ensure nothing like\n * a 'this' is used. These methods utilize the registers and their own simple loops to pound\n * through large amounts of information while providing capabilities to edit vertices in batches.\n *\n * You will also notice there are many many similar methods with just a single extra parameter\n * here and there. This is to prevent ANY calculations on trying to determine a proper parameter set\n * while also making method calls directly without any .call or .apply.\n *\n * The number of update methods is how many differing attributes are supported. If you need more supported\n * attributes add an updateBufferN method and provide the required attributes. Insert the logic in the EXACT\n * pattern seen in the other methods. DO NOT attempt to add additional logic lest the performance be something\n * terrible.\n *\n * The BufferUtil class makes use of these methods and registers. It also provides some very handy methods\n * for working with your large buffers.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar webgl_stat_1 = __webpack_require__(12);\nvar debugGenerator = __webpack_require__(5);\nvar debug = __webpack_require__(5)('WebGLSurface:BufferUtil');\nvar TriangleOrientation;\n(function (TriangleOrientation) {\n    // The triangles points are clockwise\n    TriangleOrientation[TriangleOrientation[\"CW\"] = 0] = \"CW\";\n    // The triangles points are Counter clockwise\n    TriangleOrientation[TriangleOrientation[\"CCW\"] = 1] = \"CCW\";\n    // The triangles points are linear, thus degenerate\n    TriangleOrientation[TriangleOrientation[\"DEGENERATE\"] = 2] = \"DEGENERATE\";\n})(TriangleOrientation = exports.TriangleOrientation || (exports.TriangleOrientation = {}));\nvar AttributeSize;\n(function (AttributeSize) {\n    AttributeSize[AttributeSize[\"ONE\"] = 0] = \"ONE\";\n    AttributeSize[AttributeSize[\"TWO\"] = 1] = \"TWO\";\n    AttributeSize[AttributeSize[\"THREE\"] = 2] = \"THREE\";\n    AttributeSize[AttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(AttributeSize = exports.AttributeSize || (exports.AttributeSize = {}));\nvar UniformAttributeSize;\n(function (UniformAttributeSize) {\n    UniformAttributeSize[UniformAttributeSize[\"ONE\"] = 0] = \"ONE\";\n    UniformAttributeSize[UniformAttributeSize[\"TWO\"] = 1] = \"TWO\";\n    UniformAttributeSize[UniformAttributeSize[\"THREE\"] = 2] = \"THREE\";\n    UniformAttributeSize[UniformAttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(UniformAttributeSize = exports.UniformAttributeSize || (exports.UniformAttributeSize = {}));\n/**\n * These are for fast look ups of the default values provided\n * Doing this fashion avoids array look ups in the defaults values\n */\nvar defaultsHolder0 = 0;\nvar defaultsHolder1 = 0;\nvar defaultsHolder2 = 0;\nvar defaultsHolder3 = 0;\n/**\n * These are for fast look ups of attribute buffers that are going\n * through the update process. We do everything to mitigate array look ups\n * when and where we can\n */\nvar attrRegister0 = [];\nvar attrRegister1 = [];\nvar attrRegister2 = [];\nvar attrRegister3 = [];\nvar attrRegister4 = [];\nvar attrRegister5 = [];\nvar attrRegister6 = [];\nvar attrRegister7 = [];\nvar attrRegister8 = [];\nvar attrRegister9 = [];\nvar attrRegister10 = [];\nvar attrIndex0 = 0;\nvar attrIndex1 = 0;\nvar attrIndex2 = 0;\nvar attrIndex3 = 0;\nvar attrIndex4 = 0;\nvar attrIndex5 = 0;\nvar attrIndex6 = 0;\nvar attrIndex7 = 0;\nvar attrIndex8 = 0;\nvar attrIndex9 = 0;\nvar attrIndex10 = 0;\nvar attrIndexIncr0 = 0;\nvar attrIndexIncr1 = 0;\nvar attrIndexIncr2 = 0;\nvar attrIndexIncr3 = 0;\nvar attrIndexIncr4 = 0;\nvar attrIndexIncr5 = 0;\nvar attrIndexIncr6 = 0;\nvar attrIndexIncr7 = 0;\nvar attrIndexIncr8 = 0;\nvar attrIndexIncr9 = 0;\nvar attrIndexIncr10 = 0;\n/** This is used to define a starting batch location to aid in continuing batch updates */\nvar lastBatchRegister = 0;\nvar isStreamUpdatingRegister = false;\n/**\n * This takes our list of attribute buffers and applies them to the registers for rapid lookups\n *\n * @param {number[][]} attributeBuffers The buffers for each attribute to be updated\n * @param {number[]} incrementValues How much each batch increments it's lookup index\n */\nfunction applyAttributeRegisters(attributeBuffers, incrementValues) {\n    attrRegister0 = attributeBuffers[0];\n    attrRegister1 = attributeBuffers[1];\n    attrRegister2 = attributeBuffers[2];\n    attrRegister3 = attributeBuffers[3];\n    attrRegister4 = attributeBuffers[4];\n    attrRegister5 = attributeBuffers[5];\n    attrRegister6 = attributeBuffers[6];\n    attrRegister7 = attributeBuffers[7];\n    attrRegister8 = attributeBuffers[8];\n    attrRegister9 = attributeBuffers[9];\n    attrRegister10 = attributeBuffers[10];\n    attrIndexIncr0 = incrementValues[0];\n    attrIndexIncr1 = incrementValues[1];\n    attrIndexIncr2 = incrementValues[2];\n    attrIndexIncr3 = incrementValues[3];\n    attrIndexIncr4 = incrementValues[4];\n    attrIndexIncr5 = incrementValues[5];\n    attrIndexIncr6 = incrementValues[6];\n    attrIndexIncr7 = incrementValues[7];\n    attrIndexIncr8 = incrementValues[8];\n    attrIndexIncr9 = incrementValues[9];\n    attrIndexIncr10 = incrementValues[10];\n}\n/**\n * The following methods are targetted at executing the update accessor with varying number\n * of parameters while mitigating array look ups.\n *\n * @param {number} numBatches The number of batches to execute\n * @param {Function} updateAccessor The accessor function that will update the buffer values\n */\nfunction updateBuffer1(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0);\n    }\n}\nfunction updateBuffer2(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1);\n    }\n}\nfunction updateBuffer3(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2);\n    }\n}\nfunction updateBuffer4(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3);\n    }\n}\nfunction updateBuffer5(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4);\n    }\n}\nfunction updateBuffer6(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5);\n    }\n}\nfunction updateBuffer7(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6);\n    }\n}\nfunction updateBuffer8(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7);\n    }\n}\nfunction updateBuffer9(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8);\n    }\n}\nfunction updateBuffer10(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9);\n    }\n}\nfunction updateBuffer11(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        attrIndex10 = i * attrIndexIncr10;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9, attrRegister10, attrIndex10);\n    }\n}\n/**\n * This takes the defaults array provided and loads them into our default\n * lookup values\n *\n * @param {number[]} defaults The array with the default values in them for our buffer attribute\n */\nfunction applyDefaultsHolders(defaults) {\n    defaultsHolder0 = defaults[0] || 0;\n    defaultsHolder1 = defaults[1] || 0;\n    defaultsHolder2 = defaults[2] || 0;\n    defaultsHolder3 = defaults[3] || 0;\n}\n/**\n * The following methods are rapid ways of populating the buffer without\n * setting up a generic loop. This saves on performance by not creating a loop\n * nor allocating the variables necessary for the generic loop.\n *\n * @param {Float32Array} buffer The buffer to populate\n * @param {number} start The index the data should be populated into\n */\nfunction fillSize1(buffer, start) {\n    buffer[start] = defaultsHolder0;\n}\nfunction fillSize2(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n}\nfunction fillSize3(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n}\nfunction fillSize4(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n    buffer[++start] = defaultsHolder3;\n}\nfunction isList(val) {\n    if (Array.isArray(val))\n        return true;\n    return false;\n}\n/**\n * This is a quick lookup to find the correct filler method for the given attribute size\n */\nvar fillMethodLookUp = (_a = {},\n    _a[AttributeSize.ONE] = fillSize1,\n    _a[AttributeSize.TWO] = fillSize2,\n    _a[AttributeSize.THREE] = fillSize3,\n    _a[AttributeSize.FOUR] = fillSize4,\n    _a);\nvar updateBufferLookUp = {\n    1: updateBuffer1,\n    2: updateBuffer2,\n    3: updateBuffer3,\n    4: updateBuffer4,\n    5: updateBuffer5,\n    6: updateBuffer6,\n    7: updateBuffer7,\n    8: updateBuffer8,\n    9: updateBuffer9,\n    10: updateBuffer10,\n    11: updateBuffer11,\n};\n/**\n * This provides methods for handling common buffer tasks such as construction\n * and population.\n */\nvar BufferUtil = (function () {\n    function BufferUtil() {\n    }\n    /**\n     * This places our updateBuffer into a mode where the updates start at index 0 of the\n     * buffer. Subsequent calls will start where the previous call left off. This lets\n     * you stream in updates to the buffer rather than just update the entire buffer\n     * all at once.\n     */\n    BufferUtil.beginUpdates = function () {\n        isStreamUpdatingRegister = true;\n        lastBatchRegister = 0;\n    };\n    /**\n     * This takes the buffer items and cleans up their use within memory as best as possible.\n     *\n     * @param bufferItems\n     */\n    BufferUtil.dispose = function (buffers) {\n        if (buffers) {\n            buffers.forEach(function (bufferItems) {\n                bufferItems.attributes = null;\n                bufferItems.currentData = null;\n                bufferItems.geometry.dispose();\n                bufferItems.geometry = null;\n                bufferItems.system = null;\n            });\n        }\n    };\n    /**\n     * This stops updates streaming into the buffers and makes it where an update\n     * will always just start at the beginning of the buffer.\n     */\n    BufferUtil.endUpdates = function () {\n        var totalBatches = lastBatchRegister;\n        isStreamUpdatingRegister = false;\n        lastBatchRegister = 0;\n        return totalBatches;\n    };\n    /**\n     * It is often needed to examine a given buffer and see how the triangles are packed in.\n     * This is a common debugging need and will speed up debugging significantly.\n     *\n     * @param {IBufferItems<T, U>} bufferItems This is the buffer whose structure we want\n     *                                         to examine.\n     * @param {string} message This is the message for the debug statement. There are two\n     *                         predefined %o. The first is the vertex information the second\n     *                         is the uniform info. Leave null for a default message.\n     * @param {string} debugNamespace The namespace for the debugging info.\n     */\n    BufferUtil.examineBuffer = function (bufferItems, message, debugNamespace) {\n        // Get the appropriate debug namespace\n        var debugBuffer = debugGenerator(debugNamespace);\n        // Quick quit if the debugger is not enabled\n        if (!debugBuffer.enabled) {\n            return;\n        }\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // Get the attributes by name out of the three js buffer\n        var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n        // Get the raw number buffers\n        var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n        // This will store all of the examined triangles for easy viewing\n        var triangles = [];\n        if (bufferItems.system.drawMode === three_1.TrianglesDrawMode) {\n            var currentVertex_1 = 0;\n            var attrSize_1 = 0;\n            var currentIndex_1 = 0;\n            var length_1 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_1 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_2 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_1 = attr.size + 1;\n                        currentIndex_1 = currentVertex_1 * attrSize_1;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_1, currentIndex_1 + attrSize_1);\n                    });\n                    // Move to the next vertex\n                    currentVertex_1++;\n                };\n                // Each new triangle is a culmination of three vertices which are packed in\n                // The buffer with no vertex sharing\n                for (var i = 0; i < 3; ++i) {\n                    _loop_2(i);\n                }\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_1 < length_1) {\n                _loop_1();\n            }\n        }\n        else if (bufferItems.system.drawMode === three_1.TriangleStripDrawMode) {\n            var currentVertex_2 = 0;\n            var attrSize_2 = 0;\n            var currentIndex_2 = 0;\n            var length_2 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_3 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_4 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_2 = attr.size + 1;\n                        currentIndex_2 = currentVertex_2 * attrSize_2;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_2, currentIndex_2 + attrSize_2);\n                    });\n                    // Move to the next vertex\n                    currentVertex_2++;\n                };\n                // Each new triangle is three vertices, where the first two are shared with\n                // The previous triangle's last two vertices\n                for (var i = 0; i < 3; ++i) {\n                    _loop_4(i);\n                }\n                // Go back two vertices as the next tri will use them + the next vertex to\n                // Make the next triangle\n                currentVertex_2 -= 2;\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_2 < length_2) {\n                _loop_3();\n            }\n        }\n        // Log the debug info to the console using the debug utility\n        debugBuffer(message || 'vertices: %o uniforms: %o', {\n            drawRange: buffer.drawRange,\n            triangles: triangles,\n        }, bufferItems.system.material.uniforms);\n    };\n    /**\n     * Aids in taking in multiple multibuffers and flattening it to a single list\n     *\n     * @param multiShapeBuffers\n     */\n    BufferUtil.flattenMultiBuffers = function (multiShapeBuffers) {\n        var all = [];\n        multiShapeBuffers.forEach(function (multiBuffer) {\n            multiBuffer.getBuffers().forEach(function (buffer) { return all = all.concat(buffer); });\n        });\n        return all;\n    };\n    /**\n     * @static\n     * This helps aid in updating a complex multi buffer. It will establish when a new\n     * buffer needs to be created and initialized and it will automatically call a BaseBuffer's\n     * update when an update is detected as a need for the buffer.\n     *\n     * @param multiShapeBuffer\n     * @param buffers\n     * @param init\n     *\n     * @return {boolean} True if a buffer was updated\n     */\n    BufferUtil.updateMultiBuffer = function (multiShapeBuffer, buffers, init, update, forceUpdates) {\n        // If no buffers provided, then we do not need to update anything\n        if (!multiShapeBuffer) {\n            return false;\n        }\n        // This flag indicates whether an update occurred or not\n        var didUpdate = false;\n        // Get the shape buffers we need rendered into vertex buffers\n        var shapeBuffers;\n        // If this is a list of multibuffers, we flatten out all of the sub buffers\n        // This is a one level deep flatten as we do not want to accidentally handle shape clustering here\n        if (isList(multiShapeBuffer)) {\n            shapeBuffers = multiShapeBuffer.reduce(function (flat, toFlatten) { return flat.concat(toFlatten.getBuffers()); }, []);\n        }\n        else {\n            shapeBuffers = multiShapeBuffer.getBuffers();\n        }\n        // Make a lookup to identify the buffers that already exists for the given multi shape buffers\n        var bufferLookup = new Map();\n        buffers.forEach(function (buffer) { return bufferLookup.set(buffer.bufferItems.currentData, buffer); });\n        // This will store all of the shape buffers that needs to be rendered into a vertex buffer\n        var needsBuffer = [];\n        // If we're forcing updates then we should be ensuring all shapeBuffers needs a buffer\n        // And leave all of the bufferLookup so they will all be updated with the provided needed shape buffer updates\n        if (forceUpdates) {\n            needsBuffer = [].concat(shapeBuffers);\n        }\n        else {\n            shapeBuffers.forEach(function (shapes) {\n                if (bufferLookup.get(shapes)) {\n                    bufferLookup.delete(shapes);\n                }\n                else if (shapes.length > 0) {\n                    needsBuffer.push(shapes);\n                }\n            });\n        }\n        // All buffers remaining in the buffer lookup are available for re-rendering the\n        // Shape buffers that still needs updates\n        // If the shape buffers needing updates is greater than the vertex buffers available\n        // Then we update with what we have and initialize any additional vertex buffers needed\n        if (needsBuffer.length >= bufferLookup.size) {\n            // Take any buffer that is not found with an existing shape buffer and update it\n            // With a buffer that needs an update\n            bufferLookup.forEach(function (value) {\n                didUpdate = update(value, needsBuffer.shift()) || didUpdate;\n            });\n            // Any remaining buffers that need updates will have to initialize a buffer\n            // To cram it in\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = init();\n                buffers.push(vertexBuffer);\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n        }\n        else {\n            var vertexBuffers_1 = Array.from(bufferLookup.values());\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = vertexBuffers_1.shift();\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n            vertexBuffers_1.forEach(function (buffer) {\n                buffer.bufferItems.geometry.setDrawRange(0, 0);\n            });\n        }\n        return didUpdate;\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with constructing a new buffer\n     * such as applying the name, generating the buffer, and populating default values to\n     * that buffer.\n     *\n     * @param {number} numVertices The number of vertices this buffer will have\n     * @param {IAttributeInfo[]} attributes A description of each attribute in the buffer\n     *\n     * @returns {BufferGeometry} The newly made buffer\n     */\n    BufferUtil.makeBuffer = function (numVertices, attributes) {\n        var iMax = attributes.length;\n        var geometry = new three_1.BufferGeometry();\n        var totalAttributeSize = 0;\n        var foundPosition = false;\n        for (var i = 0; i < iMax; ++i) {\n            var attribute = attributes[i];\n            var attributeSize = attribute.size + 1;\n            totalAttributeSize += attributeSize;\n            var name_1 = attribute.name;\n            var injectBuffer = attribute.injectBuffer;\n            var buffer = injectBuffer || new Float32Array(attributeSize * numVertices);\n            var fillMethod = fillMethodLookUp[attribute.size];\n            var customFill = attribute.customFill;\n            var defaults = attribute.defaults;\n            if (name_1 === 'position') {\n                foundPosition = true;\n            }\n            // If an explicit buffer was not provided, then we fill with the defaults\n            if (!injectBuffer) {\n                if (customFill) {\n                    // Let the custom fill method populate the buffer with whatever so be desired\n                    for (var k = 0; k < numVertices; ++k) {\n                        customFill(buffer, k, k * attributeSize, defaults);\n                    }\n                }\n                else {\n                    // We set up our default value registers before executing the fill method\n                    applyDefaultsHolders(defaults);\n                    // Fill our buffer with the indicated default values\n                    for (var k = 0; k < numVertices; ++k) {\n                        fillMethod(buffer, k * attributeSize);\n                    }\n                }\n            }\n            // Apply the buffer to our geometry buffer\n            var attr = new three_1.BufferAttribute(buffer, attributeSize);\n            attr.setDynamic(true);\n            geometry.addAttribute(name_1, attr);\n            debug('Made Buffer Attribute:', name_1, attributeSize);\n        }\n        if (!foundPosition) {\n            console.warn('It is recommended you ALWAYS use the position attribute as one of your attributes', 'There are features of threejs that REQUIRES this to be in place (even if not explicitly', 'documented). You don\\'t have to use for exact position information, rather fill it with something', 'you need. Failure to do so will have you see consequences that are EXTREMELY hard to find.');\n        }\n        if (totalAttributeSize > 16) {\n            console.warn('A Buffer has specified more attributes than available. The max is 16 and the buffer provided:', totalAttributeSize);\n        }\n        return geometry;\n    };\n    /**\n     *\n     * @param attributes\n     * @param sharedBuffer\n     */\n    BufferUtil.shareBuffer = function (attributes, sharedBuffer) {\n        var bufferAttributes = sharedBuffer.attributes;\n        var newBuffer = new three_1.BufferGeometry();\n        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n            var attr = attributes_1[_i];\n            var shareAttribute = bufferAttributes[attr.name];\n            if (shareAttribute) {\n                newBuffer.addAttribute(attr.name, shareAttribute);\n            }\n            else {\n                console.warn('Could not find attribute', attr, 'in the buffer to be shared. Can not share buffers properly');\n            }\n        }\n        return newBuffer;\n    };\n    /**\n     * Generates the necessary metrics based on uniform attributes to generate a uniform buffer for\n     * rendering.\n     *\n     * @param uniforms\n     */\n    BufferUtil.makeUniformBuffer = function (uniforms) {\n        var maxBlock = 0;\n        var buffer = [];\n        var uniformBufferBlockMax = webgl_stat_1.WebGLStat.MAX_VERTEX_INSTANCE_DATA;\n        var sizeCheck = {};\n        uniforms.forEach(function (uniform) {\n            maxBlock = Math.max(uniform.block, maxBlock);\n            var check = sizeCheck[uniform.block] = (sizeCheck[uniform.block] || 0) + (uniform.size + 1);\n            if (check > 4) {\n                console.warn('There were too many uniform attribute usages of a single block:', uniform);\n            }\n        });\n        for (var i = 0; i < uniformBufferBlockMax; ++i) {\n            buffer.push(new three_1.Vector4(0, 0, 0, 0));\n        }\n        return {\n            blocksPerInstance: maxBlock + 1,\n            buffer: buffer,\n            maxInstances: Math.floor(uniformBufferBlockMax / maxBlock),\n        };\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with updating a buffer. You specify how many vertices\n     * to update in a batch and you specify how many batches are present.\n     *\n     * Batches are used to represent your full shape object that is being loaded from the cpu:\n     *\n     * IE- you have a rectangle object you wish to update in your buffer. This takes around 6 vertices typically\n     * so you make your vertexBatch 6 and the numBatches the number of quads you need to update in the buffer.\n     *\n     * You then provide an accessor which aids in pointing to the buffer items that need updating. The accessor has\n     * variable arguments depending on the attributes you inject in.\n     *\n     * If you have attributes like:\n     * [\n     *  {name: position, size: AttributeSize.Three},\n     *  {name: color, size: AttributeSize.Four},\n     * ]\n     *\n     * Then your accessor will be delievered arguments in this form:\n     *\n     * function(batchIndex: number, positionBuffer: number[], positionIndex: number, colorBuffer: number[], colorIndex: number)\n     *\n     * NOTE: The params handed in ARE ORDERED BY the attributes injected in\n     *\n     * You then can update the buffers based on the index information handed alongside each buffer\n     *\n     * @param {T[]} newData The new data that is going to be injected into the buffer. This must be a NEW REFERENCE of data\n     *                      that does NOT match the reference in the bufferItems.currentData. So newData !== bufferItems.currentData\n     *                      in order for the update to occur.\n     * @param {BufferGeometry} bufferItems The buffer related items used to identify how to update the buffer\n     * @param {number} vertexBatch The number of vertices to include per update batch\n     * @param {number} numBatches The number of batches to execute\n     * @param {Function} updateAccessor The accessor for performing the data update to the buffer\n     * @param {boolean} force This bypasses the typical checks that determines if the buffer SHOULD update.\n     *\n     * @return {boolean} True if the buffer was updated with this call\n     */\n    BufferUtil.updateBuffer = function (newData, bufferItems, vertexBatch, numBatches, updateAccessor, force) {\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            // Flag the newly rendered data as our current data\n            bufferItems.currentData = newData;\n            // Get the attributes by name out of the three js buffer\n            var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n            // Get the raw number buffers\n            var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n            // Determine what kind of buffer pointer increments we will need\n            var incrementValues = attributes.map(function (attr) { return (attr.size + 1) * vertexBatch; });\n            // Apply all data needed to any registers we need\n            applyAttributeRegisters(attributeBuffers, incrementValues);\n            // Get the method that will perform the update based on number of attributes\n            var updateMethod = updateBufferLookUp[attributes.length];\n            // Execute the update method\n            updateMethod(numBatches + lastBatchRegister, updateAccessor);\n            // Flag each buffer attribute for needing an update\n            bufferAttributes.forEach(function (attr) {\n                if (attr.updateRange) {\n                    attr.updateRange.offset = 0;\n                    attr.updateRange.count = vertexBatch * (lastBatchRegister + numBatches) * attr.itemSize;\n                }\n                attr.needsUpdate = true;\n            });\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n        }\n        return false;\n    };\n    /**\n     * This is an alternative way to specify data for rendering. This updates information within the\n     * uniform blocks to specify instancing data (the alternative is just updating a vertex buffer\n     * with all of the data needed for every piece of geometry for every instance). This update method\n     * CAN save massive amounts of committed data for large geometry items (ie curves). It requires a\n     * different pipeline to make work (your shader must specify a uniform vec4 instanceData[], and\n     * your shape buffer to vertex buffer conversion must have a static vertex buffer).\n     *\n     * This is like a vertex buffer update except the updateAccessor will be of this format:\n     *\n     * updateAccessor(instanceIndex: number, uniformBlock0: Vector4, ..., uniformBlockN: Vector4);\n     *\n     * Where the uniform blocks provided will appear in the same order the IUniformAttributes were in\n     * when the uniform buffer was created.\n     *\n     */\n    BufferUtil.updateUniformBuffer = function (newData, bufferItems, instanceBatchSize, updateAccessor, force) {\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            var material = bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var instanceData = uniforms.instanceData;\n            bufferItems.currentData = newData;\n            // If the instance data uniform is available and it is the proper vec4 array type, then we\n            // Are able to update the uniform buffer\n            if (instanceData && instanceData.type === 'v4v' || instanceData.type === 'bvec4' && bufferItems.uniformBuffer) {\n                var attributes = bufferItems.uniformAttributes;\n                var blocksPerInstance = bufferItems.uniformBuffer.blocksPerInstance;\n                var buffer = bufferItems.uniformBuffer.buffer;\n                var maxInstances = bufferItems.uniformBuffer.maxInstances;\n                var currentInstance = lastBatchRegister;\n                var currentInstanceStartBlock = lastBatchRegister * blocksPerInstance;\n                // We loop and update as many instances as specified, only up to the\n                // Number of instances allowed for the uniform buffer\n                for (var i = 0; i < instanceBatchSize && currentInstance < maxInstances; ++i) {\n                    // Our current instance depends on our lastBatchRegister we utilize\n                    // When begin() is called\n                    currentInstance = lastBatchRegister + i;\n                    // We get the first block the instance will utilize\n                    currentInstanceStartBlock = blocksPerInstance * currentInstance;\n                    // This will contain all of our arguments the accessor will use\n                    var updateArguments = [currentInstance];\n                    // Loop through the attributes in the order they appear and gather the block they will\n                    // Update\n                    for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {\n                        var attribute = attributes_2[_i];\n                        updateArguments.push(buffer[attribute.block + currentInstanceStartBlock]);\n                    }\n                    // Call the update accessor for the instance using the gathered arguments\n                    // TODO: This should be done with registers like vertex array buffer updates for Optimal\n                    // Performance. A method apply is very slow compared to the register way.\n                    updateAccessor.apply(null, updateArguments);\n                }\n                // Tell the uniform to update with the new dataset\n                instanceData.value = [].concat(buffer);\n            }\n            else {\n                console.warn('A uniform buffer update was specified on a material that lacks uniform buffer usage');\n                return false;\n            }\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n        }\n        return false;\n    };\n    /**\n     * This makes all of the typical items used in creating and managing a buffer of items rendered to the screen\n     *\n     * @returns {IBufferItems<T>} An empty object of the particular buffer items needed\n     */\n    BufferUtil.makeBufferItems = function () {\n        return {\n            attributes: [],\n            currentData: [],\n            geometry: null,\n            system: null,\n            uniformAttributes: [],\n            uniformBuffer: null,\n        };\n    };\n    return BufferUtil;\n}());\nexports.BufferUtil = BufferUtil;\nvar _a;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar buffer_util_1 = __webpack_require__(1);\n/**\n * This deinfes the minimal set of methods that should be implemented to create\n * a reusable buffer object that can be initialized and populated.\n */\nvar BaseBuffer = (function () {\n    function BaseBuffer() {\n    }\n    /**\n     * This disposes the resources associated with a buffer.\n     */\n    BaseBuffer.prototype.dispose = function () {\n        if (this.bufferItems) {\n            buffer_util_1.BufferUtil.dispose([this.bufferItems]);\n        }\n    };\n    /**\n     * This initializes the buffer and generates the buffer items object.\n     */\n    BaseBuffer.prototype.init = function (material, unitCount) {\n        // To be implemented by a subclass\n    };\n    /**\n     * This updates the buffer by providing the shape buffer needed to update\n     * the internal buffer items\n     *\n     * @param {T[]} shapeBuffer The shape buffer containing all of the shape data\n     *                          to be placed into the buffer.\n     *\n     * @return {boolean} Retrusn true if this pushed up any updates\n     */\n    BaseBuffer.prototype.update = function (shapeBuffer) {\n        // To be implemented by a subclass\n        return false;\n    };\n    return BaseBuffer;\n}());\nexports.BaseBuffer = BaseBuffer;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nvar Bounds = (function () {\n    /**\n     * Create a new instance\n     *\n     * @param left  The left side (x coordinate) of the instance\n     * @param right The right side of the instance\n     * @param top The top (y coordinate) of the instance\n     * @param bottom The bottom of the instance\n     */\n    function Bounds(left, right, top, bottom) {\n        this.height = 0;\n        this.width = 0;\n        this.x = 0;\n        this.y = 0;\n        if (arguments.length === 4) {\n            this.x = left;\n            this.width = right - left;\n            this.y = top;\n            this.height = top - bottom;\n        }\n    }\n    Object.defineProperty(Bounds.prototype, \"area\", {\n        /** The total rectangular surface area of this instance */\n        get: function () {\n            return this.width * this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"bottom\", {\n        /** The bottom coordinate for this instance (y + height) */\n        get: function () {\n            return this.y - this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"mid\", {\n        /** An x, y coordinate pair representing the center of this object */\n        get: function () {\n            return {\n                x: this.x + (this.width / 2),\n                y: this.y - (this.height / 2),\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"right\", {\n        get: function () {\n            return this.x + this.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Check to see if a given point lies within the bounds of this instance\n     *\n     * @param point The point to check\n     */\n    Bounds.prototype.containsPoint = function (point) {\n        if (point.x < this.x) {\n            return false;\n        }\n        if (point.y > this.y) {\n            return false;\n        }\n        if (point.x > this.right) {\n            return false;\n        }\n        if (point.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Copies the properties of the bounds specified\n     *\n     * @param b The bounds whose dimensions we wish to copy\n     */\n    Bounds.prototype.copyBounds = function (b) {\n        this.height = b.height;\n        this.width = b.width;\n        this.x = b.x;\n        this.y = b.y;\n    };\n    /**\n     * Ensure that this object contains the smaller bounds\n     *\n     * This method will not shrink this class, but only grow it as necessary to\n     * fit the destination object\n     *\n     * @param bounds The bounds to encapsulate\n     */\n    Bounds.prototype.encapsulate = function (bounds) {\n        if (bounds.x < this.x) {\n            this.width += this.x - bounds.x;\n            this.x = bounds.x;\n        }\n        if (bounds.y > this.y) {\n            this.height += bounds.y - this.y;\n            this.y = bounds.y;\n        }\n        if (bounds.right > this.right) {\n            this.width = bounds.right - this.x;\n        }\n        if (bounds.bottom < this.bottom) {\n            this.height = this.y - bounds.bottom;\n        }\n    };\n    /**\n     * Ensure that this object contains the provided list of bounds\n     *\n     * This will never shrink or modify the original area covered by this bounds\n     * but will instead stay the same or include the original area plus the specified\n     * list of bounds.\n     *\n     * @param {Bounds<any>[]} bounds The list of bounds objects to encapsulate\n     * @param {boolean} sizeToFirst If this is set, the procedure will start by making this bounds\n     *                              be a clone of the first bounds object in the list\n     */\n    Bounds.prototype.encapsulateBounds = function (bounds, sizeToFirst) {\n        if (sizeToFirst && bounds.length) {\n            this.copyBounds(bounds[0]);\n        }\n        if (bounds.length === 0) {\n            return;\n        }\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        bounds.forEach(function (p) {\n            if (p.x < minX) {\n                minX = p.x;\n            }\n            if (p.right > maxX) {\n                maxX = p.right;\n            }\n            if (p.bottom < minY) {\n                minY = p.bottom;\n            }\n            if (p.y > maxY) {\n                maxY = p.y;\n            }\n        });\n        // Make bounds that encompasses the bounds list, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Grow this class to contain the specified point\n     *\n     * This method will not shrink this instance. It will only grow it as\n     * necessary.\n     *\n     * @param point The point to encapsulate\n     */\n    Bounds.prototype.encapsulatePoint = function (point) {\n        if (point.x < this.x) {\n            this.width += this.x - point.x;\n            this.x = point.x;\n        }\n        if (point.y > this.y) {\n            this.height += point.y - this.y;\n            this.y = point.y;\n        }\n        if (point.x > this.right) {\n            this.width = point.x - this.x;\n        }\n        if (point.y < this.bottom) {\n            this.height = this.y - point.y;\n        }\n    };\n    /**\n     * Efficiently encapsulates a set of points by growing the current dimensions\n     * of the bounds until the points are enclosed. This will perform faster than\n     * running encapsulatePoint for a list of points.\n     *\n     * @param points An array of points that Can be of format {x, y} or [x, y]\n     *\n     * @memberOf Bounds\n     */\n    Bounds.prototype.encapsulatePoints = function (points) {\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        if (points[0] !== undefined && points[0].x) {\n            points.forEach(function (p) {\n                if (p.x < minX) {\n                    minX = p.x;\n                }\n                else if (p.x > maxX) {\n                    maxX = p.x;\n                }\n                if (p.y < minY) {\n                    minY = p.y;\n                }\n                else if (p.y > maxY) {\n                    maxY = p.y;\n                }\n            });\n        }\n        else {\n            points.forEach(function (p) {\n                if (p[0] < minX) {\n                    minX = p[0];\n                }\n                else if (p[0] > maxX) {\n                    maxX = p[0];\n                }\n                if (p[1] < minY) {\n                    minY = p[1];\n                }\n                else if (p[1] > maxY) {\n                    maxY = p[1];\n                }\n            });\n        }\n        // Make bounds that encompasses the points, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Checks to see if another bounds fits in itself.\n     *\n     * @param {Bounds} inner The bounds to test against\n     *\n     * @return {number} int 1 is an exact fit, 2 it fits with space, 0 it doesn't fit\n     */\n    Bounds.prototype.fits = function (inner) {\n        if (this.width === inner.width) {\n            if (this.height === inner.height) {\n                return 1;\n            }\n        }\n        if (this.width >= inner.width) {\n            if (this.height >= inner.height) {\n                return 2;\n            }\n        }\n        return 0;\n    };\n    /**\n     * Check to see if the provided bounds intersects with this instance\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if the other object intersects with this instance\n     */\n    Bounds.prototype.hitBounds = function (bounds) {\n        if (bounds.right < this.x) {\n            return false;\n        }\n        if (bounds.x > this.right) {\n            return false;\n        }\n        if (bounds.bottom > this.y) {\n            return false;\n        }\n        if (bounds.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Tests if a point is inside this bounds\n     *\n     * @param p The point to test\n     *\n     * @return boolean The point to test\n     */\n    Bounds.prototype.pointInside = function (p) {\n        if (p.x < this.x) {\n            return false;\n        }\n        if (p.y > this.y) {\n            return false;\n        }\n        if (p.x > this.right) {\n            return false;\n        }\n        if (p.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Test function to type check the provided value\n     *\n     * @return True if value is a bounds object\n     */\n    Bounds.isBounds = function (value) {\n        // Falsy values aren't bounds objects\n        if (!value) {\n            return false;\n        }\n        // Direct test for bounds objects\n        if (value instanceof this) {\n            return true;\n        }\n        // Duck-typing check\n        return value &&\n            'containsPoint' in value &&\n            'encapsulate' in value &&\n            'hitTest' in value;\n    };\n    /**\n     * Check if this instance is completely inside the provided bounds\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if this instance is inside the provided bounds\n     */\n    Bounds.prototype.isInside = function (bounds) {\n        return (bounds.x <= this.x &&\n            bounds.right >= this.right &&\n            bounds.y >= this.y &&\n            bounds.bottom <= this.bottom);\n    };\n    /**\n     * Generates a Bounds object covering max extents\n     *\n     * @return {Bounds} bounds covering as wide of a range as possible\n     */\n    Bounds.maxBounds = function () {\n        return new Bounds(Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE);\n    };\n    return Bounds;\n}());\nexports.Bounds = Bounds;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(31);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculates the distance between two points, but keeps the distance in dquared form\n * thus performing Math.sqrt() on the output of this distance would provide the true\n * distance between the points.\n *\n * It is often faster and all that is needed to compare squared distances vs real distances\n * thus eliminating multiple Math.sqrt operations\n *\n * NOTE: For vectors this is the same as (pseudo code):\n * let vector3 = vector2.subtract(vector1)\n * return vector3.dot(vector3)\n *\n * @param p1 The point to find the distance from the second point\n * @param p2 The point to find the distance from the first point\n *\n * @return {number} The distance * distance between the two points\n */\nfunction squareDistance(p1, p2) {\n    var dx = p1.x - p2.x;\n    var dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n}\n/**\n * Contains methods for managing or manipulating points\n *\n * @export\n * @class Point\n */\nvar Point = (function () {\n    function Point() {\n    }\n    /**\n     * Adds two points together\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @return {IPoint} The two points added together\n     */\n    Point.add = function (p1, p2, out) {\n        if (out) {\n            out.x = p1.x + p2.x;\n            out.y = p1.y + p2.y;\n            return out;\n        }\n        return {\n            x: p1.x + p2.x,\n            y: p1.y + p2.y,\n        };\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {IPoint} The closest point to the test point\n     */\n    Point.getClosest = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = null;\n        var distance;\n        var findClosest = function (point) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = point;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * This just returns the index of the found point and not the point itself\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {number} The index of the closest point to the test point\n     */\n    Point.getClosestIndex = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = 0;\n        var distance;\n        var findClosest = function (point, i) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = i;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This will calculate a direction vector between two points that points toward p2\n     *\n     * @param {IPoint} p1 The start of the direction\n     * @param {IPoint} p2 The direction to point the vector towards\n     * @param {boolean} normalize If true, this will make the vector have a magnitude of 1\n     *\n     * @returns {number}\n     */\n    Point.getDirection = function (p1, p2, normalize) {\n        if (normalize === void 0) { normalize = false; }\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        if (normalize) {\n            var magnitude = Math.sqrt(dx * dx + dy * dy);\n            dx /= magnitude;\n            dy /= magnitude;\n        }\n        return {\n            x: dx,\n            y: dy,\n        };\n    };\n    /**\n     * @static\n     * Gets the distance between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {boolean} squared If set to true, returns the distance * distance (performs faster)\n     *\n     * @returns {number} The real distance between two points\n     */\n    Point.getDistance = function (p1, p2, squared) {\n        if (squared === void 0) { squared = false; }\n        if (squared) {\n            return squareDistance(p1, p2);\n        }\n        return Math.sqrt(squareDistance(p1, p2));\n    };\n    /**\n     * @static\n     * Gets a point perfectly between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     *\n     * @returns {IPoint} The point between the two provided points\n     */\n    Point.getMidpoint = function (p1, p2) {\n        var direction = Point.getDirection(p1, p2);\n        return {\n            x: direction.x / 2 + p1.x,\n            y: direction.y / 2 + p1.y,\n        };\n    };\n    Point.make = function (x, y) {\n        return { x: x, y: y };\n    };\n    /**\n     * Scales a point by a given amount\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {number} s The amount to scale the point by\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @memberof Point\n     */\n    Point.scale = function (p1, s, out) {\n        if (out) {\n            out.x = p1.x * s;\n            out.y = p1.y * s;\n            return out;\n        }\n        return {\n            x: p1.x * s,\n            y: p1.y * s,\n        };\n    };\n    /**\n     * Makes a new point initialized to {0,0}\n     *\n     * @static\n     * @returns {IPoint} A new point object at {0,0}\n     */\n    Point.zero = function () {\n        return {\n            x: 0,\n            y: 0,\n        };\n    };\n    return Point;\n}());\nexports.Point = Point;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(4);\n/**\n * Represents a line with a given slope\n */\nvar Line = (function (_super) {\n    __extends(Line, _super);\n    /**\n     * Creates a new line that passes through the two specified points\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    function Line(p1, p2) {\n        var _this = _super.call(this, 0, 1, 1, 0) || this;\n        _this.setPoints(p1, p2);\n        return _this;\n    }\n    /**\n     * This calculates the distance to a point from the provided line\n     * BUT this ALSO retains the directionality of that distance. So one side of\n     * the line will be positive while the other negative\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.directionTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line, but we won't take the absolute to retain the direction\n        return this.perpendicular.x * vector.x + this.perpendicular.y * vector.y;\n    };\n    /**\n     * This calculates the distance to a point from the provided line\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.distanceTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line\n        return Math.abs(this.perpendicular.x * vector.x +\n            this.perpendicular.y * vector.y);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {Array} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    Line.getClosest = function (lines, p) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(p);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This sets the two endpoints for this line and recalculates the bounds\n     * of the line accordingly\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    Line.prototype.setPoints = function (p1, p2) {\n        this.x = p1.x - 1;\n        this.y = p1.y - 1;\n        this.width = 2;\n        this.height = 2;\n        this.encapsulatePoint(p2);\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        this.slope = dy / dx;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.magnitude = Math.sqrt(dx * dx + dy * dy);\n        this.perpendicular = {\n            x: this.p2.y - this.p1.y,\n            y: -(this.p2.x - this.p1.x),\n        };\n        // Normalize the perpendicular line\n        var mag = Math.sqrt(this.perpendicular.x * this.perpendicular.x +\n            this.perpendicular.y * this.perpendicular.y);\n        this.perpendicular.x /= mag;\n        this.perpendicular.y /= mag;\n    };\n    return Line;\n}(bounds_1.Bounds));\nexports.Line = Line;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_1 = __webpack_require__(6);\nvar easing_1 = __webpack_require__(13);\n/**\n * This enum is just a common way to define interpolation types\n */\nvar InterpolationMethod;\n(function (InterpolationMethod) {\n    InterpolationMethod[InterpolationMethod[\"BEZIER2\"] = 0] = \"BEZIER2\";\n    InterpolationMethod[InterpolationMethod[\"BEZIER3\"] = 1] = \"BEZIER3\";\n    InterpolationMethod[InterpolationMethod[\"CIRCULAR\"] = 2] = \"CIRCULAR\";\n})(InterpolationMethod = exports.InterpolationMethod || (exports.InterpolationMethod = {}));\n/**\n * This calculates a quadratic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier2(t, p1, p2, c1) {\n    var t2 = t * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    return {\n        x: p1.x * mt2 + c1.x * 2 * mt * t + p2.x * t2,\n        y: p1.y * mt2 + c1.y * 2 * mt * t + p2.y * t2,\n    };\n}\nexports.bezier2 = bezier2;\n/**\n * This calculates a cubic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The first control point of the curve\n * @param {IPoint} c2 The second control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier3(t, p1, p2, c1, c2) {\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    var mt3 = mt2 * mt;\n    return {\n        x: p1.x * mt3 + 3 * c1.x * mt2 * t + 3 * c2.x * mt * t2 + p2.x * t3,\n        y: p1.y * mt3 + 3 * c1.y * mt2 * t + 3 * c2.y * mt * t2 + p2.y * t3,\n    };\n}\nexports.bezier3 = bezier3;\n/**\n * This calculates a point along a path defined as a circular path which is a\n * path moving along the edge of a circle from one point to the next. This will\n * even allow for moving along a circle with a growing radius.\n *\n * @param {number} t The 0 - 1 time interval for the part of the path we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point, or more importantly, the center of the circle\n * @param {EasingMethod} radiusEasing Default easing for the radius growing is linear.\n *                                    Insert a custom easing method to change this.\n *\n * @returns {IPoint}\n */\nfunction circular(t, p1, p2, c1, radiusEasing) {\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(c1, p1);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(c1, p2);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Ensure our theta's are definitely between 0 to Math.PI * 2 after the atan\n    // Calculation\n    if (theta1 < 0)\n        theta1 += Math.PI * 2;\n    if (theta2 < 0)\n        theta2 += Math.PI * 2;\n    var dTheta = theta2 - theta1;\n    // We ALWAYS want our path to be the shortest around the circle\n    if (dTheta > Math.PI) {\n        dTheta = theta1 - theta2;\n    }\n    // We use this to calculate how far we are between the two points in radians\n    // Based on the time parameter provided for the interpolation\n    dTheta *= t;\n    // We must have the radial distance of both points to properly calculate\n    // An easing between the two radii\n    var radius1 = point_1.Point.getDistance(p1, c1);\n    var radius2 = point_1.Point.getDistance(p2, c1);\n    // We control how the radius eases out for the path, which is determined by\n    // The easing method, otherwise, it just linearly radiates out\n    var radius = (radiusEasing || easing_1.linear)(t, radius1, radius2 - radius1, 1.0);\n    return {\n        x: Math.cos(theta1 + dTheta) * radius + c1.x,\n        y: Math.sin(theta1 + dTheta) * radius + c1.y,\n    };\n}\nexports.circular = circular;\nexports.pickInterpolation = (_a = {},\n    _a[InterpolationMethod.BEZIER2] = bezier2,\n    _a[InterpolationMethod.BEZIER3] = bezier3,\n    _a[InterpolationMethod.CIRCULAR] = circular,\n    _a);\nvar _a;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar curved_line_1 = __webpack_require__(21);\nvar line_1 = __webpack_require__(7);\nvar point_1 = __webpack_require__(6);\n/**\n * This gets the radian of line from center to point\n *\n * @param point\n * @param center\n */\nfunction getAngle(point, center) {\n    if (point.x > center.x) {\n        return Math.atan((point.y - center.y) / (point.x - center.x));\n    }\n    else if (point.x === center.x) {\n        if (point.y > center.y)\n            return Math.PI / 2;\n        else\n            return -Math.PI / 2;\n    }\n    else {\n        if (point.y >= center.y) {\n            return Math.PI + Math.atan((point.y - center.y) / (point.x - center.x));\n        }\n        else {\n            return Math.atan((point.y - center.y) / (point.x - center.x)) - Math.PI;\n        }\n    }\n}\n/**\n * This defines a drawable curved line shape. It contains the information necessary\n * to efficiently render the line.\n *\n * @export\n * @class CurvedLineShape\n * @extends {CurvedLine<T>}\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\n *             with the shape easier.\n */\nvar CurvedLineShape = (function (_super) {\n    __extends(CurvedLineShape, _super);\n    /**\n     * Creates an instance of CurvedLineShape.\n     *\n     * @param {ICurvedLineShapeOptions} options The options for creating this line\n     */\n    function CurvedLineShape(options) {\n        var _this = \n        // We pass our properties to the curve line but we do not let it cache it's version of the line segments\n        // As we will be constructing our own segmentation requiring a new type of cache\n        _super.call(this, options) || this;\n        /** Depeth of draw location */\n        _this.depth = 0;\n        /** How thick the line should be */\n        _this.lineWidth = 1;\n        _this.cachesQuadSegments = options.cacheSegments;\n        _this.depth = options.depth || 0;\n        _this.lineWidth = options.lineWidth || 1;\n        _this.encapsulatePoints(_this.getTriangleStrip());\n        _this.startColor = options.startColor;\n        _this.endColor = options.endColor;\n        _this.marchingAnts = options.marchingAnts;\n        return _this;\n    }\n    /**\n     * Returns a new instance of this object that mimicks the properties of this Object\n     *\n     * @returns {CurvedLineShape<T>} The cloned object\n     */\n    CurvedLineShape.prototype.clone = function () {\n        // Perform the clone\n        var clone = new CurvedLineShape({\n            cacheSegments: this.cachesSegments,\n            controlPoints: this.controlPoints,\n            end: this.end,\n            endColor: this.endColor,\n            lineWidth: this.lineWidth,\n            resolution: this.resolution,\n            start: this.start,\n            startColor: this.startColor,\n            type: this.type,\n        });\n        clone.d = this.d;\n        return clone;\n    };\n    /**\n     * @override\n     * See base definition\n     */\n    CurvedLineShape.prototype.distanceTo = function (point) {\n        return Math.max(0, _super.prototype.distanceTo.call(this, point) - (this.lineWidth / 2.0));\n    };\n    /**\n     * This produces a triangle strip that represents the quads that composes this line. If caching is present,\n     * subsequent calls to this method will be much faster unless the cache gets invalidated.\n     *\n     * @return {IPoint[]} The Triangle Strip of points to create the quads that make each segment of the curve\n     */\n    CurvedLineShape.prototype.getTriangleStrip = function () {\n        if (this.cachesSegments && this.cachedQuadSegments) {\n            return this.cachedQuadSegments;\n        }\n        // Make a container to hold our triangle strip info\n        var strip = [];\n        var normal = [];\n        // Start with calculating the line strip so we can use the line segments\n        // To produce the quads we need to render\n        var lineStrip = this.getLineStrip();\n        var lineWidthHalf = this.lineWidth / 2.0;\n        var line = new line_1.Line(point_1.Point.zero(), point_1.Point.zero());\n        // We make a container point for the scaling operation to reduce allocations\n        var scaledPoint = point_1.Point.zero();\n        // If the line strip is empty, then there is nothing to produce and makes\n        // Us unable to reduce the lineStrip, so return empty here\n        if (lineStrip.length < 2) {\n            return [];\n        }\n        // Calculate bisecting normal or each node\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            line.setPoints(lineStrip[i], lineStrip[i + 1]);\n            if (normal.length === 0) {\n                normal.push(line.perpendicular);\n            }\n            else {\n                // Sum of two normals of a point\n                var temp = {\n                    x: normal[i].x + line.perpendicular.x,\n                    y: normal[i].y + line.perpendicular.y,\n                };\n                // Normalize the sum of two normals\n                var sqrt = Math.sqrt(temp.x * temp.x + temp.y * temp.y);\n                temp.x = temp.x / sqrt;\n                temp.y = temp.y / sqrt;\n                normal[i] = temp;\n            }\n            normal.push(line.perpendicular);\n        }\n        // Use the new normals to generate quads\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            var previous = lineStrip[i];\n            var current = lineStrip[i + 1];\n            // TR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], -lineWidthHalf, scaledPoint), current));\n            // BR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], lineWidthHalf, scaledPoint), current));\n            // TL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], -lineWidthHalf, scaledPoint), previous));\n            // BL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], lineWidthHalf, scaledPoint), previous));\n        }\n        return strip;\n    };\n    /**\n     * @override\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     */\n    CurvedLineShape.prototype.setPoints = function (start, end, controlPoints) {\n        _super.prototype.setPoints.call(this, start, end, controlPoints);\n        this.cachedQuadSegments = [];\n    };\n    CurvedLineShape.prototype.containsPoint = function (point) {\n        if (this.type === curved_line_1.CurveType.CircularCW || this.type === curved_line_1.CurveType.CircularCCW) {\n            // Center\n            var center = this.controlPoints[1];\n            // Radius' suare value\n            var radiusSquare = Math.pow(this.start.x - center.x, 2) + Math.pow(this.start.y - center.y, 2);\n            // It is used to calculate squared value of (radius + lineWidth / 2)\n            var radius = Math.sqrt(radiusSquare);\n            // Distance'square value from mouse to center\n            var distanceSquare = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2);\n            // Linewidth's square value\n            var lineWidthSquare = this.lineWidth * this.lineWidth;\n            // Angles\n            var angle = getAngle(point, center);\n            var startAngle = getAngle(this.start, center);\n            var endAngle = getAngle(this.end, center);\n            if (startAngle > 0 && endAngle < 0) {\n                if (angle < 0)\n                    angle += 2 * Math.PI;\n                endAngle += 2 * Math.PI;\n            }\n            // Make sure point is in the endpoint\n            if (distanceSquare <= radiusSquare + this.lineWidth * radius + lineWidthSquare / 4\n                && distanceSquare >= radiusSquare - this.lineWidth * radius + lineWidthSquare / 4\n                && angle >= startAngle\n                && angle <= endAngle) {\n                return true;\n            }\n            return false;\n        }\n        else if (this.type === curved_line_1.CurveType.Bezier) {\n            return _super.prototype.containsPoint.call(this, point);\n        }\n        return false;\n    };\n    return CurvedLineShape;\n}(curved_line_1.CurvedLine));\nexports.CurvedLineShape = CurvedLineShape;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines a texture that is located on an atlas\n */\nvar AtlasTexture = (function () {\n    /**\n     * Generates a new atlas texture that points to a specific image resource.\n     *\n     * @param path The path to the image resource to be loaded into the atlas.\n     */\n    function AtlasTexture(path, label) {\n        /** Stores the aspect ratio of the image for quick reference */\n        this.aspectRatio = 1.0;\n        this.imagePath = path;\n        this.label = label;\n        // Let the label keep track of it's rasterization\n        if (label) {\n            this.label.rasterizedLabel = this;\n        }\n    }\n    return AtlasTexture;\n}());\nexports.AtlasTexture = AtlasTexture;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FrameInfo = (function () {\n    function FrameInfo() {\n    }\n    /** Contains the time the previous frame started */\n    FrameInfo.lastFrameTime = Date.now();\n    /** Contains a theoretical approximation the next frame will start */\n    FrameInfo.nextFrameTime = Date.now();\n    /** Contains how many frames have been played for a given WebGLSurface context */\n    FrameInfo.framesPlayed = new Map();\n    return FrameInfo;\n}());\nexports.FrameInfo = FrameInfo;\n/**\n * This gets an integer time value that can fit within an attribute. Be aware,\n * this only supports up to 7 digits of the millisecond time.\n */\nfunction getAttributeCurrentTime() {\n    var time = FrameInfo.lastFrameTime / 1E7;\n    return Math.floor((time - Math.floor(time)) * 1E7);\n}\nexports.getAttributeCurrentTime = getAttributeCurrentTime;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProgramInfo(gl, program) {\n    var result = {\n        attributeCount: 0,\n        attributes: new Array(),\n        uniformCount: 0,\n        uniforms: new Array(),\n    }, activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    // Taken from the WebGl spec:\n    // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n    var enums = {\n        0x8B50: 'FLOAT_VEC2',\n        0x8B51: 'FLOAT_VEC3',\n        0x8B52: 'FLOAT_VEC4',\n        0x8B53: 'INT_VEC2',\n        0x8B54: 'INT_VEC3',\n        0x8B55: 'INT_VEC4',\n        0x8B56: 'BOOL',\n        0x8B57: 'BOOL_VEC2',\n        0x8B58: 'BOOL_VEC3',\n        0x8B59: 'BOOL_VEC4',\n        0x8B5A: 'FLOAT_MAT2',\n        0x8B5B: 'FLOAT_MAT3',\n        0x8B5C: 'FLOAT_MAT4',\n        0x8B5E: 'SAMPLER_2D',\n        0x8B60: 'SAMPLER_CUBE',\n        0x1400: 'BYTE',\n        0x1401: 'UNSIGNED_BYTE',\n        0x1402: 'SHORT',\n        0x1403: 'UNSIGNED_SHORT',\n        0x1404: 'INT',\n        0x1405: 'UNSIGNED_INT',\n        0x1406: 'FLOAT',\n    };\n    var blocks = {\n        0x8B50: 1,\n        0x8B51: 1,\n        0x8B52: 1,\n        0x8B53: 1,\n        0x8B54: 1,\n        0x8B55: 1,\n        0x8B56: 1,\n        0x8B57: 1,\n        0x8B58: 1,\n        0x8B59: 1,\n        0x8B5A: 1,\n        0x8B5B: 3,\n        0x8B5C: 4,\n        0x8B5E: 1,\n        0x8B60: 1,\n        0x1400: 1,\n        0x1401: 1,\n        0x1402: 1,\n        0x1403: 1,\n        0x1404: 1,\n        0x1405: 1,\n        0x1406: 1,\n    };\n    // Loop through active uniforms\n    for (var i = 0; i < activeUniforms; ++i) {\n        var uniform = gl.getActiveUniform(program, i);\n        uniform.typeName = enums[uniform.type];\n        result.uniforms.push(uniform);\n        result.uniformCount += uniform.size;\n        uniform.size = uniform.size * blocks[uniform.type];\n    }\n    // Loop through active attributes\n    for (var i = 0; i < activeAttributes; i++) {\n        var attribute = gl.getActiveAttrib(program, i);\n        attribute.typeName = enums[attribute.type];\n        result.attributes.push(attribute);\n        result.attributeCount += attribute.size;\n    }\n    return result;\n}\nvar WebGLStat = (function () {\n    function WebGLStat() {\n    }\n    WebGLStat.printCurrentProgramInfo = function (debug, surface) {\n        if (surface.gl) {\n            var info = getProgramInfo(surface.gl, surface.gl.getParameter(surface.gl.CURRENT_PROGRAM));\n            var table = window.table;\n            if (table) {\n                table(info.uniforms);\n            }\n        }\n        else {\n            debug('Attempted to printProgramInfo but the surface has not established its gl context yet');\n        }\n    };\n    WebGLStat.MAX_VERTEX_UNIFORMS = 0;\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = 0;\n    WebGLStat.MAX_ATTRIBUTES = 0;\n    WebGLStat.WEBGL_SUPPORTED = false;\n    // TODO: This remains static until we have a qay to inject variable parameters into the shader\n    //       Strings. 128 is the guaranteed saftey range for uniform sizes for WebGL. We could have\n    //       Significantly higher numbers on most devices if we have dynamic field replacement for\n    //       Shaders.\n    WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    return WebGLStat;\n}());\nexports.WebGLStat = WebGLStat;\nfunction initStats() {\n    // Let's perform some immediate operations to do some gl querying for useful information\n    function getAContext() {\n        try {\n            var canvas = document.createElement('canvas');\n            return window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    // Attempt to retrieve a context for webgl\n    var gl = getAContext();\n    // If the context exists, then we know gl is supported and we can fill in some metrics\n    if (gl) {\n        WebGLStat.WEBGL_SUPPORTED = true;\n        WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        WebGLStat.MAX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n        // TODO: See TODO at declaration\n        WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    }\n}\ninitStats();\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Does a linear easing of a value\n *\n * @param {number} t The time elapsed: 0 to d\n * @param {number} s The start value\n * @param {number} c The change in value\n * @param {number} d The duration of the change\n *\n * @returns A number linearly progressing from s to s+c depending on the value of\n *          t in relation to d\n */\nfunction linear(t, s, c, d) {\n    return c * t / d + s;\n}\nexports.linear = linear;\nfunction easeInQuad(t, b, c, d) {\n    return c * (t /= d) * t + b;\n}\nexports.easeInQuad = easeInQuad;\nfunction easeOutQuad(t, b, c, d) {\n    return -c * (t /= d) * (t - 2) + b;\n}\nexports.easeOutQuad = easeOutQuad;\nfunction easeInOutQuad(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t + b;\n    return -c / 2 * ((--t) * (t - 2) - 1) + b;\n}\nexports.easeInOutQuad = easeInOutQuad;\nfunction easeInCubic(t, b, c, d) {\n    return c * (t /= d) * t * t + b;\n}\nexports.easeInCubic = easeInCubic;\nfunction easeOutCubic(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t + 1) + b;\n}\nexports.easeOutCubic = easeOutCubic;\nfunction easeInOutCubic(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t + 2) + b;\n}\nexports.easeInOutCubic = easeInOutCubic;\nfunction easeInQuart(t, b, c, d) {\n    return c * (t /= d) * t * t * t + b;\n}\nexports.easeInQuart = easeInQuart;\nfunction easeOutQuart(t, b, c, d) {\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n}\nexports.easeOutQuart = easeOutQuart;\nfunction easeInOutQuart(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t + b;\n    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n}\nexports.easeInOutQuart = easeInOutQuart;\nfunction easeInQuint(t, b, c, d) {\n    return c * (t /= d) * t * t * t * t + b;\n}\nexports.easeInQuint = easeInQuint;\nfunction easeOutQuint(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n}\nexports.easeOutQuint = easeOutQuint;\nfunction easeInOutQuint(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n}\nexports.easeInOutQuint = easeInOutQuint;\nfunction easeInSine(t, b, c, d) {\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n}\nexports.easeInSine = easeInSine;\nfunction easeOutSine(t, b, c, d) {\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\n}\nexports.easeOutSine = easeOutSine;\nfunction easeInOutSine(t, b, c, d) {\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n}\nexports.easeInOutSine = easeInOutSine;\nfunction easeInExpo(t, b, c, d) {\n    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n}\nexports.easeInExpo = easeInExpo;\nfunction easeOutExpo(t, b, c, d) {\n    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n}\nexports.easeOutExpo = easeOutExpo;\nfunction easeInOutExpo(t, b, c, d) {\n    if (t === 0)\n        return b;\n    if (t === d)\n        return b + c;\n    if ((t /= d / 2) < 1)\n        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n}\nexports.easeInOutExpo = easeInOutExpo;\nfunction easeInCirc(t, b, c, d) {\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n}\nexports.easeInCirc = easeInCirc;\nfunction easeOutCirc(t, b, c, d) {\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n}\nexports.easeOutCirc = easeOutCirc;\nfunction easeInOutCirc(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n}\nexports.easeInOutCirc = easeInOutCirc;\nfunction easeInElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n}\nexports.easeInElastic = easeInElastic;\nfunction easeOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n}\nexports.easeOutElastic = easeOutElastic;\nfunction easeInOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d / 2) === 2)\n        return b + c;\n    if (!p)\n        p = d * (.3 * 1.5);\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    if (t < 1)\n        return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n}\nexports.easeInOutElastic = easeInOutElastic;\nfunction easeInBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\n}\nexports.easeInBack = easeInBack;\nfunction easeOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n}\nexports.easeOutBack = easeOutBack;\nfunction easeInOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    if ((t /= d / 2) < 1)\n        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n}\nexports.easeInOutBack = easeInOutBack;\nfunction easeInBounce(t, b, c, d) {\n    return c - easeOutBounce(d - t, 0, c, d) + b;\n}\nexports.easeInBounce = easeInBounce;\nfunction easeOutBounce(t, b, c, d) {\n    if ((t /= d) < (1 / 2.75)) {\n        return c * (7.5625 * t * t) + b;\n    }\n    else if (t < (2 / 2.75)) {\n        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n    }\n    else if (t < (2.5 / 2.75)) {\n        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n    }\n    else {\n        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n    }\n}\nexports.easeOutBounce = easeOutBounce;\nfunction easeInOutBounce(t, b, c, d) {\n    if (t < d / 2)\n        return easeInBounce(t * 2, 0, c, d) * .5 + b;\n    return easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n}\nexports.easeInOutBounce = easeInOutBounce;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar d3_color_1 = __webpack_require__(29);\nvar three_1 = __webpack_require__(0);\nvar bounds_1 = __webpack_require__(4);\nvar pack_node_1 = __webpack_require__(15);\nvar label_1 = __webpack_require__(16);\nvar atlas_texture_1 = __webpack_require__(10);\nvar debug = __webpack_require__(5)('webgl-surface:Atlas');\nvar debugLabels = __webpack_require__(5)('webgl-surface:Labels');\nvar ZERO_IMAGE = {\n    atlasBL: { x: 0, y: 0 },\n    atlasBR: { x: 0, y: 0 },\n    atlasTL: { x: 0, y: 0 },\n    atlasTR: { x: 0, y: 0 },\n    label: new label_1.Label({ text: ' ' }),\n    pixelHeight: 0,\n    pixelWidth: 0,\n};\n/**\n * Defines a manager of atlas', which includes generating the atlas and producing\n * textures defining those pieces of atlas.\n */\nvar AtlasManager = (function () {\n    /**\n     * Generates a new manager for atlas'. This will create and destroy atlas' and\n     * ensure they have the correct settings applied. A manager will also aid in\n     * packing images into the atlas indicated.\n     *\n     * @param {number} width The width of all atlas' generated\n     * @param {number} height The height of all atlas' generated\n     */\n    function AtlasManager(width, height) {\n        /** Gives a reference of all of the images loaded for the atlas */\n        this.atlasImages = {};\n        /** Stores the current mapping of the atlas */\n        this.atlasMap = {};\n        /** Stores all of the textures that are our atlases */\n        this.atlasTexture = {};\n        this.textureWidth = width;\n        this.textureHeight = height;\n    }\n    /**\n     * Atlas' must be created from scratch to update them. In order to properly\n     * update an existing one, you must destroy it then recreate it again.\n     * This is from not knowing how to update a texture via three js.\n     *\n     * @param atlasName The unique name of the atlas so it can be retrieved/referenced easily\n     * @param images The images with their image path set to be loaded into the atlas.\n     *               Images that keep an atlas ID of null indicates the image did not load\n     *               correctly\n     *\n     * @return {Texture} The Threejs texture that is created as our atlas. The images injected\n     *                   into the texture will be populated with the atlas'\n     */\n    AtlasManager.prototype.createAtlas = function (atlasName, images, colors) {\n        return __awaiter(this, void 0, void 0, function () {\n            var atlasMap, canvas, _i, images_1, image, image, texture, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        atlasMap = new pack_node_1.PackNode(0, 0, this.textureWidth, this.textureHeight);\n                        // Create the mapping element for the new atlas so we can track insertions / deletions\n                        this.atlasMap[atlasName] = atlasMap;\n                        // Make a listing of images that is within the atlas\n                        this.atlasImages[atlasName] = [];\n                        canvas = document.createElement('canvas').getContext('2d');\n                        // Size the canvas to the atlas size\n                        canvas.canvas.width = this.textureWidth;\n                        canvas.canvas.height = this.textureHeight;\n                        if (!images) return [3 /*break*/, 4];\n                        _i = 0, images_1 = images;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < images_1.length)) return [3 /*break*/, 4];\n                        image = images_1[_i];\n                        return [4 /*yield*/, this.draw(image, atlasName, canvas)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (!colors) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.drawColors(colors, atlasName, canvas)];\n                    case 5:\n                        image = _b.sent();\n                        // Add the dummy texture info as an image to our list of images\n                        if (image) {\n                            this.atlasImages[atlasName].push(image);\n                        }\n                        _b.label = 6;\n                    case 6:\n                        texture = new three_1.Texture(canvas.canvas);\n                        texture.premultiplyAlpha = true;\n                        texture.generateMipmaps = true;\n                        // Store the texture as the atlas.\n                        this.atlasTexture[atlasName] = texture;\n                        // Store the images as images within the atlas\n                        if (images) {\n                            (_a = this.atlasImages[atlasName]).push.apply(_a, images);\n                        }\n                        debug('Atlas Created-> texture: %o mapping: %o images: %o', texture, atlasMap, images);\n                        return [2 /*return*/, texture];\n                }\n            });\n        });\n    };\n    /**\n     * Disposes of the resources the atlas held and makes the atlas invalid for use\n     *\n     * @param atlasName\n     */\n    AtlasManager.prototype.destroyAtlas = function (atlasName) {\n        if (this.atlasTexture[atlasName]) {\n            this.atlasTexture[atlasName].dispose();\n            this.atlasTexture[atlasName] = null;\n        }\n        if (this.atlasMap[atlasName]) {\n            this.atlasMap[atlasName].destroy();\n            this.atlasMap[atlasName] = null;\n        }\n        if (this.atlasImages[atlasName]) {\n            var none_1 = { x: 0, y: 0 };\n            this.atlasImages[atlasName].forEach(function (image) {\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                image.pixelHeight = 0;\n                image.atlasBL = none_1;\n                image.atlasBR = none_1;\n                image.atlasTL = none_1;\n                image.atlasTR = none_1;\n            });\n            this.atlasImages[atlasName] = null;\n        }\n    };\n    AtlasManager.prototype.isValidImage = function (image) {\n        var isValid = false;\n        if (image && (image.imagePath || (image.label && image.label.text))) {\n            if (image.pixelWidth && image.pixelHeight) {\n                isValid = true;\n            }\n        }\n        return isValid;\n    };\n    AtlasManager.prototype.setDefaultImage = function (image, atlasName) {\n        image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n        return image;\n    };\n    /**\n     * This loads, packs, and draws the indicated image into the specified canvas\n     * using the metrics that exists for the specified atlas.\n     *\n     * @param image The image who should have it's image path loaded\n     * @param atlasName The name of the atlas to make the packing work\n     * @param canvas The canvas we will be drawing into to generate the complete image\n     *\n     * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\n     */\n    AtlasManager.prototype.draw = function (image, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var loadedImage, rect, dimensions, node, insertedNode, ux, uy, uw, uh, atlasDimensions;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Validate the index\n                        if (!this.atlasMap[atlasName]) {\n                            debug('Can not load image, invalid Atlas Name: %o for atlasMaps: %o', atlasName, this.atlasMap);\n                            return [2 /*return*/, false];\n                        }\n                        return [4 /*yield*/, this.loadImage(image)];\n                    case 1:\n                        loadedImage = _a.sent();\n                        // Make sure at this point the image knows it is not affiliated with an atlas\n                        // If something goes wrong with loading or insertting this image, then a null\n                        // Atlas value will indicate the image can not be used appropriately\n                        image.atlasReferenceID = null;\n                        // Only a non-null image means the image loaded correctly\n                        if (loadedImage && this.isValidImage(image)) {\n                            debug('Image loaded: %o', image.imagePath);\n                            rect = new bounds_1.Bounds(0, image.pixelWidth, image.pixelHeight, 0);\n                            dimensions = {\n                                first: image,\n                                second: rect,\n                            };\n                            // Auto add a buffer in\n                            dimensions.second.width += 1;\n                            dimensions.second.height += 1;\n                            node = this.atlasMap[atlasName];\n                            insertedNode = node.insert(dimensions);\n                            // If the result was NULL we did not successfully insert the image into any map\n                            if (insertedNode) {\n                                debug('Atlas location determined: %o', insertedNode);\n                                if (image.label) {\n                                    debugLabels('Atlas location determined. PackNode: %o Dimensions: %o', insertedNode, dimensions);\n                                }\n                                // Apply the image to the node\n                                insertedNode.nodeImage = image;\n                                ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                                uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                                uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                                uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                                atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                                image.atlasReferenceID = atlasName;\n                                image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                                image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                                // Now draw the image to the indicated canvas\n                                canvas.drawImage(loadedImage, insertedNode.nodeDimensions.x, insertedNode.nodeDimensions.y);\n                                // We have finished inserting\n                                return [2 /*return*/, true];\n                            }\n                            else {\n                                // Log an error\n                                console.error(\"Could not fit image into atlas \" + image.imagePath);\n                                image = this.setDefaultImage(image, atlasName);\n                                return [2 /*return*/, false];\n                            }\n                        }\n                        else {\n                            // Log an error and load a default image\n                            console.error(\"Could not load image \" + image.imagePath);\n                            image = this.setDefaultImage(image, atlasName);\n                            return [2 /*return*/, false];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This renders a list of colors to the canvas. This using the same packing\n     * algorithm as any image so the rendering is placed correctly or determines\n     * if enough space is not available.\n     *\n     * @param {AtlasColor[]} colors The list of colors to be rendered to the atlas\n     * @param {string} atlasName The name of the atlas being rendered to\n     * @param {CanvasRenderingContext2D} canvas The canvas of the atlas being rendered to\n     *\n     * @returns {Promise<boolean>} Resolves to true if the operation was successful\n     */\n    AtlasManager.prototype.drawColors = function (colors, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var colorWidth, colorHeight, maxPerRow, rowWidth, rowCount, colCount, renderHeight, dimensions, node, insertedNode, image, ux, uy, uw, uh, atlasDimensions, renderSpace, startX, startY, nextX, nextY, beginX, beginY, col, row, _i, colors_1, color, _a, r, g, b;\n            return __generator(this, function (_b) {\n                debug('Finding space for colors on the atlas: %o', colors);\n                colorWidth = 2;\n                colorHeight = 2;\n                maxPerRow = 1024 / colorWidth;\n                rowWidth = Math.min(this.textureWidth, maxPerRow * colorWidth);\n                rowCount = Math.ceil((colors.length * colorWidth) / rowWidth);\n                colCount = Math.ceil(rowWidth / colorWidth);\n                renderHeight = rowCount * colorHeight;\n                dimensions = {\n                    // Since the algorithm requires something to fill this slot, just make a\n                    // Dummy object\n                    first: new atlas_texture_1.AtlasTexture(null, null),\n                    // Set the dimensions we calculated for the space our colors will take up\n                    // Within the atlas\n                    second: new bounds_1.Bounds(0, rowWidth, renderHeight, 0),\n                };\n                // Auto add a buffer in\n                dimensions.second.width += 1;\n                dimensions.second.height += 1;\n                node = this.atlasMap[atlasName];\n                insertedNode = node.insert(dimensions);\n                // If the result was NULL we did not successfully insert the image into any map\n                if (insertedNode) {\n                    debug('Atlas location determined for colors: %o', insertedNode);\n                    image = insertedNode.nodeImage = dimensions.first;\n                    ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                    uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                    uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                    uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                    atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                    image.atlasReferenceID = atlasName;\n                    image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                    image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                    renderSpace = insertedNode.nodeDimensions;\n                    startX = renderSpace.x;\n                    startY = renderSpace.y;\n                    nextX = colorWidth / this.textureWidth;\n                    nextY = -colorHeight / this.textureHeight;\n                    beginX = (startX / this.textureWidth) + (nextX / 2.0);\n                    beginY = 1.0 - (startY / this.textureHeight) + (nextY / 2.0);\n                    col = 0;\n                    row = 0;\n                    // Loop through each color, establish metrics, draw to the atlas\n                    for (_i = 0, colors_1 = colors; _i < colors_1.length; _i++) {\n                        color = colors_1[_i];\n                        // Staore the info needed to make the color referenceable again\n                        color.atlasReferenceID = atlasName;\n                        color.colorIndex = col + (row * colCount);\n                        color.colorsPerRow = colCount;\n                        // The location of the middle of the first color\n                        color.firstColor = {\n                            x: beginX,\n                            y: beginY,\n                        };\n                        color.nextColor = {\n                            x: nextX,\n                            y: nextY,\n                        };\n                        _a = color.color, r = _a.r, g = _a.g, b = _a.b;\n                        // Draw the color to the canvas\n                        canvas.fillStyle = \"rgba(\" + Math.round(r * 255.0) + \", \" + Math.round(g * 255.0) + \", \" + Math.round(b * 255.0) + \", \" + color.opacity + \")\";\n                        canvas.fillRect(col * colorWidth + startX, row * colorHeight + startY, colorWidth, colorHeight);\n                        col++;\n                        if (col === colCount) {\n                            col = 0;\n                            row++;\n                        }\n                    }\n                    // We have finished inserting\n                    return [2 /*return*/, image];\n                }\n                else {\n                    // Log an error\n                    throw new Error('Could not fit colors into atlas');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Retrieves the threejs texture for the atlas\n     *\n     * @param atlasName The identifier of the atlas\n     */\n    AtlasManager.prototype.getAtlasTexture = function (atlasName) {\n        return this.atlasTexture[atlasName];\n    };\n    /**\n     * This reads the input path and loads the image specified by the path\n     *\n     * @param {AtlasTexture} texture This is an atlas texture with the path set\n     *\n     * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\n     *                                     or null if there was an error\n     */\n    AtlasManager.prototype.loadImage = function (texture) {\n        if (texture.imagePath) {\n            return new Promise(function (resolve, reject) {\n                var image = new Image();\n                image.onload = function () {\n                    texture.pixelWidth = image.width;\n                    texture.pixelHeight = image.height;\n                    texture.aspectRatio = image.width / image.height;\n                    resolve(image);\n                };\n                image.onerror = function () {\n                    resolve(null);\n                };\n                image.src = texture.imagePath;\n            });\n        }\n        else if (texture.label) {\n            return new Promise(function (resolve, reject) {\n                var label = texture.label;\n                var labelSize = label.getSize();\n                var canvas = document.createElement('canvas');\n                var ctx = canvas.getContext('2d');\n                // Set the dimensions of the canvas/texture space we will be using to rasterize\n                // The label. Use the label's rasterization controls to aid in rendering the label\n                canvas.width = labelSize.width;\n                canvas.height = labelSize.height;\n                debug('label X %o', texture.label.rasterizationOffset.x);\n                if (ctx) {\n                    var fontSize = label.fontSize;\n                    var color = d3_color_1.rgb(label.color.base.color.r * 255, label.color.base.color.g * 255, label.color.base.color.b * 255, label.color.base.opacity);\n                    ctx.font = label.makeCSSFont(fontSize);\n                    ctx.textAlign = label.textAlign;\n                    ctx.textBaseline = label.textBaseline;\n                    ctx.fillStyle = color.toString();\n                    // Render the label to the canvas/texture space. This utilizes the label's\n                    // Rasterization metrics to aid in getting a clean render.\n                    ctx.fillText(label.truncatedText || label.text, texture.label.rasterizationOffset.x, texture.label.rasterizationOffset.y);\n                    var image_1 = new Image();\n                    image_1.onload = function () {\n                        // Here we use the canvas dimensions and NOT the image dimensions\n                        // As the image dimensions are unreliable here when setting the src\n                        // To a data url\n                        texture.pixelWidth = image_1.width;\n                        texture.pixelHeight = image_1.height;\n                        texture.aspectRatio = image_1.width / image_1.height;\n                        debugLabels('Applying size based on rasterization to the Label: w: %o h: %o', image_1.width, image_1.height);\n                        label.setSize({\n                            height: image_1.height,\n                            width: image_1.width,\n                        });\n                        resolve(image_1);\n                    };\n                    image_1.onerror = function () {\n                        resolve(null);\n                    };\n                    image_1.src = canvas.toDataURL('image/png');\n                }\n            });\n        }\n        return Promise.resolve(null);\n    };\n    return AtlasManager;\n}());\nexports.AtlasManager = AtlasManager;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(4);\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nvar PackNode = (function () {\n    function PackNode(x, y, width, height) {\n        this.child = [null, null];\n        this.isLeaf = true;\n        this.nodeImage = null;\n        this.nodeDimensions = new bounds_1.Bounds(x, x + width, y, y - height);\n    }\n    /**\n     * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n     */\n    PackNode.prototype.destroy = function () {\n        this.nodeImage = null;\n        if (this.child[0]) {\n            this.child[0].destroy();\n        }\n        if (this.child[1]) {\n            this.child[1].destroy();\n        }\n        this.child[0] = undefined;\n        this.child[1] = undefined;\n    };\n    /**\n     * Indicates if there is a child\n     */\n    PackNode.prototype.hasChild = function () {\n        if (this.child[0] && !this.child[0].nodeImage) {\n            return !this.child[0].isLeaf;\n        }\n        if (this.child[1] && !this.child[1].nodeImage) {\n            return !this.child[1].isLeaf;\n        }\n        return false;\n    };\n    /**\n     * Inserts images into our mapping, fitting them appropriately\n     */\n    PackNode.prototype.insert = function (image) {\n        if (!this.isLeaf) {\n            // Try inserting into first child\n            var newNode = this.child[0].insert(image);\n            if (newNode !== null) {\n                return newNode;\n            }\n            // No room in first so insert into second\n            return this.child[1].insert(image);\n        }\n        else {\n            // If there's already an image here, return\n            if (this.nodeImage) {\n                return null;\n            }\n            // Check the fit status of the image in this nodes rectangle space\n            var fitFlag = this.nodeDimensions.fits(image.second);\n            // If we're too small, return null indicating can not fit\n            if (fitFlag === 0) {\n                return null;\n            }\n            // If we're just right, accept\n            if (fitFlag === 1) {\n                return this;\n            }\n            // Otherwise, gotta split this node and create some leaves\n            this.isLeaf = false;\n            // Get the image width\n            var imgWidth = image.second.width;\n            var imgHeight = image.second.height;\n            // Decide which way to split\n            var dWidth = this.nodeDimensions.width - imgWidth;\n            var dHeight = this.nodeDimensions.height - image.second.height;\n            if (dWidth > dHeight) {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, imgWidth, this.nodeDimensions.height);\n                this.child[1] = new PackNode(this.nodeDimensions.x + imgWidth, this.nodeDimensions.y, dWidth, this.nodeDimensions.height);\n            }\n            else {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, this.nodeDimensions.width, imgHeight);\n                this.child[1] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y + imgHeight, this.nodeDimensions.width, dHeight);\n            }\n        }\n        // Insert into first child we created\n        return this.child[0].insert(image);\n    };\n    /**\n     * Removes the image from the mapping and tries to open up as much space as possible.\n     *\n     * @param {AtlasTexture} image The image to insert into the\n     */\n    PackNode.prototype.remove = function (image) {\n        if (!this.isLeaf) {\n            // Try removing from first child\n            var removed = this.child[0].remove(image);\n            if (removed) {\n                return true;\n            }\n            // Try remove from second\n            removed = this.child[1].remove(image);\n            if (!this.child[0].hasChild()) {\n                if (!this.child[1].hasChild()) {\n                    this.child[0] = null;\n                    this.child[1] = null;\n                }\n            }\n            return removed;\n        }\n        else {\n            if (this.nodeImage === image) {\n                this.nodeImage = null;\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    return PackNode;\n}());\nexports.PackNode = PackNode;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar rotateable_quad_1 = __webpack_require__(17);\nvar sprite_1 = __webpack_require__(18);\nvar measurement = new sprite_1.Sprite(200, 200, 1, 1);\nvar Label = (function (_super) {\n    __extends(Label, _super);\n    /**\n     * Creates an instance of Label.\n     *\n     * @param {Partial<Label<T>>} [options={}]\n     */\n    function Label(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { x: 0, y: 1 }, { width: 1, height: 1 }, 0, rotateable_quad_1.AnchorPosition.TopLeft) || this;\n        _this.depth = 40;\n        _this.direction = 'inherit';\n        _this.font = 'serif';\n        _this.fontSize = 10;\n        _this.fontWeight = 400;\n        _this.maxWidth = undefined;\n        _this.text = '';\n        _this.truncatedText = '';\n        _this.id = '';\n        _this.textAlign = 'start';\n        _this.textBaseline = 'alphabetic';\n        _this.allowScaling = true;\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to offset the rasterization if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationOffset = { x: 20, y: 0 };\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to pad the rasterization space if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationPadding = { width: 0, height: 0 };\n        // Set props\n        Object.assign(_this, options);\n        // Make sure our dimensions are set\n        _this.setFontSize(options.fontSize || 12);\n        return _this;\n    }\n    Object.defineProperty(Label.prototype, \"baseLabel\", {\n        get: function () {\n            return this._baseLabel;\n        },\n        set: function (value) {\n            this._baseLabel = value;\n            this.text = value.text;\n            this.fontSize = value.fontSize;\n            this.font = value.font;\n            this.textAlign = value.textAlign;\n            this.textBaseline = value.textBaseline;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Label.prototype, \"rasterizedLabel\", {\n        /**\n         * This getter ensures the rasterized label retrieved is either this labels own rasterization\n         * or from a base.\n         */\n        get: function () {\n            if (this.baseLabel) {\n                return this.baseLabel.rasterizedLabel;\n            }\n            return this._rasterizedLabel;\n        },\n        set: function (value) {\n            this._rasterizedLabel = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Copies all of the properties of a label and makes this label use them\n     *\n     * @param {Label} label The labels whose properties we wish to copy\n     */\n    Label.prototype.copyLabel = function (label) {\n        // Assign the properties of the other label to this\n        // Specifically, ONLY label properties\n        Object.assign(this, ramda_1.omit(['x', 'y', 'width', 'height'], label));\n        // Use this to set the text to make sure all of the metrics are re-calculated\n        this.setText(label.text);\n    };\n    /**\n     * This gets the actual text this label is capable of rendering\n     */\n    Label.prototype.getText = function () {\n        if (this._baseLabel) {\n            return this._baseLabel.getText();\n        }\n        return this.text;\n    };\n    /**\n     * Takes all of the current settings and makes a CSS font string\n     */\n    Label.prototype.makeCSSFont = function (fontSize) {\n        return this.fontWeight + \" \" + (fontSize || this.fontSize) + \"px \" + this.font;\n    };\n    /**\n     * Change the position this text is rendered to\n     *\n     * @param x X world coordinate\n     * @param y Y world coordinate\n     */\n    Label.prototype.position = function (x, y) {\n        this.x = x;\n        this.y = y;\n    };\n    /**\n     * This sets the font size for the label based on the base text dimensions\n     *\n     * @param {number} fontSize\n     */\n    Label.prototype.setFontSize = function (fontSize) {\n        var lbl = this.getText();\n        var size = this.getSize();\n        var width = size.width;\n        var height = size.height;\n        if (this.baseLabel) {\n            var baseSize = this.baseLabel.getSize();\n            var scale = fontSize / this.baseLabel.fontSize;\n            height = baseSize.height * scale;\n            width = baseSize.width * scale;\n        }\n        else {\n            var ctx = measurement.context;\n            ctx.font = this.makeCSSFont();\n            var size_1 = ctx.measureText(lbl);\n            // Set our properties based on the calculated size\n            height = fontSize + this.rasterizationPadding.height;\n            width = size_1.width + this.rasterizationOffset.x + this.rasterizationPadding.width;\n            // We must analyze the label for truncation based on the max width\n            var threeDotsWide = ctx.measureText('...').width;\n            var str = this.text;\n            var truncatedWidth = width;\n            // If we're beyond our max width limit, we must truncate\n            if (this.maxWidth && (width > this.maxWidth)) {\n                var beyondMax = false;\n                while (truncatedWidth > this.maxWidth) {\n                    str = str.substring(0, str.length - 2);\n                    truncatedWidth =\n                        ctx.measureText(str).width +\n                            threeDotsWide +\n                            this.rasterizationOffset.x +\n                            this.rasterizationPadding.width;\n                    beyondMax = true;\n                }\n                if (beyondMax) {\n                    str += '...';\n                }\n                this.truncatedText = str;\n                width = truncatedWidth;\n            }\n            else {\n                this.truncatedText = '';\n            }\n        }\n        this.fontSize = fontSize;\n        this.setSize({ width: width, height: height });\n    };\n    /**\n     * Change the text and the calculated bounding box for this label\n     */\n    Label.prototype.setText = function (lbl) {\n        this.text = lbl;\n        this.setFontSize(this.fontSize);\n    };\n    Label.prototype.update = function () {\n        this.setFontSize(this.fontSize);\n        _super.prototype.update.call(this);\n    };\n    return Label;\n}(rotateable_quad_1.RotateableQuad));\nexports.Label = Label;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar bounds_1 = __webpack_require__(4);\nvar AnchorPosition;\n(function (AnchorPosition) {\n    AnchorPosition[AnchorPosition[\"BottomLeft\"] = 0] = \"BottomLeft\";\n    AnchorPosition[AnchorPosition[\"BottomRight\"] = 1] = \"BottomRight\";\n    AnchorPosition[AnchorPosition[\"Custom\"] = 2] = \"Custom\";\n    AnchorPosition[AnchorPosition[\"Middle\"] = 3] = \"Middle\";\n    AnchorPosition[AnchorPosition[\"MiddleBottom\"] = 4] = \"MiddleBottom\";\n    AnchorPosition[AnchorPosition[\"MiddleLeft\"] = 5] = \"MiddleLeft\";\n    AnchorPosition[AnchorPosition[\"MiddleRight\"] = 6] = \"MiddleRight\";\n    AnchorPosition[AnchorPosition[\"MiddleTop\"] = 7] = \"MiddleTop\";\n    AnchorPosition[AnchorPosition[\"TopLeft\"] = 8] = \"TopLeft\";\n    AnchorPosition[AnchorPosition[\"TopRight\"] = 9] = \"TopRight\";\n})(AnchorPosition = exports.AnchorPosition || (exports.AnchorPosition = {}));\nvar anchorCalculations = (_a = {},\n    _a[AnchorPosition.BottomLeft] = function (quad) { return ({\n        x: 0,\n        y: 0,\n    }); },\n    _a[AnchorPosition.BottomRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: 0,\n    }); },\n    _a[AnchorPosition.Custom] = function (quad) { return ({\n        x: 0,\n        y: -quad.getSize().height,\n    }); },\n    _a[AnchorPosition.Middle] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: -quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleBottom] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: 0,\n    }); },\n    _a[AnchorPosition.MiddleLeft] = function (quad) { return ({\n        x: 0,\n        y: -quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: -quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleTop] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: -quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopLeft] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: -quad.getSize().height,\n    }); },\n    _a);\nvar RotateableQuad = (function (_super) {\n    __extends(RotateableQuad, _super);\n    /**\n     * Generates a quad\n     *\n     * @param {IPoint} location The location of the quad (it's anchorpoint will be placed here)\n     * @param {number} width The width of the quad\n     * @param {number} height The height of the quad\n     * @param {AnchorPosition} anchor The anchor location of the quad.\n     *                                Location and rotation will be relative to this.\n     */\n    function RotateableQuad(location, size, rotation, anchor) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        // Apply our properties\n        _this.setSize(size);\n        _this.setAnchor(anchor);\n        _this.setLocation(location);\n        _this.setRotation(rotation);\n        return _this;\n    }\n    /**\n     * @private\n     * Recalculates this anchor position based on the anchor type\n     *\n     * @param {AnchorPosition} anchor\n     */\n    RotateableQuad.prototype.calculateAnchor = function (anchor) {\n        this.anchor = anchorCalculations[anchor](this);\n    };\n    /**\n     * Get the base size of the quad\n     *\n     * @returns {ISize} The base size of this quad\n     */\n    RotateableQuad.prototype.getSize = function () {\n        return this.size;\n    };\n    /**\n     * Sets the specified anchor position on the quad\n     *\n     * @param {AnchorPosition} anchor This specifies an auto calculated position for the anchor\n     * @param {IPoint} custom If specified, will set a custom anchor location rather\n     *                        than the calculated version.\n     */\n    RotateableQuad.prototype.setAnchor = function (anchor, custom) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        this.anchorType = anchor;\n        // Apply the custom position if present\n        if (custom) {\n            this.anchorType = AnchorPosition.Custom;\n            this.anchor = custom;\n            return;\n        }\n        this.calculateAnchor(anchor);\n    };\n    RotateableQuad.prototype.getAnchor = function () {\n        return this.anchor;\n    };\n    RotateableQuad.prototype.getAnchorType = function () {\n        return this.anchorType;\n    };\n    /**\n     * This sets the location of this quad to a given position where the anchor\n     * point will be located on top of the location provided.\n     *\n     * @param {IPoint} location The location to place the quad\n     */\n    RotateableQuad.prototype.setLocation = function (location) {\n        this.location = location;\n    };\n    RotateableQuad.prototype.getLocation = function () {\n        return this.location;\n    };\n    /**\n     * Sets the rotation of this quad, in radians, rotated around the anchor point.\n     *\n     * @param {number} rotation The rotation of the quad\n     */\n    RotateableQuad.prototype.setRotation = function (rotation) {\n        this.rotation = rotation;\n    };\n    /**\n     * get Rotation\n     */\n    RotateableQuad.prototype.getRotation = function () {\n        return this.rotation;\n    };\n    /**\n     * get direction as a point\n     */\n    RotateableQuad.prototype.getDirection = function () {\n        var angle = this.rotation;\n        return {\n            x: Math.cos(angle),\n            y: Math.sin(angle),\n        };\n    };\n    /**\n     * Applies the size to the base\n     *\n     * @param {ISize} size The size of the base quad\n     */\n    RotateableQuad.prototype.setSize = function (size) {\n        this.size = size;\n        this.base = [\n            new three_1.Vector4(0, size.height, 0, 1),\n            new three_1.Vector4(size.width, size.height, 0, 1),\n            new three_1.Vector4(0, 0, 0, 1),\n            new three_1.Vector4(size.width, 0, 0, 1),\n        ];\n        if (this.anchorType) {\n            this.calculateAnchor(this.anchorType);\n        }\n    };\n    /**\n     * This re-calculates the transform for this quad and applies the transform to\n     * the corners.\n     */\n    RotateableQuad.prototype.update = function () {\n        // Calculate the pieces of the transformation\n        var anchorMat = new three_1.Matrix4().makeTranslation(-this.anchor.x, this.anchor.y, 0);\n        var rotationMat = new three_1.Matrix4().makeRotationZ(this.rotation);\n        var locationMat = new three_1.Matrix4().makeTranslation(this.location.x, this.location.y, 0);\n        // Compose the transform based on the pieces and apply them\n        // In the proper compositing order\n        this.transform = new three_1.Matrix4()\n            .multiply(locationMat)\n            .multiply(rotationMat)\n            .multiply(anchorMat);\n        // Apply the transform to all of our base vertices\n        this.TL = this.base[0].clone().applyMatrix4(this.transform);\n        this.TR = this.base[1].clone().applyMatrix4(this.transform);\n        this.BL = this.base[2].clone().applyMatrix4(this.transform);\n        this.BR = this.base[3].clone().applyMatrix4(this.transform);\n        // Update the bounds of this object\n        this.x = this.TL.x;\n        this.y = this.TL.y;\n        this.width = 1;\n        this.height = 1;\n        this.encapsulatePoints([this.TR, this.BL, this.BR]);\n    };\n    return RotateableQuad;\n}(bounds_1.Bounds));\nexports.RotateableQuad = RotateableQuad;\nvar _a;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A canvas element wrapper that aids in tracking a canvas element along with\n * content scaling properties.\n *\n * @class Sprite\n */\nvar Sprite = (function () {\n    //\n    // Ctor at the top below props\n    //\n    /**\n     * Creates an instance of Sprite.\n     *\n     * @param w             The width of the context to create\n     * @param h             The height of the context to create\n     * @param contentScaleX The content scaling of the content\n     * @param contentScaleY The content scaling of the content\n     *\n     * @memberOf Sprite\n     */\n    function Sprite(w, h, contentScaleX, contentScaleY) {\n        this.scaleX = 1;\n        this.scaleY = 1;\n        var canvas = document.createElement('canvas');\n        if (canvas) {\n            this.scaleX = contentScaleX || this.scaleX;\n            this.scaleY = contentScaleY || this.scaleY;\n            canvas.width = w * this.scaleX;\n            canvas.height = h * this.scaleY;\n            this.context = canvas.getContext('2d');\n            this.canvas = canvas;\n        }\n    }\n    /**\n     * Retrieves the content scaling of this object\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentScale = function () {\n        return {\n            x: this.scaleX,\n            y: this.scaleY,\n        };\n    };\n    /**\n     * Retrieves the size of the content ignoring scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentSize = function () {\n        return {\n            height: this.canvas.height,\n            width: this.canvas.width,\n        };\n    };\n    /**\n     * Retrieves the dimensional width of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getWidth = function () {\n        return this.canvas.width / this.scaleX;\n    };\n    /**\n     * Retrieves the dimensional height of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getHeight = function () {\n        return this.canvas.height / this.scaleY;\n    };\n    return Sprite;\n}());\nexports.Sprite = Sprite;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar browser = __webpack_require__(33);\nvar three_1 = __webpack_require__(0);\nvar debug = __webpack_require__(5)('CommunicationsView:Mouse');\n/** Used to adjust the base whee delta for IE browsers */\nvar IE_ADJUSTMENT = 1 / 30;\n/** Used to adjust the rates for IE 11 */\nvar OLD_IE_ADJUSTMENT = -0.25;\n// This determines how large the delta can grow to in firefox\nvar MAX_FIREFOX_WHEELDELTA = 100;\n/**\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\n */\nvar lowPassY = [0, 0, 0, 0];\n// These coefficients represent the coefficients of a FIR filter.\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\n// Attained.\nvar LOW_PASS_U0 = 0.1;\nvar LOW_PASS_U1 = 0.2;\nvar LOW_PASS_U2 = 0.2;\nvar LOW_PASS_U3 = 0.5;\nfunction normalizeFirefoxWheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = 0;\n    var deltaY = 0;\n    // Reset the filter if the direction changes to prevent lag in directional change\n    if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\n        lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\n    }\n    deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\n    // Calculate the next value output from the FIR filter\n    deltaY = (wheel.deltaY * MAX_FIREFOX_WHEELDELTA) * LOW_PASS_U0 + lowPassY[0] * LOW_PASS_U1 + lowPassY[1] * LOW_PASS_U2 + lowPassY[2] * LOW_PASS_U3;\n    // Store the value of the filter in the FIR memory bank\n    lowPassY.unshift(deltaY);\n    // Keep our FIR memory clean and only the size of the number of coefficients\n    lowPassY.pop();\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeChromeWheel(e) {\n    var wheel = e.nativeEvent;\n    return new three_1.Vector2(wheel.deltaX, -wheel.deltaY);\n}\nfunction normalizeIE11Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    var deltaY = wheel.deltaY;\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\n        }\n    }\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeIE12Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX, deltaY = wheel.deltaY;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = wheel.wheelDelta || -wheel.detail;\n        }\n    }\n    var v = new three_1.Vector2(deltaX, -deltaY);\n    v.multiplyScalar(0.25);\n    return v;\n}\n// Determine this browsers version of wheel normalization and apply it\nvar normalizeWheel;\nexports.normalizeWheel = normalizeWheel;\nif (browser.firefox) {\n    debug('Using mouse wheel for firefox');\n    exports.normalizeWheel = normalizeWheel = normalizeFirefoxWheel;\n}\nelse if (browser.msie && +browser.version >= 11) {\n    debug('Using mouse wheel for IE 11');\n    exports.normalizeWheel = normalizeWheel = normalizeIE11Wheel;\n}\nelse if (browser.msedge) {\n    debug('Using mouse wheel for MS EDGE');\n    exports.normalizeWheel = normalizeWheel = normalizeIE12Wheel;\n}\nelse {\n    debug('Using mouse wheel for Chrome');\n    exports.normalizeWheel = normalizeWheel = normalizeChromeWheel;\n}\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(e, relative) {\n    var mouseX = 0, mouseY = 0, eventX = 0, eventY = 0, object = relative || e.nativeEvent.target;\n    // Get mouse position on document crossbrowser\n    if (!e) {\n        e = window.event;\n    }\n    if (e.pageX || e.pageY) {\n        mouseX = e.pageX;\n        mouseY = e.pageY;\n    }\n    else if (e.clientX || e.clientY) {\n        mouseX = e.clientX + document.body.scrollLeft\n            + document.documentElement.scrollLeft;\n        mouseY = e.clientY + document.body.scrollTop\n            + document.documentElement.scrollTop;\n    }\n    // Get parent element position in document\n    if (object.offsetParent) {\n        do {\n            eventX += object.offsetLeft;\n            eventY += object.offsetTop;\n            object = object.offsetParent;\n        } while (object);\n    }\n    // Mouse position minus elm position is mouseposition relative to element:\n    return { x: mouseX - eventX, y: mouseY - eventY };\n}\nexports.eventElementPosition = eventElementPosition;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(4);\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nvar maxPopulation = 5;\nvar maxDepth = 10;\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nfunction filterQuery(type, queryValues) {\n    var filtered = [];\n    queryValues.forEach(function (obj) {\n        if (type.find(function (t) { return obj instanceof t; })) {\n            filtered.push(obj);\n        }\n    });\n    return filtered;\n}\nexports.filterQuery = filterQuery;\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nvar Quadrants = (function () {\n    /**\n     * Creates an instance of Quadrants.\n     *\n     * @param bounds The bounds this will create quandrants for\n     * @param depth  The child depth of this element\n     *\n     * @memberOf Quadrants\n     */\n    function Quadrants(bounds, depth) {\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n        var mid = bounds.mid;\n        this.TL = new Node(bounds.x, mid.x, bounds.y, mid.y, depth);\n        this.TR = new Node(mid.x, bounds.right, bounds.y, mid.y, depth);\n        this.BL = new Node(bounds.x, mid.x, mid.y, bounds.bottom, depth);\n        this.BR = new Node(mid.x, bounds.right, mid.y, bounds.bottom, depth);\n    }\n    /**\n     * Ensures all memory is released for all nodes and all references are removed\n     * to potentially high memory consumption items\n     *\n     * @memberOf Quadrants\n     */\n    Quadrants.prototype.destroy = function () {\n        this.TL.destroy();\n        this.TR.destroy();\n        this.BL.destroy();\n        this.BR.destroy();\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n    };\n    return Quadrants;\n}());\nexports.Quadrants = Quadrants;\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nvar Node = (function () {\n    /**\n     * Creates an instance of Node.\n     *\n     * @param l     The bounding left wall of the space this node covers\n     * @param r     The bounding right wall of the space this node covers\n     * @param t     The bounding top wall of the space this node covers\n     * @param b     The bounding bottom wall of the space this node covers\n     * @param depth The depth within the quad tree this node resides\n     *\n     * @memberOf Node\n     */\n    function Node(left, right, top, bottom, depth) {\n        this.bounds = null;\n        this.children = [];\n        this.childrenProps = [];\n        this.depth = 0;\n        this.nodes = null;\n        // If params insertted\n        if (arguments.length >= 4) {\n            this.bounds = new bounds_1.Bounds(left, right, top, bottom);\n        }\n        else {\n            this.bounds = new bounds_1.Bounds(0, 1, 1, 0);\n        }\n        // Ensure the depth is set\n        this.depth = depth || 0;\n    }\n    /**\n     * Destroys this node and ensures all child nodes are destroyed as well.\n     *\n     * @memberOf Node\n     */\n    Node.prototype.destroy = function () {\n        this.children = null;\n        this.bounds = null;\n        if (this.nodes) {\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n    };\n    /**\n     * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n     * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n     * this quad tree spans (and this is the root node), the quad tree will expand to include\n     * the new child.\n     *\n     * @param child The Bounds type object to inject\n     * @param props Properties that can be retrieved with the child object if applicable\n     *\n     * @returns True if the insertion was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.add = function (child, props) {\n        // This is the entry function for adding children, so we must first expand our top node\n        // To cover the area that the child is located.\n        // If we're in bounds, then let's just add the child\n        if (child.isInside(this.bounds)) {\n            return this.doAdd(child);\n        }\n        else {\n            this.cover(child);\n            return this.add(child, props);\n        }\n    };\n    /**\n     * Adds a list of new children to this quad tree. It performs the same operations as\n     * addChild for each child in the list, however, it more efficiently recalculates the\n     * bounds necessary to cover the area the children cover.\n     *\n     * @param children      List of Bounds objects to inject\n     * @param childrenProps List of props to associate with each element\n     *\n     * @memberOf Node\n     */\n    Node.prototype.addAll = function (children, childrenProps) {\n        var _this = this;\n        // Ensure the properties are at least defined\n        childrenProps = childrenProps || [];\n        // Make sure we cover the entire area of all the children.\n        // We can speed this up a lot if we first calculate the total bounds the new children covers\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = -Number.MAX_VALUE;\n        var maxY = -Number.MAX_VALUE;\n        // Get the dimensions of the new bounds\n        children.forEach(function (child) {\n            if (child.x < minX) {\n                minX = child.x;\n            }\n            if (child.right > maxX) {\n                maxX = child.right;\n            }\n            if (child.bottom < minY) {\n                minY = child.bottom;\n            }\n            if (child.y > maxY) {\n                maxY = child.y;\n            }\n        });\n        // Make sure our bounds includes the specified bounds\n        this.cover(new bounds_1.Bounds(minX, maxX, maxY, minY));\n        // Add all of the children into the tree\n        children.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n     * This will cause all children to be re-injected into the tree.\n     *\n     * @param bounds The bounds to include in the tree's coverage\n     *\n     * @memberOf Node\n     */\n    Node.prototype.cover = function (bounds) {\n        var _this = this;\n        // If we are already covering the area: abort\n        if (bounds.isInside(this.bounds)) {\n            return;\n        }\n        // Make our bounds cover the new area\n        this.bounds.encapsulate(bounds);\n        this.bounds.x -= 1;\n        this.bounds.y += 1;\n        this.bounds.width += 2;\n        this.bounds.height += 4;\n        // Get all of the children underneath this node\n        var allChildren = this.gatherChildren([]);\n        // Destroy the split nodes\n        if (this.nodes) {\n            // Completely...destroy...\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n        // Reinsert all children with the new dimensions in place\n        allChildren.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * When adding children, this performs the actual action of injecting the child into the tree\n     * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n     *\n     * @param child The Bounds item to inject into the tree\n     * @param props The props to remain associated with the child\n     *\n     * @returns True if the injection was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.doAdd = function (child) {\n        // If nodes are present, then we have already exceeded the population of this node\n        if (this.nodes) {\n            if (child.isInside(this.nodes.TL.bounds)) {\n                return this.nodes.TL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.TR.bounds)) {\n                return this.nodes.TR.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BL.bounds)) {\n                return this.nodes.BL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BR.bounds)) {\n                return this.nodes.BR.doAdd(child);\n            }\n            // Otherwise, this is a child overlapping this border\n            this.children.push(child);\n            return true;\n        }\n        else if (child.isInside(this.bounds)) {\n            this.children.push(child);\n            // If we exceeded our population for this quadrant, it is time to split up\n            if (this.children.length > maxPopulation && this.depth < maxDepth) {\n                this.split();\n            }\n            return true;\n        }\n        // This is when there is something wrong with the insertted child. The bounds\n        // For the quad should have grown without issue, but in this case the bounds\n        // Could not grow to accomodate the child.\n        if (isNaN(child.width + child.height + child.x + child.y)) {\n            console.error('Child did not fit into bounds because a dimension is NaN', child);\n        }\n        else if (child.area === 0) {\n            console.error('Child did not fit into bounds because the area is zero', child);\n        }\n        // Don't insert the child and continue\n        return true;\n    };\n    /**\n     * Collects all children of all the current and sub nodes into a single list.\n     *\n     * @param list The list we must aggregate children into\n     *\n     * @return The list specified as the list parameter\n     */\n    Node.prototype.gatherChildren = function (list) {\n        list = list.concat(this.children);\n        if (this.nodes) {\n            this.nodes.TL.gatherChildren(list);\n            this.nodes.TR.gatherChildren(list);\n            this.nodes.BL.gatherChildren(list);\n            this.nodes.BR.gatherChildren(list);\n        }\n        return list;\n    };\n    /**\n     * Collects all props associated with the children. This array of props will\n     * mirror the list retrieved with gatherChildren.\n     *\n     * @param list\n     *\n     * @returns The list specified as the list paramter\n     *\n     * @memberOf Node\n     */\n    Node.prototype.gatherProps = function (list) {\n        var _this = this;\n        this.children.forEach(function (c, index) {\n            list.push(_this.childrenProps[index]);\n        });\n        if (this.nodes) {\n            this.nodes.TL.gatherProps(list);\n            this.nodes.TR.gatherProps(list);\n            this.nodes.BL.gatherProps(list);\n            this.nodes.BR.gatherProps(list);\n        }\n        return list;\n    };\n    /**\n     * Entry query for determining query type based on input object\n     *\n     * @param bounds Can be a Bounds or a Point object\n     * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n     *               information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return An array of children that intersects with the query\n     */\n    Node.prototype.query = function (bounds, visit) {\n        // Query a rectangle\n        if (bounds instanceof bounds_1.Bounds) {\n            if (bounds.hitBounds(this.bounds)) {\n                return this.queryBounds(bounds, [], visit);\n            }\n            // Return an empty array when nothing is collided with\n            return [];\n        }\n        // Query a point\n        if (this.bounds.containsPoint(bounds)) {\n            return this.queryPoint(bounds, [], visit);\n        }\n        // Return an empty array when nothing is collided with\n        return [];\n    };\n    /**\n     * Queries children for intersection with a bounds object\n     *\n     * @param b     The Bounds to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return     Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryBounds = function (b, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.hitBounds(b)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (b.hitBounds(this.nodes.TL.bounds)) {\n                this.nodes.TL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.TR.bounds)) {\n                this.nodes.TR.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BL.bounds)) {\n                this.nodes.BL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BR.bounds)) {\n                this.nodes.BR.queryBounds(b, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Queries children for intersection with a point\n     *\n     * @param p     The Point to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return      Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryPoint = function (p, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.containsPoint(p)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (this.nodes.TL.bounds.containsPoint(p)) {\n                this.nodes.TL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.TR.bounds.containsPoint(p)) {\n                this.nodes.TR.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BL.bounds.containsPoint(p)) {\n                this.nodes.BL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BR.bounds.containsPoint(p)) {\n                this.nodes.BR.queryPoint(p, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Creates four sub quadrants for this node.\n     */\n    Node.prototype.split = function () {\n        // Gather all items to be handed down\n        var allChildren = this.gatherChildren([]);\n        // Gather all props for the children to be handed down as well\n        this.nodes = new Quadrants(this.bounds, this.depth + 1);\n        this.children = [];\n        this.childrenProps = [];\n        while (allChildren.length > 0) {\n            this.doAdd(allChildren.pop());\n        }\n    };\n    /**\n     * Traverses the quad tree returning every quadrant encountered\n     *\n     * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n     */\n    Node.prototype.visit = function (cb) {\n        var finished = Boolean(cb(this));\n        if (this.nodes && !finished) {\n            this.nodes.TL.visit(cb);\n            this.nodes.TR.visit(cb);\n            this.nodes.BL.visit(cb);\n            this.nodes.BR.visit(cb);\n        }\n    };\n    return Node;\n}());\nexports.Node = Node;\nvar QuadTree = (function (_super) {\n    __extends(QuadTree, _super);\n    function QuadTree() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QuadTree;\n}(Node));\nexports.QuadTree = QuadTree;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interpolation_1 = __webpack_require__(8);\nvar bounds_1 = __webpack_require__(4);\nvar line_1 = __webpack_require__(7);\nvar point_1 = __webpack_require__(6);\nvar debug = __webpack_require__(5)('bezier');\n/**\n * This enum covers the type of curved lines that can be made. Making a specific curve\n *\n * @export\n * @enum {number}\n */\nvar CurveType;\n(function (CurveType) {\n    /** This will make the curve be generated from interpolating between the end points and provided control points */\n    CurveType[CurveType[\"Bezier\"] = 0] = \"Bezier\";\n    /**\n     * This will draw a curve as though there is a circular arc passing over the two end points. The radius of the\n     * circular arc is determined by how far the control point is from the straight line that can be made from the two\n     * end points.\n     */\n    CurveType[CurveType[\"CircularCCW\"] = 1] = \"CircularCCW\";\n    CurveType[CurveType[\"CircularCW\"] = 2] = \"CircularCW\";\n    /**\n     * This ignores the control points altogether and just created a straight line with a single segment that consists\n     * of the specified endpoints\n     */\n    CurveType[CurveType[\"Straight\"] = 3] = \"Straight\";\n})(CurveType = exports.CurveType || (exports.CurveType = {}));\n// -------[ Distance Calculating Methods ]----------------------------\n/**\n * Calculates the distance to the bezier curve by testing all of the bezier curve's segment lines\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction bezierDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a circle\n * TODO: Using the segment approach for now. Can be sped up by using circle math\n * instead\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction circularDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a straight line\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction straightDistance(line, testPoint) {\n    return new line_1.Line(line.start, line.end).distanceTo(testPoint);\n}\n// -------[ Segment Generating Methods ]----------------------------\n/**\n * Uses quadratic bezier principles to create the segments for a quadratic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier2Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier2(dt * i, start, lineEnd, c1));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Uses cubic bezier principles to create the segments for a cubic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier3Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    var c2 = line.controlPoints[1];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier3(dt * i, start, lineEnd, c1, c2));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that follows along a circular path on the line.\n * The distance the control point is from the straight line that flows through the two\n * end points of the line determines the radius of the curvature of the line\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeCircularCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    debug('CW');\n    // Generate a line so we can have a perpendicular calculation\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        // We get the midpoint of the line as we want to align the center of the circle with this point\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        // The shortest the radius can be is the distance from the line to the mid point\n        // Anything shorter will just result in a hemisphere being rendered\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        // Get the perpendicular direction to the line so we can calculate the center of our circle\n        // From the mid point\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        // Calculate the location of the center of the circle\n        circleCenter = {\n            x: perpendicular.x * distance + midPoint.x,\n            y: perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    debug(' center of circle is %o  %o', circleCenter.x, circleCenter.y);\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Calculate how much to increment theta in our parametric circular equation\n    if (theta1 < theta2)\n        theta1 += Math.PI * 2;\n    var dTheta = (theta1 - theta2) / line.resolution;\n    debug('theta1 is %o, theta2 is %o', theta1, theta2);\n    // Compute the segments based on the information we have gathered by applying it to a circular\n    // Parametric equation\n    var segments = [];\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 - (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 - (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    // Cache the segments if specified by the curved line\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    debug('Generated Circular Segments: %o dTheta: %o radius: %o', segments, dTheta, radius);\n    return segments;\n}\nfunction makeCircularCCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        circleCenter = {\n            x: -perpendicular.x * distance + midPoint.x,\n            y: -perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    if (theta2 < theta1)\n        theta2 += Math.PI * 2;\n    var dTheta = (theta2 - theta1) / line.resolution;\n    var segments = [];\n    // CCW, from end to start\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 + (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 + (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    if (line.cachedSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that is straight, thus only 1 segments is needed\n * and will be generated.\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeStraightSegments(line) {\n    return [line.start, line.end];\n}\n/** A quick lookup for a proper segment creating method for a curved line  */\nvar pickSegmentMethod = (_a = {},\n    _a[CurveType.Bezier] = [\n        null,\n        makeBezier2Segments,\n        makeBezier3Segments,\n    ],\n    _a[CurveType.CircularCW] = [\n        null,\n        makeCircularCWSegments,\n        makeCircularCWSegments,\n    ],\n    _a[CurveType.CircularCCW] = [\n        null,\n        makeCircularCCWSegments,\n        makeCircularCCWSegments,\n    ],\n    _a[CurveType.Straight] = [\n        makeStraightSegments,\n    ],\n    _a);\n/** A quick lookup for a proper distance calculating method for a curved line  */\nvar pickDistanceMethod = (_b = {},\n    _b[CurveType.Bezier] = bezierDistance,\n    _b[CurveType.CircularCW] = circularDistance,\n    _b[CurveType.CircularCCW] = circularDistance,\n    _b[CurveType.Straight] = straightDistance,\n    _b);\n/**\n * Defines an object which illustrates a curved line. Curved lines can be formed in many\n * ways but most often from two end points and some provided control points.\n *\n * @export\n * @class CurvedLine\n * @extends {Bounds<T>}\n * @template T An associated data type with this object. Use <never> if no data type is ever associated\n */\nvar CurvedLine = (function (_super) {\n    __extends(CurvedLine, _super);\n    /**\n     * Generates a primitive that describes a curved line, which is defined by the lines end points, type, and control points\n     *\n     * @param {ICurvedLineOptions} options The configuration options of this curved line\n     */\n    function CurvedLine(options) {\n        var _this = this;\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        _this = _super.call(this, minX, maxX, maxY, minY) || this;\n        // Apply the relevant properties to the curve\n        _this.cachesSegments = options.cacheSegments || false;\n        _this.type = options.type;\n        _this.resolution = options.resolution || 20;\n        // Set the metrics for this curved line\n        _this.setPoints(options.start, options.end, options.controlPoints);\n        // Set the method that will be used for calculating distance from a point\n        _this.distanceMethod = pickDistanceMethod[options.type];\n        return _this;\n    }\n    Object.defineProperty(CurvedLine.prototype, \"values\", {\n        get: function () {\n            return {\n                controlPoints: this.controlPoints,\n                end: this.end,\n                start: this.start,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Calculates the nearest distance from the provided point to this curved line\n     *\n     * @param {IPoint} point The point to test the distance from\n     *\n     * @returns {number} The calculated nearest distance from this curve to the point\n     */\n    CurvedLine.prototype.distanceTo = function (point) {\n        return this.distanceMethod(this, point);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {CurvedLine<any>[]} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    CurvedLine.getClosest = function (lines, point) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(point);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This returns the line strip that represents the curve. A line strip is specifically a group of points\n     * that forms line segments by taking the current point as one end and the previous point as the second end\n     * thus, you would start at index 1 and loop to the end to generate all of the lines composing this single\n     * line.\n     *\n     * @return {IPoint[]} All of the points in the line strip\n     */\n    CurvedLine.prototype.getLineStrip = function () {\n        return this.segmentMethod(this);\n    };\n    /**\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     * @param {boolean} preventRebounding If set, this will prevent the bounds from being recalculated\n     */\n    CurvedLine.prototype.setPoints = function (start, end, controlPoints) {\n        // Apply the points\n        this.start = start;\n        this.end = end;\n        if (controlPoints.length === 0)\n            debug('start: %o, end:%o', start, end);\n        // Get the available segment methods for the given type\n        var segmentMethods = pickSegmentMethod[this.type];\n        // If we adjust the control points we need to re-evaluate the type of segment creation method we use\n        if (controlPoints) {\n            this.controlPoints = controlPoints;\n            // Get the number of control points we want to base the curve off of\n            var numControlPoints = controlPoints.length;\n            // If we have more control points than the methods available, then we use the greatest method available to best\n            // Handle as many control points as possible\n            if (numControlPoints > segmentMethods.length) {\n                numControlPoints = segmentMethods.length - 1;\n            }\n            // Set the method that will be used for generating segments\n            this.segmentMethod = segmentMethods[numControlPoints];\n            // Make sure the input wasn't bad\n            if (!this.segmentMethod) {\n                throw new Error('An Invalid number of control points was provided to a curved line. You must have at LEAST 1 control point. Or 0 for a straight line');\n            }\n            if (this.type === CurveType.Bezier) {\n                this.encapsulatePoints(controlPoints);\n            }\n            else if (this.type === CurveType.CircularCCW || this.type === CurveType.CircularCW) {\n                this.encapsulatePoints(this.getLineStrip());\n            }\n        }\n        this.encapsulatePoint(start);\n        this.encapsulatePoint(end);\n        // Invalidate caches if they exist\n        this.cachedSegments = null;\n    };\n    return CurvedLine;\n}(bounds_1.Bounds));\nexports.CurvedLine = CurvedLine;\nvar _a, _b;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(4);\nvar UID = 0;\nvar Circle = (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * Generate a new Circle object\n     *\n     * @param x The center of the circle\n     * @param y The center of the circle\n     * @param r The radius of the circle\n     * @param d A data object to associate with the circle\n     */\n    function Circle(options) {\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        /** a UID of the circle */\n        _this._id = ++UID;\n        /** Radius of the circle */\n        _this._radius = 0;\n        /** X coord of the center of the circle */\n        _this._centerX = 0;\n        /** Y coord of the center of the circle */\n        _this._centerY = 0;\n        _this._centerX = options.centerX;\n        _this._centerY = options.centerY;\n        _this._radius = options.radius;\n        _this.updateBounds();\n        return _this;\n    }\n    Object.defineProperty(Circle.prototype, \"values\", {\n        get: function () {\n            return {\n                radius: this._radius,\n                x: this._centerX,\n                y: this._centerY,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"radius\", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (val) {\n            this._radius = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (val) {\n            this._centerX = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (val) {\n            this._centerY = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Tests if the specified bounds is inside this circle\n     *\n     * @param b The bounds to test against\n     */\n    Circle.prototype.boundsInside = function (b) {\n        var r2 = this._radius * this._radius;\n        var dx = b.x - this._centerX;\n        var dy = b.y - this._centerY;\n        var dy2 = dy * dy;\n        var dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.right - this._centerX;\n        dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dy = b.bottom - this._centerY;\n        dy2 = dy * dy;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.x - this._centerX;\n        dx2 = dx * dx;\n        return (dx2 + dy2) < r2;\n    };\n    /**\n     * Calculates the distance to a provided point\n     *\n     * @param {IPoint} p The point to calculate the distance of the middle of the\n     *                   circle to\n     * @param {boolean} notSquared Flag true to prevent the Math.sqrt operation, leaving\n     *                             the result as distance^2\n     *\n     * @return {number} The distance from mid circle to the point\n     */\n    Circle.prototype.distanceTo = function (p, notSquared) {\n        var dx = this._centerX - p.x;\n        var dy = this._centerY - p.y;\n        if (notSquared) {\n            return dx * dx + dy * dy;\n        }\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    /**\n     * Retrieves the closest circle to a provided point\n     *\n     * @param {Array} circles The circles to see who is the nearest\n     * @param {IPoint} p The point to compare the circles against for nearness\n     *\n     * @return {Circle} The nearest circle\n     */\n    Circle.getClosest = function (circles, p) {\n        var closestCircle;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        circles.forEach(function (circle) {\n            distance = circle.distanceTo(p, true);\n            if (distance < closestDistance) {\n                closestCircle = circle;\n                closestDistance = distance;\n            }\n        });\n        return closestCircle;\n    };\n    /**\n     * Tests if this circle is colliding with the specified circle\n     *\n     * @param c The circle to test against\n     *\n     * @return {boolean} True if colliding\n     */\n    Circle.prototype.hitCircle = function (c) {\n        var totalDistance = c._radius + this._radius;\n        totalDistance *= totalDistance;\n        return this.distanceTo({ x: c._centerX, y: c._centerY }, true) < totalDistance;\n    };\n    /**\n     * @override\n     * This makes it so the test of a point tests based on a Circle shape\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.hitPoint = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * If there are multiple metrics to update for the circle, this is the most\n     * efficient way to do that as it will update it's bounds only once.\n     *\n     * @param x\n     * @param y\n     * @param r\n     */\n    Circle.prototype.position = function (x, y, r) {\n        this._centerX = x;\n        this._centerY = y;\n        this._radius = r;\n        this.updateBounds();\n    };\n    /**\n     * @override\n     * Tests if a point is inside the circle\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.pointInside = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * When the circle gains different circle metrics, it's Bounds must adjust\n     * accordingly, which is what this method recalculates.\n     */\n    Circle.prototype.updateBounds = function () {\n        var radius = this._radius;\n        this.x = this._centerX - radius;\n        this.y = this._centerY - radius;\n        this.height = radius * 2;\n        this.width = radius * 2;\n    };\n    /**\n     * Pretty print the metrics of this circle\n     */\n    Circle.prototype.toString = function () {\n        return \"[Circle {x: \" + this._centerX + \", y: \" + this._centerY + \", r: \" + this._radius + \"}]\";\n    };\n    return Circle;\n}(bounds_1.Bounds));\nexports.Circle = Circle;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = __webpack_require__(7);\n/**\n * Defines a line that can be drawn\n */\nvar LineShape = (function (_super) {\n    __extends(LineShape, _super);\n    /**\n     * Generate a new line that can be drawn\n     */\n    function LineShape(options) {\n        var _this = _super.call(this, options.p1, options.p2) || this;\n        _this.allowScaling = options.allowScaling || false;\n        _this.depth = options.depth || 0.0;\n        _this.endColor = options.endColor;\n        _this.startColor = options.startColor;\n        _this.thickness = options.thickness || 1.0;\n        return _this;\n    }\n    /**\n     * Clones this instance of the line shape and creates a new instance of a line shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this line shape\n     */\n    LineShape.prototype.clone = function (newProperties) {\n        return Object.assign(new LineShape(this), newProperties);\n    };\n    return LineShape;\n}(line_1.Line));\nexports.LineShape = LineShape;\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar shape_buffer_cache_1 = __webpack_require__(25);\n/** This is a part of the identifier that is used to retrieve a multibuffer's storage */\nvar multiBufferSelectionPrefix = '__mb__';\n/** This is to ensure each multibuffer gets it's own unique selection identifier */\nvar multiBufferSelectionKeyUID = 0;\nfunction getIDProp(item) {\n    return item.id;\n}\nfunction evenRoundRobinBufferAdd(item, buffers) {\n    var smallest = buffers[0].buffer.length;\n    var found = buffers[0];\n    // Look for the next buffer that has the smallest length\n    // To fill it up\n    buffers.some(function (tracker) {\n        if (tracker.buffer.length < smallest) {\n            found = tracker;\n            return true;\n        }\n        return false;\n    });\n    found.buffer.push(item);\n    return [found];\n}\nfunction noop() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // NO-OP\n}\nfunction echoBuffer(item, buffer, buffers) {\n    return [buffer];\n}\n/**\n * This class helps facilitate breaking up a potentially large shape buffer into multiple buffers.\n */\nvar MultiShapeBufferCache = (function (_super) {\n    __extends(MultiShapeBufferCache, _super);\n    /**\n     * Makes a new multi shape buffer for minimizing changes\n     *\n     * @param numBuffers The number of buffers this multibuffer will manage\n     */\n    function MultiShapeBufferCache(numBuffers, methods) {\n        var _this = _super.call(this) || this;\n        /** The number of buffers this multi buffer manages */\n        _this.numBuffers = 0;\n        /** UID for storing the data for this buffer in the selection */\n        _this.selectionUID = multiBufferSelectionPrefix + (++multiBufferSelectionKeyUID);\n        /**\n         * The method used to add to the buffers. This is changeable so one can implement geometric or\n         * logical adds for invalidation. This returns a list of buffers that will be invalidated from\n         * the operation. The first buffer returned in the invalidation is the strongly associated buffer\n         * to the item injected. This first buffer is the most likely buffer the item is injected into.\n         */\n        _this.addMethod = evenRoundRobinBufferAdd;\n        /**\n         * Gives an implentor opportunity to define the way an is is specified for a given item. It\n         * defaults to searching for an 'id' property on the item.\n         */\n        _this.idMethod = getIDProp;\n        /**\n         * The method that is called right after the initial buffers get constructed. This is changeable\n         * so monitors can.\n         */\n        _this.initMethod = noop;\n        /**\n         * The method that is called right before a shape is removed from a buffer.\n         * This let's the\n         */\n        _this.removeMethod = echoBuffer;\n        /**\n         * The method that is called when an item is updated. This gives a monitor a chance to invalidate\n         * a number of buffers.\n         */\n        _this.updateMethod = echoBuffer;\n        // Store the number of buffers that are created when the buffers are initialized\n        _this.numBuffers = numBuffers;\n        // Set the hook methods if any are specified\n        if (methods) {\n            _this.addMethod = methods.add || _this.addMethod;\n            _this.idMethod = methods.id || _this.idMethod;\n            _this.initMethod = methods.init || _this.initMethod;\n            _this.removeMethod = methods.remove || _this.removeMethod;\n            _this.updateMethod = methods.update || _this.updateMethod;\n        }\n        return _this;\n    }\n    /**\n     * Adds a shape to a buffer and invalidates it\n     *\n     * @param shape The shape to add to a buffer\n     */\n    MultiShapeBufferCache.prototype.addShape = function (shape) {\n        // Perform the custom add opearation\n        var buffers = this.addMethod(shape, this.store.allBuffers);\n        // Stores the shape for lookup via id\n        this.store.idToItem.set(this.idMethod(shape), shape);\n        // Stores the shape for lookup to buffer. We count the\n        // First dirty buffer as the buffer the item is the closest to\n        // Association.\n        this.store.itemToBuffer.set(shape, buffers[0]);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * Clears the multi buffer's storage\n     */\n    MultiShapeBufferCache.prototype.destroy = function () {\n        if (this.store) {\n            this.store.selection.clearSelection(this.selectionUID);\n            delete this.store;\n        }\n    };\n    /**\n     * Sees if there is a shape associated with this id\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.containsId = function (id) {\n        return Boolean(this.store.idToItem.get(id));\n    };\n    /**\n     * Sees if this shape has been added to this buffer or not\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.containsShape = function (shape) {\n        // Check if this multibuffer has the shape or no\n        return Boolean(this.store.itemToBuffer.get(shape));\n    };\n    /**\n     * This flags a list of buffers as dirty\n     *\n     * @param buffers\n     */\n    MultiShapeBufferCache.prototype.flagBuffersDirty = function (buffers) {\n        // Flag provided buffers as dirty\n        if (buffers) {\n            // This flags the indicated buffers as dirty\n            buffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n        else {\n            this.store.allBuffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n    };\n    /**\n     * @override\n     * This is called with triggers all of the updates necessary.\n     * We add in our buffer update and invalidation to this process here.\n     *\n     * @param args\n     */\n    MultiShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        // Run the generation which will trigger cache building and modding\n        _super.prototype.generate.apply(this, arguments);\n        // We now invalidate any buffers that have been flagged\n        this.processDirtyBuffers();\n    };\n    /**\n     * @override\n     * This retrieves the multibuffer for this shape buffer\n     */\n    MultiShapeBufferCache.prototype.getBuffer = function () {\n        console.warn('A multishape buffer should have getBuffers called instead');\n        return [];\n    };\n    /**\n     * Get all of the buffers.\n     * WARNING: do NOT modify the output values in any way.\n     *\n     * @return {T[][]} All of the buffers\n     */\n    MultiShapeBufferCache.prototype.getBuffers = function () {\n        if (this.store) {\n            return this.store.allBuffers.map(function (tracker) { return tracker.buffer; });\n        }\n        return [];\n    };\n    /**\n     * Returns the number of buffers this MultiShapeBuffer is managing.\n     */\n    MultiShapeBufferCache.prototype.getNumBuffers = function () {\n        return this.store.allBuffers.length;\n    };\n    /**\n     * Retrieves a shape by the given id. Is undefined if the id is not recognized.\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.getShapeById = function (id) {\n        return this.store.idToItem.get(id);\n    };\n    /**\n     * This makes all buffers a part of a new array pointer thus making sure\n     * they will be committed to the gpu.\n     */\n    MultiShapeBufferCache.prototype.processDirtyBuffers = function () {\n        this.store.allBuffers.forEach(function (tracker) {\n            if (tracker.isDirty) {\n                tracker.isDirty = false;\n                tracker.buffer = [].concat(tracker.buffer);\n            }\n        });\n    };\n    /**\n     * This retrieves the storage inside the selection. If it doesn't exist,\n     * then the storage is created.\n     *\n     * @param selection\n     */\n    MultiShapeBufferCache.prototype.getStorage = function (selection) {\n        // Get the storage from the selection\n        var storage = (selection.getSelection(this.selectionUID) || [])[0];\n        // If the storage is not stored in the selection, then we create a storage and update the selection with that storage\n        if (!storage) {\n            storage = {\n                allBuffers: [],\n                idToItem: new Map(),\n                itemToBuffer: new Map(),\n                selection: selection,\n            };\n            // Generate the buffers indicated\n            for (var i = 0; i < this.numBuffers; ++i) {\n                storage.allBuffers.push({\n                    buffer: [],\n                    isDirty: false,\n                });\n            }\n            // Initialize anything that may be monitoring the buffers\n            this.initMethod(storage.allBuffers);\n            // Add the storage to the selection\n            selection.select(this.selectionUID, storage);\n        }\n        // Make sure our internal pointer to the storage is set correctly\n        return (this.store = storage);\n    };\n    /**\n     * Removes a shape from the buffer it is a part of.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.removeShape = function (shape) {\n        // This is the buffer associated with the shape\n        var buffer = this.store.itemToBuffer.get(shape);\n        // Get the buffers invalidated by the remove\n        var buffers = this.removeMethod(shape, buffer, this.store.allBuffers);\n        // Clear the shape out from the buffer\n        buffer.buffer.splice(buffer.buffer.indexOf(shape), 1);\n        // Delete the item from the id lookup\n        this.store.idToItem.delete(this.idMethod(shape));\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * This is called to indicate an update to an item has occurred.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.updateShape = function (shape) {\n        // Flag each element that needs updating\n        var buffers = this.updateMethod(shape, this.store.itemToBuffer.get(shape), this.store.allBuffers);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    return MultiShapeBufferCache;\n}(shape_buffer_cache_1.ShapeBufferCache));\nexports.MultiShapeBufferCache = MultiShapeBufferCache;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar ShapeBufferCache = (function () {\n    function ShapeBufferCache() {\n        this.buffer = [];\n        this.bustCache = true;\n    }\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    ShapeBufferCache.prototype.generate = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this.bustCache) {\n            this.buildCache.apply(this, args);\n            this.bustCache = false;\n        }\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    ShapeBufferCache.prototype.buildCache = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Get the buffer the cache has generated\n     */\n    ShapeBufferCache.prototype.getBuffer = function () {\n        return this.buffer;\n    };\n    return ShapeBufferCache;\n}());\nexports.ShapeBufferCache = ShapeBufferCache;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(27));\n__export(__webpack_require__(34));\n__export(__webpack_require__(47));\n__export(__webpack_require__(57));\n__export(__webpack_require__(58));\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar React = __webpack_require__(28);\nvar three_1 = __webpack_require__(0);\nvar atlas_manager_1 = __webpack_require__(14);\nvar atlas_texture_1 = __webpack_require__(10);\nvar bounds_1 = __webpack_require__(4);\nvar frame_info_1 = __webpack_require__(11);\nvar mouse_1 = __webpack_require__(19);\nvar quad_tree_1 = __webpack_require__(20);\nvar webgl_stat_1 = __webpack_require__(12);\nvar debug = __webpack_require__(5)('webgl-surface:GPU');\nvar debugCam = __webpack_require__(5)('webgl-surface:Camera');\nvar debugLabels = __webpack_require__(5)('webgl-surface:Labels');\nvar debugColors = __webpack_require__(5)('webgl-surface:Colors');\n/**\n * This enum names the base methods that are passed into the applyPropsMethods\n * method. This allows subclasses to easily pick the property setting methods they need\n * from the base\n */\nvar BaseApplyPropsMethods;\n(function (BaseApplyPropsMethods) {\n    /** Initializes any context that needs to be set up before the props are set */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"INITIALIZE\"] = 0] = \"INITIALIZE\";\n    /** Moment when any buffer changes should be applied */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"BUFFERCHANGES\"] = 1] = \"BUFFERCHANGES\";\n    /** Initializes camera properties to facilitate smoothe start up */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"CAMERA\"] = 2] = \"CAMERA\";\n    /** Generates the labels as images within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"LABELS\"] = 3] = \"LABELS\";\n    /** Generates the colors within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"COLORS\"] = 4] = \"COLORS\";\n})(BaseApplyPropsMethods = exports.BaseApplyPropsMethods || (exports.BaseApplyPropsMethods = {}));\n/**\n * This enum names the base methods that are passed into the animatedMethods\n * method. This allows subsclasses to easily pick the animated methods they need\n * from the base\n */\nvar BaseAnimatedMethods;\n(function (BaseAnimatedMethods) {\n    /** Sets up the base context needed to execute most methods */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"CONTEXT\"] = 0] = \"CONTEXT\";\n    /** Sets up the inertia method for inertial panning */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"INERTIA\"] = 1] = \"INERTIA\";\n    /** Animates the postion of the camera to a destination */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"POSITION\"] = 2] = \"POSITION\";\n    /** Zooms the camera based on a point of focus */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"ZOOM\"] = 3] = \"ZOOM\";\n})(BaseAnimatedMethods = exports.BaseAnimatedMethods || (exports.BaseAnimatedMethods = {}));\nfunction isAnimatedWithOptions(value) {\n    if (value.options) {\n        return true;\n    }\n    return false;\n}\nfunction isAnimated(value) {\n    if (!value.options) {\n        return true;\n    }\n    return false;\n}\n/** This is the smallest increment the zoom can make. Anything less and nothing will happen */\nvar MIN_ZOOM_INCREMENT = 0.001;\nvar BYTE_MAX = 0xFF;\nvar BACKGROUND_COLOR = new three_1.Color().setRGB(38 / BYTE_MAX, 50 / BYTE_MAX, 78 / BYTE_MAX);\n// --[ CONSTANTS ]-------------------------------------------\n// Make a container vector for performing operations within\nvar vector = new three_1.Vector3();\n// --[ SHADERS ]-------------------------------------------\n/**\n * Equivalent of Math.sign, but faster, and works in all browsers\n *\n * @param {number} value The number to determine the sign\n *\n * @return {number} Returns zero if a sign can not be determined, -1 for a negative, 1 for a positive\n */\nfunction sign(value) {\n    if (!value) {\n        return 0;\n    }\n    if (value > 0) {\n        return 1;\n    }\n    if (value < 0) {\n        return -1;\n    }\n    return 0;\n}\n/**\n * The base component for the communications view\n */\nvar WebGLSurface = (function (_super) {\n    __extends(WebGLSurface, _super);\n    function WebGLSurface() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** This is the atlas manager for managing images and labels rendered as textures */\n        _this.atlasManager = new atlas_manager_1.AtlasManager(2048, 2048);\n        /** Tracks the names of the atlas' generated */\n        _this.atlasNames = {\n            colors: 'colors',\n            labels: 'labels',\n        };\n        /**\n         * List of methods that execute within the animation loop. Makes adding and removing these methods\n         * simpler to manage, as well as gives a clear and optimized way of overriding existing methods\n         * or reordering their execution\n         */\n        _this.animatedMethodList = [];\n        /**\n         * If this is set to true during an animated method's lifecycle, then all subsequent animated methods\n         * will not be executed for the current frame. Upon reaching the end of the frame, the break will reset\n         * and the animated methods will attempt executing again\n         */\n        _this.animatedMethodBreak = false;\n        /**\n         * The camera that 'looks' at our world and gives us the ability to convert\n         * screen coordinates to world coordinates, and vice versa\n         */\n        _this.camera = new three_1.OrthographicCamera(0, 0, 0, 0, 0, 0);\n        /**\n         * This is the latest colors loading identifier, used to determine if the colors\n         * last loaded matches the colors currently needing to be rendered. Fixes asynchronous\n         * Issue where a new set of colors is requested before the previous set(s) have completed\n         */\n        _this.colorsCurrentLoadedId = 0;\n        /** This is the is of the current and most recent color group being loaded in */\n        _this.colorsLoadId = 0;\n        /**\n         * While this number is positive it will be decremented every frame.\n         * While positive, mouse interactions will not occur. This utilizes frame ticks\n         * as SOME values and numbers settle per frame, not necessarily within timelapses.\n         * More often than not, there will only be a need for 1-2 frames of mouse disable to\n         * allow the camera to be positioned in a correct location before screen to world projections\n         * start taking place.\n         */\n        _this.disableMouseInteraction = 0;\n        /** Used to aid in mouse interactions */\n        _this.distance = 0;\n        _this.sizeCamera = null;\n        /** Keep track of the current zoom so it can be set in requestAnimationFrame */\n        _this.currentZoom = 1;\n        /** Horizontal destination the camera will pan to */\n        _this.destinationX = 0;\n        /** Vertical position the camera will pan to */\n        _this.destinationY = 0;\n        /** The destination zoom level the camera used during panning */\n        _this.destinationZoom = 1;\n        /** Is the camera currently in a panning state */\n        _this.isPanning = false;\n        /** Last known screen position of the mouse */\n        _this.lastMousePosition = { x: 0, y: 0 };\n        /** List of methods to execute when applying props */\n        _this.propsMethodList = [];\n        /** Inertial values for drag panning */\n        _this.inertia = null;\n        _this.inertiaBuild = 1.5;\n        _this.inertiaDecay = .9;\n        _this.inertiaMax = 100;\n        /**\n         * All data is put into this quad tree so we can query spatial regions for\n         * items\n         */\n        _this.quadTree = null;\n        /**\n         * True if the shift key is currently being held\n         *\n         * Panning is affected by whether or not the shift key is being held down, but\n         * I don't know how yet.\n         */\n        _this.shiftIsDown = false;\n        _this.stop = false;\n        /** The current rendered position and zoom */\n        _this.currentX = 0;\n        _this.currentY = 0;\n        _this.targetZoom = 1;\n        /** The (world) position the focus will zoom in and out of */\n        _this.previousZoomToFit = 0;\n        _this.zoomTargetX = 0;\n        _this.zoomTargetY = 0;\n        /** When this is set, the draw loop continues to run. Used by the draw loop to complete animations */\n        _this.animating = false;\n        _this.labels = [];\n        _this.labelsReady = false;\n        /**\n         * This is the latest labels loading identifier, used to determine if the labels\n         * last loaded matches the labels currently needing to be rendered.\n         */\n        _this.labelsCurrentLoadedId = 0;\n        _this.labelsLoadId = 0;\n        /** When this is set to true, the atlas with the colors is now ready to be referenced */\n        _this.colors = [];\n        _this.colorsReady = false;\n        /** This is a flag that allows some extra control over when an onRender can fire */\n        _this.isRenderReady = true;\n        /** Holds the items currently hovered over */\n        _this.currentHoverItems = [];\n        /** Mouse in stage or not */\n        _this.dragOver = true;\n        /** Flag for detecting whether or not webgl is supported at all */\n        /**\n         * This is the update loop that operates at the requestAnimationFrame speed.\n         * This updates the cameras current position and causes changes over time for\n         * any property that has a start and a destination.\n         */\n        _this.animate = function () {\n            if (_this.stop) {\n                return;\n            }\n            frame_info_1.FrameInfo.lastFrameTime = Date.now();\n            frame_info_1.FrameInfo.framesPlayed.set(_this, (frame_info_1.FrameInfo.framesPlayed.get(_this) || 0) + 1);\n            requestAnimationFrame(function () { return _this.animate(); });\n            var response;\n            var doDraw = false;\n            var didBreak = _this.animatedMethodList.some(function (method) {\n                if (isAnimatedWithOptions(method)) {\n                    if (method.options.labelsReady && method.options.colorsReady) {\n                        if (_this.labelsReady && _this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.labelsReady) {\n                        if (_this.labelsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.colorsReady) {\n                        if (_this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                }\n                else if (isAnimated(method)) {\n                    response = method();\n                }\n                // Update our draw status based on response\n                if (!doDraw) {\n                    doDraw = response.doDraw;\n                }\n                // Stop the system if needed\n                if (response.stop) {\n                    _this.stop = true;\n                }\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            // We prevent any animation loop execution if we did break\n            if (didBreak) {\n                return;\n            }\n            // Make sure all camera related uniforms are up to date\n            _this.updateCameraUniforms();\n            // Handle the deactivation period of mouse interactions by decrementing it\n            // If it's positive\n            if (_this.disableMouseInteraction > 0) {\n                _this.disableMouseInteraction--;\n            }\n            if (doDraw || _this.forceDraw) {\n                _this.forceDraw = false;\n                _this.emitViewport();\n                _this.draw();\n            }\n        };\n        /**\n         * Applies new props injected into this component.\n         *\n         * Applying new props does not entail that a re-render will happen so we\n         * handle application of props as a separate concept. Here we:\n         *\n         * set up zoom targetting and apply quested zoom levels\n         *\n         * Create our quad tree and associate properties to objects if a new dataset\n         * is provided\n         *\n         * Analyze our dataset for interesting and useful metrics such as max and mins\n         * to aid in visualization normalization\n         *\n         * @param {T} props The new properties for this component\n         */\n        _this.applyProps = function (props) {\n            debug('Applying props');\n            var response;\n            _this.propsMethodList.some(function (method) {\n                response = method(props);\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            debugCam('current cam', _this.currentX, _this.currentY, _this.destinationX, _this.destinationY);\n            debugCam('Zoom Target: [%o, %o]', _this.zoomTargetX, _this.zoomTargetY);\n            debugCam('Last Mouse: [%o, %o]', _this.lastMousePosition.x, _this.lastMousePosition.y);\n        };\n        /**\n         * This initializes the surface and calls for sub class classes to initialize\n         * their buffers\n         *\n         * @param {HTMLElement} el The DOM element this component is contained in\n         * @param {number} w The width of the rendering\n         * @param {number} h The height of the rendering\n         */\n        _this.init = function (el, w, h) {\n            if (!el || _this.scene) {\n                return;\n            }\n            _this.renderEl = el;\n            if (w === 0 || h === 0) {\n                return;\n            }\n            debug('Initializing GPU objects el: %o width: %o height: %o', el, w, h);\n            // Set up a ctx for our render space\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2.0,\n                width: w,\n                widthHalf: w / 2.0,\n            };\n            // Set up the camera now that the ctx is set up\n            _this.initCamera();\n            // Create a scene so we can add our buffer objects to it\n            // We also add the scene to the window to make threejs tools available\n            window.scene = _this.scene = new three_1.Scene();\n            // Fire our hook for starting up our specific buffer implementation\n            _this.initBuffers();\n            // FINALIZE SET UP\n            // Generate the renderer along with it's properties\n            _this.renderer = new three_1.WebGLRenderer({\n                alpha: _this.props.backgroundColor && (_this.props.backgroundColor.opacity < 1.0),\n                antialias: true,\n                preserveDrawingBuffer: true,\n            });\n            // This sets the pixel ratio to handle differing pixel densities in screens\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            // Applies the background color and establishes whether or not the context supports\n            // Alpha or not\n            if (_this.props.backgroundColor) {\n                _this.renderer.setClearColor(new three_1.Color(_this.props.backgroundColor.r, _this.props.backgroundColor.g, _this.props.backgroundColor.b), _this.props.backgroundColor.opacity);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            // We render shapes. We care not for culling.\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            // Set up DOM interaction with the renderer\n            var container = el;\n            container.appendChild(_this.renderer.domElement);\n            // Get the gl context for queries and advanced operations\n            _this.gl = _this.renderer.domElement.getContext('webgl');\n            _this.makeDraggable(document.getElementById('div'), _this);\n        };\n        /**\n         * Initializes the camera and any contexts associated with it\n         */\n        _this.initCamera = function () {\n            debug('Initializing Camera');\n            // INITIALIZE THE CAMERA\n            var h = _this.ctx.height;\n            var viewSize = h;\n            var w = _this.ctx.width;\n            var aspectRatio = w / h;\n            var viewport = {\n                aspectRatio: aspectRatio,\n                bottom: -viewSize / 2,\n                far: 10000000,\n                left: (-aspectRatio * viewSize) / 2,\n                near: -100,\n                right: (aspectRatio * viewSize) / 2,\n                top: viewSize / 2,\n                viewSize: viewSize,\n            };\n            _this.camera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.sizeCamera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.camera.position.z = 300;\n            _this.sizeCamera.position.set(0, 0, 300);\n        };\n        /**\n         * This is executed when our rendering surface (the canvas) changes in size in any\n         * way. It will make sure our renderer matches the context to prevent scaling\n         * and other deformations.\n         */\n        _this.resizeContext = function () {\n            var w = _this.props.width;\n            var h = _this.props.height;\n            // See if a renderer even exists yet\n            if (!_this.renderer) {\n                return false;\n            }\n            var renderSize = _this.renderer.getSize();\n            // Check if the resize is needed\n            if (renderSize.width === w && renderSize.height === h) {\n                return false;\n            }\n            debug('RENDERER RESIZE');\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2,\n                width: w,\n                widthHalf: w / 2,\n            };\n            var zoom = _this.camera.zoom;\n            var position = _this.camera.position.clone();\n            _this.initCamera();\n            _this.camera.zoom = zoom;\n            _this.camera.position.set(position.x, position.y, position.z);\n            _this.camera.updateProjectionMatrix();\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            if (_this.props.backgroundColor) {\n                var color = _this.props.backgroundColor;\n                _this.renderer.setClearColor(new three_1.Color(color.r, color.g, color.b), color.opacity < 1.0 ? color.opacity : undefined);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            return true;\n        };\n        /**\n         * This method handles emitting the viewport and the current visible elements\n         * to the subclass that needs detailed information regarding the viewport.\n         */\n        _this.emitViewport = function () {\n            var tl = _this.screenToWorld(0, 0);\n            var br = _this.screenToWorld(_this.ctx.width, _this.ctx.height);\n            _this.camera.updateMatrixWorld(true);\n            var visible = _this.quadTree.query(new bounds_1.Bounds(tl.x, br.x, tl.y, br.y));\n            _this.onViewport(visible, _this.projection, _this.ctx);\n        };\n        /**\n         * Handles mouse interactions when the mouse is pressed on the canvas. This\n         * engages panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseDown = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = true;\n            _this.distance = 0;\n            _this.onMouseDown();\n        };\n        /**\n         * Handles mouse interactions when the mouse is release or left the canvas. This\n         * stops panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseOut = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            _this.distance = 0;\n            _this.onMouseOut();\n        };\n        /**\n         * Handles mouse interactions when the mouse is released on the canvas. This\n         * stops panning and engages click events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseUp = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            // Handle mouse interaction\n            if (_this.distance < 5) {\n                var hitInside = [];\n                // Circle Interaction\n                var hitItems = _this.quadTree.query(world);\n                for (var _i = 0, hitItems_1 = hitItems; _i < hitItems_1.length; _i++) {\n                    var item = hitItems_1[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                    }\n                }\n                // Tell the listener that the user clicked on some items\n                if (hitInside.length) {\n                    _this.onMouseUp(e, hitInside, mouse, world, _this.projection);\n                }\n                else {\n                    _this.onMouseUp(e, null, mouse, world, _this.projection);\n                }\n            }\n        };\n        /**\n         * Handles mouse interactions when the mouse is moving on the canvas. This\n         * causes panning and hover events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseMove = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            var onMouse = _this.props.onMouse;\n            var zoom = _this.props.zoom;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            _this.distance++;\n            // Handle panning\n            if (_this.isPanning) {\n                debug('down and moving ~~');\n                var xDistance = (mouse.x - _this.lastMousePosition.x) / _this.targetZoom;\n                var yDistance = -(mouse.y - _this.lastMousePosition.y) / _this.targetZoom;\n                // Execute the hook to allow subclasses\n                var pan = _this.willPan(xDistance, yDistance);\n                xDistance = pan.x;\n                yDistance = pan.y;\n                _this.destinationX -= xDistance;\n                _this.destinationY -= yDistance;\n                _this.inertia = _this.inertia || { x: 0, y: 0 };\n                if (sign(xDistance) !== sign(_this.inertia.x)) {\n                    _this.inertia.x = 0;\n                }\n                if (sign(yDistance) !== sign(_this.inertia.y)) {\n                    _this.inertia.y = 0;\n                }\n                _this.inertia.x = xDistance * _this.inertiaBuild;\n                _this.inertia.y = yDistance * _this.inertiaBuild;\n                var maxInertia = _this.inertiaMax / zoom;\n                var mag = Math.sqrt(_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y);\n                // Make sure the magnitude of the inertia is less than our max allowed\n                if (mag > maxInertia) {\n                    // Since it's greater, let's confine the inertia's magnitude to the max magnitude\n                    // By normalizing the intertia vector and multilying it by the max\n                    _this.inertia.x = (_this.inertia.x / mag) * maxInertia;\n                    _this.inertia.y = (_this.inertia.y / mag) * maxInertia;\n                }\n            }\n            if (_this.quadTree && !_this.isPanning) {\n                // Empty the last hovered items to populate a new list\n                var currentHoverItems = [];\n                // Handle mouse interaction with items\n                // Interaction with circles\n                var hitItems = _this.quadTree.query(world);\n                var hitInside = [];\n                for (var _i = 0, hitItems_2 = hitItems; _i < hitItems_2.length; _i++) {\n                    var item = hitItems_2[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                        currentHoverItems.push(item);\n                    }\n                }\n                // Inform of all items hit or hovered\n                _this.onMouseHover(hitInside, mouse, world, _this.projection);\n                // Diff the currently hovered items with the old ones to see what is\n                // No longer hit\n                var left = [];\n                for (var _a = 0, _b = _this.currentHoverItems; _a < _b.length; _a++) {\n                    var item = _b[_a];\n                    if (currentHoverItems.indexOf(item) < 0) {\n                        left.push(item);\n                    }\n                }\n                // Inform of all items no longer hovered\n                _this.onMouseLeave(left, mouse, world, _this.projection);\n                _this.currentHoverItems = currentHoverItems;\n            }\n            if (onMouse) {\n                _this.onMouse(mouse, world, _this.isPanning);\n            }\n            _this.lastMousePosition = mouse;\n        };\n        /**\n         * We make the ref application be a declared function so react does not find the need to execute the\n         * application numerous times for a detected changed method\n         *\n         * @param {HTMLElement} n This is the canvas element from the dom\n         */\n        _this.applyRef = function (n) {\n            _this.init(n, _this.props.width, _this.props.height);\n            _this.applyProps(_this.props);\n        };\n        return _this;\n    }\n    /**\n     * This is a hook so subclasses can contribute animated methods to the animation loop and organize the base methods\n     * as desired.\n     *\n     * @param {AnimatedMethodLookup} baseAnimatedMethods The base animated methods referenceable by name\n     * @param {AnimatedMethod[]} orderedBaseAnimatedMethods The base animated methods in their default order for ease of use\n     *\n     * @return {AnimatedMethods[]} The list of animated methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.animatedMethods = function (baseAnimatedMethods, orderedBaseAnimatedMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBaseAnimatedMethods;\n    };\n    /**\n     * This generates the base animated methods lookup.\n     * We do not make these methods a part of the class as this is the base class\n     * We want the start up methods to be inconsequential to sub classes, thus allowing\n     * us to override, sort, or replace the initial methods and have the method get garbage\n     * collected and no longer a part of the object. It is recommended to make the sub classes\n     * actually point to class methods for better clarity\n     *\n     * @return {ANimatedMethodLookup} The base animated methods in a lookup\n     */\n    WebGLSurface.prototype.animatedMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            // Context changes and early checks\n            _a[BaseAnimatedMethods.CONTEXT] = function () {\n                var response = {\n                    break: false,\n                    doDraw: false,\n                };\n                if (_this.resizeContext()) {\n                    response.doDraw = true;\n                }\n                // Quadtree MUST be present to do proper computations\n                if (!_this.quadTree) {\n                    response.break = true;\n                }\n                return response;\n            },\n            // Apply inertia\n            _a[BaseAnimatedMethods.INERTIA] = function () {\n                if (!_this.isPanning) {\n                    if (_this.inertia) {\n                        // Disabled inertia for now\n                        // This.destinationX -= this.inertia.x\n                        // This.destinationY -= this.inertia.y\n                        _this.inertia.x *= _this.inertiaDecay;\n                        _this.inertia.y *= _this.inertiaDecay;\n                        if (_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y < 1) {\n                            _this.inertia = null;\n                        }\n                    }\n                }\n                // A non response\n                return {\n                    doDraw: false,\n                };\n            },\n            // Apply position\n            _a[BaseAnimatedMethods.POSITION] = function () {\n                // If values are transitioned rather than immediately applied, this is\n                // The value you would want the minimum change to be before cutting off\n                // The transition\n                // Const minAdjust = 1 / this.props.zoom\n                // If there is change in X apply the new position to the old\n                // This is where animated values were originally placed and can be placed\n                // Again if a transition is desired\n                var response = {\n                    doDraw: (_this.currentX !== _this.destinationX) || (_this.currentY !== _this.destinationY),\n                };\n                _this.currentX = _this.destinationX;\n                _this.currentY = _this.destinationY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            // Apply zooming\n            _a[BaseAnimatedMethods.ZOOM] = function () {\n                var response = {\n                    doDraw: false,\n                };\n                // Apply Zoom\n                var destZoom = _this.destinationZoom;\n                var dZoom = Math.abs(destZoom - _this.targetZoom);\n                var minDZoom = MIN_ZOOM_INCREMENT;\n                var zoomRate = 3;\n                if (dZoom > minDZoom) {\n                    _this.targetZoom = _this.targetZoom + ((destZoom - _this.targetZoom) / zoomRate);\n                    response.doDraw = true;\n                }\n                else if (dZoom !== 0) {\n                    _this.targetZoom = destZoom;\n                    response.doDraw = true;\n                }\n                // Get the zoom target metrics before zooming\n                var zoomTargetX = _this.zoomTargetX;\n                var zoomTargetY = _this.zoomTargetY;\n                var screenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Update the camera zoom level\n                _this.zoomCamera(_this.targetZoom);\n                // After we have zoomed we see how much our target location moved on screen\n                var newScreenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Now we move our screen by the moved delta to keep it exactly where it was before hand\n                var zoomDX = -(newScreenZoomTarget.x - screenZoomTarget.x) / _this.targetZoom;\n                var zoomDY = (newScreenZoomTarget.y - screenZoomTarget.y) / _this.targetZoom;\n                _this.currentX -= zoomDX;\n                _this.currentY -= zoomDY;\n                _this.destinationX -= zoomDX;\n                _this.destinationY -= zoomDY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for subclasses to be able to apply buffer changes that rely\n     * on colors rendered into the atlas after the system has prepped the colors for render.\n     */\n    WebGLSurface.prototype.applyColorBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * This is a hook for subclasses to be able to apply label buffer changes after the system has\n     * prepped the labels for render.\n     */\n    WebGLSurface.prototype.applyLabelBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * @override\n     * This is a hook so subclasses can contribute property application methods to the applyProps process and organize the base methods\n     * as desired.\n     *\n     * @param {ApplyPropsMethodLookup<T>} basePropsMethods The base props methods referenceable by name\n     * @param {ApplyPropsMethod<T>[]} orderedBasePropsMethods The base animated methods in their default order for ease of use\n     *\n     * @return {ApplyPropsMethod<T>[]} The list of property application methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.applyPropsMethods = function (basePropsMethods, orderedBasePropsMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBasePropsMethods;\n    };\n    /**\n     * This is a hook so subclasses can contribute methods to the applying props procedure and organize the base methods\n     * as desired.\n     *\n     * @return {ApplyPropsMethodLookup<T>} The base apply props method that are indexed for ease of reference\n     */\n    WebGLSurface.prototype.applyPropsMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            _a[BaseApplyPropsMethods.INITIALIZE] = function (props) {\n                var backgroundColor = props.backgroundColor, height = props.height, width = props.width;\n                _this.init(_this.renderEl, width, height);\n                if (!_this.renderEl || width === 0 || height === 0) {\n                    return {\n                        break: true,\n                    };\n                }\n                // Get the target for zooming\n                if (_this.camera) {\n                    var world = _this.screenToWorld(_this.lastMousePosition.x, _this.lastMousePosition.y);\n                    _this.zoomTargetX = world.x;\n                    _this.zoomTargetY = world.y;\n                }\n                if (_this.renderer && backgroundColor) {\n                    var oldColor = _this.props.backgroundColor || {\n                        b: BACKGROUND_COLOR.b,\n                        g: BACKGROUND_COLOR.g,\n                        opacity: 1.0,\n                        r: BACKGROUND_COLOR.r,\n                    };\n                    var same = oldColor.r === backgroundColor.r &&\n                        oldColor.g === backgroundColor.g &&\n                        oldColor.b === backgroundColor.b &&\n                        oldColor.opacity === backgroundColor.opacity;\n                    if (!same) {\n                        _this.renderer.setClearColor(new three_1.Color(backgroundColor.r, backgroundColor.g, backgroundColor.b), \n                        // Only if a transparent background is specified should we\n                        // Allow the parameter. We avoid the parameter to ensure\n                        // Transparent mode it not activated unless absolutely necessary\n                        backgroundColor.opacity < 1 ? backgroundColor.opacity : undefined);\n                    }\n                }\n                debug('props', props);\n                return {};\n            },\n            _a[BaseApplyPropsMethods.LABELS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.labels && props.labels !== _this.labels) {\n                    debugLabels('Labels are being comitted to an Atlas %o', props.labels);\n                    // Flag the labels as incapable of rendering\n                    _this.labelsReady = false;\n                    _this.labelsLoadId++;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.labels = props.labels;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.labels)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.labels);\n                    }\n                    var textures = props.labels.map(function (label) { return new atlas_texture_1.AtlasTexture(null, label); });\n                    debugLabels('Creating the atlas for labels based on these textures %o', textures);\n                    _this.atlasManager.createAtlas(_this.atlasNames.labels, textures)\n                        .then(function () {\n                        debugLabels('Labels rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.labels));\n                        _this.forceDraw = true;\n                        _this.labelsCurrentLoadedId++;\n                        // If we are done loading AND we match up with the current load id, then labels\n                        // For the latest labels update are indeed ready for display\n                        if (_this.labelsCurrentLoadedId === _this.labelsLoadId) {\n                            _this.labelsReady = true;\n                        }\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.COLORS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.colors && props.colors !== _this.colors) {\n                    debugColors('Colors are being comitted to an Atlas %o', props.colors);\n                    // Flag the labels as incapable of rendering\n                    _this.colorsReady = false;\n                    _this.colorsLoadId++;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.colors = props.colors;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.colors)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.colors);\n                    }\n                    _this.atlasManager.createAtlas(_this.atlasNames.colors, null, _this.colors)\n                        .then(function () {\n                        debugColors('Colors rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.colors));\n                        _this.forceDraw = true;\n                        _this.colorsCurrentLoadedId++;\n                        // If we are done loading AND we match up with the current load id, then colors\n                        // For the latest colors update are indeed ready for display. This solves asynchronous\n                        // Issues with multiple color pallette updates\n                        if (_this.colorsCurrentLoadedId === _this.colorsLoadId) {\n                            _this.colorsReady = true;\n                        }\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.BUFFERCHANGES] = function (props) {\n                // Call the hook to allow sub componentry to have a place to update it's buffers\n                _this.applyBufferChanges(props);\n                // We call the label buffering when the labels are ready to render.\n                // Labels now utilize the color atlas as well, thus requiring colors\n                // To be loaded\n                if (_this.labelsReady && _this.colorsReady) {\n                    debugLabels('labels changed %o', props);\n                    _this.applyLabelBufferChanges(props);\n                }\n                // For resources that only need the color atlas to be ready\n                if (_this.colorsReady) {\n                    _this.applyColorBufferChanges(props);\n                }\n                return {};\n            },\n            _a[BaseApplyPropsMethods.CAMERA] = function (props) {\n                _this.destinationZoom = props.zoom;\n                // On initialization this should start with some base camera metrics\n                if (props.viewport && props.viewport !== _this.appliedViewport && _this.quadTree) {\n                    // Position the camera over the mid of the specified viewport\n                    var mid = props.viewport.mid;\n                    _this.currentX = _this.destinationX = mid.x;\n                    _this.currentY = _this.destinationY = mid.y;\n                    // Calculate the zoom needed for the viewport\n                    var zoomToFitViewH = props.width / props.viewport.width;\n                    var zoomToFitViewV = props.height / props.viewport.height;\n                    var zoomToFit = Math.min(zoomToFitViewH, zoomToFitViewV);\n                    // This adjusts the destination zxoom by a tiny amount so the view will redraw\n                    var microAdjustment = 1.001;\n                    // Make our destination zoom a zoom that will fit the dimensions of the viewport\n                    _this.destinationZoom = zoomToFit;\n                    _this.targetZoom = _this.destinationZoom * microAdjustment;\n                    // Make sure any zooming that happens occurs over the middle of the initial viewport\n                    _this.zoomTargetX = mid.x;\n                    _this.zoomTargetY = mid.y;\n                    // Make sure mouse position doesn't mess with the zooming focus either\n                    _this.lastMousePosition.x = props.width / 2.0;\n                    _this.lastMousePosition.y = props.height / 2.0;\n                    // Apply the values immediately to the camera\n                    _this.positionCamera(_this.currentX, _this.currentY);\n                    _this.zoomCamera(_this.targetZoom);\n                    _this.updateCameraUniforms();\n                    // We request the calculated zoom level so adjustments on the input can be made\n                    if (props.onZoomRequest) {\n                        props.onZoomRequest(_this.destinationZoom);\n                        debugCam('Requesting zoom level', _this.destinationZoom);\n                    }\n                    // Let's disable mouse interactions for a little bit until the camera has settled into place\n                    var framesToDisable = 10;\n                    _this.disableMouseInteraction = framesToDisable;\n                    _this.appliedViewport = props.viewport;\n                    debugCam('init cam', _this.currentX, _this.currentY);\n                }\n                // Ensure we have our quad tree available even if it is empty\n                if (!_this.quadTree) {\n                    _this.quadTree = new quad_tree_1.QuadTree(0, 1, 1, 0);\n                }\n                return {};\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for sub components to have a location to update their buffers\n     *\n     * @param {T} props This is the next set of props that are going to be applied to this component\n     */\n    WebGLSurface.prototype.applyBufferChanges = function (props) {\n        // NOTE: This will be implemented by base classes\n    };\n    /**\n     * @override\n     * Start the update loop and register any interesting listeners\n     */\n    WebGLSurface.prototype.componentDidMount = function () {\n        this.animate();\n    };\n    /**\n     * @override\n     * This will set up any unchanging context as well as establish the set of methods\n     * that are to be used within constructed method loops.\n     */\n    WebGLSurface.prototype.componentWillMount = function () {\n        /** Create our context bound projection methods for handing to processes that may need them */\n        this.projection = {\n            screenSizeToWorld: this.screenSizeToWorld.bind(this),\n            screenToWorld: this.screenToWorld.bind(this),\n            worldSizeToScreen: this.worldSizeToScreen.bind(this),\n            worldToScreen: this.worldToScreen.bind(this),\n        };\n        /** Generate our applying props methods to execute within our applyProps process */\n        var basePropsMethods = this.applyPropsMethodsBase();\n        this.propsMethodList = this.applyPropsMethods(basePropsMethods, [\n            basePropsMethods[BaseApplyPropsMethods.INITIALIZE],\n            basePropsMethods[BaseApplyPropsMethods.LABELS],\n            basePropsMethods[BaseApplyPropsMethods.COLORS],\n            basePropsMethods[BaseApplyPropsMethods.BUFFERCHANGES],\n            basePropsMethods[BaseApplyPropsMethods.CAMERA],\n        ]);\n        /** Generate our animated methods to execute within our animation loop */\n        var baseAnimatedMethods = this.animatedMethodsBase();\n        this.animatedMethodList = this.animatedMethods(baseAnimatedMethods, [\n            baseAnimatedMethods[BaseAnimatedMethods.CONTEXT],\n            baseAnimatedMethods[BaseAnimatedMethods.INERTIA],\n            baseAnimatedMethods[BaseAnimatedMethods.POSITION],\n            baseAnimatedMethods[BaseAnimatedMethods.ZOOM],\n        ]);\n    };\n    /**\n     * @override\n     * Simply applies the new injected props\n     *\n     * @param {T} props The new properties to be applied to this component\n     */\n    WebGLSurface.prototype.componentWillReceiveProps = function (props) {\n        this.applyProps(props);\n    };\n    /**\n     * @override\n     * Release listeners and stop update loop\n     */\n    WebGLSurface.prototype.componentWillUnmount = function () {\n        this.stop = true;\n        if (this.quadTree) {\n            this.quadTree.destroy();\n        }\n        this.quadTree = null;\n        this.camera = null;\n        this.sizeCamera = null;\n        this.ctx = null;\n        this.renderEl = null;\n        this.renderer = null;\n        this.scene = null;\n        this.atlasManager.destroyAtlas(this.atlasNames.colors);\n        this.atlasManager.destroyAtlas(this.atlasNames.labels);\n        frame_info_1.FrameInfo.framesPlayed.delete(this);\n    };\n    /**\n     * This is the draw method executed from the animation loop. Everytime, this is\n     * called, the webgl surface will be redrawn.\n     */\n    WebGLSurface.prototype.draw = function () {\n        // Draw the 3D scene\n        this.renderer.render(this.scene, this.camera);\n        if (this.props.onRender && (this.colorsReady || this.colors.length === 0) &&\n            (this.labelsReady || this.labels.length === 0) &&\n            this.isRenderReady) {\n            var imageData = this.renderer.domElement.toDataURL();\n            this.props.onRender(imageData);\n        }\n    };\n    /**\n     * This is a hook allowing sub classes to have a place to initialize their buffers\n     * and materials etc.\n     */\n    WebGLSurface.prototype.initBuffers = function () {\n        // NOTE: This is to be implemented by subclasses\n    };\n    /**\n     * Hook for subclasses to when the mouse moves. Provides some information\n     * about mouse location and interaction.\n     *\n     * @param {IPoint} mouse Position of the mouse relative to the canvas\n     * @param {IPoint} world Position of the mouse relative to the world space\n     * @param {boolean} isPanning The panning state of the mouse\n     */\n    WebGLSurface.prototype.onMouse = function (mouse, world, isPanning) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse down events\n     */\n    WebGLSurface.prototype.onMouseDown = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse out events\n     */\n    WebGLSurface.prototype.onMouseOut = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse up events and the items that were interacted with in the process\n     *\n     * @param {React.MouseEvent} e The react synthetic event associated with the action\n     * @param {Bounds[]} hitInside The items the mouse interacted with\n     * @param {IPoint} mouse The location of the mouse on the screen\n     * @param {IPoint} world The location of the mouse projected into the world\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseUp = function (e, hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse hovering over an item included in the quadtree\n     *\n     * @param {Bounds[]} hitInside The items hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseHover = function (hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse leaving an item included in the quadtree\n     *\n     * @param {Bounds[]} left The items no longer hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseLeave = function (left, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to changes in the viewport and currently visible items\n     *\n     * @param {Bounds[]} visible\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     * @param {IScreenContext} ctx\n     */\n    WebGLSurface.prototype.onViewport = function (visible, projection, ctx) {\n        // NOTE: For subclasses\n    };\n    WebGLSurface.prototype.makeDraggable = function (element, stage) {\n        var _this = this;\n        element.onmousedown = function (event) {\n            stage.dragOver = false;\n            document.onmousemove = function (event) {\n                var mouse = mouse_1.eventElementPosition(event, element);\n                var mouseX = mouse.x;\n                var mouseY = mouse.y;\n                var distanceX = (mouseX - stage.lastMousePosition.x) / stage.targetZoom;\n                var distanceY = (mouseY - stage.lastMousePosition.y) / stage.targetZoom;\n                // Provide the same hook the normal mouse pan does to allow for panning adjustments\n                var pan = _this.willPan(distanceX, distanceY);\n                stage.destinationX -= pan.x;\n                stage.destinationY += pan.y;\n                stage.lastMousePosition.x = mouseX;\n                stage.lastMousePosition.y = mouseY;\n            };\n            document.onmouseup = function () {\n                document.onmousemove = null;\n                stage.isPanning = false;\n                stage.dragOver = true;\n            };\n            document.onmouseover = function () {\n                if (stage.dragOver === false)\n                    stage.isPanning = true;\n            };\n            element.onmouseup = function () {\n                stage.dragOver = true;\n            };\n            // Text will not be selected when it is being dragged\n            element.onselectstart = function () {\n                return false;\n            };\n        };\n    };\n    /**\n     * Places the camera at a given location in world space\n     *\n     * @param {number} x The x-coordinate for the camera in world space\n     * @param {number} y The x-coordinate for the camera in world space\n     */\n    WebGLSurface.prototype.positionCamera = function (x, y) {\n        if (this.camera) {\n            this.camera.position.set(x, y, this.camera.position.z);\n        }\n    };\n    /**\n     * Projects a screen coordinate to a world coordinate\n     *\n     * @param {number} x The x coord within the screen to project into the world\n     * @param {number} y The y coord within the screen to project into the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenToWorld = function (x, y, obj) {\n        // Get the coordinates in normalized screen space\n        vector.set((x / this.ctx.width) * 2 - 1, -(y / this.ctx.height) * 2 + 1, 0.0);\n        // Unproject the normalized space to the world. It will project\n        // The vector to a REALLY far away z coordinate, but it does not matter\n        // Since we are utilizing an orthographic camera (no perspective distortion)\n        vector.unproject(this.camera);\n        obj = obj || { x: 0, y: 0 };\n        obj.x = vector.x;\n        obj.y = vector.y;\n        return obj;\n    };\n    /**\n     * Projects a size on the screen to the size represented in the world\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenSizeToWorld = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        obj.height = h / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        return obj;\n    };\n    /**\n     * Projects a world coordinate to the screen\n     *\n     * @param {number} x The x coord in the world to project to the screen\n     * @param {number} y The y coord in the world to project to the screen\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {IPoint} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldToScreen = function (x, y, obj) {\n        // This projects to NORMALIZED screen space (-1, 1) range for x and y\n        vector.set(x, y, 0);\n        vector.project(this.camera);\n        // Use the window dimensions to denormalize the vector\n        obj = ramda_1.merge(obj || {}, {\n            x: (vector.x * this.ctx.widthHalf) + this.ctx.widthHalf,\n            y: -(vector.y * this.ctx.heightHalf) + this.ctx.heightHalf,\n        });\n        return obj;\n    };\n    /**\n     * Projects a size within the world to how it would appear on the screen\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldSizeToScreen = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w * this.sizeCamera.zoom;\n        obj.height = h * this.sizeCamera.zoom;\n        return obj;\n    };\n    /**\n     * Sets the zoom level the camera will view the world with\n     *\n     * @param {number} zoom The zoom level. Must be > 0\n     */\n    WebGLSurface.prototype.zoomCamera = function (zoom) {\n        this.camera.zoom = zoom;\n        this.sizeCamera.zoom = zoom;\n        this.camera.updateProjectionMatrix();\n        this.sizeCamera.updateProjectionMatrix();\n    };\n    /**\n     * This is a hook allowing a sub class to update uniforms when the camera is changed in\n     * any way\n     */\n    WebGLSurface.prototype.updateCameraUniforms = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * @override\n     * Only re-render if the dimensions of the component have changed. All other\n     * internal render updates are handled internally\n     *\n     * @param {T} nextProps The next properties injected\n     */\n    WebGLSurface.prototype.shouldComponentUpdate = function (nextProps) {\n        return this.props.width !== nextProps.width || this.props.height !== nextProps.height;\n    };\n    /**\n     * Hook to allow subclasses some control over panning distances\n     *\n     * @param {number} distanceX The distance to pan in the x direction\n     * @param {number} distanceY The distance to pan in the y direction\n     *\n     * @return {Vector3} The vector indicating the direction to pan\n     */\n    WebGLSurface.prototype.willPan = function (distanceX, distanceY) {\n        return new three_1.Vector3(distanceX, distanceY, 0.0);\n    };\n    // -----[ Render ]---------------------------------------------\n    //\n    // In a React app, it's nice to put the render function at the bottom of the\n    // File\n    /**\n     * This should only attempt rendering when the canvas DOM element needs to be resized.\n     * You will note shouldComponentUpdate helps facilitate this.\n     */\n    WebGLSurface.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, width = _a.width, height = _a.height;\n        if (!webgl_stat_1.WebGLStat.WEBGL_SUPPORTED) {\n            return React.createElement(\"div\", null, this.props.children || 'Web GL not supported');\n        }\n        return (React.createElement(\"div\", { id: \"div\", onMouseDown: this.handleMouseDown, onMouseOut: this.handleMouseOut, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseOut, onMouseMove: this.handleMouseMove, onDoubleClick: function (e) {\n                if (_this.props.onDoubleClick) {\n                    _this.props.onDoubleClick(e);\n                }\n            }, style: { position: 'relative', width: width, height: height } },\n            React.createElement(\"div\", { ref: this.applyRef })));\n    };\n    return WebGLSurface;\n}(React.Component));\nexports.WebGLSurface = WebGLSurface;\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_28__;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(32);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_33__;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(35));\n__export(__webpack_require__(36));\n__export(__webpack_require__(37));\n__export(__webpack_require__(2));\n__export(__webpack_require__(38));\n__export(__webpack_require__(39));\n__export(__webpack_require__(40));\n__export(__webpack_require__(41));\n__export(__webpack_require__(42));\n__export(__webpack_require__(43));\n__export(__webpack_require__(44));\n__export(__webpack_require__(45));\n__export(__webpack_require__(46));\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBufferAnts = (function (_super) {\n    __extends(SharedControlCurvedLineBufferAnts, _super);\n    function SharedControlCurvedLineBufferAnts() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBufferAnts.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'marching',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBufferAnts.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer && buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var marchingAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var antLength;\n        var antGap;\n        var antSpeed;\n        var controlPoint;\n        var controlRef;\n        // We can not accurately send very large numbers via float point into the attributes\n        // So we trim down our time sent to the attribute down to a number that is less than\n        // 16,777,217 which means we can only reliably grab the last 7 digits of the date's time\n        var antStartTime = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            // We will not render the curved line with this buffer if the marching ants are not provided\n            if (!curvedLine.marchingAnts) {\n                console.error('Attempted to render a curved line shape with a marching ant buffer but provided no marching ant metrics. This curved line shape will be skipped', curvedLine);\n                return \"continue\";\n            }\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            antGap = curvedLine.marchingAnts.gapLength;\n            antSpeed = curvedLine.marchingAnts.speed;\n            antLength = curvedLine.marchingAnts.strokeLength + curvedLine.marchingAnts.gapLength;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, marching, mpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                marching[mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, buffer_1 = buffer; _i < buffer_1.length; _i++) {\n            var curvedLine = buffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBufferAnts;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBufferAnts = SharedControlCurvedLineBufferAnts;\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineColorsBuffer = (function (_super) {\n    __extends(SharedControlCurvedLineColorsBuffer, _super);\n    function SharedControlCurvedLineColorsBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'colorPicks',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'timing',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (shapeBuffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var uniforms;\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\n            var colorRef = shapeBuffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var timingAttributeSize = 2;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorStartStop;\n        var colorEnd;\n        var colorEndStop;\n        var alpha;\n        var startTime;\n        var duration;\n        var controlRef;\n        var controlPoint;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorEnd = curvedLine.endColor.base.colorIndex;\n            colorEndStop = curvedLine.endColorStop.base.colorIndex;\n            colorStart = curvedLine.startColor.base.colorIndex;\n            colorStartStop = curvedLine.startColorStop.base.colorIndex;\n            duration = curvedLine.duration;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.currentStart;\n            p2 = curvedLine.currentEnd;\n            startTime = curvedLine.startTime;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colorPicks, cpos, controlPick, ctpos, timing, tpos, normals, npos, endPoints, epos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                controlPick[ctpos] = controlRef;\n                cpos += colorAttributeSize;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[wpos] = halfWidthSize;\n                normals[npos] = 1;\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                tpos += timingAttributeSize;\n                // TR\n                colorPicks[cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[tpos] = startTime;\n                timing[++tpos] = duration;\n                // BR\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // TL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // BL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++ctpos] = controlRef;\n            }, \n            // We force updates for this buffer since it has animated properties\n            // Such as currentStartStop and currentEndStop which calculates\n            // Animations on the CPU side.\n            true);\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineColorsBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineColorsBuffer = SharedControlCurvedLineColorsBuffer;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceArcBufferAnts = (function (_super) {\n    __extends(UniformInstanceArcBufferAnts, _super);\n    function UniformInstanceArcBufferAnts() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    UniformInstanceArcBufferAnts.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'halfLineWidth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'maxResolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 3,\n                name: 'marching',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            // Commit static curved lines\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceArcBufferAnts.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        // This let's us know if we're maxing out the instances this buffer can handle\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, halfLineWidth, resolution, maxResolution, depth, endpoints, marching) {\n            var curve = buffer[instance];\n            var antLength = curve.marchingAnts.strokeLength + curve.marchingAnts.gapLength;\n            controlPoints.x = curve.controlPoints[controlPointSource].x;\n            controlPoints.y = curve.controlPoints[controlPointSource].y;\n            startColor.z = curve.startColor.base.colorIndex;\n            endColor.w = curve.endColor.base.colorIndex;\n            halfLineWidth.x = curve.lineWidth / 2.0;\n            resolution.y = curve.resolution;\n            maxResolution.z = MAX_SEGMENTS_PER_CURVE;\n            depth.w = curve.depth;\n            endpoints.x = curve.start.x;\n            endpoints.y = curve.start.y;\n            endpoints.z = curve.end.x;\n            endpoints.w = curve.end.y;\n            marching.x = 0;\n            marching.y = curve.marchingAnts.speed;\n            marching.z = curve.marchingAnts.gapLength;\n            marching.w = antLength;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformInstanceArcBufferAnts;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceArcBufferAnts = UniformInstanceArcBufferAnts;\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBuffer = (function (_super) {\n    __extends(SharedControlCurvedLineBuffer, _super);\n    function SharedControlCurvedLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var controlPoint;\n        var controlRef;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, buffer_1 = buffer; _i < buffer_1.length; _i++) {\n            var curvedLine = buffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBuffer = SharedControlCurvedLineBuffer;\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This ONLY supports a single color\n */\nvar SimpleStaticBezierLineBuffer = (function (_super) {\n    __extends(SimpleStaticBezierLineBuffer, _super);\n    function SimpleStaticBezierLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticBezierLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0, 0],\n                name: 'controlPoint',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticBezierLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var color;\n        var alpha;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            color = curvedLine.startColor.base.color;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colors, cpos, normals, npos, endPoints, epos, controlPoints, copos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                cpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticBezierLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticBezierLineBuffer = SimpleStaticBezierLineBuffer;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nfunction isCluster(value) {\n    return Array.isArray(value[0]);\n}\nvar SimpleStaticCircleBuffer = (function (_super) {\n    __extends(SimpleStaticCircleBuffer, _super);\n    function SimpleStaticCircleBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticCircleBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'radius',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'innerRadius',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'innerColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 1;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Points(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticCircleBuffer.prototype.update = function (shapeBuffer, atlasManager, camera) {\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (!buffer || buffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        if (atlasManager) {\n            var colorRef = buffer[0].outerColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n            if (camera) {\n                uniforms.zoom.value = camera.zoom;\n            }\n        }\n        var needsUpdate = false;\n        var circle;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, 1, buffer.length, function (i, positions, ppos, radius, rpos, innerRadius, irpos, color, cpos, innerColor, icpos) {\n            circle = buffer[i];\n            // These are point sprites, so just update a single vertex\n            positions[ppos] = circle._centerX;\n            positions[++ppos] = circle._centerY;\n            positions[++ppos] = circle.depth;\n            radius[rpos] = circle._radius;\n            innerRadius[irpos] = circle.innerRadius || 0.0;\n            color[cpos] = circle.outerColor.base.colorIndex;\n            innerColor[icpos] = circle.innerColor ? circle.innerColor.base.colorIndex : 0;\n        });\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, buffer.length);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticCircleBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticCircleBuffer = SimpleStaticCircleBuffer;\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticLabelBuffer = (function (_super) {\n    __extends(SimpleStaticLabelBuffer, _super);\n    function SimpleStaticLabelBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLabelBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 1],\n                name: 'texCoord',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'size',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0, 0],\n                name: 'anchor',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLabelBuffer.prototype.update = function (shapeBuffer, atlasManager, startFade, endFade, labelMaxSize) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // Make some constants and props for our buffer update loop\n        var numVerticesPerQuad = 6;\n        var label;\n        var texture;\n        var color;\n        var alpha;\n        var anchor;\n        var labelSize;\n        if (atlasManager && buffer.length > 0) {\n            var colorRef = buffer[0].color;\n            var labelBase = buffer[0].baseLabel;\n            if (colorRef && labelBase) {\n                var colorBase = colorRef.base;\n                var material = this.bufferItems.system.material;\n                var uniforms = material.uniforms;\n                var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n                var texture_1 = atlasManager.getAtlasTexture(labelBase.rasterizedLabel.atlasReferenceID);\n                if (uniforms.colorAtlas.value !== atlas) {\n                    uniforms.colorAtlas.value = atlas;\n                    uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n                    uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n                    uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n                    atlas.needsUpdate = true;\n                }\n                if (uniforms.atlasTexture.value !== texture_1) {\n                    uniforms.atlasTexture.value = texture_1;\n                    texture_1.needsUpdate = true;\n                    texture_1.anisotropy = 2;\n                }\n                if (startFade || endFade || labelMaxSize) {\n                    material = this.bufferItems.system.material;\n                    uniforms = material.uniforms;\n                    uniforms.startFade.value = startFade || 0;\n                    uniforms.endFade.value = endFade || 0;\n                    uniforms.maxLabelSize.value = labelMaxSize || 0;\n                }\n            }\n        }\n        var updated = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerQuad, buffer.length, function (i, positions, ppos, colors, cpos, texCoords, tpos, sizes, spos, anchors, apos) {\n            label = buffer[i];\n            texture = label.rasterizedLabel;\n            color = label.color.base;\n            alpha = label.color.base.opacity;\n            anchor = {\n                x: label.getLocation().x,\n                y: label.getLocation().y,\n            };\n            labelSize = label.getSize();\n            // Make sure the label is updated with it's latest metrics\n            label.update();\n            // Copy first vertex twice for intro degenerate tri\n            positions[ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[cpos] = color.colorIndex;\n            sizes[spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TR\n            positions[++ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BR\n            positions[++ppos] = label.BR.x;\n            positions[++ppos] = label.BR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBR.x;\n            texCoords[++tpos] = texture.atlasBR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TL\n            positions[++ppos] = label.TL.x;\n            positions[++ppos] = label.TL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTL.x;\n            texCoords[++tpos] = texture.atlasTL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BL\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // Copy last vertex again for degenerate tri\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n        });\n        this.bufferItems.geometry.setDrawRange(0, numVerticesPerQuad * buffer.length);\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return updated;\n    };\n    return SimpleStaticLabelBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLabelBuffer = SimpleStaticLabelBuffer;\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nvar SimpleStaticLineBuffer = (function (_super) {\n    __extends(SimpleStaticLineBuffer, _super);\n    function SimpleStaticLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var colorAttributeSize = 4;\n        var stripPos = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var TR;\n        var BR;\n        var TL;\n        var BL;\n        var color;\n        var alpha;\n        var _loop_1 = function (curvedLine) {\n            var strip = curvedLine.getTriangleStrip();\n            color = curvedLine.startColor.base.color;\n            alpha = curvedLine.startColor.base.opacity;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, strip.length / 4, function (i, positions, ppos, colors, cpos) {\n                stripPos = i * 4;\n                TR = strip[stripPos];\n                BR = strip[stripPos + 1];\n                TL = strip[stripPos + 2];\n                BL = strip[stripPos + 3];\n                // 1\n                positions[ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n                // 2\n                positions[++ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 3\n                positions[++ppos] = BR.x;\n                positions[++ppos] = BR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 4\n                positions[++ppos] = TL.x;\n                positions[++ppos] = TL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 5\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 6\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n            });\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLineBuffer = SimpleStaticLineBuffer;\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar point_1 = __webpack_require__(6);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticStraightLineBuffer = (function (_super) {\n    __extends(SimpleStaticStraightLineBuffer, _super);\n    function SimpleStaticStraightLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticStraightLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticStraightLineBuffer.prototype.update = function (shapeBuffer, atlasManager) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var TR = point_1.Point.zero();\n        var BR = point_1.Point.zero();\n        var TL = point_1.Point.zero();\n        var BL = point_1.Point.zero();\n        var startColor = 0;\n        var endColor = 0;\n        var line;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerSegment, buffer.length, function (i, positions, ppos, color, cpos) {\n            line = buffer[i];\n            startColor = line.startColor.base.colorIndex;\n            endColor = line.endColor.base.colorIndex;\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TR);\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BR);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TL);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BL);\n            // 1\n            positions[ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            cpos += 1.0;\n            // 2\n            positions[++ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            color[cpos] = endColor;\n            // 3\n            positions[++ppos] = BR.x;\n            positions[++ppos] = BR.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = endColor;\n            // 4\n            positions[++ppos] = TL.x;\n            positions[++ppos] = TL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 5\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 6\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n        });\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n            // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n            // Come into existance) we must explicitly ensure the current data is set to the actual\n            // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n            if (isCluster(shapeBuffer)) {\n                this.bufferItems.currentData = shapeBuffer;\n            }\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticStraightLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticStraightLineBuffer = SimpleStaticStraightLineBuffer;\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceArcBuffer = (function (_super) {\n    __extends(UniformInstanceArcBuffer, _super);\n    function UniformInstanceArcBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    UniformInstanceArcBuffer.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'halfLineWidth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'maxResolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            // Commit static curved lines\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceArcBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        // This let's us know if we're maxing out the instances this buffer can handle\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, halfLineWidth, resolution, maxResolution, depth, endpoints) {\n            var curve = buffer[instance];\n            controlPoints.x = curve.controlPoints[controlPointSource].x;\n            controlPoints.y = curve.controlPoints[controlPointSource].y;\n            startColor.z = curve.startColor.base.colorIndex;\n            endColor.w = curve.endColor.base.colorIndex;\n            halfLineWidth.x = curve.lineWidth / 2.0;\n            resolution.y = curve.resolution;\n            maxResolution.z = MAX_SEGMENTS_PER_CURVE;\n            depth.w = curve.depth;\n            endpoints.x = curve.start.x;\n            endpoints.y = curve.start.y;\n            endpoints.z = curve.end.x;\n            endpoints.w = curve.end.y;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformInstanceArcBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceArcBuffer = UniformInstanceArcBuffer;\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceEdgeBuffer = (function (_super) {\n    __extends(UniformInstanceEdgeBuffer, _super);\n    function UniformInstanceEdgeBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    UniformInstanceEdgeBuffer.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'sizes',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 1,\n                name: 'maxResolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            // Commit static curved lines\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedEdgeShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceEdgeBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        // This let's us know if we're maxing out the instances this buffer can handle\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, sizes, maxResolution, depth, endpoints) {\n            var curve = buffer[instance];\n            controlPoints.x = curve.controlPoints[controlPointSource].x;\n            controlPoints.y = curve.controlPoints[controlPointSource].y;\n            startColor.z = curve.startColor.base.colorIndex;\n            endColor.w = curve.endColor.base.colorIndex;\n            sizes.x = curve.startWidth / 2.0;\n            sizes.y = curve.endWidth / 2.0;\n            maxResolution.z = MAX_SEGMENTS_PER_CURVE;\n            depth.w = curve.depth;\n            endpoints.x = curve.start.x;\n            endpoints.y = curve.start.y;\n            endpoints.z = curve.end.x;\n            endpoints.w = curve.end.y;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformInstanceEdgeBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceEdgeBuffer = UniformInstanceEdgeBuffer;\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(3);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(1);\nvar base_buffer_1 = __webpack_require__(2);\n// CONSTANT\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\n/**\n * THRESHOLD sets the number of instance to render both ends of ribbon\n * In order to make both ends round\n */\nvar THRESHOLD = 30;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\nvar UniformRibbonBuffer = (function (_super) {\n    __extends(UniformRibbonBuffer, _super);\n    function UniformRibbonBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    UniformRibbonBuffer.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'endPoints1',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 2,\n                name: 'endPoints2',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 3,\n                name: 'centers',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 4,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 4,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 4,\n                name: 'threshold',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    UniformRibbonBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, endPoints1, endPoints2, centers, depth, resolution, threshold) {\n            var ribbon = buffer[instance];\n            controlPoints.x = ribbon.controlPoints[controlPointSource].x;\n            controlPoints.y = ribbon.controlPoints[controlPointSource].y;\n            startColor.z = ribbon.startColor.base.colorIndex;\n            endColor.w = ribbon.endColor.base.colorIndex;\n            endPoints1.x = ribbon.start.x;\n            endPoints1.y = ribbon.start.y;\n            endPoints1.z = ribbon.start2.x;\n            endPoints1.w = ribbon.start2.y;\n            endPoints2.x = ribbon.end.x;\n            endPoints2.y = ribbon.end.y;\n            endPoints2.z = ribbon.end2.x;\n            endPoints2.w = ribbon.end2.y;\n            centers.x = ribbon.center1.x;\n            centers.y = ribbon.center1.y;\n            centers.z = ribbon.center2.x;\n            centers.w = ribbon.center2.y;\n            depth.x = ribbon.depth;\n            resolution.y = MAX_SEGMENTS_PER_CURVE;\n            threshold.z = THRESHOLD;\n            threshold.w = THRESHOLD;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformRibbonBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformRibbonBuffer = UniformRibbonBuffer;\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(48));\n__export(__webpack_require__(49));\n__export(__webpack_require__(50));\n__export(__webpack_require__(51));\n__export(__webpack_require__(9));\n__export(__webpack_require__(52));\n__export(__webpack_require__(53));\n__export(__webpack_require__(16));\n__export(__webpack_require__(23));\n__export(__webpack_require__(54));\n__export(__webpack_require__(55));\n__export(__webpack_require__(56));\n__export(__webpack_require__(14));\n__export(__webpack_require__(10));\n__export(__webpack_require__(18));\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines a reference to a color that has been rendered to a texture\n * (See AtlasColor). This exposes the only properties that MAY be utilized\n * in a shader to modify the existing values without altering what is rendered\n * on the texture.\n */\nvar ReferenceColor = (function () {\n    /**\n     * Creates an instance of ReferenceColor.\n     *\n     * @param {AtlasColor} base The color to be based off of\n     */\n    function ReferenceColor(base) {\n        this.base = base;\n    }\n    return ReferenceColor;\n}());\nexports.ReferenceColor = ReferenceColor;\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar easing_1 = __webpack_require__(13);\nvar frame_info_1 = __webpack_require__(11);\nvar interpolation_1 = __webpack_require__(8);\nvar curved_line_shape_1 = __webpack_require__(9);\n/**\n * This represents curved lines and what it would take to animate various properties.\n * While this provides helpers to aid in animating the properties, it is up to\n * buffers, shaders and materials to render those changes appropriately.\n */\nvar AnimatedCurvedLineShape = (function (_super) {\n    __extends(AnimatedCurvedLineShape, _super);\n    function AnimatedCurvedLineShape(options) {\n        var _this = _super.call(this, options) || this;\n        /**\n         * This defines the suggested easing for the animation for any of\n         * the values.\n         */\n        _this.easing = easing_1.linear;\n        _this._startColorChange = new three_1.Color(0, 0, 0);\n        _this._endColorChange = new three_1.Color(0, 0, 0);\n        /** The starting end point's destination */\n        _this.startStop = { x: 0, y: 0 };\n        _this.endStop = { x: 0, y: 0 };\n        /**\n         * This calculates the current start color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentStartColor = new three_1.Color(0, 0, 0);\n        /**\n         * This calculates the current end color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentEndColor = new three_1.Color(0, 0, 0);\n        if (options) {\n            _this.startStop = options.startStop || { x: 0, y: 0 };\n            _this.endStop = options.endStop || { x: 0, y: 0 };\n            if (options.startColorStop) {\n                _this.startColorStop = options.startColorStop;\n            }\n            if (options.endColorStop) {\n                _this.endColorStop = options.endColorStop;\n            }\n        }\n        return _this;\n    }\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"startColorStop\", {\n        get: function () {\n            return this._startColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._startColorStop = value;\n            this._startColorChange.r = newBase.r - startBase.r;\n            this._startColorChange.g = newBase.g - startBase.g;\n            this._startColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"endColorStop\", {\n        get: function () {\n            return this._endColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._endColorStop = value;\n            this._endColorChange.r = newBase.r - startBase.r;\n            this._endColorChange.g = newBase.g - startBase.g;\n            this._endColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStartColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var startBase = this.startColor.base.color;\n            this._currentStartColor.r = this.easing(time, startBase.r, this._startColorChange.r, this.duration);\n            this._currentStartColor.g = this.easing(time, startBase.g, this._startColorChange.g, this.duration);\n            this._currentStartColor.b = this.easing(time, startBase.b, this._startColorChange.b, this.duration);\n            return this._currentStartColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEndColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var endBase = this.endColor.base.color;\n            this._currentEndColor.r = this.easing(time, endBase.r, this._endColorChange.r, this.duration);\n            this._currentEndColor.g = this.easing(time, endBase.g, this._endColorChange.g, this.duration);\n            this._currentEndColor.b = this.easing(time, endBase.b, this._endColorChange.b, this.duration);\n            return this._currentEndColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStart\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            var newStart = interpolation_1.circular(easedTime, this.start, this.startStop, this.controlPoints[1]);\n            return newStart;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEnd\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            // Apply the circular interpolation to the points\n            return interpolation_1.circular(easedTime, this.end, this.endStop, this.controlPoints[1]);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AnimatedCurvedLineShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.AnimatedCurvedLineShape = AnimatedCurvedLineShape;\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar circle_1 = __webpack_require__(22);\n/**\n * Defines a circular shape that can be drawn\n */\nvar CircleShape = (function (_super) {\n    __extends(CircleShape, _super);\n    /**\n     * Sets the properties of the shape to be drawn\n     *\n     * @param {ICircleShapeOptions} options The options for the shape\n     */\n    function CircleShape(options) {\n        var _this = _super.call(this, options) || this;\n        _this.depth = options.depth || 0;\n        _this.innerColor = options.innerColor;\n        _this.innerRadius = options.innerRadius;\n        _this.outerColor = options.outerColor;\n        return _this;\n    }\n    /**\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this circleshape\n     */\n    CircleShape.prototype.clone = function (newProperties) {\n        var instance = new CircleShape(this);\n        instance.d = this.d;\n        return instance;\n    };\n    return CircleShape;\n}(circle_1.Circle));\nexports.CircleShape = CircleShape;\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar curved_line_shape_1 = __webpack_require__(9);\n/**\n * A curved edge will be the same as a curved line, but it will have the properties to properly\n * define a curved shape that interpolates between two widths from start to end.\n */\nvar CurvedEdgeShape = (function (_super) {\n    __extends(CurvedEdgeShape, _super);\n    function CurvedEdgeShape(options) {\n        var _this = _super.call(this, options) || this;\n        _this.startWidth = options.startWidth;\n        _this.endWidth = options.endWidth;\n        return _this;\n    }\n    return CurvedEdgeShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.CurvedEdgeShape = CurvedEdgeShape;\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = __webpack_require__(7);\nvar line_shape_1 = __webpack_require__(23);\n/**\n * This defines an edge that can be drawn.\n * This type of edge is a quad with distorted ends. The quad will represent a\n * line with each end having potentially different sizes thus giving a four sided\n * polygon rather than a parallelogram.\n *\n * The edge shape also doubles up as a simple line shape should it be desired to\n * render differently.\n */\nvar EdgeShape = (function (_super) {\n    __extends(EdgeShape, _super);\n    /**\n     * Constructor with basic parameters to declare an edge\n     *\n     * @param p1 The point the edge begins at\n     * @param p2 The point the edge terminates at\n     * @param d The data associated with the edge\n     * @param p1Col The color at the start point\n     * @param p2Col The color at the end point\n     * @param p1Width The width at the start point. Example: if you specify 4, then\n     *                the start part of the edge will fan out 2 on either side of the\n     *                start point\n     * @param p2Width The width at the end point. Example: if you specify 4, then\n     *                the end part of the edge will fan out 2 on either side of the\n     *                end point\n     */\n    function EdgeShape(options) {\n        var _this = \n        // Set up all of our line shape based metrics\n        _super.call(this, Object.assign(options, {\n            thickness: options.startWidth,\n        })) || this;\n        /** Top left of the quad to generate this edge */\n        _this.tl = { x: 0, y: 0 };\n        /** Bottom left of the quad to generate this edge */\n        _this.bl = { x: 0, y: 0 };\n        /** Top right of the quad to generate this edge */\n        _this.tr = { x: 0, y: 0 };\n        /** Bottom Right of the quad to generate this edge */\n        _this.br = { x: 0, y: 0 };\n        /** The width of the edge at the termination point */\n        _this.endWidth = 1;\n        _this.endWidth = options.endWidth || 1.0;\n        _this.setPoints(options.p1, options.p2);\n        return _this;\n    }\n    /**\n     * Clones this instance of the edge shape and creates a new instance of an edge shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {EdgeShape} A newly cloned instance of this edgeshape\n     */\n    EdgeShape.prototype.clone = function (newProperties) {\n        return Object.assign(new EdgeShape(Object.assign(this, {\n            startWidth: this.thickness,\n        })), newProperties);\n    };\n    /**\n     * Algorithm provided by\n     * https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n     * Adapted to Javascript by Chris @ VoidRay co\n     *\n     * Remember the point must be in the same\n     * coordinate system that the edge is using\n     *\n     * @param {number} point The point to test\n     *\n     * @return {boolean} True if the point is inside the edge\n     */\n    EdgeShape.prototype.pointInside = function (point) {\n        var testx = point.x;\n        var testy = point.y;\n        // This is an algortihm to handle any number of points for a polygon. In this\n        // Case our polygon is simply the points that make this fat edge. Note:\n        // The points MUST be in CW order\n        var points = [this.tl, this.tr, this.br, this.bl];\n        var numberVertices = points.length;\n        var isClockwise = false;\n        for (var i = 0, j = numberVertices - 1; i < numberVertices; j = i++) {\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\n                    (points[j].y - points[i].y) + points[i].x)) {\n                isClockwise = !isClockwise;\n            }\n        }\n        return isClockwise;\n    };\n    /**\n     * @override\n     * This sets the two endpoints for this edge and recalculates the bounds\n     * of the edge accordingly.\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    EdgeShape.prototype.setPoints = function (p1, p2) {\n        _super.prototype.setPoints.call(this, p1, p2);\n        if (this.tl) {\n            // Get the distance from the points we will go based on specified widths\n            var p1Dx = this.thickness / 2;\n            var p2Dx = this.endWidth / 2;\n            // Calculate the deltas to get from point to quad edge\n            var p1DeltaX = this.perpendicular.x * p1Dx;\n            var p1DeltaY = this.perpendicular.y * p1Dx;\n            var p2DeltaX = this.perpendicular.x * p2Dx;\n            var p2DeltaY = this.perpendicular.y * p2Dx;\n            // Apply the metrics to our quad points\n            // Start side of the edge\n            this.tl.x = this.p1.x + p1DeltaX;\n            this.tl.y = this.p1.y + p1DeltaY;\n            this.bl.x = this.p1.x - p1DeltaX;\n            this.bl.y = this.p1.y - p1DeltaY;\n            // End side of the edge\n            this.tr.x = this.p2.x + p2DeltaX;\n            this.tr.y = this.p2.y + p2DeltaY;\n            this.br.x = this.p2.x - p2DeltaX;\n            this.br.y = this.p2.y - p2DeltaY;\n            // Create lines for the edges for computations and faster hit detections\n            this.topEdge = new line_1.Line(this.tl, this.tr);\n            this.bottomEdge = new line_1.Line(this.bl, this.br);\n            // Make sure our bounds reflects the entirety of the fat edge\n            this.encapsulatePoints([this.tl, this.tr, this.bl, this.br]);\n        }\n    };\n    return EdgeShape;\n}(line_shape_1.LineShape));\nexports.EdgeShape = EdgeShape;\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(4);\n/**\n * Defines an image that can be rendered by the gpu. This is an axis oriented\n * image only (no rotations)\n */\nvar ImageShape = (function (_super) {\n    __extends(ImageShape, _super);\n    /**\n     * Generates a new ImageShape that can be rendered\n     *\n     * @param {AtlasTexture} image The AtlasTexture to use when rendering this image\n     * @param {number} size This is the size of the longest edge of the image while\n     *                      retaining aspect ratio.\n     */\n    function ImageShape(image, size) {\n        var _this = _super.call(this, 0, 0, size, size) || this;\n        /** This is the level of opacity the image will be rendered with */\n        _this.opacity = 1.0;\n        _this.texture = image;\n        _this.size = size;\n        return _this;\n    }\n    Object.defineProperty(ImageShape.prototype, \"size\", {\n        /**\n         * Returns the largest edge of the image\n         */\n        get: function () {\n            return Math.max(this.width, this.height);\n        },\n        /**\n         * This is the size the image will be rendered within World Space. The size\n         * correlates to the largest edge of the image\n         */\n        set: function (val) {\n            if (this.texture.aspectRatio > 1) {\n                this.width = val;\n                this.height = val / this.texture.aspectRatio;\n            }\n            else {\n                this.width = val * this.texture.aspectRatio;\n                this.height = val;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Centers this image on a provided location\n     *\n     * @param {number} x The x coordinate in world space\n     * @param {number} y The y coordinate in world space\n     */\n    ImageShape.prototype.centerOn = function (x, y) {\n        this.x = x - (this.width / 2.0);\n        this.y = y - (this.height / 2.0);\n    };\n    return ImageShape;\n}(bounds_1.Bounds));\nexports.ImageShape = ImageShape;\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(4);\nvar QuadShape = (function (_super) {\n    __extends(QuadShape, _super);\n    function QuadShape(bounds, color) {\n        var _this = _super.call(this, bounds.x, bounds.right, bounds.y, bounds.bottom) || this;\n        _this.r = 1.0;\n        _this.g = 0.0;\n        _this.b = 0.0;\n        _this.a = 1.0;\n        return _this;\n    }\n    return QuadShape;\n}(bounds_1.Bounds));\nexports.QuadShape = QuadShape;\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interpolation_1 = __webpack_require__(8);\nvar curved_line_shape_1 = __webpack_require__(9);\n/**\n * This defines a drawable ribbon shape.  It contains the information necessary\n * to efficiently render the ribbon.\n *\n * @export\n * @class RibbonShape\n * @extends {CurvedLineShape<T>}\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\n *             with the shape easier\n */\nvar RibbonShape = (function (_super) {\n    __extends(RibbonShape, _super);\n    /**\n     *\n     * Creates and instance of RibbonShape\n     *\n     * @param {IRibbonOptions} options  The options for creating this ribbon\n     *\n     */\n    function RibbonShape(options) {\n        var _this = _super.call(this, options) || this;\n        /** Depeth of draw location */\n        _this.depth = 0;\n        _this.cachesQuadSegments = options.cachedQuadSegments || true;\n        _this.depth = options.depth || 0;\n        _this.start2 = options.start2;\n        _this.end2 = options.end2;\n        _this.encapsulatePoints(_this.getRibbonStrip());\n        _this.center1 = options.center1;\n        _this.center2 = options.center2;\n        return _this;\n    }\n    /**\n     * Returns a new instance of this object that mimicks the properties of this Object\n     *\n     * @returns {RibbonShape<T>} The cloned object\n     */\n    RibbonShape.prototype.clone = function () {\n        // Perform the clone\n        var clone = new RibbonShape({\n            center1: this.center1,\n            center2: this.center2,\n            controlPoints: this.controlPoints,\n            end: this.end,\n            end2: this.end2,\n            endColor: this.endColor,\n            resolution: this.resolution,\n            start: this.start,\n            start2: this.start2,\n            startColor: this.startColor,\n            type: this.type,\n        });\n        clone.d = this.d;\n        return clone;\n    };\n    /**\n     * @override\n     * Return distance from a point to ribbon. If the point is in ribbon, return 0\n     * Otherwise use method of superclass.\n     */\n    RibbonShape.prototype.distanceTo = function (point) {\n        if (this.pointInside(point))\n            return 0;\n        return _super.prototype.distanceTo.call(this, point);\n    };\n    /**\n     * Test whether a point is in the ribbon using Point Inclusion in Polygon Test method\n     * @param point\n     */\n    RibbonShape.prototype.pointInside = function (point) {\n        var points = this.getRibbonStrip();\n        var nvert = points.length;\n        var i;\n        var j;\n        var c = false;\n        var testx = point.x;\n        var testy = point.y;\n        for (i = 0, j = nvert - 1; i < nvert; j = i++) {\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\n                    (points[j].y - points[i].y) + points[i].x)) {\n                c = !c;\n            }\n        }\n        return c;\n    };\n    /**\n     * This prodeuces all the points along the two bezier lines.\n     * The order of all the points pushed should be clockwise.\n     *\n     * @return {IPoint[]} The points to create the quads that make each segment of the ribbon.\n     *\n     */\n    RibbonShape.prototype.getRibbonStrip = function () {\n        var strip = [];\n        var dt = 1 / this.resolution;\n        var c1 = this.controlPoints[0];\n        for (var i = 0; i <= this.resolution; i++) {\n            strip.push(interpolation_1.bezier2(dt * i, this.start, this.end, c1));\n        }\n        for (var i = this.resolution; i >= 0; i--) {\n            strip.push(interpolation_1.bezier2(dt * i, this.start2, this.end2, c1));\n        }\n        return strip;\n    };\n    return RibbonShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.RibbonShape = RibbonShape;\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\n/**\n * Defines a color that is located on an atlas\n */\nvar AtlasColor = (function () {\n    /**\n     * Constructor implementation\n     */\n    function AtlasColor(color, g, b, a) {\n        if (a === void 0) { a = 1.0; }\n        // Value between 1 - 0 for the opacity of the color\n        this.opacity = 1.0;\n        // The pixel width and height of the color rendered onto the atlas\n        // This will always be a 2x2 so the color can be sampled in the middle\n        // For a guaranteed pure color regardless of gl sampling states\n        this.pixelWidth = 2;\n        this.pixelHeight = 2;\n        if (color instanceof three_1.Color) {\n            this.color = color.clone();\n            this.opacity = g === undefined ? 1.0 : g;\n        }\n        else {\n            this.color = new three_1.Color(color, g, b);\n            this.opacity = a;\n        }\n    }\n    return AtlasColor;\n}());\nexports.AtlasColor = AtlasColor;\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(4));\n__export(__webpack_require__(22));\n__export(__webpack_require__(21));\n__export(__webpack_require__(7));\n__export(__webpack_require__(6));\n__export(__webpack_require__(17));\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(59));\n__export(__webpack_require__(60));\n__export(__webpack_require__(1));\n__export(__webpack_require__(61));\n__export(__webpack_require__(13));\n__export(__webpack_require__(11));\n__export(__webpack_require__(62));\n__export(__webpack_require__(8));\n__export(__webpack_require__(19));\n__export(__webpack_require__(24));\n__export(__webpack_require__(15));\n__export(__webpack_require__(20));\n__export(__webpack_require__(25));\n__export(__webpack_require__(12));\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"PLAY\"] = 0] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 1] = \"STOP\";\n})(PlayState || (PlayState = {}));\nvar Animate = (function () {\n    function Animate() {\n    }\n    Animate.animate = function () {\n        if (Animate.playState === PlayState.PLAY) {\n            requestAnimationFrame(Animate.animate);\n        }\n        this.animating.forEach(function (propToItem) {\n            propToItem.forEach(function (animate) {\n                // TODO\n            });\n        });\n    };\n    Animate.cancel = function (container, prop) {\n        // TODO\n    };\n    Animate.value = function (container, prop, start, end, duration, ease) {\n        // TODO\n    };\n    Animate.point = function (container) {\n        // TODO\n    };\n    Animate.start = function () {\n        // TODO\n    };\n    Animate.stop = function () {\n        // TODO\n    };\n    Animate.playState = PlayState.PLAY;\n    Animate.animating = new Map();\n    return Animate;\n}());\nexports.Animate = Animate;\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar multi_shape_buffer_cache_1 = __webpack_require__(24);\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"INIT\"] = 0] = \"INIT\";\n    PlayState[PlayState[\"PLAY\"] = 1] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 2] = \"STOP\";\n})(PlayState = exports.PlayState || (exports.PlayState = {}));\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar AnimatedShapeBufferCache = (function (_super) {\n    __extends(AnimatedShapeBufferCache, _super);\n    function AnimatedShapeBufferCache() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.playState = PlayState.INIT;\n        _this.buffer = [];\n        _this.bustCache = true;\n        /**\n         * This is the internal control for managing execution of the animate method\n         */\n        _this.doAnimate = function () {\n            if (_this.playState === PlayState.PLAY) {\n                requestAnimationFrame(_this.doAnimate);\n            }\n            _this.animate();\n        };\n        return _this;\n    }\n    /**\n     * This is the method that will execute with the frame rate. Subclasses can\n     * override this to implement animated changes\n     */\n    AnimatedShapeBufferCache.prototype.animate = function () {\n        // Implemented by subclasses\n    };\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    AnimatedShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        if (this.bustCache) {\n            this.buildCache.apply(this, arguments);\n            this.bustCache = false;\n            if (this.playState === PlayState.INIT) {\n                this.start();\n                requestAnimationFrame(this.doAnimate);\n            }\n        }\n        // We always invalidate and commit all of our buffers for animations\n        this.flagBuffersDirty();\n        // Make sure our buffers are updated so they will commit to vertex buffers\n        this.processDirtyBuffers();\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    AnimatedShapeBufferCache.prototype.buildCache = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Begins executing the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.start = function () {\n        this.playState = PlayState.PLAY;\n    };\n    /**\n     * Ceases the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.stop = function () {\n        this.playState = PlayState.STOP;\n    };\n    return AnimatedShapeBufferCache;\n}(multi_shape_buffer_cache_1.MultiShapeBufferCache));\nexports.AnimatedShapeBufferCache = AnimatedShapeBufferCache;\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Takes a map of the form <T, boolean> and returns an array of the keys,\n * excluding entries who's mapped value is false.\n *\n * @param map The map to convert to a list\n *\n * @return T[] A list of the keys, exluding false mappings\n */\nfunction boolMapToArray(map) {\n    return Array\n        .from(map)\n        .filter(function (item) { return item[1]; })\n        .map(function (item) { return item[0]; });\n}\nexports.boolMapToArray = boolMapToArray;\n/**\n * Defines a selection control for custom types and categories\n */\nvar CustomSelection = (function () {\n    function CustomSelection() {\n        /** This caches the list generation of a selection */\n        this.cachedSelection = new Map();\n        /** Map of the custom categories to the selection state */\n        this.selections = new Map();\n        /** Keeps flags indicating if a selection for a given category has changed or not */\n        this._didSelectionChange = new Map();\n    }\n    /**\n     * Clears out all custom selections for every category\n     */\n    CustomSelection.prototype.clearAllSelections = function () {\n        for (var _i = 0, _a = Array.from(this.selections.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this.clearSelection(key);\n        }\n    };\n    /**\n     * Clears the selection for the category specified\n     *\n     * @param {string} category Name of the category of selection\n     */\n    CustomSelection.prototype.clearSelection = function (category) {\n        // We must have selected items to clear the selection\n        if (this.getSelection(category).length) {\n            this.selections.set(category, null);\n            this.cachedSelection.set(category, null);\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Makes an item no longer flaged as selected within the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to remove from being selected\n     */\n    CustomSelection.prototype.deselect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        // See if the item is selected already, if it is, clear the selection and bust caches\n        if (selectionMap && selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, false);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Checks if a selection from a category has been modified\n     *\n     * @param {string} category The selection category to check\n     */\n    CustomSelection.prototype.didSelectionCategoryChange = function (category) {\n        return this._didSelectionChange.get(category);\n    };\n    /**\n     * Checks if ANY selection has changed\n     *\n     * @return {boolean} True if any selection has changed\n     */\n    CustomSelection.prototype.didSelectionChange = function () {\n        return boolMapToArray(this._didSelectionChange).length > 0;\n    };\n    /**\n     * This indicates that updates have taken place to account for selection\n     * changes.\n     */\n    CustomSelection.prototype.finalizeUpdate = function () {\n        for (var _i = 0, _a = Array.from(this._didSelectionChange.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this._didSelectionChange.set(key, false);\n        }\n    };\n    /**\n     * This retrieves a list of the items that are selected\n     *\n     * @param category The selection category to check on\n     *\n     * @return {T} Returns a list of items that are currently selected\n     */\n    CustomSelection.prototype.getSelection = function (category) {\n        if (!this.cachedSelection.get(category)) {\n            var theSelection = this.selections.get(category);\n            if (theSelection) {\n                this.cachedSelection.set(category, boolMapToArray(theSelection));\n            }\n            else {\n                this.cachedSelection.set(category, []);\n            }\n        }\n        return this.cachedSelection.get(category);\n    };\n    /**\n     * Specifies an item to flag as selected for the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.select = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        if (!selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, true);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Specifies an item to toggle it's selection status for the provided category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.toggleSelect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        // Clear the cache for the selection list\n        this.cachedSelection.set(category, null);\n        // Toggle the selection off if already selected\n        if (selectionMap.get(item)) {\n            this.deselect(category, item);\n        }\n        else {\n            this.select(category, item);\n        }\n        // Flag the category of selections as changed\n        this._didSelectionChange.set(category, true);\n    };\n    return CustomSelection;\n}());\nexports.CustomSelection = CustomSelection;\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getFontMetrics(props) {\n    var ctx = props.ctx;\n    var text = props.text;\n    var bboxHeight = props.bboxHeight;\n    var canvasHeight = props.ctx.canvas.height;\n    var baseline = props.baseline || 'alphabetic';\n    var flip = props.flip || false;\n    var drawBaseline = props.drawBaseline || false;\n    var fontFamily = 'Arial, san-serif';\n    var fontSize = 14;\n    if (props.fontFamily) {\n        fontFamily = props.fontFamily;\n    }\n    if (props.fontSize) {\n        fontSize = props.fontSize;\n    }\n    // Setting up the canvas\n    ctx.save(); // Create canvas to use as buffer\n    ctx.font = fontSize + \"px \" + fontFamily;\n    var textWidth = ctx.measureText(text).width;\n    // This keeps font in-screen, measureText().width doesn't\n    // Quite do it in some cases. For instance \"j\", or the letter \"f\"\n    // In the font \"Zapfino\".\n    var offsetx = fontSize * 2;\n    var offsety = fontSize * 2;\n    var cwidth = ctx.canvas.width = Math.round(textWidth + offsetx * 2);\n    var cheight = ctx.canvas.height = canvasHeight ? canvasHeight : Math.round(offsety * 2);\n    if (typeof (baseline) === 'string') {\n        offsety = 0; // Using <canvas> baseline\n        ctx.textBaseline = baseline;\n    }\n    // Ctx.font has to be called twice because resetting the size resets the state\n    if (flip) {\n        ctx.scale(1, -1);\n    }\n    ctx.font = fontSize + \"px \" + fontFamily;\n    ctx.fillText(text, offsetx, (typeof (bboxHeight) === 'number' ? bboxHeight : offsety));\n    // Drawing baseline\n    if (drawBaseline) {\n        ctx.fillRect(0, canvasHeight / 2, ctx.canvas.width, 1);\n    }\n    // Grabbing image data\n    var imageData = ctx.getImageData(0, 0, cwidth, cheight);\n    var data = imageData.data;\n    // Calculating top\n    var top = 0;\n    var pos = data.length;\n    var bottom = 0;\n    var realBottom = 0;\n    var left = 0;\n    var right = 0;\n    while (pos > 0) {\n        if (data[pos + 3]) {\n            pos -= pos % (cwidth * 4); // Back to beginning of the line top = (pos / 4) / cwidth; // calculate pixel position top -= offsety - fontSize; pos = data.length; // exit loop } pos += 4; } // calculating bottom var bottom = 0; var pos = data.length; while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                bottom = (pos / 4) / cwidth;\n                bottom -= offsety - fontSize;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Calculating left\n        left = 0;\n        var col = 0;\n        var row = 0; // Left bounds\n        while (row < cheight && col < cwidth) {\n            var px = data[(row * cwidth * 4) + (col * 4) + 3];\n            if (px) {\n                left = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col++;\n            }\n        }\n        // Calculating right\n        right = 0;\n        col = cwidth;\n        row = 0; // Right bounds\n        while (row < cheight && col > 0) {\n            if (data[(row * cwidth * 4) + (col * 4) + 3]) {\n                right = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col--;\n            }\n        }\n        // Calculating real-bottom\n        realBottom = 0;\n        pos = data.length;\n        while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                realBottom = (pos / 4) / cwidth;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Restoring state\n        ctx.restore();\n    }\n    // Returning raw-metrics\n    return {\n        bottom: realBottom,\n        height: (bottom - top),\n        left: (-left),\n        top: (fontSize - top),\n        width: (right - left),\n    };\n}\nexports.getFontMetrics = getFontMetrics;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 26);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bda8d42c38c8045a3118","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"three\"\n// module id = 0\n// module chunks = 0","\"use strict\";\n/**\n * This class and set of methods is provided to attempt to create as efficient as possible\n * methods for updating large vertex buffers with values. The first portion of the file is\n * a list of methods and registers. This is to prevent any instantiation needed for the methods\n * and registers to exist. Also, the methods have no useable parent scope to ensure nothing like\n * a 'this' is used. These methods utilize the registers and their own simple loops to pound\n * through large amounts of information while providing capabilities to edit vertices in batches.\n *\n * You will also notice there are many many similar methods with just a single extra parameter\n * here and there. This is to prevent ANY calculations on trying to determine a proper parameter set\n * while also making method calls directly without any .call or .apply.\n *\n * The number of update methods is how many differing attributes are supported. If you need more supported\n * attributes add an updateBufferN method and provide the required attributes. Insert the logic in the EXACT\n * pattern seen in the other methods. DO NOT attempt to add additional logic lest the performance be something\n * terrible.\n *\n * The BufferUtil class makes use of these methods and registers. It also provides some very handy methods\n * for working with your large buffers.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar webgl_stat_1 = require(\"./webgl-stat\");\nvar debugGenerator = require('debug');\nvar debug = require('debug')('WebGLSurface:BufferUtil');\nvar TriangleOrientation;\n(function (TriangleOrientation) {\n    // The triangles points are clockwise\n    TriangleOrientation[TriangleOrientation[\"CW\"] = 0] = \"CW\";\n    // The triangles points are Counter clockwise\n    TriangleOrientation[TriangleOrientation[\"CCW\"] = 1] = \"CCW\";\n    // The triangles points are linear, thus degenerate\n    TriangleOrientation[TriangleOrientation[\"DEGENERATE\"] = 2] = \"DEGENERATE\";\n})(TriangleOrientation = exports.TriangleOrientation || (exports.TriangleOrientation = {}));\nvar AttributeSize;\n(function (AttributeSize) {\n    AttributeSize[AttributeSize[\"ONE\"] = 0] = \"ONE\";\n    AttributeSize[AttributeSize[\"TWO\"] = 1] = \"TWO\";\n    AttributeSize[AttributeSize[\"THREE\"] = 2] = \"THREE\";\n    AttributeSize[AttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(AttributeSize = exports.AttributeSize || (exports.AttributeSize = {}));\nvar UniformAttributeSize;\n(function (UniformAttributeSize) {\n    UniformAttributeSize[UniformAttributeSize[\"ONE\"] = 0] = \"ONE\";\n    UniformAttributeSize[UniformAttributeSize[\"TWO\"] = 1] = \"TWO\";\n    UniformAttributeSize[UniformAttributeSize[\"THREE\"] = 2] = \"THREE\";\n    UniformAttributeSize[UniformAttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(UniformAttributeSize = exports.UniformAttributeSize || (exports.UniformAttributeSize = {}));\n/**\n * These are for fast look ups of the default values provided\n * Doing this fashion avoids array look ups in the defaults values\n */\nvar defaultsHolder0 = 0;\nvar defaultsHolder1 = 0;\nvar defaultsHolder2 = 0;\nvar defaultsHolder3 = 0;\n/**\n * These are for fast look ups of attribute buffers that are going\n * through the update process. We do everything to mitigate array look ups\n * when and where we can\n */\nvar attrRegister0 = [];\nvar attrRegister1 = [];\nvar attrRegister2 = [];\nvar attrRegister3 = [];\nvar attrRegister4 = [];\nvar attrRegister5 = [];\nvar attrRegister6 = [];\nvar attrRegister7 = [];\nvar attrRegister8 = [];\nvar attrRegister9 = [];\nvar attrRegister10 = [];\nvar attrIndex0 = 0;\nvar attrIndex1 = 0;\nvar attrIndex2 = 0;\nvar attrIndex3 = 0;\nvar attrIndex4 = 0;\nvar attrIndex5 = 0;\nvar attrIndex6 = 0;\nvar attrIndex7 = 0;\nvar attrIndex8 = 0;\nvar attrIndex9 = 0;\nvar attrIndex10 = 0;\nvar attrIndexIncr0 = 0;\nvar attrIndexIncr1 = 0;\nvar attrIndexIncr2 = 0;\nvar attrIndexIncr3 = 0;\nvar attrIndexIncr4 = 0;\nvar attrIndexIncr5 = 0;\nvar attrIndexIncr6 = 0;\nvar attrIndexIncr7 = 0;\nvar attrIndexIncr8 = 0;\nvar attrIndexIncr9 = 0;\nvar attrIndexIncr10 = 0;\n/** This is used to define a starting batch location to aid in continuing batch updates */\nvar lastBatchRegister = 0;\nvar isStreamUpdatingRegister = false;\n/**\n * This takes our list of attribute buffers and applies them to the registers for rapid lookups\n *\n * @param {number[][]} attributeBuffers The buffers for each attribute to be updated\n * @param {number[]} incrementValues How much each batch increments it's lookup index\n */\nfunction applyAttributeRegisters(attributeBuffers, incrementValues) {\n    attrRegister0 = attributeBuffers[0];\n    attrRegister1 = attributeBuffers[1];\n    attrRegister2 = attributeBuffers[2];\n    attrRegister3 = attributeBuffers[3];\n    attrRegister4 = attributeBuffers[4];\n    attrRegister5 = attributeBuffers[5];\n    attrRegister6 = attributeBuffers[6];\n    attrRegister7 = attributeBuffers[7];\n    attrRegister8 = attributeBuffers[8];\n    attrRegister9 = attributeBuffers[9];\n    attrRegister10 = attributeBuffers[10];\n    attrIndexIncr0 = incrementValues[0];\n    attrIndexIncr1 = incrementValues[1];\n    attrIndexIncr2 = incrementValues[2];\n    attrIndexIncr3 = incrementValues[3];\n    attrIndexIncr4 = incrementValues[4];\n    attrIndexIncr5 = incrementValues[5];\n    attrIndexIncr6 = incrementValues[6];\n    attrIndexIncr7 = incrementValues[7];\n    attrIndexIncr8 = incrementValues[8];\n    attrIndexIncr9 = incrementValues[9];\n    attrIndexIncr10 = incrementValues[10];\n}\n/**\n * The following methods are targetted at executing the update accessor with varying number\n * of parameters while mitigating array look ups.\n *\n * @param {number} numBatches The number of batches to execute\n * @param {Function} updateAccessor The accessor function that will update the buffer values\n */\nfunction updateBuffer1(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0);\n    }\n}\nfunction updateBuffer2(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1);\n    }\n}\nfunction updateBuffer3(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2);\n    }\n}\nfunction updateBuffer4(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3);\n    }\n}\nfunction updateBuffer5(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4);\n    }\n}\nfunction updateBuffer6(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5);\n    }\n}\nfunction updateBuffer7(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6);\n    }\n}\nfunction updateBuffer8(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7);\n    }\n}\nfunction updateBuffer9(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8);\n    }\n}\nfunction updateBuffer10(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9);\n    }\n}\nfunction updateBuffer11(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        attrIndex10 = i * attrIndexIncr10;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9, attrRegister10, attrIndex10);\n    }\n}\n/**\n * This takes the defaults array provided and loads them into our default\n * lookup values\n *\n * @param {number[]} defaults The array with the default values in them for our buffer attribute\n */\nfunction applyDefaultsHolders(defaults) {\n    defaultsHolder0 = defaults[0] || 0;\n    defaultsHolder1 = defaults[1] || 0;\n    defaultsHolder2 = defaults[2] || 0;\n    defaultsHolder3 = defaults[3] || 0;\n}\n/**\n * The following methods are rapid ways of populating the buffer without\n * setting up a generic loop. This saves on performance by not creating a loop\n * nor allocating the variables necessary for the generic loop.\n *\n * @param {Float32Array} buffer The buffer to populate\n * @param {number} start The index the data should be populated into\n */\nfunction fillSize1(buffer, start) {\n    buffer[start] = defaultsHolder0;\n}\nfunction fillSize2(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n}\nfunction fillSize3(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n}\nfunction fillSize4(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n    buffer[++start] = defaultsHolder3;\n}\nfunction isList(val) {\n    if (Array.isArray(val))\n        return true;\n    return false;\n}\n/**\n * This is a quick lookup to find the correct filler method for the given attribute size\n */\nvar fillMethodLookUp = (_a = {},\n    _a[AttributeSize.ONE] = fillSize1,\n    _a[AttributeSize.TWO] = fillSize2,\n    _a[AttributeSize.THREE] = fillSize3,\n    _a[AttributeSize.FOUR] = fillSize4,\n    _a);\nvar updateBufferLookUp = {\n    1: updateBuffer1,\n    2: updateBuffer2,\n    3: updateBuffer3,\n    4: updateBuffer4,\n    5: updateBuffer5,\n    6: updateBuffer6,\n    7: updateBuffer7,\n    8: updateBuffer8,\n    9: updateBuffer9,\n    10: updateBuffer10,\n    11: updateBuffer11,\n};\n/**\n * This provides methods for handling common buffer tasks such as construction\n * and population.\n */\nvar BufferUtil = (function () {\n    function BufferUtil() {\n    }\n    /**\n     * This places our updateBuffer into a mode where the updates start at index 0 of the\n     * buffer. Subsequent calls will start where the previous call left off. This lets\n     * you stream in updates to the buffer rather than just update the entire buffer\n     * all at once.\n     */\n    BufferUtil.beginUpdates = function () {\n        isStreamUpdatingRegister = true;\n        lastBatchRegister = 0;\n    };\n    /**\n     * This takes the buffer items and cleans up their use within memory as best as possible.\n     *\n     * @param bufferItems\n     */\n    BufferUtil.dispose = function (buffers) {\n        if (buffers) {\n            buffers.forEach(function (bufferItems) {\n                bufferItems.attributes = null;\n                bufferItems.currentData = null;\n                bufferItems.geometry.dispose();\n                bufferItems.geometry = null;\n                bufferItems.system = null;\n            });\n        }\n    };\n    /**\n     * This stops updates streaming into the buffers and makes it where an update\n     * will always just start at the beginning of the buffer.\n     */\n    BufferUtil.endUpdates = function () {\n        var totalBatches = lastBatchRegister;\n        isStreamUpdatingRegister = false;\n        lastBatchRegister = 0;\n        return totalBatches;\n    };\n    /**\n     * It is often needed to examine a given buffer and see how the triangles are packed in.\n     * This is a common debugging need and will speed up debugging significantly.\n     *\n     * @param {IBufferItems<T, U>} bufferItems This is the buffer whose structure we want\n     *                                         to examine.\n     * @param {string} message This is the message for the debug statement. There are two\n     *                         predefined %o. The first is the vertex information the second\n     *                         is the uniform info. Leave null for a default message.\n     * @param {string} debugNamespace The namespace for the debugging info.\n     */\n    BufferUtil.examineBuffer = function (bufferItems, message, debugNamespace) {\n        // Get the appropriate debug namespace\n        var debugBuffer = debugGenerator(debugNamespace);\n        // Quick quit if the debugger is not enabled\n        if (!debugBuffer.enabled) {\n            return;\n        }\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // Get the attributes by name out of the three js buffer\n        var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n        // Get the raw number buffers\n        var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n        // This will store all of the examined triangles for easy viewing\n        var triangles = [];\n        if (bufferItems.system.drawMode === three_1.TrianglesDrawMode) {\n            var currentVertex_1 = 0;\n            var attrSize_1 = 0;\n            var currentIndex_1 = 0;\n            var length_1 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_1 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_2 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_1 = attr.size + 1;\n                        currentIndex_1 = currentVertex_1 * attrSize_1;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_1, currentIndex_1 + attrSize_1);\n                    });\n                    // Move to the next vertex\n                    currentVertex_1++;\n                };\n                // Each new triangle is a culmination of three vertices which are packed in\n                // The buffer with no vertex sharing\n                for (var i = 0; i < 3; ++i) {\n                    _loop_2(i);\n                }\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_1 < length_1) {\n                _loop_1();\n            }\n        }\n        else if (bufferItems.system.drawMode === three_1.TriangleStripDrawMode) {\n            var currentVertex_2 = 0;\n            var attrSize_2 = 0;\n            var currentIndex_2 = 0;\n            var length_2 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_3 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_4 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_2 = attr.size + 1;\n                        currentIndex_2 = currentVertex_2 * attrSize_2;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_2, currentIndex_2 + attrSize_2);\n                    });\n                    // Move to the next vertex\n                    currentVertex_2++;\n                };\n                // Each new triangle is three vertices, where the first two are shared with\n                // The previous triangle's last two vertices\n                for (var i = 0; i < 3; ++i) {\n                    _loop_4(i);\n                }\n                // Go back two vertices as the next tri will use them + the next vertex to\n                // Make the next triangle\n                currentVertex_2 -= 2;\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_2 < length_2) {\n                _loop_3();\n            }\n        }\n        // Log the debug info to the console using the debug utility\n        debugBuffer(message || 'vertices: %o uniforms: %o', {\n            drawRange: buffer.drawRange,\n            triangles: triangles,\n        }, bufferItems.system.material.uniforms);\n    };\n    /**\n     * Aids in taking in multiple multibuffers and flattening it to a single list\n     *\n     * @param multiShapeBuffers\n     */\n    BufferUtil.flattenMultiBuffers = function (multiShapeBuffers) {\n        var all = [];\n        multiShapeBuffers.forEach(function (multiBuffer) {\n            multiBuffer.getBuffers().forEach(function (buffer) { return all = all.concat(buffer); });\n        });\n        return all;\n    };\n    /**\n     * @static\n     * This helps aid in updating a complex multi buffer. It will establish when a new\n     * buffer needs to be created and initialized and it will automatically call a BaseBuffer's\n     * update when an update is detected as a need for the buffer.\n     *\n     * @param multiShapeBuffer\n     * @param buffers\n     * @param init\n     *\n     * @return {boolean} True if a buffer was updated\n     */\n    BufferUtil.updateMultiBuffer = function (multiShapeBuffer, buffers, init, update, forceUpdates) {\n        // If no buffers provided, then we do not need to update anything\n        if (!multiShapeBuffer) {\n            return false;\n        }\n        // This flag indicates whether an update occurred or not\n        var didUpdate = false;\n        // Get the shape buffers we need rendered into vertex buffers\n        var shapeBuffers;\n        // If this is a list of multibuffers, we flatten out all of the sub buffers\n        // This is a one level deep flatten as we do not want to accidentally handle shape clustering here\n        if (isList(multiShapeBuffer)) {\n            shapeBuffers = multiShapeBuffer.reduce(function (flat, toFlatten) { return flat.concat(toFlatten.getBuffers()); }, []);\n        }\n        else {\n            shapeBuffers = multiShapeBuffer.getBuffers();\n        }\n        // Make a lookup to identify the buffers that already exists for the given multi shape buffers\n        var bufferLookup = new Map();\n        buffers.forEach(function (buffer) { return bufferLookup.set(buffer.bufferItems.currentData, buffer); });\n        // This will store all of the shape buffers that needs to be rendered into a vertex buffer\n        var needsBuffer = [];\n        // If we're forcing updates then we should be ensuring all shapeBuffers needs a buffer\n        // And leave all of the bufferLookup so they will all be updated with the provided needed shape buffer updates\n        if (forceUpdates) {\n            needsBuffer = [].concat(shapeBuffers);\n        }\n        else {\n            shapeBuffers.forEach(function (shapes) {\n                if (bufferLookup.get(shapes)) {\n                    bufferLookup.delete(shapes);\n                }\n                else if (shapes.length > 0) {\n                    needsBuffer.push(shapes);\n                }\n            });\n        }\n        // All buffers remaining in the buffer lookup are available for re-rendering the\n        // Shape buffers that still needs updates\n        // If the shape buffers needing updates is greater than the vertex buffers available\n        // Then we update with what we have and initialize any additional vertex buffers needed\n        if (needsBuffer.length >= bufferLookup.size) {\n            // Take any buffer that is not found with an existing shape buffer and update it\n            // With a buffer that needs an update\n            bufferLookup.forEach(function (value) {\n                didUpdate = update(value, needsBuffer.shift()) || didUpdate;\n            });\n            // Any remaining buffers that need updates will have to initialize a buffer\n            // To cram it in\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = init();\n                buffers.push(vertexBuffer);\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n        }\n        else {\n            var vertexBuffers_1 = Array.from(bufferLookup.values());\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = vertexBuffers_1.shift();\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n            vertexBuffers_1.forEach(function (buffer) {\n                buffer.bufferItems.geometry.setDrawRange(0, 0);\n            });\n        }\n        return didUpdate;\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with constructing a new buffer\n     * such as applying the name, generating the buffer, and populating default values to\n     * that buffer.\n     *\n     * @param {number} numVertices The number of vertices this buffer will have\n     * @param {IAttributeInfo[]} attributes A description of each attribute in the buffer\n     *\n     * @returns {BufferGeometry} The newly made buffer\n     */\n    BufferUtil.makeBuffer = function (numVertices, attributes) {\n        var iMax = attributes.length;\n        var geometry = new three_1.BufferGeometry();\n        var totalAttributeSize = 0;\n        var foundPosition = false;\n        for (var i = 0; i < iMax; ++i) {\n            var attribute = attributes[i];\n            var attributeSize = attribute.size + 1;\n            totalAttributeSize += attributeSize;\n            var name_1 = attribute.name;\n            var injectBuffer = attribute.injectBuffer;\n            var buffer = injectBuffer || new Float32Array(attributeSize * numVertices);\n            var fillMethod = fillMethodLookUp[attribute.size];\n            var customFill = attribute.customFill;\n            var defaults = attribute.defaults;\n            if (name_1 === 'position') {\n                foundPosition = true;\n            }\n            // If an explicit buffer was not provided, then we fill with the defaults\n            if (!injectBuffer) {\n                if (customFill) {\n                    // Let the custom fill method populate the buffer with whatever so be desired\n                    for (var k = 0; k < numVertices; ++k) {\n                        customFill(buffer, k, k * attributeSize, defaults);\n                    }\n                }\n                else {\n                    // We set up our default value registers before executing the fill method\n                    applyDefaultsHolders(defaults);\n                    // Fill our buffer with the indicated default values\n                    for (var k = 0; k < numVertices; ++k) {\n                        fillMethod(buffer, k * attributeSize);\n                    }\n                }\n            }\n            // Apply the buffer to our geometry buffer\n            var attr = new three_1.BufferAttribute(buffer, attributeSize);\n            attr.setDynamic(true);\n            geometry.addAttribute(name_1, attr);\n            debug('Made Buffer Attribute:', name_1, attributeSize);\n        }\n        if (!foundPosition) {\n            console.warn('It is recommended you ALWAYS use the position attribute as one of your attributes', 'There are features of threejs that REQUIRES this to be in place (even if not explicitly', 'documented). You don\\'t have to use for exact position information, rather fill it with something', 'you need. Failure to do so will have you see consequences that are EXTREMELY hard to find.');\n        }\n        if (totalAttributeSize > 16) {\n            console.warn('A Buffer has specified more attributes than available. The max is 16 and the buffer provided:', totalAttributeSize);\n        }\n        return geometry;\n    };\n    /**\n     *\n     * @param attributes\n     * @param sharedBuffer\n     */\n    BufferUtil.shareBuffer = function (attributes, sharedBuffer) {\n        var bufferAttributes = sharedBuffer.attributes;\n        var newBuffer = new three_1.BufferGeometry();\n        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n            var attr = attributes_1[_i];\n            var shareAttribute = bufferAttributes[attr.name];\n            if (shareAttribute) {\n                newBuffer.addAttribute(attr.name, shareAttribute);\n            }\n            else {\n                console.warn('Could not find attribute', attr, 'in the buffer to be shared. Can not share buffers properly');\n            }\n        }\n        return newBuffer;\n    };\n    /**\n     * Generates the necessary metrics based on uniform attributes to generate a uniform buffer for\n     * rendering.\n     *\n     * @param uniforms\n     */\n    BufferUtil.makeUniformBuffer = function (uniforms) {\n        var maxBlock = 0;\n        var buffer = [];\n        var uniformBufferBlockMax = webgl_stat_1.WebGLStat.MAX_VERTEX_INSTANCE_DATA;\n        var sizeCheck = {};\n        uniforms.forEach(function (uniform) {\n            maxBlock = Math.max(uniform.block, maxBlock);\n            var check = sizeCheck[uniform.block] = (sizeCheck[uniform.block] || 0) + (uniform.size + 1);\n            if (check > 4) {\n                console.warn('There were too many uniform attribute usages of a single block:', uniform);\n            }\n        });\n        for (var i = 0; i < uniformBufferBlockMax; ++i) {\n            buffer.push(new three_1.Vector4(0, 0, 0, 0));\n        }\n        return {\n            blocksPerInstance: maxBlock + 1,\n            buffer: buffer,\n            maxInstances: Math.floor(uniformBufferBlockMax / maxBlock),\n        };\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with updating a buffer. You specify how many vertices\n     * to update in a batch and you specify how many batches are present.\n     *\n     * Batches are used to represent your full shape object that is being loaded from the cpu:\n     *\n     * IE- you have a rectangle object you wish to update in your buffer. This takes around 6 vertices typically\n     * so you make your vertexBatch 6 and the numBatches the number of quads you need to update in the buffer.\n     *\n     * You then provide an accessor which aids in pointing to the buffer items that need updating. The accessor has\n     * variable arguments depending on the attributes you inject in.\n     *\n     * If you have attributes like:\n     * [\n     *  {name: position, size: AttributeSize.Three},\n     *  {name: color, size: AttributeSize.Four},\n     * ]\n     *\n     * Then your accessor will be delievered arguments in this form:\n     *\n     * function(batchIndex: number, positionBuffer: number[], positionIndex: number, colorBuffer: number[], colorIndex: number)\n     *\n     * NOTE: The params handed in ARE ORDERED BY the attributes injected in\n     *\n     * You then can update the buffers based on the index information handed alongside each buffer\n     *\n     * @param {T[]} newData The new data that is going to be injected into the buffer. This must be a NEW REFERENCE of data\n     *                      that does NOT match the reference in the bufferItems.currentData. So newData !== bufferItems.currentData\n     *                      in order for the update to occur.\n     * @param {BufferGeometry} bufferItems The buffer related items used to identify how to update the buffer\n     * @param {number} vertexBatch The number of vertices to include per update batch\n     * @param {number} numBatches The number of batches to execute\n     * @param {Function} updateAccessor The accessor for performing the data update to the buffer\n     * @param {boolean} force This bypasses the typical checks that determines if the buffer SHOULD update.\n     *\n     * @return {boolean} True if the buffer was updated with this call\n     */\n    BufferUtil.updateBuffer = function (newData, bufferItems, vertexBatch, numBatches, updateAccessor, force) {\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            // Flag the newly rendered data as our current data\n            bufferItems.currentData = newData;\n            // Get the attributes by name out of the three js buffer\n            var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n            // Get the raw number buffers\n            var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n            // Determine what kind of buffer pointer increments we will need\n            var incrementValues = attributes.map(function (attr) { return (attr.size + 1) * vertexBatch; });\n            // Apply all data needed to any registers we need\n            applyAttributeRegisters(attributeBuffers, incrementValues);\n            // Get the method that will perform the update based on number of attributes\n            var updateMethod = updateBufferLookUp[attributes.length];\n            // Execute the update method\n            updateMethod(numBatches + lastBatchRegister, updateAccessor);\n            // Flag each buffer attribute for needing an update\n            bufferAttributes.forEach(function (attr) {\n                if (attr.updateRange) {\n                    attr.updateRange.offset = 0;\n                    attr.updateRange.count = vertexBatch * (lastBatchRegister + numBatches) * attr.itemSize;\n                }\n                attr.needsUpdate = true;\n            });\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n        }\n        return false;\n    };\n    /**\n     * This is an alternative way to specify data for rendering. This updates information within the\n     * uniform blocks to specify instancing data (the alternative is just updating a vertex buffer\n     * with all of the data needed for every piece of geometry for every instance). This update method\n     * CAN save massive amounts of committed data for large geometry items (ie curves). It requires a\n     * different pipeline to make work (your shader must specify a uniform vec4 instanceData[], and\n     * your shape buffer to vertex buffer conversion must have a static vertex buffer).\n     *\n     * This is like a vertex buffer update except the updateAccessor will be of this format:\n     *\n     * updateAccessor(instanceIndex: number, uniformBlock0: Vector4, ..., uniformBlockN: Vector4);\n     *\n     * Where the uniform blocks provided will appear in the same order the IUniformAttributes were in\n     * when the uniform buffer was created.\n     *\n     */\n    BufferUtil.updateUniformBuffer = function (newData, bufferItems, instanceBatchSize, updateAccessor, force) {\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            var material = bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var instanceData = uniforms.instanceData;\n            bufferItems.currentData = newData;\n            // If the instance data uniform is available and it is the proper vec4 array type, then we\n            // Are able to update the uniform buffer\n            if (instanceData && instanceData.type === 'v4v' || instanceData.type === 'bvec4' && bufferItems.uniformBuffer) {\n                var attributes = bufferItems.uniformAttributes;\n                var blocksPerInstance = bufferItems.uniformBuffer.blocksPerInstance;\n                var buffer = bufferItems.uniformBuffer.buffer;\n                var maxInstances = bufferItems.uniformBuffer.maxInstances;\n                var currentInstance = lastBatchRegister;\n                var currentInstanceStartBlock = lastBatchRegister * blocksPerInstance;\n                // We loop and update as many instances as specified, only up to the\n                // Number of instances allowed for the uniform buffer\n                for (var i = 0; i < instanceBatchSize && currentInstance < maxInstances; ++i) {\n                    // Our current instance depends on our lastBatchRegister we utilize\n                    // When begin() is called\n                    currentInstance = lastBatchRegister + i;\n                    // We get the first block the instance will utilize\n                    currentInstanceStartBlock = blocksPerInstance * currentInstance;\n                    // This will contain all of our arguments the accessor will use\n                    var updateArguments = [currentInstance];\n                    // Loop through the attributes in the order they appear and gather the block they will\n                    // Update\n                    for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {\n                        var attribute = attributes_2[_i];\n                        updateArguments.push(buffer[attribute.block + currentInstanceStartBlock]);\n                    }\n                    // Call the update accessor for the instance using the gathered arguments\n                    // TODO: This should be done with registers like vertex array buffer updates for Optimal\n                    // Performance. A method apply is very slow compared to the register way.\n                    updateAccessor.apply(null, updateArguments);\n                }\n                // Tell the uniform to update with the new dataset\n                instanceData.value = [].concat(buffer);\n            }\n            else {\n                console.warn('A uniform buffer update was specified on a material that lacks uniform buffer usage');\n                return false;\n            }\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n        }\n        return false;\n    };\n    /**\n     * This makes all of the typical items used in creating and managing a buffer of items rendered to the screen\n     *\n     * @returns {IBufferItems<T>} An empty object of the particular buffer items needed\n     */\n    BufferUtil.makeBufferItems = function () {\n        return {\n            attributes: [],\n            currentData: [],\n            geometry: null,\n            system: null,\n            uniformAttributes: [],\n            uniformBuffer: null,\n        };\n    };\n    return BufferUtil;\n}());\nexports.BufferUtil = BufferUtil;\nvar _a;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/buffer-util.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar buffer_util_1 = require(\"../util/buffer-util\");\n/**\n * This deinfes the minimal set of methods that should be implemented to create\n * a reusable buffer object that can be initialized and populated.\n */\nvar BaseBuffer = (function () {\n    function BaseBuffer() {\n    }\n    /**\n     * This disposes the resources associated with a buffer.\n     */\n    BaseBuffer.prototype.dispose = function () {\n        if (this.bufferItems) {\n            buffer_util_1.BufferUtil.dispose([this.bufferItems]);\n        }\n    };\n    /**\n     * This initializes the buffer and generates the buffer items object.\n     */\n    BaseBuffer.prototype.init = function (material, unitCount) {\n        // To be implemented by a subclass\n    };\n    /**\n     * This updates the buffer by providing the shape buffer needed to update\n     * the internal buffer items\n     *\n     * @param {T[]} shapeBuffer The shape buffer containing all of the shape data\n     *                          to be placed into the buffer.\n     *\n     * @return {boolean} Retrusn true if this pushed up any updates\n     */\n    BaseBuffer.prototype.update = function (shapeBuffer) {\n        // To be implemented by a subclass\n        return false;\n    };\n    return BaseBuffer;\n}());\nexports.BaseBuffer = BaseBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/base-buffer.ts\n// module id = 2\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ramda\"\n// module id = 3\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nvar Bounds = (function () {\n    /**\n     * Create a new instance\n     *\n     * @param left  The left side (x coordinate) of the instance\n     * @param right The right side of the instance\n     * @param top The top (y coordinate) of the instance\n     * @param bottom The bottom of the instance\n     */\n    function Bounds(left, right, top, bottom) {\n        this.height = 0;\n        this.width = 0;\n        this.x = 0;\n        this.y = 0;\n        if (arguments.length === 4) {\n            this.x = left;\n            this.width = right - left;\n            this.y = top;\n            this.height = top - bottom;\n        }\n    }\n    Object.defineProperty(Bounds.prototype, \"area\", {\n        /** The total rectangular surface area of this instance */\n        get: function () {\n            return this.width * this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"bottom\", {\n        /** The bottom coordinate for this instance (y + height) */\n        get: function () {\n            return this.y - this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"mid\", {\n        /** An x, y coordinate pair representing the center of this object */\n        get: function () {\n            return {\n                x: this.x + (this.width / 2),\n                y: this.y - (this.height / 2),\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"right\", {\n        get: function () {\n            return this.x + this.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Check to see if a given point lies within the bounds of this instance\n     *\n     * @param point The point to check\n     */\n    Bounds.prototype.containsPoint = function (point) {\n        if (point.x < this.x) {\n            return false;\n        }\n        if (point.y > this.y) {\n            return false;\n        }\n        if (point.x > this.right) {\n            return false;\n        }\n        if (point.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Copies the properties of the bounds specified\n     *\n     * @param b The bounds whose dimensions we wish to copy\n     */\n    Bounds.prototype.copyBounds = function (b) {\n        this.height = b.height;\n        this.width = b.width;\n        this.x = b.x;\n        this.y = b.y;\n    };\n    /**\n     * Ensure that this object contains the smaller bounds\n     *\n     * This method will not shrink this class, but only grow it as necessary to\n     * fit the destination object\n     *\n     * @param bounds The bounds to encapsulate\n     */\n    Bounds.prototype.encapsulate = function (bounds) {\n        if (bounds.x < this.x) {\n            this.width += this.x - bounds.x;\n            this.x = bounds.x;\n        }\n        if (bounds.y > this.y) {\n            this.height += bounds.y - this.y;\n            this.y = bounds.y;\n        }\n        if (bounds.right > this.right) {\n            this.width = bounds.right - this.x;\n        }\n        if (bounds.bottom < this.bottom) {\n            this.height = this.y - bounds.bottom;\n        }\n    };\n    /**\n     * Ensure that this object contains the provided list of bounds\n     *\n     * This will never shrink or modify the original area covered by this bounds\n     * but will instead stay the same or include the original area plus the specified\n     * list of bounds.\n     *\n     * @param {Bounds<any>[]} bounds The list of bounds objects to encapsulate\n     * @param {boolean} sizeToFirst If this is set, the procedure will start by making this bounds\n     *                              be a clone of the first bounds object in the list\n     */\n    Bounds.prototype.encapsulateBounds = function (bounds, sizeToFirst) {\n        if (sizeToFirst && bounds.length) {\n            this.copyBounds(bounds[0]);\n        }\n        if (bounds.length === 0) {\n            return;\n        }\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        bounds.forEach(function (p) {\n            if (p.x < minX) {\n                minX = p.x;\n            }\n            if (p.right > maxX) {\n                maxX = p.right;\n            }\n            if (p.bottom < minY) {\n                minY = p.bottom;\n            }\n            if (p.y > maxY) {\n                maxY = p.y;\n            }\n        });\n        // Make bounds that encompasses the bounds list, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Grow this class to contain the specified point\n     *\n     * This method will not shrink this instance. It will only grow it as\n     * necessary.\n     *\n     * @param point The point to encapsulate\n     */\n    Bounds.prototype.encapsulatePoint = function (point) {\n        if (point.x < this.x) {\n            this.width += this.x - point.x;\n            this.x = point.x;\n        }\n        if (point.y > this.y) {\n            this.height += point.y - this.y;\n            this.y = point.y;\n        }\n        if (point.x > this.right) {\n            this.width = point.x - this.x;\n        }\n        if (point.y < this.bottom) {\n            this.height = this.y - point.y;\n        }\n    };\n    /**\n     * Efficiently encapsulates a set of points by growing the current dimensions\n     * of the bounds until the points are enclosed. This will perform faster than\n     * running encapsulatePoint for a list of points.\n     *\n     * @param points An array of points that Can be of format {x, y} or [x, y]\n     *\n     * @memberOf Bounds\n     */\n    Bounds.prototype.encapsulatePoints = function (points) {\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        if (points[0] !== undefined && points[0].x) {\n            points.forEach(function (p) {\n                if (p.x < minX) {\n                    minX = p.x;\n                }\n                else if (p.x > maxX) {\n                    maxX = p.x;\n                }\n                if (p.y < minY) {\n                    minY = p.y;\n                }\n                else if (p.y > maxY) {\n                    maxY = p.y;\n                }\n            });\n        }\n        else {\n            points.forEach(function (p) {\n                if (p[0] < minX) {\n                    minX = p[0];\n                }\n                else if (p[0] > maxX) {\n                    maxX = p[0];\n                }\n                if (p[1] < minY) {\n                    minY = p[1];\n                }\n                else if (p[1] > maxY) {\n                    maxY = p[1];\n                }\n            });\n        }\n        // Make bounds that encompasses the points, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Checks to see if another bounds fits in itself.\n     *\n     * @param {Bounds} inner The bounds to test against\n     *\n     * @return {number} int 1 is an exact fit, 2 it fits with space, 0 it doesn't fit\n     */\n    Bounds.prototype.fits = function (inner) {\n        if (this.width === inner.width) {\n            if (this.height === inner.height) {\n                return 1;\n            }\n        }\n        if (this.width >= inner.width) {\n            if (this.height >= inner.height) {\n                return 2;\n            }\n        }\n        return 0;\n    };\n    /**\n     * Check to see if the provided bounds intersects with this instance\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if the other object intersects with this instance\n     */\n    Bounds.prototype.hitBounds = function (bounds) {\n        if (bounds.right < this.x) {\n            return false;\n        }\n        if (bounds.x > this.right) {\n            return false;\n        }\n        if (bounds.bottom > this.y) {\n            return false;\n        }\n        if (bounds.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Tests if a point is inside this bounds\n     *\n     * @param p The point to test\n     *\n     * @return boolean The point to test\n     */\n    Bounds.prototype.pointInside = function (p) {\n        if (p.x < this.x) {\n            return false;\n        }\n        if (p.y > this.y) {\n            return false;\n        }\n        if (p.x > this.right) {\n            return false;\n        }\n        if (p.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Test function to type check the provided value\n     *\n     * @return True if value is a bounds object\n     */\n    Bounds.isBounds = function (value) {\n        // Falsy values aren't bounds objects\n        if (!value) {\n            return false;\n        }\n        // Direct test for bounds objects\n        if (value instanceof this) {\n            return true;\n        }\n        // Duck-typing check\n        return value &&\n            'containsPoint' in value &&\n            'encapsulate' in value &&\n            'hitTest' in value;\n    };\n    /**\n     * Check if this instance is completely inside the provided bounds\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if this instance is inside the provided bounds\n     */\n    Bounds.prototype.isInside = function (bounds) {\n        return (bounds.x <= this.x &&\n            bounds.right >= this.right &&\n            bounds.y >= this.y &&\n            bounds.bottom <= this.bottom);\n    };\n    /**\n     * Generates a Bounds object covering max extents\n     *\n     * @return {Bounds} bounds covering as wide of a range as possible\n     */\n    Bounds.maxBounds = function () {\n        return new Bounds(Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE);\n    };\n    return Bounds;\n}());\nexports.Bounds = Bounds;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/bounds.ts\n// module id = 4\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/browser.js\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculates the distance between two points, but keeps the distance in dquared form\n * thus performing Math.sqrt() on the output of this distance would provide the true\n * distance between the points.\n *\n * It is often faster and all that is needed to compare squared distances vs real distances\n * thus eliminating multiple Math.sqrt operations\n *\n * NOTE: For vectors this is the same as (pseudo code):\n * let vector3 = vector2.subtract(vector1)\n * return vector3.dot(vector3)\n *\n * @param p1 The point to find the distance from the second point\n * @param p2 The point to find the distance from the first point\n *\n * @return {number} The distance * distance between the two points\n */\nfunction squareDistance(p1, p2) {\n    var dx = p1.x - p2.x;\n    var dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n}\n/**\n * Contains methods for managing or manipulating points\n *\n * @export\n * @class Point\n */\nvar Point = (function () {\n    function Point() {\n    }\n    /**\n     * Adds two points together\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @return {IPoint} The two points added together\n     */\n    Point.add = function (p1, p2, out) {\n        if (out) {\n            out.x = p1.x + p2.x;\n            out.y = p1.y + p2.y;\n            return out;\n        }\n        return {\n            x: p1.x + p2.x,\n            y: p1.y + p2.y,\n        };\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {IPoint} The closest point to the test point\n     */\n    Point.getClosest = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = null;\n        var distance;\n        var findClosest = function (point) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = point;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * This just returns the index of the found point and not the point itself\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {number} The index of the closest point to the test point\n     */\n    Point.getClosestIndex = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = 0;\n        var distance;\n        var findClosest = function (point, i) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = i;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This will calculate a direction vector between two points that points toward p2\n     *\n     * @param {IPoint} p1 The start of the direction\n     * @param {IPoint} p2 The direction to point the vector towards\n     * @param {boolean} normalize If true, this will make the vector have a magnitude of 1\n     *\n     * @returns {number}\n     */\n    Point.getDirection = function (p1, p2, normalize) {\n        if (normalize === void 0) { normalize = false; }\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        if (normalize) {\n            var magnitude = Math.sqrt(dx * dx + dy * dy);\n            dx /= magnitude;\n            dy /= magnitude;\n        }\n        return {\n            x: dx,\n            y: dy,\n        };\n    };\n    /**\n     * @static\n     * Gets the distance between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {boolean} squared If set to true, returns the distance * distance (performs faster)\n     *\n     * @returns {number} The real distance between two points\n     */\n    Point.getDistance = function (p1, p2, squared) {\n        if (squared === void 0) { squared = false; }\n        if (squared) {\n            return squareDistance(p1, p2);\n        }\n        return Math.sqrt(squareDistance(p1, p2));\n    };\n    /**\n     * @static\n     * Gets a point perfectly between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     *\n     * @returns {IPoint} The point between the two provided points\n     */\n    Point.getMidpoint = function (p1, p2) {\n        var direction = Point.getDirection(p1, p2);\n        return {\n            x: direction.x / 2 + p1.x,\n            y: direction.y / 2 + p1.y,\n        };\n    };\n    Point.make = function (x, y) {\n        return { x: x, y: y };\n    };\n    /**\n     * Scales a point by a given amount\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {number} s The amount to scale the point by\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @memberof Point\n     */\n    Point.scale = function (p1, s, out) {\n        if (out) {\n            out.x = p1.x * s;\n            out.y = p1.y * s;\n            return out;\n        }\n        return {\n            x: p1.x * s,\n            y: p1.y * s,\n        };\n    };\n    /**\n     * Makes a new point initialized to {0,0}\n     *\n     * @static\n     * @returns {IPoint} A new point object at {0,0}\n     */\n    Point.zero = function () {\n        return {\n            x: 0,\n            y: 0,\n        };\n    };\n    return Point;\n}());\nexports.Point = Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/point.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"./bounds\");\n/**\n * Represents a line with a given slope\n */\nvar Line = (function (_super) {\n    __extends(Line, _super);\n    /**\n     * Creates a new line that passes through the two specified points\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    function Line(p1, p2) {\n        var _this = _super.call(this, 0, 1, 1, 0) || this;\n        _this.setPoints(p1, p2);\n        return _this;\n    }\n    /**\n     * This calculates the distance to a point from the provided line\n     * BUT this ALSO retains the directionality of that distance. So one side of\n     * the line will be positive while the other negative\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.directionTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line, but we won't take the absolute to retain the direction\n        return this.perpendicular.x * vector.x + this.perpendicular.y * vector.y;\n    };\n    /**\n     * This calculates the distance to a point from the provided line\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.distanceTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line\n        return Math.abs(this.perpendicular.x * vector.x +\n            this.perpendicular.y * vector.y);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {Array} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    Line.getClosest = function (lines, p) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(p);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This sets the two endpoints for this line and recalculates the bounds\n     * of the line accordingly\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    Line.prototype.setPoints = function (p1, p2) {\n        this.x = p1.x - 1;\n        this.y = p1.y - 1;\n        this.width = 2;\n        this.height = 2;\n        this.encapsulatePoint(p2);\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        this.slope = dy / dx;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.magnitude = Math.sqrt(dx * dx + dy * dy);\n        this.perpendicular = {\n            x: this.p2.y - this.p1.y,\n            y: -(this.p2.x - this.p1.x),\n        };\n        // Normalize the perpendicular line\n        var mag = Math.sqrt(this.perpendicular.x * this.perpendicular.x +\n            this.perpendicular.y * this.perpendicular.y);\n        this.perpendicular.x /= mag;\n        this.perpendicular.y /= mag;\n    };\n    return Line;\n}(bounds_1.Bounds));\nexports.Line = Line;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/line.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_1 = require(\"../primitives/point\");\nvar easing_1 = require(\"./easing\");\n/**\n * This enum is just a common way to define interpolation types\n */\nvar InterpolationMethod;\n(function (InterpolationMethod) {\n    InterpolationMethod[InterpolationMethod[\"BEZIER2\"] = 0] = \"BEZIER2\";\n    InterpolationMethod[InterpolationMethod[\"BEZIER3\"] = 1] = \"BEZIER3\";\n    InterpolationMethod[InterpolationMethod[\"CIRCULAR\"] = 2] = \"CIRCULAR\";\n})(InterpolationMethod = exports.InterpolationMethod || (exports.InterpolationMethod = {}));\n/**\n * This calculates a quadratic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier2(t, p1, p2, c1) {\n    var t2 = t * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    return {\n        x: p1.x * mt2 + c1.x * 2 * mt * t + p2.x * t2,\n        y: p1.y * mt2 + c1.y * 2 * mt * t + p2.y * t2,\n    };\n}\nexports.bezier2 = bezier2;\n/**\n * This calculates a cubic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The first control point of the curve\n * @param {IPoint} c2 The second control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier3(t, p1, p2, c1, c2) {\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    var mt3 = mt2 * mt;\n    return {\n        x: p1.x * mt3 + 3 * c1.x * mt2 * t + 3 * c2.x * mt * t2 + p2.x * t3,\n        y: p1.y * mt3 + 3 * c1.y * mt2 * t + 3 * c2.y * mt * t2 + p2.y * t3,\n    };\n}\nexports.bezier3 = bezier3;\n/**\n * This calculates a point along a path defined as a circular path which is a\n * path moving along the edge of a circle from one point to the next. This will\n * even allow for moving along a circle with a growing radius.\n *\n * @param {number} t The 0 - 1 time interval for the part of the path we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point, or more importantly, the center of the circle\n * @param {EasingMethod} radiusEasing Default easing for the radius growing is linear.\n *                                    Insert a custom easing method to change this.\n *\n * @returns {IPoint}\n */\nfunction circular(t, p1, p2, c1, radiusEasing) {\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(c1, p1);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(c1, p2);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Ensure our theta's are definitely between 0 to Math.PI * 2 after the atan\n    // Calculation\n    if (theta1 < 0)\n        theta1 += Math.PI * 2;\n    if (theta2 < 0)\n        theta2 += Math.PI * 2;\n    var dTheta = theta2 - theta1;\n    // We ALWAYS want our path to be the shortest around the circle\n    if (dTheta > Math.PI) {\n        dTheta = theta1 - theta2;\n    }\n    // We use this to calculate how far we are between the two points in radians\n    // Based on the time parameter provided for the interpolation\n    dTheta *= t;\n    // We must have the radial distance of both points to properly calculate\n    // An easing between the two radii\n    var radius1 = point_1.Point.getDistance(p1, c1);\n    var radius2 = point_1.Point.getDistance(p2, c1);\n    // We control how the radius eases out for the path, which is determined by\n    // The easing method, otherwise, it just linearly radiates out\n    var radius = (radiusEasing || easing_1.linear)(t, radius1, radius2 - radius1, 1.0);\n    return {\n        x: Math.cos(theta1 + dTheta) * radius + c1.x,\n        y: Math.sin(theta1 + dTheta) * radius + c1.y,\n    };\n}\nexports.circular = circular;\nexports.pickInterpolation = (_a = {},\n    _a[InterpolationMethod.BEZIER2] = bezier2,\n    _a[InterpolationMethod.BEZIER3] = bezier3,\n    _a[InterpolationMethod.CIRCULAR] = circular,\n    _a);\nvar _a;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/interpolation.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar curved_line_1 = require(\"../../primitives/curved-line\");\nvar line_1 = require(\"../../primitives/line\");\nvar point_1 = require(\"../../primitives/point\");\n/**\n * This gets the radian of line from center to point\n *\n * @param point\n * @param center\n */\nfunction getAngle(point, center) {\n    if (point.x > center.x) {\n        return Math.atan((point.y - center.y) / (point.x - center.x));\n    }\n    else if (point.x === center.x) {\n        if (point.y > center.y)\n            return Math.PI / 2;\n        else\n            return -Math.PI / 2;\n    }\n    else {\n        if (point.y >= center.y) {\n            return Math.PI + Math.atan((point.y - center.y) / (point.x - center.x));\n        }\n        else {\n            return Math.atan((point.y - center.y) / (point.x - center.x)) - Math.PI;\n        }\n    }\n}\n/**\n * This defines a drawable curved line shape. It contains the information necessary\n * to efficiently render the line.\n *\n * @export\n * @class CurvedLineShape\n * @extends {CurvedLine<T>}\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\n *             with the shape easier.\n */\nvar CurvedLineShape = (function (_super) {\n    __extends(CurvedLineShape, _super);\n    /**\n     * Creates an instance of CurvedLineShape.\n     *\n     * @param {ICurvedLineShapeOptions} options The options for creating this line\n     */\n    function CurvedLineShape(options) {\n        var _this = \n        // We pass our properties to the curve line but we do not let it cache it's version of the line segments\n        // As we will be constructing our own segmentation requiring a new type of cache\n        _super.call(this, options) || this;\n        /** Depeth of draw location */\n        _this.depth = 0;\n        /** How thick the line should be */\n        _this.lineWidth = 1;\n        _this.cachesQuadSegments = options.cacheSegments;\n        _this.depth = options.depth || 0;\n        _this.lineWidth = options.lineWidth || 1;\n        _this.encapsulatePoints(_this.getTriangleStrip());\n        _this.startColor = options.startColor;\n        _this.endColor = options.endColor;\n        _this.marchingAnts = options.marchingAnts;\n        return _this;\n    }\n    /**\n     * Returns a new instance of this object that mimicks the properties of this Object\n     *\n     * @returns {CurvedLineShape<T>} The cloned object\n     */\n    CurvedLineShape.prototype.clone = function () {\n        // Perform the clone\n        var clone = new CurvedLineShape({\n            cacheSegments: this.cachesSegments,\n            controlPoints: this.controlPoints,\n            end: this.end,\n            endColor: this.endColor,\n            lineWidth: this.lineWidth,\n            resolution: this.resolution,\n            start: this.start,\n            startColor: this.startColor,\n            type: this.type,\n        });\n        clone.d = this.d;\n        return clone;\n    };\n    /**\n     * @override\n     * See base definition\n     */\n    CurvedLineShape.prototype.distanceTo = function (point) {\n        return Math.max(0, _super.prototype.distanceTo.call(this, point) - (this.lineWidth / 2.0));\n    };\n    /**\n     * This produces a triangle strip that represents the quads that composes this line. If caching is present,\n     * subsequent calls to this method will be much faster unless the cache gets invalidated.\n     *\n     * @return {IPoint[]} The Triangle Strip of points to create the quads that make each segment of the curve\n     */\n    CurvedLineShape.prototype.getTriangleStrip = function () {\n        if (this.cachesSegments && this.cachedQuadSegments) {\n            return this.cachedQuadSegments;\n        }\n        // Make a container to hold our triangle strip info\n        var strip = [];\n        var normal = [];\n        // Start with calculating the line strip so we can use the line segments\n        // To produce the quads we need to render\n        var lineStrip = this.getLineStrip();\n        var lineWidthHalf = this.lineWidth / 2.0;\n        var line = new line_1.Line(point_1.Point.zero(), point_1.Point.zero());\n        // We make a container point for the scaling operation to reduce allocations\n        var scaledPoint = point_1.Point.zero();\n        // If the line strip is empty, then there is nothing to produce and makes\n        // Us unable to reduce the lineStrip, so return empty here\n        if (lineStrip.length < 2) {\n            return [];\n        }\n        // Calculate bisecting normal or each node\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            line.setPoints(lineStrip[i], lineStrip[i + 1]);\n            if (normal.length === 0) {\n                normal.push(line.perpendicular);\n            }\n            else {\n                // Sum of two normals of a point\n                var temp = {\n                    x: normal[i].x + line.perpendicular.x,\n                    y: normal[i].y + line.perpendicular.y,\n                };\n                // Normalize the sum of two normals\n                var sqrt = Math.sqrt(temp.x * temp.x + temp.y * temp.y);\n                temp.x = temp.x / sqrt;\n                temp.y = temp.y / sqrt;\n                normal[i] = temp;\n            }\n            normal.push(line.perpendicular);\n        }\n        // Use the new normals to generate quads\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            var previous = lineStrip[i];\n            var current = lineStrip[i + 1];\n            // TR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], -lineWidthHalf, scaledPoint), current));\n            // BR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], lineWidthHalf, scaledPoint), current));\n            // TL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], -lineWidthHalf, scaledPoint), previous));\n            // BL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], lineWidthHalf, scaledPoint), previous));\n        }\n        return strip;\n    };\n    /**\n     * @override\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     */\n    CurvedLineShape.prototype.setPoints = function (start, end, controlPoints) {\n        _super.prototype.setPoints.call(this, start, end, controlPoints);\n        this.cachedQuadSegments = [];\n    };\n    CurvedLineShape.prototype.containsPoint = function (point) {\n        if (this.type === curved_line_1.CurveType.CircularCW || this.type === curved_line_1.CurveType.CircularCCW) {\n            // Center\n            var center = this.controlPoints[1];\n            // Radius' suare value\n            var radiusSquare = Math.pow(this.start.x - center.x, 2) + Math.pow(this.start.y - center.y, 2);\n            // It is used to calculate squared value of (radius + lineWidth / 2)\n            var radius = Math.sqrt(radiusSquare);\n            // Distance'square value from mouse to center\n            var distanceSquare = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2);\n            // Linewidth's square value\n            var lineWidthSquare = this.lineWidth * this.lineWidth;\n            // Angles\n            var angle = getAngle(point, center);\n            var startAngle = getAngle(this.start, center);\n            var endAngle = getAngle(this.end, center);\n            if (startAngle > 0 && endAngle < 0) {\n                if (angle < 0)\n                    angle += 2 * Math.PI;\n                endAngle += 2 * Math.PI;\n            }\n            // Make sure point is in the endpoint\n            if (distanceSquare <= radiusSquare + this.lineWidth * radius + lineWidthSquare / 4\n                && distanceSquare >= radiusSquare - this.lineWidth * radius + lineWidthSquare / 4\n                && angle >= startAngle\n                && angle <= endAngle) {\n                return true;\n            }\n            return false;\n        }\n        else if (this.type === curved_line_1.CurveType.Bezier) {\n            return _super.prototype.containsPoint.call(this, point);\n        }\n        return false;\n    };\n    return CurvedLineShape;\n}(curved_line_1.CurvedLine));\nexports.CurvedLineShape = CurvedLineShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/curved-line-shape.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines a texture that is located on an atlas\n */\nvar AtlasTexture = (function () {\n    /**\n     * Generates a new atlas texture that points to a specific image resource.\n     *\n     * @param path The path to the image resource to be loaded into the atlas.\n     */\n    function AtlasTexture(path, label) {\n        /** Stores the aspect ratio of the image for quick reference */\n        this.aspectRatio = 1.0;\n        this.imagePath = path;\n        this.label = label;\n        // Let the label keep track of it's rasterization\n        if (label) {\n            this.label.rasterizedLabel = this;\n        }\n    }\n    return AtlasTexture;\n}());\nexports.AtlasTexture = AtlasTexture;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-texture.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FrameInfo = (function () {\n    function FrameInfo() {\n    }\n    /** Contains the time the previous frame started */\n    FrameInfo.lastFrameTime = Date.now();\n    /** Contains a theoretical approximation the next frame will start */\n    FrameInfo.nextFrameTime = Date.now();\n    /** Contains how many frames have been played for a given WebGLSurface context */\n    FrameInfo.framesPlayed = new Map();\n    return FrameInfo;\n}());\nexports.FrameInfo = FrameInfo;\n/**\n * This gets an integer time value that can fit within an attribute. Be aware,\n * this only supports up to 7 digits of the millisecond time.\n */\nfunction getAttributeCurrentTime() {\n    var time = FrameInfo.lastFrameTime / 1E7;\n    return Math.floor((time - Math.floor(time)) * 1E7);\n}\nexports.getAttributeCurrentTime = getAttributeCurrentTime;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/frame-info.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProgramInfo(gl, program) {\n    var result = {\n        attributeCount: 0,\n        attributes: new Array(),\n        uniformCount: 0,\n        uniforms: new Array(),\n    }, activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    // Taken from the WebGl spec:\n    // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n    var enums = {\n        0x8B50: 'FLOAT_VEC2',\n        0x8B51: 'FLOAT_VEC3',\n        0x8B52: 'FLOAT_VEC4',\n        0x8B53: 'INT_VEC2',\n        0x8B54: 'INT_VEC3',\n        0x8B55: 'INT_VEC4',\n        0x8B56: 'BOOL',\n        0x8B57: 'BOOL_VEC2',\n        0x8B58: 'BOOL_VEC3',\n        0x8B59: 'BOOL_VEC4',\n        0x8B5A: 'FLOAT_MAT2',\n        0x8B5B: 'FLOAT_MAT3',\n        0x8B5C: 'FLOAT_MAT4',\n        0x8B5E: 'SAMPLER_2D',\n        0x8B60: 'SAMPLER_CUBE',\n        0x1400: 'BYTE',\n        0x1401: 'UNSIGNED_BYTE',\n        0x1402: 'SHORT',\n        0x1403: 'UNSIGNED_SHORT',\n        0x1404: 'INT',\n        0x1405: 'UNSIGNED_INT',\n        0x1406: 'FLOAT',\n    };\n    var blocks = {\n        0x8B50: 1,\n        0x8B51: 1,\n        0x8B52: 1,\n        0x8B53: 1,\n        0x8B54: 1,\n        0x8B55: 1,\n        0x8B56: 1,\n        0x8B57: 1,\n        0x8B58: 1,\n        0x8B59: 1,\n        0x8B5A: 1,\n        0x8B5B: 3,\n        0x8B5C: 4,\n        0x8B5E: 1,\n        0x8B60: 1,\n        0x1400: 1,\n        0x1401: 1,\n        0x1402: 1,\n        0x1403: 1,\n        0x1404: 1,\n        0x1405: 1,\n        0x1406: 1,\n    };\n    // Loop through active uniforms\n    for (var i = 0; i < activeUniforms; ++i) {\n        var uniform = gl.getActiveUniform(program, i);\n        uniform.typeName = enums[uniform.type];\n        result.uniforms.push(uniform);\n        result.uniformCount += uniform.size;\n        uniform.size = uniform.size * blocks[uniform.type];\n    }\n    // Loop through active attributes\n    for (var i = 0; i < activeAttributes; i++) {\n        var attribute = gl.getActiveAttrib(program, i);\n        attribute.typeName = enums[attribute.type];\n        result.attributes.push(attribute);\n        result.attributeCount += attribute.size;\n    }\n    return result;\n}\nvar WebGLStat = (function () {\n    function WebGLStat() {\n    }\n    WebGLStat.printCurrentProgramInfo = function (debug, surface) {\n        if (surface.gl) {\n            var info = getProgramInfo(surface.gl, surface.gl.getParameter(surface.gl.CURRENT_PROGRAM));\n            var table = window.table;\n            if (table) {\n                table(info.uniforms);\n            }\n        }\n        else {\n            debug('Attempted to printProgramInfo but the surface has not established its gl context yet');\n        }\n    };\n    WebGLStat.MAX_VERTEX_UNIFORMS = 0;\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = 0;\n    WebGLStat.MAX_ATTRIBUTES = 0;\n    WebGLStat.WEBGL_SUPPORTED = false;\n    // TODO: This remains static until we have a qay to inject variable parameters into the shader\n    //       Strings. 128 is the guaranteed saftey range for uniform sizes for WebGL. We could have\n    //       Significantly higher numbers on most devices if we have dynamic field replacement for\n    //       Shaders.\n    WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    return WebGLStat;\n}());\nexports.WebGLStat = WebGLStat;\nfunction initStats() {\n    // Let's perform some immediate operations to do some gl querying for useful information\n    function getAContext() {\n        try {\n            var canvas = document.createElement('canvas');\n            return window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    // Attempt to retrieve a context for webgl\n    var gl = getAContext();\n    // If the context exists, then we know gl is supported and we can fill in some metrics\n    if (gl) {\n        WebGLStat.WEBGL_SUPPORTED = true;\n        WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        WebGLStat.MAX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n        // TODO: See TODO at declaration\n        WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    }\n}\ninitStats();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/webgl-stat.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Does a linear easing of a value\n *\n * @param {number} t The time elapsed: 0 to d\n * @param {number} s The start value\n * @param {number} c The change in value\n * @param {number} d The duration of the change\n *\n * @returns A number linearly progressing from s to s+c depending on the value of\n *          t in relation to d\n */\nfunction linear(t, s, c, d) {\n    return c * t / d + s;\n}\nexports.linear = linear;\nfunction easeInQuad(t, b, c, d) {\n    return c * (t /= d) * t + b;\n}\nexports.easeInQuad = easeInQuad;\nfunction easeOutQuad(t, b, c, d) {\n    return -c * (t /= d) * (t - 2) + b;\n}\nexports.easeOutQuad = easeOutQuad;\nfunction easeInOutQuad(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t + b;\n    return -c / 2 * ((--t) * (t - 2) - 1) + b;\n}\nexports.easeInOutQuad = easeInOutQuad;\nfunction easeInCubic(t, b, c, d) {\n    return c * (t /= d) * t * t + b;\n}\nexports.easeInCubic = easeInCubic;\nfunction easeOutCubic(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t + 1) + b;\n}\nexports.easeOutCubic = easeOutCubic;\nfunction easeInOutCubic(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t + 2) + b;\n}\nexports.easeInOutCubic = easeInOutCubic;\nfunction easeInQuart(t, b, c, d) {\n    return c * (t /= d) * t * t * t + b;\n}\nexports.easeInQuart = easeInQuart;\nfunction easeOutQuart(t, b, c, d) {\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n}\nexports.easeOutQuart = easeOutQuart;\nfunction easeInOutQuart(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t + b;\n    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n}\nexports.easeInOutQuart = easeInOutQuart;\nfunction easeInQuint(t, b, c, d) {\n    return c * (t /= d) * t * t * t * t + b;\n}\nexports.easeInQuint = easeInQuint;\nfunction easeOutQuint(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n}\nexports.easeOutQuint = easeOutQuint;\nfunction easeInOutQuint(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n}\nexports.easeInOutQuint = easeInOutQuint;\nfunction easeInSine(t, b, c, d) {\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n}\nexports.easeInSine = easeInSine;\nfunction easeOutSine(t, b, c, d) {\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\n}\nexports.easeOutSine = easeOutSine;\nfunction easeInOutSine(t, b, c, d) {\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n}\nexports.easeInOutSine = easeInOutSine;\nfunction easeInExpo(t, b, c, d) {\n    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n}\nexports.easeInExpo = easeInExpo;\nfunction easeOutExpo(t, b, c, d) {\n    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n}\nexports.easeOutExpo = easeOutExpo;\nfunction easeInOutExpo(t, b, c, d) {\n    if (t === 0)\n        return b;\n    if (t === d)\n        return b + c;\n    if ((t /= d / 2) < 1)\n        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n}\nexports.easeInOutExpo = easeInOutExpo;\nfunction easeInCirc(t, b, c, d) {\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n}\nexports.easeInCirc = easeInCirc;\nfunction easeOutCirc(t, b, c, d) {\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n}\nexports.easeOutCirc = easeOutCirc;\nfunction easeInOutCirc(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n}\nexports.easeInOutCirc = easeInOutCirc;\nfunction easeInElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n}\nexports.easeInElastic = easeInElastic;\nfunction easeOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n}\nexports.easeOutElastic = easeOutElastic;\nfunction easeInOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d / 2) === 2)\n        return b + c;\n    if (!p)\n        p = d * (.3 * 1.5);\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    if (t < 1)\n        return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n}\nexports.easeInOutElastic = easeInOutElastic;\nfunction easeInBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\n}\nexports.easeInBack = easeInBack;\nfunction easeOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n}\nexports.easeOutBack = easeOutBack;\nfunction easeInOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    if ((t /= d / 2) < 1)\n        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n}\nexports.easeInOutBack = easeInOutBack;\nfunction easeInBounce(t, b, c, d) {\n    return c - easeOutBounce(d - t, 0, c, d) + b;\n}\nexports.easeInBounce = easeInBounce;\nfunction easeOutBounce(t, b, c, d) {\n    if ((t /= d) < (1 / 2.75)) {\n        return c * (7.5625 * t * t) + b;\n    }\n    else if (t < (2 / 2.75)) {\n        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n    }\n    else if (t < (2.5 / 2.75)) {\n        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n    }\n    else {\n        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n    }\n}\nexports.easeOutBounce = easeOutBounce;\nfunction easeInOutBounce(t, b, c, d) {\n    if (t < d / 2)\n        return easeInBounce(t * 2, 0, c, d) * .5 + b;\n    return easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n}\nexports.easeInOutBounce = easeInOutBounce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/easing.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar d3_color_1 = require(\"d3-color\");\nvar three_1 = require(\"three\");\nvar bounds_1 = require(\"../../primitives/bounds\");\nvar pack_node_1 = require(\"../../util/pack-node\");\nvar label_1 = require(\"../shape/label\");\nvar atlas_texture_1 = require(\"./atlas-texture\");\nvar debug = require('debug')('webgl-surface:Atlas');\nvar debugLabels = require('debug')('webgl-surface:Labels');\nvar ZERO_IMAGE = {\n    atlasBL: { x: 0, y: 0 },\n    atlasBR: { x: 0, y: 0 },\n    atlasTL: { x: 0, y: 0 },\n    atlasTR: { x: 0, y: 0 },\n    label: new label_1.Label({ text: ' ' }),\n    pixelHeight: 0,\n    pixelWidth: 0,\n};\n/**\n * Defines a manager of atlas', which includes generating the atlas and producing\n * textures defining those pieces of atlas.\n */\nvar AtlasManager = (function () {\n    /**\n     * Generates a new manager for atlas'. This will create and destroy atlas' and\n     * ensure they have the correct settings applied. A manager will also aid in\n     * packing images into the atlas indicated.\n     *\n     * @param {number} width The width of all atlas' generated\n     * @param {number} height The height of all atlas' generated\n     */\n    function AtlasManager(width, height) {\n        /** Gives a reference of all of the images loaded for the atlas */\n        this.atlasImages = {};\n        /** Stores the current mapping of the atlas */\n        this.atlasMap = {};\n        /** Stores all of the textures that are our atlases */\n        this.atlasTexture = {};\n        this.textureWidth = width;\n        this.textureHeight = height;\n    }\n    /**\n     * Atlas' must be created from scratch to update them. In order to properly\n     * update an existing one, you must destroy it then recreate it again.\n     * This is from not knowing how to update a texture via three js.\n     *\n     * @param atlasName The unique name of the atlas so it can be retrieved/referenced easily\n     * @param images The images with their image path set to be loaded into the atlas.\n     *               Images that keep an atlas ID of null indicates the image did not load\n     *               correctly\n     *\n     * @return {Texture} The Threejs texture that is created as our atlas. The images injected\n     *                   into the texture will be populated with the atlas'\n     */\n    AtlasManager.prototype.createAtlas = function (atlasName, images, colors) {\n        return __awaiter(this, void 0, void 0, function () {\n            var atlasMap, canvas, _i, images_1, image, image, texture, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        atlasMap = new pack_node_1.PackNode(0, 0, this.textureWidth, this.textureHeight);\n                        // Create the mapping element for the new atlas so we can track insertions / deletions\n                        this.atlasMap[atlasName] = atlasMap;\n                        // Make a listing of images that is within the atlas\n                        this.atlasImages[atlasName] = [];\n                        canvas = document.createElement('canvas').getContext('2d');\n                        // Size the canvas to the atlas size\n                        canvas.canvas.width = this.textureWidth;\n                        canvas.canvas.height = this.textureHeight;\n                        if (!images) return [3 /*break*/, 4];\n                        _i = 0, images_1 = images;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < images_1.length)) return [3 /*break*/, 4];\n                        image = images_1[_i];\n                        return [4 /*yield*/, this.draw(image, atlasName, canvas)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (!colors) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.drawColors(colors, atlasName, canvas)];\n                    case 5:\n                        image = _b.sent();\n                        // Add the dummy texture info as an image to our list of images\n                        if (image) {\n                            this.atlasImages[atlasName].push(image);\n                        }\n                        _b.label = 6;\n                    case 6:\n                        texture = new three_1.Texture(canvas.canvas);\n                        texture.premultiplyAlpha = true;\n                        texture.generateMipmaps = true;\n                        // Store the texture as the atlas.\n                        this.atlasTexture[atlasName] = texture;\n                        // Store the images as images within the atlas\n                        if (images) {\n                            (_a = this.atlasImages[atlasName]).push.apply(_a, images);\n                        }\n                        debug('Atlas Created-> texture: %o mapping: %o images: %o', texture, atlasMap, images);\n                        return [2 /*return*/, texture];\n                }\n            });\n        });\n    };\n    /**\n     * Disposes of the resources the atlas held and makes the atlas invalid for use\n     *\n     * @param atlasName\n     */\n    AtlasManager.prototype.destroyAtlas = function (atlasName) {\n        if (this.atlasTexture[atlasName]) {\n            this.atlasTexture[atlasName].dispose();\n            this.atlasTexture[atlasName] = null;\n        }\n        if (this.atlasMap[atlasName]) {\n            this.atlasMap[atlasName].destroy();\n            this.atlasMap[atlasName] = null;\n        }\n        if (this.atlasImages[atlasName]) {\n            var none_1 = { x: 0, y: 0 };\n            this.atlasImages[atlasName].forEach(function (image) {\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                image.pixelHeight = 0;\n                image.atlasBL = none_1;\n                image.atlasBR = none_1;\n                image.atlasTL = none_1;\n                image.atlasTR = none_1;\n            });\n            this.atlasImages[atlasName] = null;\n        }\n    };\n    AtlasManager.prototype.isValidImage = function (image) {\n        var isValid = false;\n        if (image && (image.imagePath || (image.label && image.label.text))) {\n            if (image.pixelWidth && image.pixelHeight) {\n                isValid = true;\n            }\n        }\n        return isValid;\n    };\n    AtlasManager.prototype.setDefaultImage = function (image, atlasName) {\n        image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n        return image;\n    };\n    /**\n     * This loads, packs, and draws the indicated image into the specified canvas\n     * using the metrics that exists for the specified atlas.\n     *\n     * @param image The image who should have it's image path loaded\n     * @param atlasName The name of the atlas to make the packing work\n     * @param canvas The canvas we will be drawing into to generate the complete image\n     *\n     * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\n     */\n    AtlasManager.prototype.draw = function (image, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var loadedImage, rect, dimensions, node, insertedNode, ux, uy, uw, uh, atlasDimensions;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Validate the index\n                        if (!this.atlasMap[atlasName]) {\n                            debug('Can not load image, invalid Atlas Name: %o for atlasMaps: %o', atlasName, this.atlasMap);\n                            return [2 /*return*/, false];\n                        }\n                        return [4 /*yield*/, this.loadImage(image)];\n                    case 1:\n                        loadedImage = _a.sent();\n                        // Make sure at this point the image knows it is not affiliated with an atlas\n                        // If something goes wrong with loading or insertting this image, then a null\n                        // Atlas value will indicate the image can not be used appropriately\n                        image.atlasReferenceID = null;\n                        // Only a non-null image means the image loaded correctly\n                        if (loadedImage && this.isValidImage(image)) {\n                            debug('Image loaded: %o', image.imagePath);\n                            rect = new bounds_1.Bounds(0, image.pixelWidth, image.pixelHeight, 0);\n                            dimensions = {\n                                first: image,\n                                second: rect,\n                            };\n                            // Auto add a buffer in\n                            dimensions.second.width += 1;\n                            dimensions.second.height += 1;\n                            node = this.atlasMap[atlasName];\n                            insertedNode = node.insert(dimensions);\n                            // If the result was NULL we did not successfully insert the image into any map\n                            if (insertedNode) {\n                                debug('Atlas location determined: %o', insertedNode);\n                                if (image.label) {\n                                    debugLabels('Atlas location determined. PackNode: %o Dimensions: %o', insertedNode, dimensions);\n                                }\n                                // Apply the image to the node\n                                insertedNode.nodeImage = image;\n                                ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                                uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                                uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                                uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                                atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                                image.atlasReferenceID = atlasName;\n                                image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                                image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                                // Now draw the image to the indicated canvas\n                                canvas.drawImage(loadedImage, insertedNode.nodeDimensions.x, insertedNode.nodeDimensions.y);\n                                // We have finished inserting\n                                return [2 /*return*/, true];\n                            }\n                            else {\n                                // Log an error\n                                console.error(\"Could not fit image into atlas \" + image.imagePath);\n                                image = this.setDefaultImage(image, atlasName);\n                                return [2 /*return*/, false];\n                            }\n                        }\n                        else {\n                            // Log an error and load a default image\n                            console.error(\"Could not load image \" + image.imagePath);\n                            image = this.setDefaultImage(image, atlasName);\n                            return [2 /*return*/, false];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This renders a list of colors to the canvas. This using the same packing\n     * algorithm as any image so the rendering is placed correctly or determines\n     * if enough space is not available.\n     *\n     * @param {AtlasColor[]} colors The list of colors to be rendered to the atlas\n     * @param {string} atlasName The name of the atlas being rendered to\n     * @param {CanvasRenderingContext2D} canvas The canvas of the atlas being rendered to\n     *\n     * @returns {Promise<boolean>} Resolves to true if the operation was successful\n     */\n    AtlasManager.prototype.drawColors = function (colors, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var colorWidth, colorHeight, maxPerRow, rowWidth, rowCount, colCount, renderHeight, dimensions, node, insertedNode, image, ux, uy, uw, uh, atlasDimensions, renderSpace, startX, startY, nextX, nextY, beginX, beginY, col, row, _i, colors_1, color, _a, r, g, b;\n            return __generator(this, function (_b) {\n                debug('Finding space for colors on the atlas: %o', colors);\n                colorWidth = 2;\n                colorHeight = 2;\n                maxPerRow = 1024 / colorWidth;\n                rowWidth = Math.min(this.textureWidth, maxPerRow * colorWidth);\n                rowCount = Math.ceil((colors.length * colorWidth) / rowWidth);\n                colCount = Math.ceil(rowWidth / colorWidth);\n                renderHeight = rowCount * colorHeight;\n                dimensions = {\n                    // Since the algorithm requires something to fill this slot, just make a\n                    // Dummy object\n                    first: new atlas_texture_1.AtlasTexture(null, null),\n                    // Set the dimensions we calculated for the space our colors will take up\n                    // Within the atlas\n                    second: new bounds_1.Bounds(0, rowWidth, renderHeight, 0),\n                };\n                // Auto add a buffer in\n                dimensions.second.width += 1;\n                dimensions.second.height += 1;\n                node = this.atlasMap[atlasName];\n                insertedNode = node.insert(dimensions);\n                // If the result was NULL we did not successfully insert the image into any map\n                if (insertedNode) {\n                    debug('Atlas location determined for colors: %o', insertedNode);\n                    image = insertedNode.nodeImage = dimensions.first;\n                    ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                    uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                    uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                    uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                    atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                    image.atlasReferenceID = atlasName;\n                    image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                    image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                    renderSpace = insertedNode.nodeDimensions;\n                    startX = renderSpace.x;\n                    startY = renderSpace.y;\n                    nextX = colorWidth / this.textureWidth;\n                    nextY = -colorHeight / this.textureHeight;\n                    beginX = (startX / this.textureWidth) + (nextX / 2.0);\n                    beginY = 1.0 - (startY / this.textureHeight) + (nextY / 2.0);\n                    col = 0;\n                    row = 0;\n                    // Loop through each color, establish metrics, draw to the atlas\n                    for (_i = 0, colors_1 = colors; _i < colors_1.length; _i++) {\n                        color = colors_1[_i];\n                        // Staore the info needed to make the color referenceable again\n                        color.atlasReferenceID = atlasName;\n                        color.colorIndex = col + (row * colCount);\n                        color.colorsPerRow = colCount;\n                        // The location of the middle of the first color\n                        color.firstColor = {\n                            x: beginX,\n                            y: beginY,\n                        };\n                        color.nextColor = {\n                            x: nextX,\n                            y: nextY,\n                        };\n                        _a = color.color, r = _a.r, g = _a.g, b = _a.b;\n                        // Draw the color to the canvas\n                        canvas.fillStyle = \"rgba(\" + Math.round(r * 255.0) + \", \" + Math.round(g * 255.0) + \", \" + Math.round(b * 255.0) + \", \" + color.opacity + \")\";\n                        canvas.fillRect(col * colorWidth + startX, row * colorHeight + startY, colorWidth, colorHeight);\n                        col++;\n                        if (col === colCount) {\n                            col = 0;\n                            row++;\n                        }\n                    }\n                    // We have finished inserting\n                    return [2 /*return*/, image];\n                }\n                else {\n                    // Log an error\n                    throw new Error('Could not fit colors into atlas');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Retrieves the threejs texture for the atlas\n     *\n     * @param atlasName The identifier of the atlas\n     */\n    AtlasManager.prototype.getAtlasTexture = function (atlasName) {\n        return this.atlasTexture[atlasName];\n    };\n    /**\n     * This reads the input path and loads the image specified by the path\n     *\n     * @param {AtlasTexture} texture This is an atlas texture with the path set\n     *\n     * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\n     *                                     or null if there was an error\n     */\n    AtlasManager.prototype.loadImage = function (texture) {\n        if (texture.imagePath) {\n            return new Promise(function (resolve, reject) {\n                var image = new Image();\n                image.onload = function () {\n                    texture.pixelWidth = image.width;\n                    texture.pixelHeight = image.height;\n                    texture.aspectRatio = image.width / image.height;\n                    resolve(image);\n                };\n                image.onerror = function () {\n                    resolve(null);\n                };\n                image.src = texture.imagePath;\n            });\n        }\n        else if (texture.label) {\n            return new Promise(function (resolve, reject) {\n                var label = texture.label;\n                var labelSize = label.getSize();\n                var canvas = document.createElement('canvas');\n                var ctx = canvas.getContext('2d');\n                // Set the dimensions of the canvas/texture space we will be using to rasterize\n                // The label. Use the label's rasterization controls to aid in rendering the label\n                canvas.width = labelSize.width;\n                canvas.height = labelSize.height;\n                debug('label X %o', texture.label.rasterizationOffset.x);\n                if (ctx) {\n                    var fontSize = label.fontSize;\n                    var color = d3_color_1.rgb(label.color.base.color.r * 255, label.color.base.color.g * 255, label.color.base.color.b * 255, label.color.base.opacity);\n                    ctx.font = label.makeCSSFont(fontSize);\n                    ctx.textAlign = label.textAlign;\n                    ctx.textBaseline = label.textBaseline;\n                    ctx.fillStyle = color.toString();\n                    // Render the label to the canvas/texture space. This utilizes the label's\n                    // Rasterization metrics to aid in getting a clean render.\n                    ctx.fillText(label.truncatedText || label.text, texture.label.rasterizationOffset.x, texture.label.rasterizationOffset.y);\n                    var image_1 = new Image();\n                    image_1.onload = function () {\n                        // Here we use the canvas dimensions and NOT the image dimensions\n                        // As the image dimensions are unreliable here when setting the src\n                        // To a data url\n                        texture.pixelWidth = image_1.width;\n                        texture.pixelHeight = image_1.height;\n                        texture.aspectRatio = image_1.width / image_1.height;\n                        debugLabels('Applying size based on rasterization to the Label: w: %o h: %o', image_1.width, image_1.height);\n                        label.setSize({\n                            height: image_1.height,\n                            width: image_1.width,\n                        });\n                        resolve(image_1);\n                    };\n                    image_1.onerror = function () {\n                        resolve(null);\n                    };\n                    image_1.src = canvas.toDataURL('image/png');\n                }\n            });\n        }\n        return Promise.resolve(null);\n    };\n    return AtlasManager;\n}());\nexports.AtlasManager = AtlasManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-manager.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../primitives/bounds\");\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nvar PackNode = (function () {\n    function PackNode(x, y, width, height) {\n        this.child = [null, null];\n        this.isLeaf = true;\n        this.nodeImage = null;\n        this.nodeDimensions = new bounds_1.Bounds(x, x + width, y, y - height);\n    }\n    /**\n     * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n     */\n    PackNode.prototype.destroy = function () {\n        this.nodeImage = null;\n        if (this.child[0]) {\n            this.child[0].destroy();\n        }\n        if (this.child[1]) {\n            this.child[1].destroy();\n        }\n        this.child[0] = undefined;\n        this.child[1] = undefined;\n    };\n    /**\n     * Indicates if there is a child\n     */\n    PackNode.prototype.hasChild = function () {\n        if (this.child[0] && !this.child[0].nodeImage) {\n            return !this.child[0].isLeaf;\n        }\n        if (this.child[1] && !this.child[1].nodeImage) {\n            return !this.child[1].isLeaf;\n        }\n        return false;\n    };\n    /**\n     * Inserts images into our mapping, fitting them appropriately\n     */\n    PackNode.prototype.insert = function (image) {\n        if (!this.isLeaf) {\n            // Try inserting into first child\n            var newNode = this.child[0].insert(image);\n            if (newNode !== null) {\n                return newNode;\n            }\n            // No room in first so insert into second\n            return this.child[1].insert(image);\n        }\n        else {\n            // If there's already an image here, return\n            if (this.nodeImage) {\n                return null;\n            }\n            // Check the fit status of the image in this nodes rectangle space\n            var fitFlag = this.nodeDimensions.fits(image.second);\n            // If we're too small, return null indicating can not fit\n            if (fitFlag === 0) {\n                return null;\n            }\n            // If we're just right, accept\n            if (fitFlag === 1) {\n                return this;\n            }\n            // Otherwise, gotta split this node and create some leaves\n            this.isLeaf = false;\n            // Get the image width\n            var imgWidth = image.second.width;\n            var imgHeight = image.second.height;\n            // Decide which way to split\n            var dWidth = this.nodeDimensions.width - imgWidth;\n            var dHeight = this.nodeDimensions.height - image.second.height;\n            if (dWidth > dHeight) {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, imgWidth, this.nodeDimensions.height);\n                this.child[1] = new PackNode(this.nodeDimensions.x + imgWidth, this.nodeDimensions.y, dWidth, this.nodeDimensions.height);\n            }\n            else {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, this.nodeDimensions.width, imgHeight);\n                this.child[1] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y + imgHeight, this.nodeDimensions.width, dHeight);\n            }\n        }\n        // Insert into first child we created\n        return this.child[0].insert(image);\n    };\n    /**\n     * Removes the image from the mapping and tries to open up as much space as possible.\n     *\n     * @param {AtlasTexture} image The image to insert into the\n     */\n    PackNode.prototype.remove = function (image) {\n        if (!this.isLeaf) {\n            // Try removing from first child\n            var removed = this.child[0].remove(image);\n            if (removed) {\n                return true;\n            }\n            // Try remove from second\n            removed = this.child[1].remove(image);\n            if (!this.child[0].hasChild()) {\n                if (!this.child[1].hasChild()) {\n                    this.child[0] = null;\n                    this.child[1] = null;\n                }\n            }\n            return removed;\n        }\n        else {\n            if (this.nodeImage === image) {\n                this.nodeImage = null;\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    return PackNode;\n}());\nexports.PackNode = PackNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/pack-node.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar rotateable_quad_1 = require(\"../../primitives/rotateable-quad\");\nvar sprite_1 = require(\"../texture/sprite\");\nvar measurement = new sprite_1.Sprite(200, 200, 1, 1);\nvar Label = (function (_super) {\n    __extends(Label, _super);\n    /**\n     * Creates an instance of Label.\n     *\n     * @param {Partial<Label<T>>} [options={}]\n     */\n    function Label(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { x: 0, y: 1 }, { width: 1, height: 1 }, 0, rotateable_quad_1.AnchorPosition.TopLeft) || this;\n        _this.depth = 40;\n        _this.direction = 'inherit';\n        _this.font = 'serif';\n        _this.fontSize = 10;\n        _this.fontWeight = 400;\n        _this.maxWidth = undefined;\n        _this.text = '';\n        _this.truncatedText = '';\n        _this.id = '';\n        _this.textAlign = 'start';\n        _this.textBaseline = 'alphabetic';\n        _this.allowScaling = true;\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to offset the rasterization if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationOffset = { x: 20, y: 0 };\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to pad the rasterization space if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationPadding = { width: 0, height: 0 };\n        // Set props\n        Object.assign(_this, options);\n        // Make sure our dimensions are set\n        _this.setFontSize(options.fontSize || 12);\n        return _this;\n    }\n    Object.defineProperty(Label.prototype, \"baseLabel\", {\n        get: function () {\n            return this._baseLabel;\n        },\n        set: function (value) {\n            this._baseLabel = value;\n            this.text = value.text;\n            this.fontSize = value.fontSize;\n            this.font = value.font;\n            this.textAlign = value.textAlign;\n            this.textBaseline = value.textBaseline;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Label.prototype, \"rasterizedLabel\", {\n        /**\n         * This getter ensures the rasterized label retrieved is either this labels own rasterization\n         * or from a base.\n         */\n        get: function () {\n            if (this.baseLabel) {\n                return this.baseLabel.rasterizedLabel;\n            }\n            return this._rasterizedLabel;\n        },\n        set: function (value) {\n            this._rasterizedLabel = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Copies all of the properties of a label and makes this label use them\n     *\n     * @param {Label} label The labels whose properties we wish to copy\n     */\n    Label.prototype.copyLabel = function (label) {\n        // Assign the properties of the other label to this\n        // Specifically, ONLY label properties\n        Object.assign(this, ramda_1.omit(['x', 'y', 'width', 'height'], label));\n        // Use this to set the text to make sure all of the metrics are re-calculated\n        this.setText(label.text);\n    };\n    /**\n     * This gets the actual text this label is capable of rendering\n     */\n    Label.prototype.getText = function () {\n        if (this._baseLabel) {\n            return this._baseLabel.getText();\n        }\n        return this.text;\n    };\n    /**\n     * Takes all of the current settings and makes a CSS font string\n     */\n    Label.prototype.makeCSSFont = function (fontSize) {\n        return this.fontWeight + \" \" + (fontSize || this.fontSize) + \"px \" + this.font;\n    };\n    /**\n     * Change the position this text is rendered to\n     *\n     * @param x X world coordinate\n     * @param y Y world coordinate\n     */\n    Label.prototype.position = function (x, y) {\n        this.x = x;\n        this.y = y;\n    };\n    /**\n     * This sets the font size for the label based on the base text dimensions\n     *\n     * @param {number} fontSize\n     */\n    Label.prototype.setFontSize = function (fontSize) {\n        var lbl = this.getText();\n        var size = this.getSize();\n        var width = size.width;\n        var height = size.height;\n        if (this.baseLabel) {\n            var baseSize = this.baseLabel.getSize();\n            var scale = fontSize / this.baseLabel.fontSize;\n            height = baseSize.height * scale;\n            width = baseSize.width * scale;\n        }\n        else {\n            var ctx = measurement.context;\n            ctx.font = this.makeCSSFont();\n            var size_1 = ctx.measureText(lbl);\n            // Set our properties based on the calculated size\n            height = fontSize + this.rasterizationPadding.height;\n            width = size_1.width + this.rasterizationOffset.x + this.rasterizationPadding.width;\n            // We must analyze the label for truncation based on the max width\n            var threeDotsWide = ctx.measureText('...').width;\n            var str = this.text;\n            var truncatedWidth = width;\n            // If we're beyond our max width limit, we must truncate\n            if (this.maxWidth && (width > this.maxWidth)) {\n                var beyondMax = false;\n                while (truncatedWidth > this.maxWidth) {\n                    str = str.substring(0, str.length - 2);\n                    truncatedWidth =\n                        ctx.measureText(str).width +\n                            threeDotsWide +\n                            this.rasterizationOffset.x +\n                            this.rasterizationPadding.width;\n                    beyondMax = true;\n                }\n                if (beyondMax) {\n                    str += '...';\n                }\n                this.truncatedText = str;\n                width = truncatedWidth;\n            }\n            else {\n                this.truncatedText = '';\n            }\n        }\n        this.fontSize = fontSize;\n        this.setSize({ width: width, height: height });\n    };\n    /**\n     * Change the text and the calculated bounding box for this label\n     */\n    Label.prototype.setText = function (lbl) {\n        this.text = lbl;\n        this.setFontSize(this.fontSize);\n    };\n    Label.prototype.update = function () {\n        this.setFontSize(this.fontSize);\n        _super.prototype.update.call(this);\n    };\n    return Label;\n}(rotateable_quad_1.RotateableQuad));\nexports.Label = Label;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/label.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar bounds_1 = require(\"./bounds\");\nvar AnchorPosition;\n(function (AnchorPosition) {\n    AnchorPosition[AnchorPosition[\"BottomLeft\"] = 0] = \"BottomLeft\";\n    AnchorPosition[AnchorPosition[\"BottomRight\"] = 1] = \"BottomRight\";\n    AnchorPosition[AnchorPosition[\"Custom\"] = 2] = \"Custom\";\n    AnchorPosition[AnchorPosition[\"Middle\"] = 3] = \"Middle\";\n    AnchorPosition[AnchorPosition[\"MiddleBottom\"] = 4] = \"MiddleBottom\";\n    AnchorPosition[AnchorPosition[\"MiddleLeft\"] = 5] = \"MiddleLeft\";\n    AnchorPosition[AnchorPosition[\"MiddleRight\"] = 6] = \"MiddleRight\";\n    AnchorPosition[AnchorPosition[\"MiddleTop\"] = 7] = \"MiddleTop\";\n    AnchorPosition[AnchorPosition[\"TopLeft\"] = 8] = \"TopLeft\";\n    AnchorPosition[AnchorPosition[\"TopRight\"] = 9] = \"TopRight\";\n})(AnchorPosition = exports.AnchorPosition || (exports.AnchorPosition = {}));\nvar anchorCalculations = (_a = {},\n    _a[AnchorPosition.BottomLeft] = function (quad) { return ({\n        x: 0,\n        y: 0,\n    }); },\n    _a[AnchorPosition.BottomRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: 0,\n    }); },\n    _a[AnchorPosition.Custom] = function (quad) { return ({\n        x: 0,\n        y: -quad.getSize().height,\n    }); },\n    _a[AnchorPosition.Middle] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: -quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleBottom] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: 0,\n    }); },\n    _a[AnchorPosition.MiddleLeft] = function (quad) { return ({\n        x: 0,\n        y: -quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: -quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleTop] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: -quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopLeft] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: -quad.getSize().height,\n    }); },\n    _a);\nvar RotateableQuad = (function (_super) {\n    __extends(RotateableQuad, _super);\n    /**\n     * Generates a quad\n     *\n     * @param {IPoint} location The location of the quad (it's anchorpoint will be placed here)\n     * @param {number} width The width of the quad\n     * @param {number} height The height of the quad\n     * @param {AnchorPosition} anchor The anchor location of the quad.\n     *                                Location and rotation will be relative to this.\n     */\n    function RotateableQuad(location, size, rotation, anchor) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        // Apply our properties\n        _this.setSize(size);\n        _this.setAnchor(anchor);\n        _this.setLocation(location);\n        _this.setRotation(rotation);\n        return _this;\n    }\n    /**\n     * @private\n     * Recalculates this anchor position based on the anchor type\n     *\n     * @param {AnchorPosition} anchor\n     */\n    RotateableQuad.prototype.calculateAnchor = function (anchor) {\n        this.anchor = anchorCalculations[anchor](this);\n    };\n    /**\n     * Get the base size of the quad\n     *\n     * @returns {ISize} The base size of this quad\n     */\n    RotateableQuad.prototype.getSize = function () {\n        return this.size;\n    };\n    /**\n     * Sets the specified anchor position on the quad\n     *\n     * @param {AnchorPosition} anchor This specifies an auto calculated position for the anchor\n     * @param {IPoint} custom If specified, will set a custom anchor location rather\n     *                        than the calculated version.\n     */\n    RotateableQuad.prototype.setAnchor = function (anchor, custom) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        this.anchorType = anchor;\n        // Apply the custom position if present\n        if (custom) {\n            this.anchorType = AnchorPosition.Custom;\n            this.anchor = custom;\n            return;\n        }\n        this.calculateAnchor(anchor);\n    };\n    RotateableQuad.prototype.getAnchor = function () {\n        return this.anchor;\n    };\n    RotateableQuad.prototype.getAnchorType = function () {\n        return this.anchorType;\n    };\n    /**\n     * This sets the location of this quad to a given position where the anchor\n     * point will be located on top of the location provided.\n     *\n     * @param {IPoint} location The location to place the quad\n     */\n    RotateableQuad.prototype.setLocation = function (location) {\n        this.location = location;\n    };\n    RotateableQuad.prototype.getLocation = function () {\n        return this.location;\n    };\n    /**\n     * Sets the rotation of this quad, in radians, rotated around the anchor point.\n     *\n     * @param {number} rotation The rotation of the quad\n     */\n    RotateableQuad.prototype.setRotation = function (rotation) {\n        this.rotation = rotation;\n    };\n    /**\n     * get Rotation\n     */\n    RotateableQuad.prototype.getRotation = function () {\n        return this.rotation;\n    };\n    /**\n     * get direction as a point\n     */\n    RotateableQuad.prototype.getDirection = function () {\n        var angle = this.rotation;\n        return {\n            x: Math.cos(angle),\n            y: Math.sin(angle),\n        };\n    };\n    /**\n     * Applies the size to the base\n     *\n     * @param {ISize} size The size of the base quad\n     */\n    RotateableQuad.prototype.setSize = function (size) {\n        this.size = size;\n        this.base = [\n            new three_1.Vector4(0, size.height, 0, 1),\n            new three_1.Vector4(size.width, size.height, 0, 1),\n            new three_1.Vector4(0, 0, 0, 1),\n            new three_1.Vector4(size.width, 0, 0, 1),\n        ];\n        if (this.anchorType) {\n            this.calculateAnchor(this.anchorType);\n        }\n    };\n    /**\n     * This re-calculates the transform for this quad and applies the transform to\n     * the corners.\n     */\n    RotateableQuad.prototype.update = function () {\n        // Calculate the pieces of the transformation\n        var anchorMat = new three_1.Matrix4().makeTranslation(-this.anchor.x, this.anchor.y, 0);\n        var rotationMat = new three_1.Matrix4().makeRotationZ(this.rotation);\n        var locationMat = new three_1.Matrix4().makeTranslation(this.location.x, this.location.y, 0);\n        // Compose the transform based on the pieces and apply them\n        // In the proper compositing order\n        this.transform = new three_1.Matrix4()\n            .multiply(locationMat)\n            .multiply(rotationMat)\n            .multiply(anchorMat);\n        // Apply the transform to all of our base vertices\n        this.TL = this.base[0].clone().applyMatrix4(this.transform);\n        this.TR = this.base[1].clone().applyMatrix4(this.transform);\n        this.BL = this.base[2].clone().applyMatrix4(this.transform);\n        this.BR = this.base[3].clone().applyMatrix4(this.transform);\n        // Update the bounds of this object\n        this.x = this.TL.x;\n        this.y = this.TL.y;\n        this.width = 1;\n        this.height = 1;\n        this.encapsulatePoints([this.TR, this.BL, this.BR]);\n    };\n    return RotateableQuad;\n}(bounds_1.Bounds));\nexports.RotateableQuad = RotateableQuad;\nvar _a;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/rotateable-quad.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A canvas element wrapper that aids in tracking a canvas element along with\n * content scaling properties.\n *\n * @class Sprite\n */\nvar Sprite = (function () {\n    //\n    // Ctor at the top below props\n    //\n    /**\n     * Creates an instance of Sprite.\n     *\n     * @param w             The width of the context to create\n     * @param h             The height of the context to create\n     * @param contentScaleX The content scaling of the content\n     * @param contentScaleY The content scaling of the content\n     *\n     * @memberOf Sprite\n     */\n    function Sprite(w, h, contentScaleX, contentScaleY) {\n        this.scaleX = 1;\n        this.scaleY = 1;\n        var canvas = document.createElement('canvas');\n        if (canvas) {\n            this.scaleX = contentScaleX || this.scaleX;\n            this.scaleY = contentScaleY || this.scaleY;\n            canvas.width = w * this.scaleX;\n            canvas.height = h * this.scaleY;\n            this.context = canvas.getContext('2d');\n            this.canvas = canvas;\n        }\n    }\n    /**\n     * Retrieves the content scaling of this object\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentScale = function () {\n        return {\n            x: this.scaleX,\n            y: this.scaleY,\n        };\n    };\n    /**\n     * Retrieves the size of the content ignoring scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentSize = function () {\n        return {\n            height: this.canvas.height,\n            width: this.canvas.width,\n        };\n    };\n    /**\n     * Retrieves the dimensional width of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getWidth = function () {\n        return this.canvas.width / this.scaleX;\n    };\n    /**\n     * Retrieves the dimensional height of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getHeight = function () {\n        return this.canvas.height / this.scaleY;\n    };\n    return Sprite;\n}());\nexports.Sprite = Sprite;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/sprite.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar browser = require(\"bowser\");\nvar three_1 = require(\"three\");\nvar debug = require('debug')('CommunicationsView:Mouse');\n/** Used to adjust the base whee delta for IE browsers */\nvar IE_ADJUSTMENT = 1 / 30;\n/** Used to adjust the rates for IE 11 */\nvar OLD_IE_ADJUSTMENT = -0.25;\n// This determines how large the delta can grow to in firefox\nvar MAX_FIREFOX_WHEELDELTA = 100;\n/**\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\n */\nvar lowPassY = [0, 0, 0, 0];\n// These coefficients represent the coefficients of a FIR filter.\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\n// Attained.\nvar LOW_PASS_U0 = 0.1;\nvar LOW_PASS_U1 = 0.2;\nvar LOW_PASS_U2 = 0.2;\nvar LOW_PASS_U3 = 0.5;\nfunction normalizeFirefoxWheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = 0;\n    var deltaY = 0;\n    // Reset the filter if the direction changes to prevent lag in directional change\n    if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\n        lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\n    }\n    deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\n    // Calculate the next value output from the FIR filter\n    deltaY = (wheel.deltaY * MAX_FIREFOX_WHEELDELTA) * LOW_PASS_U0 + lowPassY[0] * LOW_PASS_U1 + lowPassY[1] * LOW_PASS_U2 + lowPassY[2] * LOW_PASS_U3;\n    // Store the value of the filter in the FIR memory bank\n    lowPassY.unshift(deltaY);\n    // Keep our FIR memory clean and only the size of the number of coefficients\n    lowPassY.pop();\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeChromeWheel(e) {\n    var wheel = e.nativeEvent;\n    return new three_1.Vector2(wheel.deltaX, -wheel.deltaY);\n}\nfunction normalizeIE11Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    var deltaY = wheel.deltaY;\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\n        }\n    }\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeIE12Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX, deltaY = wheel.deltaY;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = wheel.wheelDelta || -wheel.detail;\n        }\n    }\n    var v = new three_1.Vector2(deltaX, -deltaY);\n    v.multiplyScalar(0.25);\n    return v;\n}\n// Determine this browsers version of wheel normalization and apply it\nvar normalizeWheel;\nexports.normalizeWheel = normalizeWheel;\nif (browser.firefox) {\n    debug('Using mouse wheel for firefox');\n    exports.normalizeWheel = normalizeWheel = normalizeFirefoxWheel;\n}\nelse if (browser.msie && +browser.version >= 11) {\n    debug('Using mouse wheel for IE 11');\n    exports.normalizeWheel = normalizeWheel = normalizeIE11Wheel;\n}\nelse if (browser.msedge) {\n    debug('Using mouse wheel for MS EDGE');\n    exports.normalizeWheel = normalizeWheel = normalizeIE12Wheel;\n}\nelse {\n    debug('Using mouse wheel for Chrome');\n    exports.normalizeWheel = normalizeWheel = normalizeChromeWheel;\n}\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(e, relative) {\n    var mouseX = 0, mouseY = 0, eventX = 0, eventY = 0, object = relative || e.nativeEvent.target;\n    // Get mouse position on document crossbrowser\n    if (!e) {\n        e = window.event;\n    }\n    if (e.pageX || e.pageY) {\n        mouseX = e.pageX;\n        mouseY = e.pageY;\n    }\n    else if (e.clientX || e.clientY) {\n        mouseX = e.clientX + document.body.scrollLeft\n            + document.documentElement.scrollLeft;\n        mouseY = e.clientY + document.body.scrollTop\n            + document.documentElement.scrollTop;\n    }\n    // Get parent element position in document\n    if (object.offsetParent) {\n        do {\n            eventX += object.offsetLeft;\n            eventY += object.offsetTop;\n            object = object.offsetParent;\n        } while (object);\n    }\n    // Mouse position minus elm position is mouseposition relative to element:\n    return { x: mouseX - eventX, y: mouseY - eventY };\n}\nexports.eventElementPosition = eventElementPosition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/mouse.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../primitives/bounds\");\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nvar maxPopulation = 5;\nvar maxDepth = 10;\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nfunction filterQuery(type, queryValues) {\n    var filtered = [];\n    queryValues.forEach(function (obj) {\n        if (type.find(function (t) { return obj instanceof t; })) {\n            filtered.push(obj);\n        }\n    });\n    return filtered;\n}\nexports.filterQuery = filterQuery;\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nvar Quadrants = (function () {\n    /**\n     * Creates an instance of Quadrants.\n     *\n     * @param bounds The bounds this will create quandrants for\n     * @param depth  The child depth of this element\n     *\n     * @memberOf Quadrants\n     */\n    function Quadrants(bounds, depth) {\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n        var mid = bounds.mid;\n        this.TL = new Node(bounds.x, mid.x, bounds.y, mid.y, depth);\n        this.TR = new Node(mid.x, bounds.right, bounds.y, mid.y, depth);\n        this.BL = new Node(bounds.x, mid.x, mid.y, bounds.bottom, depth);\n        this.BR = new Node(mid.x, bounds.right, mid.y, bounds.bottom, depth);\n    }\n    /**\n     * Ensures all memory is released for all nodes and all references are removed\n     * to potentially high memory consumption items\n     *\n     * @memberOf Quadrants\n     */\n    Quadrants.prototype.destroy = function () {\n        this.TL.destroy();\n        this.TR.destroy();\n        this.BL.destroy();\n        this.BR.destroy();\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n    };\n    return Quadrants;\n}());\nexports.Quadrants = Quadrants;\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nvar Node = (function () {\n    /**\n     * Creates an instance of Node.\n     *\n     * @param l     The bounding left wall of the space this node covers\n     * @param r     The bounding right wall of the space this node covers\n     * @param t     The bounding top wall of the space this node covers\n     * @param b     The bounding bottom wall of the space this node covers\n     * @param depth The depth within the quad tree this node resides\n     *\n     * @memberOf Node\n     */\n    function Node(left, right, top, bottom, depth) {\n        this.bounds = null;\n        this.children = [];\n        this.childrenProps = [];\n        this.depth = 0;\n        this.nodes = null;\n        // If params insertted\n        if (arguments.length >= 4) {\n            this.bounds = new bounds_1.Bounds(left, right, top, bottom);\n        }\n        else {\n            this.bounds = new bounds_1.Bounds(0, 1, 1, 0);\n        }\n        // Ensure the depth is set\n        this.depth = depth || 0;\n    }\n    /**\n     * Destroys this node and ensures all child nodes are destroyed as well.\n     *\n     * @memberOf Node\n     */\n    Node.prototype.destroy = function () {\n        this.children = null;\n        this.bounds = null;\n        if (this.nodes) {\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n    };\n    /**\n     * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n     * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n     * this quad tree spans (and this is the root node), the quad tree will expand to include\n     * the new child.\n     *\n     * @param child The Bounds type object to inject\n     * @param props Properties that can be retrieved with the child object if applicable\n     *\n     * @returns True if the insertion was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.add = function (child, props) {\n        // This is the entry function for adding children, so we must first expand our top node\n        // To cover the area that the child is located.\n        // If we're in bounds, then let's just add the child\n        if (child.isInside(this.bounds)) {\n            return this.doAdd(child);\n        }\n        else {\n            this.cover(child);\n            return this.add(child, props);\n        }\n    };\n    /**\n     * Adds a list of new children to this quad tree. It performs the same operations as\n     * addChild for each child in the list, however, it more efficiently recalculates the\n     * bounds necessary to cover the area the children cover.\n     *\n     * @param children      List of Bounds objects to inject\n     * @param childrenProps List of props to associate with each element\n     *\n     * @memberOf Node\n     */\n    Node.prototype.addAll = function (children, childrenProps) {\n        var _this = this;\n        // Ensure the properties are at least defined\n        childrenProps = childrenProps || [];\n        // Make sure we cover the entire area of all the children.\n        // We can speed this up a lot if we first calculate the total bounds the new children covers\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = -Number.MAX_VALUE;\n        var maxY = -Number.MAX_VALUE;\n        // Get the dimensions of the new bounds\n        children.forEach(function (child) {\n            if (child.x < minX) {\n                minX = child.x;\n            }\n            if (child.right > maxX) {\n                maxX = child.right;\n            }\n            if (child.bottom < minY) {\n                minY = child.bottom;\n            }\n            if (child.y > maxY) {\n                maxY = child.y;\n            }\n        });\n        // Make sure our bounds includes the specified bounds\n        this.cover(new bounds_1.Bounds(minX, maxX, maxY, minY));\n        // Add all of the children into the tree\n        children.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n     * This will cause all children to be re-injected into the tree.\n     *\n     * @param bounds The bounds to include in the tree's coverage\n     *\n     * @memberOf Node\n     */\n    Node.prototype.cover = function (bounds) {\n        var _this = this;\n        // If we are already covering the area: abort\n        if (bounds.isInside(this.bounds)) {\n            return;\n        }\n        // Make our bounds cover the new area\n        this.bounds.encapsulate(bounds);\n        this.bounds.x -= 1;\n        this.bounds.y += 1;\n        this.bounds.width += 2;\n        this.bounds.height += 4;\n        // Get all of the children underneath this node\n        var allChildren = this.gatherChildren([]);\n        // Destroy the split nodes\n        if (this.nodes) {\n            // Completely...destroy...\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n        // Reinsert all children with the new dimensions in place\n        allChildren.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * When adding children, this performs the actual action of injecting the child into the tree\n     * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n     *\n     * @param child The Bounds item to inject into the tree\n     * @param props The props to remain associated with the child\n     *\n     * @returns True if the injection was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.doAdd = function (child) {\n        // If nodes are present, then we have already exceeded the population of this node\n        if (this.nodes) {\n            if (child.isInside(this.nodes.TL.bounds)) {\n                return this.nodes.TL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.TR.bounds)) {\n                return this.nodes.TR.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BL.bounds)) {\n                return this.nodes.BL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BR.bounds)) {\n                return this.nodes.BR.doAdd(child);\n            }\n            // Otherwise, this is a child overlapping this border\n            this.children.push(child);\n            return true;\n        }\n        else if (child.isInside(this.bounds)) {\n            this.children.push(child);\n            // If we exceeded our population for this quadrant, it is time to split up\n            if (this.children.length > maxPopulation && this.depth < maxDepth) {\n                this.split();\n            }\n            return true;\n        }\n        // This is when there is something wrong with the insertted child. The bounds\n        // For the quad should have grown without issue, but in this case the bounds\n        // Could not grow to accomodate the child.\n        if (isNaN(child.width + child.height + child.x + child.y)) {\n            console.error('Child did not fit into bounds because a dimension is NaN', child);\n        }\n        else if (child.area === 0) {\n            console.error('Child did not fit into bounds because the area is zero', child);\n        }\n        // Don't insert the child and continue\n        return true;\n    };\n    /**\n     * Collects all children of all the current and sub nodes into a single list.\n     *\n     * @param list The list we must aggregate children into\n     *\n     * @return The list specified as the list parameter\n     */\n    Node.prototype.gatherChildren = function (list) {\n        list = list.concat(this.children);\n        if (this.nodes) {\n            this.nodes.TL.gatherChildren(list);\n            this.nodes.TR.gatherChildren(list);\n            this.nodes.BL.gatherChildren(list);\n            this.nodes.BR.gatherChildren(list);\n        }\n        return list;\n    };\n    /**\n     * Collects all props associated with the children. This array of props will\n     * mirror the list retrieved with gatherChildren.\n     *\n     * @param list\n     *\n     * @returns The list specified as the list paramter\n     *\n     * @memberOf Node\n     */\n    Node.prototype.gatherProps = function (list) {\n        var _this = this;\n        this.children.forEach(function (c, index) {\n            list.push(_this.childrenProps[index]);\n        });\n        if (this.nodes) {\n            this.nodes.TL.gatherProps(list);\n            this.nodes.TR.gatherProps(list);\n            this.nodes.BL.gatherProps(list);\n            this.nodes.BR.gatherProps(list);\n        }\n        return list;\n    };\n    /**\n     * Entry query for determining query type based on input object\n     *\n     * @param bounds Can be a Bounds or a Point object\n     * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n     *               information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return An array of children that intersects with the query\n     */\n    Node.prototype.query = function (bounds, visit) {\n        // Query a rectangle\n        if (bounds instanceof bounds_1.Bounds) {\n            if (bounds.hitBounds(this.bounds)) {\n                return this.queryBounds(bounds, [], visit);\n            }\n            // Return an empty array when nothing is collided with\n            return [];\n        }\n        // Query a point\n        if (this.bounds.containsPoint(bounds)) {\n            return this.queryPoint(bounds, [], visit);\n        }\n        // Return an empty array when nothing is collided with\n        return [];\n    };\n    /**\n     * Queries children for intersection with a bounds object\n     *\n     * @param b     The Bounds to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return     Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryBounds = function (b, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.hitBounds(b)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (b.hitBounds(this.nodes.TL.bounds)) {\n                this.nodes.TL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.TR.bounds)) {\n                this.nodes.TR.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BL.bounds)) {\n                this.nodes.BL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BR.bounds)) {\n                this.nodes.BR.queryBounds(b, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Queries children for intersection with a point\n     *\n     * @param p     The Point to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return      Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryPoint = function (p, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.containsPoint(p)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (this.nodes.TL.bounds.containsPoint(p)) {\n                this.nodes.TL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.TR.bounds.containsPoint(p)) {\n                this.nodes.TR.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BL.bounds.containsPoint(p)) {\n                this.nodes.BL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BR.bounds.containsPoint(p)) {\n                this.nodes.BR.queryPoint(p, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Creates four sub quadrants for this node.\n     */\n    Node.prototype.split = function () {\n        // Gather all items to be handed down\n        var allChildren = this.gatherChildren([]);\n        // Gather all props for the children to be handed down as well\n        this.nodes = new Quadrants(this.bounds, this.depth + 1);\n        this.children = [];\n        this.childrenProps = [];\n        while (allChildren.length > 0) {\n            this.doAdd(allChildren.pop());\n        }\n    };\n    /**\n     * Traverses the quad tree returning every quadrant encountered\n     *\n     * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n     */\n    Node.prototype.visit = function (cb) {\n        var finished = Boolean(cb(this));\n        if (this.nodes && !finished) {\n            this.nodes.TL.visit(cb);\n            this.nodes.TR.visit(cb);\n            this.nodes.BL.visit(cb);\n            this.nodes.BR.visit(cb);\n        }\n    };\n    return Node;\n}());\nexports.Node = Node;\nvar QuadTree = (function (_super) {\n    __extends(QuadTree, _super);\n    function QuadTree() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QuadTree;\n}(Node));\nexports.QuadTree = QuadTree;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/quad-tree.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interpolation_1 = require(\"../util/interpolation\");\nvar bounds_1 = require(\"./bounds\");\nvar line_1 = require(\"./line\");\nvar point_1 = require(\"./point\");\nvar debug = require('debug')('bezier');\n/**\n * This enum covers the type of curved lines that can be made. Making a specific curve\n *\n * @export\n * @enum {number}\n */\nvar CurveType;\n(function (CurveType) {\n    /** This will make the curve be generated from interpolating between the end points and provided control points */\n    CurveType[CurveType[\"Bezier\"] = 0] = \"Bezier\";\n    /**\n     * This will draw a curve as though there is a circular arc passing over the two end points. The radius of the\n     * circular arc is determined by how far the control point is from the straight line that can be made from the two\n     * end points.\n     */\n    CurveType[CurveType[\"CircularCCW\"] = 1] = \"CircularCCW\";\n    CurveType[CurveType[\"CircularCW\"] = 2] = \"CircularCW\";\n    /**\n     * This ignores the control points altogether and just created a straight line with a single segment that consists\n     * of the specified endpoints\n     */\n    CurveType[CurveType[\"Straight\"] = 3] = \"Straight\";\n})(CurveType = exports.CurveType || (exports.CurveType = {}));\n// -------[ Distance Calculating Methods ]----------------------------\n/**\n * Calculates the distance to the bezier curve by testing all of the bezier curve's segment lines\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction bezierDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a circle\n * TODO: Using the segment approach for now. Can be sped up by using circle math\n * instead\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction circularDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a straight line\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction straightDistance(line, testPoint) {\n    return new line_1.Line(line.start, line.end).distanceTo(testPoint);\n}\n// -------[ Segment Generating Methods ]----------------------------\n/**\n * Uses quadratic bezier principles to create the segments for a quadratic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier2Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier2(dt * i, start, lineEnd, c1));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Uses cubic bezier principles to create the segments for a cubic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier3Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    var c2 = line.controlPoints[1];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier3(dt * i, start, lineEnd, c1, c2));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that follows along a circular path on the line.\n * The distance the control point is from the straight line that flows through the two\n * end points of the line determines the radius of the curvature of the line\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeCircularCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    debug('CW');\n    // Generate a line so we can have a perpendicular calculation\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        // We get the midpoint of the line as we want to align the center of the circle with this point\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        // The shortest the radius can be is the distance from the line to the mid point\n        // Anything shorter will just result in a hemisphere being rendered\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        // Get the perpendicular direction to the line so we can calculate the center of our circle\n        // From the mid point\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        // Calculate the location of the center of the circle\n        circleCenter = {\n            x: perpendicular.x * distance + midPoint.x,\n            y: perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    debug(' center of circle is %o  %o', circleCenter.x, circleCenter.y);\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Calculate how much to increment theta in our parametric circular equation\n    if (theta1 < theta2)\n        theta1 += Math.PI * 2;\n    var dTheta = (theta1 - theta2) / line.resolution;\n    debug('theta1 is %o, theta2 is %o', theta1, theta2);\n    // Compute the segments based on the information we have gathered by applying it to a circular\n    // Parametric equation\n    var segments = [];\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 - (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 - (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    // Cache the segments if specified by the curved line\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    debug('Generated Circular Segments: %o dTheta: %o radius: %o', segments, dTheta, radius);\n    return segments;\n}\nfunction makeCircularCCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        circleCenter = {\n            x: -perpendicular.x * distance + midPoint.x,\n            y: -perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    if (theta2 < theta1)\n        theta2 += Math.PI * 2;\n    var dTheta = (theta2 - theta1) / line.resolution;\n    var segments = [];\n    // CCW, from end to start\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 + (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 + (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    if (line.cachedSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that is straight, thus only 1 segments is needed\n * and will be generated.\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeStraightSegments(line) {\n    return [line.start, line.end];\n}\n/** A quick lookup for a proper segment creating method for a curved line  */\nvar pickSegmentMethod = (_a = {},\n    _a[CurveType.Bezier] = [\n        null,\n        makeBezier2Segments,\n        makeBezier3Segments,\n    ],\n    _a[CurveType.CircularCW] = [\n        null,\n        makeCircularCWSegments,\n        makeCircularCWSegments,\n    ],\n    _a[CurveType.CircularCCW] = [\n        null,\n        makeCircularCCWSegments,\n        makeCircularCCWSegments,\n    ],\n    _a[CurveType.Straight] = [\n        makeStraightSegments,\n    ],\n    _a);\n/** A quick lookup for a proper distance calculating method for a curved line  */\nvar pickDistanceMethod = (_b = {},\n    _b[CurveType.Bezier] = bezierDistance,\n    _b[CurveType.CircularCW] = circularDistance,\n    _b[CurveType.CircularCCW] = circularDistance,\n    _b[CurveType.Straight] = straightDistance,\n    _b);\n/**\n * Defines an object which illustrates a curved line. Curved lines can be formed in many\n * ways but most often from two end points and some provided control points.\n *\n * @export\n * @class CurvedLine\n * @extends {Bounds<T>}\n * @template T An associated data type with this object. Use <never> if no data type is ever associated\n */\nvar CurvedLine = (function (_super) {\n    __extends(CurvedLine, _super);\n    /**\n     * Generates a primitive that describes a curved line, which is defined by the lines end points, type, and control points\n     *\n     * @param {ICurvedLineOptions} options The configuration options of this curved line\n     */\n    function CurvedLine(options) {\n        var _this = this;\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        _this = _super.call(this, minX, maxX, maxY, minY) || this;\n        // Apply the relevant properties to the curve\n        _this.cachesSegments = options.cacheSegments || false;\n        _this.type = options.type;\n        _this.resolution = options.resolution || 20;\n        // Set the metrics for this curved line\n        _this.setPoints(options.start, options.end, options.controlPoints);\n        // Set the method that will be used for calculating distance from a point\n        _this.distanceMethod = pickDistanceMethod[options.type];\n        return _this;\n    }\n    Object.defineProperty(CurvedLine.prototype, \"values\", {\n        get: function () {\n            return {\n                controlPoints: this.controlPoints,\n                end: this.end,\n                start: this.start,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Calculates the nearest distance from the provided point to this curved line\n     *\n     * @param {IPoint} point The point to test the distance from\n     *\n     * @returns {number} The calculated nearest distance from this curve to the point\n     */\n    CurvedLine.prototype.distanceTo = function (point) {\n        return this.distanceMethod(this, point);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {CurvedLine<any>[]} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    CurvedLine.getClosest = function (lines, point) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(point);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This returns the line strip that represents the curve. A line strip is specifically a group of points\n     * that forms line segments by taking the current point as one end and the previous point as the second end\n     * thus, you would start at index 1 and loop to the end to generate all of the lines composing this single\n     * line.\n     *\n     * @return {IPoint[]} All of the points in the line strip\n     */\n    CurvedLine.prototype.getLineStrip = function () {\n        return this.segmentMethod(this);\n    };\n    /**\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     * @param {boolean} preventRebounding If set, this will prevent the bounds from being recalculated\n     */\n    CurvedLine.prototype.setPoints = function (start, end, controlPoints) {\n        // Apply the points\n        this.start = start;\n        this.end = end;\n        if (controlPoints.length === 0)\n            debug('start: %o, end:%o', start, end);\n        // Get the available segment methods for the given type\n        var segmentMethods = pickSegmentMethod[this.type];\n        // If we adjust the control points we need to re-evaluate the type of segment creation method we use\n        if (controlPoints) {\n            this.controlPoints = controlPoints;\n            // Get the number of control points we want to base the curve off of\n            var numControlPoints = controlPoints.length;\n            // If we have more control points than the methods available, then we use the greatest method available to best\n            // Handle as many control points as possible\n            if (numControlPoints > segmentMethods.length) {\n                numControlPoints = segmentMethods.length - 1;\n            }\n            // Set the method that will be used for generating segments\n            this.segmentMethod = segmentMethods[numControlPoints];\n            // Make sure the input wasn't bad\n            if (!this.segmentMethod) {\n                throw new Error('An Invalid number of control points was provided to a curved line. You must have at LEAST 1 control point. Or 0 for a straight line');\n            }\n            if (this.type === CurveType.Bezier) {\n                this.encapsulatePoints(controlPoints);\n            }\n            else if (this.type === CurveType.CircularCCW || this.type === CurveType.CircularCW) {\n                this.encapsulatePoints(this.getLineStrip());\n            }\n        }\n        this.encapsulatePoint(start);\n        this.encapsulatePoint(end);\n        // Invalidate caches if they exist\n        this.cachedSegments = null;\n    };\n    return CurvedLine;\n}(bounds_1.Bounds));\nexports.CurvedLine = CurvedLine;\nvar _a, _b;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/curved-line.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"./bounds\");\nvar UID = 0;\nvar Circle = (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * Generate a new Circle object\n     *\n     * @param x The center of the circle\n     * @param y The center of the circle\n     * @param r The radius of the circle\n     * @param d A data object to associate with the circle\n     */\n    function Circle(options) {\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        /** a UID of the circle */\n        _this._id = ++UID;\n        /** Radius of the circle */\n        _this._radius = 0;\n        /** X coord of the center of the circle */\n        _this._centerX = 0;\n        /** Y coord of the center of the circle */\n        _this._centerY = 0;\n        _this._centerX = options.centerX;\n        _this._centerY = options.centerY;\n        _this._radius = options.radius;\n        _this.updateBounds();\n        return _this;\n    }\n    Object.defineProperty(Circle.prototype, \"values\", {\n        get: function () {\n            return {\n                radius: this._radius,\n                x: this._centerX,\n                y: this._centerY,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"radius\", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (val) {\n            this._radius = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (val) {\n            this._centerX = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (val) {\n            this._centerY = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Tests if the specified bounds is inside this circle\n     *\n     * @param b The bounds to test against\n     */\n    Circle.prototype.boundsInside = function (b) {\n        var r2 = this._radius * this._radius;\n        var dx = b.x - this._centerX;\n        var dy = b.y - this._centerY;\n        var dy2 = dy * dy;\n        var dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.right - this._centerX;\n        dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dy = b.bottom - this._centerY;\n        dy2 = dy * dy;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.x - this._centerX;\n        dx2 = dx * dx;\n        return (dx2 + dy2) < r2;\n    };\n    /**\n     * Calculates the distance to a provided point\n     *\n     * @param {IPoint} p The point to calculate the distance of the middle of the\n     *                   circle to\n     * @param {boolean} notSquared Flag true to prevent the Math.sqrt operation, leaving\n     *                             the result as distance^2\n     *\n     * @return {number} The distance from mid circle to the point\n     */\n    Circle.prototype.distanceTo = function (p, notSquared) {\n        var dx = this._centerX - p.x;\n        var dy = this._centerY - p.y;\n        if (notSquared) {\n            return dx * dx + dy * dy;\n        }\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    /**\n     * Retrieves the closest circle to a provided point\n     *\n     * @param {Array} circles The circles to see who is the nearest\n     * @param {IPoint} p The point to compare the circles against for nearness\n     *\n     * @return {Circle} The nearest circle\n     */\n    Circle.getClosest = function (circles, p) {\n        var closestCircle;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        circles.forEach(function (circle) {\n            distance = circle.distanceTo(p, true);\n            if (distance < closestDistance) {\n                closestCircle = circle;\n                closestDistance = distance;\n            }\n        });\n        return closestCircle;\n    };\n    /**\n     * Tests if this circle is colliding with the specified circle\n     *\n     * @param c The circle to test against\n     *\n     * @return {boolean} True if colliding\n     */\n    Circle.prototype.hitCircle = function (c) {\n        var totalDistance = c._radius + this._radius;\n        totalDistance *= totalDistance;\n        return this.distanceTo({ x: c._centerX, y: c._centerY }, true) < totalDistance;\n    };\n    /**\n     * @override\n     * This makes it so the test of a point tests based on a Circle shape\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.hitPoint = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * If there are multiple metrics to update for the circle, this is the most\n     * efficient way to do that as it will update it's bounds only once.\n     *\n     * @param x\n     * @param y\n     * @param r\n     */\n    Circle.prototype.position = function (x, y, r) {\n        this._centerX = x;\n        this._centerY = y;\n        this._radius = r;\n        this.updateBounds();\n    };\n    /**\n     * @override\n     * Tests if a point is inside the circle\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.pointInside = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * When the circle gains different circle metrics, it's Bounds must adjust\n     * accordingly, which is what this method recalculates.\n     */\n    Circle.prototype.updateBounds = function () {\n        var radius = this._radius;\n        this.x = this._centerX - radius;\n        this.y = this._centerY - radius;\n        this.height = radius * 2;\n        this.width = radius * 2;\n    };\n    /**\n     * Pretty print the metrics of this circle\n     */\n    Circle.prototype.toString = function () {\n        return \"[Circle {x: \" + this._centerX + \", y: \" + this._centerY + \", r: \" + this._radius + \"}]\";\n    };\n    return Circle;\n}(bounds_1.Bounds));\nexports.Circle = Circle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/circle.ts\n// module id = 22\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"../../primitives/line\");\n/**\n * Defines a line that can be drawn\n */\nvar LineShape = (function (_super) {\n    __extends(LineShape, _super);\n    /**\n     * Generate a new line that can be drawn\n     */\n    function LineShape(options) {\n        var _this = _super.call(this, options.p1, options.p2) || this;\n        _this.allowScaling = options.allowScaling || false;\n        _this.depth = options.depth || 0.0;\n        _this.endColor = options.endColor;\n        _this.startColor = options.startColor;\n        _this.thickness = options.thickness || 1.0;\n        return _this;\n    }\n    /**\n     * Clones this instance of the line shape and creates a new instance of a line shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this line shape\n     */\n    LineShape.prototype.clone = function (newProperties) {\n        return Object.assign(new LineShape(this), newProperties);\n    };\n    return LineShape;\n}(line_1.Line));\nexports.LineShape = LineShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/line-shape.ts\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar shape_buffer_cache_1 = require(\"./shape-buffer-cache\");\n/** This is a part of the identifier that is used to retrieve a multibuffer's storage */\nvar multiBufferSelectionPrefix = '__mb__';\n/** This is to ensure each multibuffer gets it's own unique selection identifier */\nvar multiBufferSelectionKeyUID = 0;\nfunction getIDProp(item) {\n    return item.id;\n}\nfunction evenRoundRobinBufferAdd(item, buffers) {\n    var smallest = buffers[0].buffer.length;\n    var found = buffers[0];\n    // Look for the next buffer that has the smallest length\n    // To fill it up\n    buffers.some(function (tracker) {\n        if (tracker.buffer.length < smallest) {\n            found = tracker;\n            return true;\n        }\n        return false;\n    });\n    found.buffer.push(item);\n    return [found];\n}\nfunction noop() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // NO-OP\n}\nfunction echoBuffer(item, buffer, buffers) {\n    return [buffer];\n}\n/**\n * This class helps facilitate breaking up a potentially large shape buffer into multiple buffers.\n */\nvar MultiShapeBufferCache = (function (_super) {\n    __extends(MultiShapeBufferCache, _super);\n    /**\n     * Makes a new multi shape buffer for minimizing changes\n     *\n     * @param numBuffers The number of buffers this multibuffer will manage\n     */\n    function MultiShapeBufferCache(numBuffers, methods) {\n        var _this = _super.call(this) || this;\n        /** The number of buffers this multi buffer manages */\n        _this.numBuffers = 0;\n        /** UID for storing the data for this buffer in the selection */\n        _this.selectionUID = multiBufferSelectionPrefix + (++multiBufferSelectionKeyUID);\n        /**\n         * The method used to add to the buffers. This is changeable so one can implement geometric or\n         * logical adds for invalidation. This returns a list of buffers that will be invalidated from\n         * the operation. The first buffer returned in the invalidation is the strongly associated buffer\n         * to the item injected. This first buffer is the most likely buffer the item is injected into.\n         */\n        _this.addMethod = evenRoundRobinBufferAdd;\n        /**\n         * Gives an implentor opportunity to define the way an is is specified for a given item. It\n         * defaults to searching for an 'id' property on the item.\n         */\n        _this.idMethod = getIDProp;\n        /**\n         * The method that is called right after the initial buffers get constructed. This is changeable\n         * so monitors can.\n         */\n        _this.initMethod = noop;\n        /**\n         * The method that is called right before a shape is removed from a buffer.\n         * This let's the\n         */\n        _this.removeMethod = echoBuffer;\n        /**\n         * The method that is called when an item is updated. This gives a monitor a chance to invalidate\n         * a number of buffers.\n         */\n        _this.updateMethod = echoBuffer;\n        // Store the number of buffers that are created when the buffers are initialized\n        _this.numBuffers = numBuffers;\n        // Set the hook methods if any are specified\n        if (methods) {\n            _this.addMethod = methods.add || _this.addMethod;\n            _this.idMethod = methods.id || _this.idMethod;\n            _this.initMethod = methods.init || _this.initMethod;\n            _this.removeMethod = methods.remove || _this.removeMethod;\n            _this.updateMethod = methods.update || _this.updateMethod;\n        }\n        return _this;\n    }\n    /**\n     * Adds a shape to a buffer and invalidates it\n     *\n     * @param shape The shape to add to a buffer\n     */\n    MultiShapeBufferCache.prototype.addShape = function (shape) {\n        // Perform the custom add opearation\n        var buffers = this.addMethod(shape, this.store.allBuffers);\n        // Stores the shape for lookup via id\n        this.store.idToItem.set(this.idMethod(shape), shape);\n        // Stores the shape for lookup to buffer. We count the\n        // First dirty buffer as the buffer the item is the closest to\n        // Association.\n        this.store.itemToBuffer.set(shape, buffers[0]);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * Clears the multi buffer's storage\n     */\n    MultiShapeBufferCache.prototype.destroy = function () {\n        if (this.store) {\n            this.store.selection.clearSelection(this.selectionUID);\n            delete this.store;\n        }\n    };\n    /**\n     * Sees if there is a shape associated with this id\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.containsId = function (id) {\n        return Boolean(this.store.idToItem.get(id));\n    };\n    /**\n     * Sees if this shape has been added to this buffer or not\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.containsShape = function (shape) {\n        // Check if this multibuffer has the shape or no\n        return Boolean(this.store.itemToBuffer.get(shape));\n    };\n    /**\n     * This flags a list of buffers as dirty\n     *\n     * @param buffers\n     */\n    MultiShapeBufferCache.prototype.flagBuffersDirty = function (buffers) {\n        // Flag provided buffers as dirty\n        if (buffers) {\n            // This flags the indicated buffers as dirty\n            buffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n        else {\n            this.store.allBuffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n    };\n    /**\n     * @override\n     * This is called with triggers all of the updates necessary.\n     * We add in our buffer update and invalidation to this process here.\n     *\n     * @param args\n     */\n    MultiShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        // Run the generation which will trigger cache building and modding\n        _super.prototype.generate.apply(this, arguments);\n        // We now invalidate any buffers that have been flagged\n        this.processDirtyBuffers();\n    };\n    /**\n     * @override\n     * This retrieves the multibuffer for this shape buffer\n     */\n    MultiShapeBufferCache.prototype.getBuffer = function () {\n        console.warn('A multishape buffer should have getBuffers called instead');\n        return [];\n    };\n    /**\n     * Get all of the buffers.\n     * WARNING: do NOT modify the output values in any way.\n     *\n     * @return {T[][]} All of the buffers\n     */\n    MultiShapeBufferCache.prototype.getBuffers = function () {\n        if (this.store) {\n            return this.store.allBuffers.map(function (tracker) { return tracker.buffer; });\n        }\n        return [];\n    };\n    /**\n     * Returns the number of buffers this MultiShapeBuffer is managing.\n     */\n    MultiShapeBufferCache.prototype.getNumBuffers = function () {\n        return this.store.allBuffers.length;\n    };\n    /**\n     * Retrieves a shape by the given id. Is undefined if the id is not recognized.\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.getShapeById = function (id) {\n        return this.store.idToItem.get(id);\n    };\n    /**\n     * This makes all buffers a part of a new array pointer thus making sure\n     * they will be committed to the gpu.\n     */\n    MultiShapeBufferCache.prototype.processDirtyBuffers = function () {\n        this.store.allBuffers.forEach(function (tracker) {\n            if (tracker.isDirty) {\n                tracker.isDirty = false;\n                tracker.buffer = [].concat(tracker.buffer);\n            }\n        });\n    };\n    /**\n     * This retrieves the storage inside the selection. If it doesn't exist,\n     * then the storage is created.\n     *\n     * @param selection\n     */\n    MultiShapeBufferCache.prototype.getStorage = function (selection) {\n        // Get the storage from the selection\n        var storage = (selection.getSelection(this.selectionUID) || [])[0];\n        // If the storage is not stored in the selection, then we create a storage and update the selection with that storage\n        if (!storage) {\n            storage = {\n                allBuffers: [],\n                idToItem: new Map(),\n                itemToBuffer: new Map(),\n                selection: selection,\n            };\n            // Generate the buffers indicated\n            for (var i = 0; i < this.numBuffers; ++i) {\n                storage.allBuffers.push({\n                    buffer: [],\n                    isDirty: false,\n                });\n            }\n            // Initialize anything that may be monitoring the buffers\n            this.initMethod(storage.allBuffers);\n            // Add the storage to the selection\n            selection.select(this.selectionUID, storage);\n        }\n        // Make sure our internal pointer to the storage is set correctly\n        return (this.store = storage);\n    };\n    /**\n     * Removes a shape from the buffer it is a part of.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.removeShape = function (shape) {\n        // This is the buffer associated with the shape\n        var buffer = this.store.itemToBuffer.get(shape);\n        // Get the buffers invalidated by the remove\n        var buffers = this.removeMethod(shape, buffer, this.store.allBuffers);\n        // Clear the shape out from the buffer\n        buffer.buffer.splice(buffer.buffer.indexOf(shape), 1);\n        // Delete the item from the id lookup\n        this.store.idToItem.delete(this.idMethod(shape));\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * This is called to indicate an update to an item has occurred.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.updateShape = function (shape) {\n        // Flag each element that needs updating\n        var buffers = this.updateMethod(shape, this.store.itemToBuffer.get(shape), this.store.allBuffers);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    return MultiShapeBufferCache;\n}(shape_buffer_cache_1.ShapeBufferCache));\nexports.MultiShapeBufferCache = MultiShapeBufferCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/multi-shape-buffer-cache.ts\n// module id = 24\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar ShapeBufferCache = (function () {\n    function ShapeBufferCache() {\n        this.buffer = [];\n        this.bustCache = true;\n    }\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    ShapeBufferCache.prototype.generate = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this.bustCache) {\n            this.buildCache.apply(this, args);\n            this.bustCache = false;\n        }\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    ShapeBufferCache.prototype.buildCache = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Get the buffer the cache has generated\n     */\n    ShapeBufferCache.prototype.getBuffer = function () {\n        return this.buffer;\n    };\n    return ShapeBufferCache;\n}());\nexports.ShapeBufferCache = ShapeBufferCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/shape-buffer-cache.ts\n// module id = 25\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./webgl-surface/webgl-surface\"));\n__export(require(\"./webgl-surface/buffers\"));\n__export(require(\"./webgl-surface/drawing\"));\n__export(require(\"./webgl-surface/primitives\"));\n__export(require(\"./webgl-surface/util\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 26\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar React = require(\"react\");\nvar three_1 = require(\"three\");\nvar atlas_manager_1 = require(\"./drawing/texture/atlas-manager\");\nvar atlas_texture_1 = require(\"./drawing/texture/atlas-texture\");\nvar bounds_1 = require(\"./primitives/bounds\");\nvar frame_info_1 = require(\"./util/frame-info\");\nvar mouse_1 = require(\"./util/mouse\");\nvar quad_tree_1 = require(\"./util/quad-tree\");\nvar webgl_stat_1 = require(\"./util/webgl-stat\");\nvar debug = require('debug')('webgl-surface:GPU');\nvar debugCam = require('debug')('webgl-surface:Camera');\nvar debugLabels = require('debug')('webgl-surface:Labels');\nvar debugColors = require('debug')('webgl-surface:Colors');\n/**\n * This enum names the base methods that are passed into the applyPropsMethods\n * method. This allows subclasses to easily pick the property setting methods they need\n * from the base\n */\nvar BaseApplyPropsMethods;\n(function (BaseApplyPropsMethods) {\n    /** Initializes any context that needs to be set up before the props are set */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"INITIALIZE\"] = 0] = \"INITIALIZE\";\n    /** Moment when any buffer changes should be applied */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"BUFFERCHANGES\"] = 1] = \"BUFFERCHANGES\";\n    /** Initializes camera properties to facilitate smoothe start up */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"CAMERA\"] = 2] = \"CAMERA\";\n    /** Generates the labels as images within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"LABELS\"] = 3] = \"LABELS\";\n    /** Generates the colors within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"COLORS\"] = 4] = \"COLORS\";\n})(BaseApplyPropsMethods = exports.BaseApplyPropsMethods || (exports.BaseApplyPropsMethods = {}));\n/**\n * This enum names the base methods that are passed into the animatedMethods\n * method. This allows subsclasses to easily pick the animated methods they need\n * from the base\n */\nvar BaseAnimatedMethods;\n(function (BaseAnimatedMethods) {\n    /** Sets up the base context needed to execute most methods */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"CONTEXT\"] = 0] = \"CONTEXT\";\n    /** Sets up the inertia method for inertial panning */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"INERTIA\"] = 1] = \"INERTIA\";\n    /** Animates the postion of the camera to a destination */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"POSITION\"] = 2] = \"POSITION\";\n    /** Zooms the camera based on a point of focus */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"ZOOM\"] = 3] = \"ZOOM\";\n})(BaseAnimatedMethods = exports.BaseAnimatedMethods || (exports.BaseAnimatedMethods = {}));\nfunction isAnimatedWithOptions(value) {\n    if (value.options) {\n        return true;\n    }\n    return false;\n}\nfunction isAnimated(value) {\n    if (!value.options) {\n        return true;\n    }\n    return false;\n}\n/** This is the smallest increment the zoom can make. Anything less and nothing will happen */\nvar MIN_ZOOM_INCREMENT = 0.001;\nvar BYTE_MAX = 0xFF;\nvar BACKGROUND_COLOR = new three_1.Color().setRGB(38 / BYTE_MAX, 50 / BYTE_MAX, 78 / BYTE_MAX);\n// --[ CONSTANTS ]-------------------------------------------\n// Make a container vector for performing operations within\nvar vector = new three_1.Vector3();\n// --[ SHADERS ]-------------------------------------------\n/**\n * Equivalent of Math.sign, but faster, and works in all browsers\n *\n * @param {number} value The number to determine the sign\n *\n * @return {number} Returns zero if a sign can not be determined, -1 for a negative, 1 for a positive\n */\nfunction sign(value) {\n    if (!value) {\n        return 0;\n    }\n    if (value > 0) {\n        return 1;\n    }\n    if (value < 0) {\n        return -1;\n    }\n    return 0;\n}\n/**\n * The base component for the communications view\n */\nvar WebGLSurface = (function (_super) {\n    __extends(WebGLSurface, _super);\n    function WebGLSurface() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** This is the atlas manager for managing images and labels rendered as textures */\n        _this.atlasManager = new atlas_manager_1.AtlasManager(2048, 2048);\n        /** Tracks the names of the atlas' generated */\n        _this.atlasNames = {\n            colors: 'colors',\n            labels: 'labels',\n        };\n        /**\n         * List of methods that execute within the animation loop. Makes adding and removing these methods\n         * simpler to manage, as well as gives a clear and optimized way of overriding existing methods\n         * or reordering their execution\n         */\n        _this.animatedMethodList = [];\n        /**\n         * If this is set to true during an animated method's lifecycle, then all subsequent animated methods\n         * will not be executed for the current frame. Upon reaching the end of the frame, the break will reset\n         * and the animated methods will attempt executing again\n         */\n        _this.animatedMethodBreak = false;\n        /**\n         * The camera that 'looks' at our world and gives us the ability to convert\n         * screen coordinates to world coordinates, and vice versa\n         */\n        _this.camera = new three_1.OrthographicCamera(0, 0, 0, 0, 0, 0);\n        /**\n         * This is the latest colors loading identifier, used to determine if the colors\n         * last loaded matches the colors currently needing to be rendered. Fixes asynchronous\n         * Issue where a new set of colors is requested before the previous set(s) have completed\n         */\n        _this.colorsCurrentLoadedId = 0;\n        /** This is the is of the current and most recent color group being loaded in */\n        _this.colorsLoadId = 0;\n        /**\n         * While this number is positive it will be decremented every frame.\n         * While positive, mouse interactions will not occur. This utilizes frame ticks\n         * as SOME values and numbers settle per frame, not necessarily within timelapses.\n         * More often than not, there will only be a need for 1-2 frames of mouse disable to\n         * allow the camera to be positioned in a correct location before screen to world projections\n         * start taking place.\n         */\n        _this.disableMouseInteraction = 0;\n        /** Used to aid in mouse interactions */\n        _this.distance = 0;\n        _this.sizeCamera = null;\n        /** Keep track of the current zoom so it can be set in requestAnimationFrame */\n        _this.currentZoom = 1;\n        /** Horizontal destination the camera will pan to */\n        _this.destinationX = 0;\n        /** Vertical position the camera will pan to */\n        _this.destinationY = 0;\n        /** The destination zoom level the camera used during panning */\n        _this.destinationZoom = 1;\n        /** Is the camera currently in a panning state */\n        _this.isPanning = false;\n        /** Last known screen position of the mouse */\n        _this.lastMousePosition = { x: 0, y: 0 };\n        /** List of methods to execute when applying props */\n        _this.propsMethodList = [];\n        /** Inertial values for drag panning */\n        _this.inertia = null;\n        _this.inertiaBuild = 1.5;\n        _this.inertiaDecay = .9;\n        _this.inertiaMax = 100;\n        /**\n         * All data is put into this quad tree so we can query spatial regions for\n         * items\n         */\n        _this.quadTree = null;\n        /**\n         * True if the shift key is currently being held\n         *\n         * Panning is affected by whether or not the shift key is being held down, but\n         * I don't know how yet.\n         */\n        _this.shiftIsDown = false;\n        _this.stop = false;\n        /** The current rendered position and zoom */\n        _this.currentX = 0;\n        _this.currentY = 0;\n        _this.targetZoom = 1;\n        /** The (world) position the focus will zoom in and out of */\n        _this.previousZoomToFit = 0;\n        _this.zoomTargetX = 0;\n        _this.zoomTargetY = 0;\n        /** When this is set, the draw loop continues to run. Used by the draw loop to complete animations */\n        _this.animating = false;\n        _this.labels = [];\n        _this.labelsReady = false;\n        /**\n         * This is the latest labels loading identifier, used to determine if the labels\n         * last loaded matches the labels currently needing to be rendered.\n         */\n        _this.labelsCurrentLoadedId = 0;\n        _this.labelsLoadId = 0;\n        /** When this is set to true, the atlas with the colors is now ready to be referenced */\n        _this.colors = [];\n        _this.colorsReady = false;\n        /** This is a flag that allows some extra control over when an onRender can fire */\n        _this.isRenderReady = true;\n        /** Holds the items currently hovered over */\n        _this.currentHoverItems = [];\n        /** Mouse in stage or not */\n        _this.dragOver = true;\n        /** Flag for detecting whether or not webgl is supported at all */\n        /**\n         * This is the update loop that operates at the requestAnimationFrame speed.\n         * This updates the cameras current position and causes changes over time for\n         * any property that has a start and a destination.\n         */\n        _this.animate = function () {\n            if (_this.stop) {\n                return;\n            }\n            frame_info_1.FrameInfo.lastFrameTime = Date.now();\n            frame_info_1.FrameInfo.framesPlayed.set(_this, (frame_info_1.FrameInfo.framesPlayed.get(_this) || 0) + 1);\n            requestAnimationFrame(function () { return _this.animate(); });\n            var response;\n            var doDraw = false;\n            var didBreak = _this.animatedMethodList.some(function (method) {\n                if (isAnimatedWithOptions(method)) {\n                    if (method.options.labelsReady && method.options.colorsReady) {\n                        if (_this.labelsReady && _this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.labelsReady) {\n                        if (_this.labelsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.colorsReady) {\n                        if (_this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                }\n                else if (isAnimated(method)) {\n                    response = method();\n                }\n                // Update our draw status based on response\n                if (!doDraw) {\n                    doDraw = response.doDraw;\n                }\n                // Stop the system if needed\n                if (response.stop) {\n                    _this.stop = true;\n                }\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            // We prevent any animation loop execution if we did break\n            if (didBreak) {\n                return;\n            }\n            // Make sure all camera related uniforms are up to date\n            _this.updateCameraUniforms();\n            // Handle the deactivation period of mouse interactions by decrementing it\n            // If it's positive\n            if (_this.disableMouseInteraction > 0) {\n                _this.disableMouseInteraction--;\n            }\n            if (doDraw || _this.forceDraw) {\n                _this.forceDraw = false;\n                _this.emitViewport();\n                _this.draw();\n            }\n        };\n        /**\n         * Applies new props injected into this component.\n         *\n         * Applying new props does not entail that a re-render will happen so we\n         * handle application of props as a separate concept. Here we:\n         *\n         * set up zoom targetting and apply quested zoom levels\n         *\n         * Create our quad tree and associate properties to objects if a new dataset\n         * is provided\n         *\n         * Analyze our dataset for interesting and useful metrics such as max and mins\n         * to aid in visualization normalization\n         *\n         * @param {T} props The new properties for this component\n         */\n        _this.applyProps = function (props) {\n            debug('Applying props');\n            var response;\n            _this.propsMethodList.some(function (method) {\n                response = method(props);\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            debugCam('current cam', _this.currentX, _this.currentY, _this.destinationX, _this.destinationY);\n            debugCam('Zoom Target: [%o, %o]', _this.zoomTargetX, _this.zoomTargetY);\n            debugCam('Last Mouse: [%o, %o]', _this.lastMousePosition.x, _this.lastMousePosition.y);\n        };\n        /**\n         * This initializes the surface and calls for sub class classes to initialize\n         * their buffers\n         *\n         * @param {HTMLElement} el The DOM element this component is contained in\n         * @param {number} w The width of the rendering\n         * @param {number} h The height of the rendering\n         */\n        _this.init = function (el, w, h) {\n            if (!el || _this.scene) {\n                return;\n            }\n            _this.renderEl = el;\n            if (w === 0 || h === 0) {\n                return;\n            }\n            debug('Initializing GPU objects el: %o width: %o height: %o', el, w, h);\n            // Set up a ctx for our render space\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2.0,\n                width: w,\n                widthHalf: w / 2.0,\n            };\n            // Set up the camera now that the ctx is set up\n            _this.initCamera();\n            // Create a scene so we can add our buffer objects to it\n            // We also add the scene to the window to make threejs tools available\n            window.scene = _this.scene = new three_1.Scene();\n            // Fire our hook for starting up our specific buffer implementation\n            _this.initBuffers();\n            // FINALIZE SET UP\n            // Generate the renderer along with it's properties\n            _this.renderer = new three_1.WebGLRenderer({\n                alpha: _this.props.backgroundColor && (_this.props.backgroundColor.opacity < 1.0),\n                antialias: true,\n                preserveDrawingBuffer: true,\n            });\n            // This sets the pixel ratio to handle differing pixel densities in screens\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            // Applies the background color and establishes whether or not the context supports\n            // Alpha or not\n            if (_this.props.backgroundColor) {\n                _this.renderer.setClearColor(new three_1.Color(_this.props.backgroundColor.r, _this.props.backgroundColor.g, _this.props.backgroundColor.b), _this.props.backgroundColor.opacity);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            // We render shapes. We care not for culling.\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            // Set up DOM interaction with the renderer\n            var container = el;\n            container.appendChild(_this.renderer.domElement);\n            // Get the gl context for queries and advanced operations\n            _this.gl = _this.renderer.domElement.getContext('webgl');\n            _this.makeDraggable(document.getElementById('div'), _this);\n        };\n        /**\n         * Initializes the camera and any contexts associated with it\n         */\n        _this.initCamera = function () {\n            debug('Initializing Camera');\n            // INITIALIZE THE CAMERA\n            var h = _this.ctx.height;\n            var viewSize = h;\n            var w = _this.ctx.width;\n            var aspectRatio = w / h;\n            var viewport = {\n                aspectRatio: aspectRatio,\n                bottom: -viewSize / 2,\n                far: 10000000,\n                left: (-aspectRatio * viewSize) / 2,\n                near: -100,\n                right: (aspectRatio * viewSize) / 2,\n                top: viewSize / 2,\n                viewSize: viewSize,\n            };\n            _this.camera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.sizeCamera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.camera.position.z = 300;\n            _this.sizeCamera.position.set(0, 0, 300);\n        };\n        /**\n         * This is executed when our rendering surface (the canvas) changes in size in any\n         * way. It will make sure our renderer matches the context to prevent scaling\n         * and other deformations.\n         */\n        _this.resizeContext = function () {\n            var w = _this.props.width;\n            var h = _this.props.height;\n            // See if a renderer even exists yet\n            if (!_this.renderer) {\n                return false;\n            }\n            var renderSize = _this.renderer.getSize();\n            // Check if the resize is needed\n            if (renderSize.width === w && renderSize.height === h) {\n                return false;\n            }\n            debug('RENDERER RESIZE');\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2,\n                width: w,\n                widthHalf: w / 2,\n            };\n            var zoom = _this.camera.zoom;\n            var position = _this.camera.position.clone();\n            _this.initCamera();\n            _this.camera.zoom = zoom;\n            _this.camera.position.set(position.x, position.y, position.z);\n            _this.camera.updateProjectionMatrix();\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            if (_this.props.backgroundColor) {\n                var color = _this.props.backgroundColor;\n                _this.renderer.setClearColor(new three_1.Color(color.r, color.g, color.b), color.opacity < 1.0 ? color.opacity : undefined);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            return true;\n        };\n        /**\n         * This method handles emitting the viewport and the current visible elements\n         * to the subclass that needs detailed information regarding the viewport.\n         */\n        _this.emitViewport = function () {\n            var tl = _this.screenToWorld(0, 0);\n            var br = _this.screenToWorld(_this.ctx.width, _this.ctx.height);\n            _this.camera.updateMatrixWorld(true);\n            var visible = _this.quadTree.query(new bounds_1.Bounds(tl.x, br.x, tl.y, br.y));\n            _this.onViewport(visible, _this.projection, _this.ctx);\n        };\n        /**\n         * Handles mouse interactions when the mouse is pressed on the canvas. This\n         * engages panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseDown = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = true;\n            _this.distance = 0;\n            _this.onMouseDown();\n        };\n        /**\n         * Handles mouse interactions when the mouse is release or left the canvas. This\n         * stops panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseOut = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            _this.distance = 0;\n            _this.onMouseOut();\n        };\n        /**\n         * Handles mouse interactions when the mouse is released on the canvas. This\n         * stops panning and engages click events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseUp = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            // Handle mouse interaction\n            if (_this.distance < 5) {\n                var hitInside = [];\n                // Circle Interaction\n                var hitItems = _this.quadTree.query(world);\n                for (var _i = 0, hitItems_1 = hitItems; _i < hitItems_1.length; _i++) {\n                    var item = hitItems_1[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                    }\n                }\n                // Tell the listener that the user clicked on some items\n                if (hitInside.length) {\n                    _this.onMouseUp(e, hitInside, mouse, world, _this.projection);\n                }\n                else {\n                    _this.onMouseUp(e, null, mouse, world, _this.projection);\n                }\n            }\n        };\n        /**\n         * Handles mouse interactions when the mouse is moving on the canvas. This\n         * causes panning and hover events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseMove = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            var onMouse = _this.props.onMouse;\n            var zoom = _this.props.zoom;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            _this.distance++;\n            // Handle panning\n            if (_this.isPanning) {\n                debug('down and moving ~~');\n                var xDistance = (mouse.x - _this.lastMousePosition.x) / _this.targetZoom;\n                var yDistance = -(mouse.y - _this.lastMousePosition.y) / _this.targetZoom;\n                // Execute the hook to allow subclasses\n                var pan = _this.willPan(xDistance, yDistance);\n                xDistance = pan.x;\n                yDistance = pan.y;\n                _this.destinationX -= xDistance;\n                _this.destinationY -= yDistance;\n                _this.inertia = _this.inertia || { x: 0, y: 0 };\n                if (sign(xDistance) !== sign(_this.inertia.x)) {\n                    _this.inertia.x = 0;\n                }\n                if (sign(yDistance) !== sign(_this.inertia.y)) {\n                    _this.inertia.y = 0;\n                }\n                _this.inertia.x = xDistance * _this.inertiaBuild;\n                _this.inertia.y = yDistance * _this.inertiaBuild;\n                var maxInertia = _this.inertiaMax / zoom;\n                var mag = Math.sqrt(_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y);\n                // Make sure the magnitude of the inertia is less than our max allowed\n                if (mag > maxInertia) {\n                    // Since it's greater, let's confine the inertia's magnitude to the max magnitude\n                    // By normalizing the intertia vector and multilying it by the max\n                    _this.inertia.x = (_this.inertia.x / mag) * maxInertia;\n                    _this.inertia.y = (_this.inertia.y / mag) * maxInertia;\n                }\n            }\n            if (_this.quadTree && !_this.isPanning) {\n                // Empty the last hovered items to populate a new list\n                var currentHoverItems = [];\n                // Handle mouse interaction with items\n                // Interaction with circles\n                var hitItems = _this.quadTree.query(world);\n                var hitInside = [];\n                for (var _i = 0, hitItems_2 = hitItems; _i < hitItems_2.length; _i++) {\n                    var item = hitItems_2[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                        currentHoverItems.push(item);\n                    }\n                }\n                // Inform of all items hit or hovered\n                _this.onMouseHover(hitInside, mouse, world, _this.projection);\n                // Diff the currently hovered items with the old ones to see what is\n                // No longer hit\n                var left = [];\n                for (var _a = 0, _b = _this.currentHoverItems; _a < _b.length; _a++) {\n                    var item = _b[_a];\n                    if (currentHoverItems.indexOf(item) < 0) {\n                        left.push(item);\n                    }\n                }\n                // Inform of all items no longer hovered\n                _this.onMouseLeave(left, mouse, world, _this.projection);\n                _this.currentHoverItems = currentHoverItems;\n            }\n            if (onMouse) {\n                _this.onMouse(mouse, world, _this.isPanning);\n            }\n            _this.lastMousePosition = mouse;\n        };\n        /**\n         * We make the ref application be a declared function so react does not find the need to execute the\n         * application numerous times for a detected changed method\n         *\n         * @param {HTMLElement} n This is the canvas element from the dom\n         */\n        _this.applyRef = function (n) {\n            _this.init(n, _this.props.width, _this.props.height);\n            _this.applyProps(_this.props);\n        };\n        return _this;\n    }\n    /**\n     * This is a hook so subclasses can contribute animated methods to the animation loop and organize the base methods\n     * as desired.\n     *\n     * @param {AnimatedMethodLookup} baseAnimatedMethods The base animated methods referenceable by name\n     * @param {AnimatedMethod[]} orderedBaseAnimatedMethods The base animated methods in their default order for ease of use\n     *\n     * @return {AnimatedMethods[]} The list of animated methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.animatedMethods = function (baseAnimatedMethods, orderedBaseAnimatedMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBaseAnimatedMethods;\n    };\n    /**\n     * This generates the base animated methods lookup.\n     * We do not make these methods a part of the class as this is the base class\n     * We want the start up methods to be inconsequential to sub classes, thus allowing\n     * us to override, sort, or replace the initial methods and have the method get garbage\n     * collected and no longer a part of the object. It is recommended to make the sub classes\n     * actually point to class methods for better clarity\n     *\n     * @return {ANimatedMethodLookup} The base animated methods in a lookup\n     */\n    WebGLSurface.prototype.animatedMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            // Context changes and early checks\n            _a[BaseAnimatedMethods.CONTEXT] = function () {\n                var response = {\n                    break: false,\n                    doDraw: false,\n                };\n                if (_this.resizeContext()) {\n                    response.doDraw = true;\n                }\n                // Quadtree MUST be present to do proper computations\n                if (!_this.quadTree) {\n                    response.break = true;\n                }\n                return response;\n            },\n            // Apply inertia\n            _a[BaseAnimatedMethods.INERTIA] = function () {\n                if (!_this.isPanning) {\n                    if (_this.inertia) {\n                        // Disabled inertia for now\n                        // This.destinationX -= this.inertia.x\n                        // This.destinationY -= this.inertia.y\n                        _this.inertia.x *= _this.inertiaDecay;\n                        _this.inertia.y *= _this.inertiaDecay;\n                        if (_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y < 1) {\n                            _this.inertia = null;\n                        }\n                    }\n                }\n                // A non response\n                return {\n                    doDraw: false,\n                };\n            },\n            // Apply position\n            _a[BaseAnimatedMethods.POSITION] = function () {\n                // If values are transitioned rather than immediately applied, this is\n                // The value you would want the minimum change to be before cutting off\n                // The transition\n                // Const minAdjust = 1 / this.props.zoom\n                // If there is change in X apply the new position to the old\n                // This is where animated values were originally placed and can be placed\n                // Again if a transition is desired\n                var response = {\n                    doDraw: (_this.currentX !== _this.destinationX) || (_this.currentY !== _this.destinationY),\n                };\n                _this.currentX = _this.destinationX;\n                _this.currentY = _this.destinationY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            // Apply zooming\n            _a[BaseAnimatedMethods.ZOOM] = function () {\n                var response = {\n                    doDraw: false,\n                };\n                // Apply Zoom\n                var destZoom = _this.destinationZoom;\n                var dZoom = Math.abs(destZoom - _this.targetZoom);\n                var minDZoom = MIN_ZOOM_INCREMENT;\n                var zoomRate = 3;\n                if (dZoom > minDZoom) {\n                    _this.targetZoom = _this.targetZoom + ((destZoom - _this.targetZoom) / zoomRate);\n                    response.doDraw = true;\n                }\n                else if (dZoom !== 0) {\n                    _this.targetZoom = destZoom;\n                    response.doDraw = true;\n                }\n                // Get the zoom target metrics before zooming\n                var zoomTargetX = _this.zoomTargetX;\n                var zoomTargetY = _this.zoomTargetY;\n                var screenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Update the camera zoom level\n                _this.zoomCamera(_this.targetZoom);\n                // After we have zoomed we see how much our target location moved on screen\n                var newScreenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Now we move our screen by the moved delta to keep it exactly where it was before hand\n                var zoomDX = -(newScreenZoomTarget.x - screenZoomTarget.x) / _this.targetZoom;\n                var zoomDY = (newScreenZoomTarget.y - screenZoomTarget.y) / _this.targetZoom;\n                _this.currentX -= zoomDX;\n                _this.currentY -= zoomDY;\n                _this.destinationX -= zoomDX;\n                _this.destinationY -= zoomDY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for subclasses to be able to apply buffer changes that rely\n     * on colors rendered into the atlas after the system has prepped the colors for render.\n     */\n    WebGLSurface.prototype.applyColorBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * This is a hook for subclasses to be able to apply label buffer changes after the system has\n     * prepped the labels for render.\n     */\n    WebGLSurface.prototype.applyLabelBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * @override\n     * This is a hook so subclasses can contribute property application methods to the applyProps process and organize the base methods\n     * as desired.\n     *\n     * @param {ApplyPropsMethodLookup<T>} basePropsMethods The base props methods referenceable by name\n     * @param {ApplyPropsMethod<T>[]} orderedBasePropsMethods The base animated methods in their default order for ease of use\n     *\n     * @return {ApplyPropsMethod<T>[]} The list of property application methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.applyPropsMethods = function (basePropsMethods, orderedBasePropsMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBasePropsMethods;\n    };\n    /**\n     * This is a hook so subclasses can contribute methods to the applying props procedure and organize the base methods\n     * as desired.\n     *\n     * @return {ApplyPropsMethodLookup<T>} The base apply props method that are indexed for ease of reference\n     */\n    WebGLSurface.prototype.applyPropsMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            _a[BaseApplyPropsMethods.INITIALIZE] = function (props) {\n                var backgroundColor = props.backgroundColor, height = props.height, width = props.width;\n                _this.init(_this.renderEl, width, height);\n                if (!_this.renderEl || width === 0 || height === 0) {\n                    return {\n                        break: true,\n                    };\n                }\n                // Get the target for zooming\n                if (_this.camera) {\n                    var world = _this.screenToWorld(_this.lastMousePosition.x, _this.lastMousePosition.y);\n                    _this.zoomTargetX = world.x;\n                    _this.zoomTargetY = world.y;\n                }\n                if (_this.renderer && backgroundColor) {\n                    var oldColor = _this.props.backgroundColor || {\n                        b: BACKGROUND_COLOR.b,\n                        g: BACKGROUND_COLOR.g,\n                        opacity: 1.0,\n                        r: BACKGROUND_COLOR.r,\n                    };\n                    var same = oldColor.r === backgroundColor.r &&\n                        oldColor.g === backgroundColor.g &&\n                        oldColor.b === backgroundColor.b &&\n                        oldColor.opacity === backgroundColor.opacity;\n                    if (!same) {\n                        _this.renderer.setClearColor(new three_1.Color(backgroundColor.r, backgroundColor.g, backgroundColor.b), \n                        // Only if a transparent background is specified should we\n                        // Allow the parameter. We avoid the parameter to ensure\n                        // Transparent mode it not activated unless absolutely necessary\n                        backgroundColor.opacity < 1 ? backgroundColor.opacity : undefined);\n                    }\n                }\n                debug('props', props);\n                return {};\n            },\n            _a[BaseApplyPropsMethods.LABELS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.labels && props.labels !== _this.labels) {\n                    debugLabels('Labels are being comitted to an Atlas %o', props.labels);\n                    // Flag the labels as incapable of rendering\n                    _this.labelsReady = false;\n                    _this.labelsLoadId++;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.labels = props.labels;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.labels)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.labels);\n                    }\n                    var textures = props.labels.map(function (label) { return new atlas_texture_1.AtlasTexture(null, label); });\n                    debugLabels('Creating the atlas for labels based on these textures %o', textures);\n                    _this.atlasManager.createAtlas(_this.atlasNames.labels, textures)\n                        .then(function () {\n                        debugLabels('Labels rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.labels));\n                        _this.forceDraw = true;\n                        _this.labelsCurrentLoadedId++;\n                        // If we are done loading AND we match up with the current load id, then labels\n                        // For the latest labels update are indeed ready for display\n                        if (_this.labelsCurrentLoadedId === _this.labelsLoadId) {\n                            _this.labelsReady = true;\n                        }\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.COLORS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.colors && props.colors !== _this.colors) {\n                    debugColors('Colors are being comitted to an Atlas %o', props.colors);\n                    // Flag the labels as incapable of rendering\n                    _this.colorsReady = false;\n                    _this.colorsLoadId++;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.colors = props.colors;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.colors)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.colors);\n                    }\n                    _this.atlasManager.createAtlas(_this.atlasNames.colors, null, _this.colors)\n                        .then(function () {\n                        debugColors('Colors rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.colors));\n                        _this.forceDraw = true;\n                        _this.colorsCurrentLoadedId++;\n                        // If we are done loading AND we match up with the current load id, then colors\n                        // For the latest colors update are indeed ready for display. This solves asynchronous\n                        // Issues with multiple color pallette updates\n                        if (_this.colorsCurrentLoadedId === _this.colorsLoadId) {\n                            _this.colorsReady = true;\n                        }\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.BUFFERCHANGES] = function (props) {\n                // Call the hook to allow sub componentry to have a place to update it's buffers\n                _this.applyBufferChanges(props);\n                // We call the label buffering when the labels are ready to render.\n                // Labels now utilize the color atlas as well, thus requiring colors\n                // To be loaded\n                if (_this.labelsReady && _this.colorsReady) {\n                    debugLabels('labels changed %o', props);\n                    _this.applyLabelBufferChanges(props);\n                }\n                // For resources that only need the color atlas to be ready\n                if (_this.colorsReady) {\n                    _this.applyColorBufferChanges(props);\n                }\n                return {};\n            },\n            _a[BaseApplyPropsMethods.CAMERA] = function (props) {\n                _this.destinationZoom = props.zoom;\n                // On initialization this should start with some base camera metrics\n                if (props.viewport && props.viewport !== _this.appliedViewport && _this.quadTree) {\n                    // Position the camera over the mid of the specified viewport\n                    var mid = props.viewport.mid;\n                    _this.currentX = _this.destinationX = mid.x;\n                    _this.currentY = _this.destinationY = mid.y;\n                    // Calculate the zoom needed for the viewport\n                    var zoomToFitViewH = props.width / props.viewport.width;\n                    var zoomToFitViewV = props.height / props.viewport.height;\n                    var zoomToFit = Math.min(zoomToFitViewH, zoomToFitViewV);\n                    // This adjusts the destination zxoom by a tiny amount so the view will redraw\n                    var microAdjustment = 1.001;\n                    // Make our destination zoom a zoom that will fit the dimensions of the viewport\n                    _this.destinationZoom = zoomToFit;\n                    _this.targetZoom = _this.destinationZoom * microAdjustment;\n                    // Make sure any zooming that happens occurs over the middle of the initial viewport\n                    _this.zoomTargetX = mid.x;\n                    _this.zoomTargetY = mid.y;\n                    // Make sure mouse position doesn't mess with the zooming focus either\n                    _this.lastMousePosition.x = props.width / 2.0;\n                    _this.lastMousePosition.y = props.height / 2.0;\n                    // Apply the values immediately to the camera\n                    _this.positionCamera(_this.currentX, _this.currentY);\n                    _this.zoomCamera(_this.targetZoom);\n                    _this.updateCameraUniforms();\n                    // We request the calculated zoom level so adjustments on the input can be made\n                    if (props.onZoomRequest) {\n                        props.onZoomRequest(_this.destinationZoom);\n                        debugCam('Requesting zoom level', _this.destinationZoom);\n                    }\n                    // Let's disable mouse interactions for a little bit until the camera has settled into place\n                    var framesToDisable = 10;\n                    _this.disableMouseInteraction = framesToDisable;\n                    _this.appliedViewport = props.viewport;\n                    debugCam('init cam', _this.currentX, _this.currentY);\n                }\n                // Ensure we have our quad tree available even if it is empty\n                if (!_this.quadTree) {\n                    _this.quadTree = new quad_tree_1.QuadTree(0, 1, 1, 0);\n                }\n                return {};\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for sub components to have a location to update their buffers\n     *\n     * @param {T} props This is the next set of props that are going to be applied to this component\n     */\n    WebGLSurface.prototype.applyBufferChanges = function (props) {\n        // NOTE: This will be implemented by base classes\n    };\n    /**\n     * @override\n     * Start the update loop and register any interesting listeners\n     */\n    WebGLSurface.prototype.componentDidMount = function () {\n        this.animate();\n    };\n    /**\n     * @override\n     * This will set up any unchanging context as well as establish the set of methods\n     * that are to be used within constructed method loops.\n     */\n    WebGLSurface.prototype.componentWillMount = function () {\n        /** Create our context bound projection methods for handing to processes that may need them */\n        this.projection = {\n            screenSizeToWorld: this.screenSizeToWorld.bind(this),\n            screenToWorld: this.screenToWorld.bind(this),\n            worldSizeToScreen: this.worldSizeToScreen.bind(this),\n            worldToScreen: this.worldToScreen.bind(this),\n        };\n        /** Generate our applying props methods to execute within our applyProps process */\n        var basePropsMethods = this.applyPropsMethodsBase();\n        this.propsMethodList = this.applyPropsMethods(basePropsMethods, [\n            basePropsMethods[BaseApplyPropsMethods.INITIALIZE],\n            basePropsMethods[BaseApplyPropsMethods.LABELS],\n            basePropsMethods[BaseApplyPropsMethods.COLORS],\n            basePropsMethods[BaseApplyPropsMethods.BUFFERCHANGES],\n            basePropsMethods[BaseApplyPropsMethods.CAMERA],\n        ]);\n        /** Generate our animated methods to execute within our animation loop */\n        var baseAnimatedMethods = this.animatedMethodsBase();\n        this.animatedMethodList = this.animatedMethods(baseAnimatedMethods, [\n            baseAnimatedMethods[BaseAnimatedMethods.CONTEXT],\n            baseAnimatedMethods[BaseAnimatedMethods.INERTIA],\n            baseAnimatedMethods[BaseAnimatedMethods.POSITION],\n            baseAnimatedMethods[BaseAnimatedMethods.ZOOM],\n        ]);\n    };\n    /**\n     * @override\n     * Simply applies the new injected props\n     *\n     * @param {T} props The new properties to be applied to this component\n     */\n    WebGLSurface.prototype.componentWillReceiveProps = function (props) {\n        this.applyProps(props);\n    };\n    /**\n     * @override\n     * Release listeners and stop update loop\n     */\n    WebGLSurface.prototype.componentWillUnmount = function () {\n        this.stop = true;\n        if (this.quadTree) {\n            this.quadTree.destroy();\n        }\n        this.quadTree = null;\n        this.camera = null;\n        this.sizeCamera = null;\n        this.ctx = null;\n        this.renderEl = null;\n        this.renderer = null;\n        this.scene = null;\n        this.atlasManager.destroyAtlas(this.atlasNames.colors);\n        this.atlasManager.destroyAtlas(this.atlasNames.labels);\n        frame_info_1.FrameInfo.framesPlayed.delete(this);\n    };\n    /**\n     * This is the draw method executed from the animation loop. Everytime, this is\n     * called, the webgl surface will be redrawn.\n     */\n    WebGLSurface.prototype.draw = function () {\n        // Draw the 3D scene\n        this.renderer.render(this.scene, this.camera);\n        if (this.props.onRender && (this.colorsReady || this.colors.length === 0) &&\n            (this.labelsReady || this.labels.length === 0) &&\n            this.isRenderReady) {\n            var imageData = this.renderer.domElement.toDataURL();\n            this.props.onRender(imageData);\n        }\n    };\n    /**\n     * This is a hook allowing sub classes to have a place to initialize their buffers\n     * and materials etc.\n     */\n    WebGLSurface.prototype.initBuffers = function () {\n        // NOTE: This is to be implemented by subclasses\n    };\n    /**\n     * Hook for subclasses to when the mouse moves. Provides some information\n     * about mouse location and interaction.\n     *\n     * @param {IPoint} mouse Position of the mouse relative to the canvas\n     * @param {IPoint} world Position of the mouse relative to the world space\n     * @param {boolean} isPanning The panning state of the mouse\n     */\n    WebGLSurface.prototype.onMouse = function (mouse, world, isPanning) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse down events\n     */\n    WebGLSurface.prototype.onMouseDown = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse out events\n     */\n    WebGLSurface.prototype.onMouseOut = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse up events and the items that were interacted with in the process\n     *\n     * @param {React.MouseEvent} e The react synthetic event associated with the action\n     * @param {Bounds[]} hitInside The items the mouse interacted with\n     * @param {IPoint} mouse The location of the mouse on the screen\n     * @param {IPoint} world The location of the mouse projected into the world\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseUp = function (e, hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse hovering over an item included in the quadtree\n     *\n     * @param {Bounds[]} hitInside The items hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseHover = function (hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse leaving an item included in the quadtree\n     *\n     * @param {Bounds[]} left The items no longer hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseLeave = function (left, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to changes in the viewport and currently visible items\n     *\n     * @param {Bounds[]} visible\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     * @param {IScreenContext} ctx\n     */\n    WebGLSurface.prototype.onViewport = function (visible, projection, ctx) {\n        // NOTE: For subclasses\n    };\n    WebGLSurface.prototype.makeDraggable = function (element, stage) {\n        var _this = this;\n        element.onmousedown = function (event) {\n            stage.dragOver = false;\n            document.onmousemove = function (event) {\n                var mouse = mouse_1.eventElementPosition(event, element);\n                var mouseX = mouse.x;\n                var mouseY = mouse.y;\n                var distanceX = (mouseX - stage.lastMousePosition.x) / stage.targetZoom;\n                var distanceY = (mouseY - stage.lastMousePosition.y) / stage.targetZoom;\n                // Provide the same hook the normal mouse pan does to allow for panning adjustments\n                var pan = _this.willPan(distanceX, distanceY);\n                stage.destinationX -= pan.x;\n                stage.destinationY += pan.y;\n                stage.lastMousePosition.x = mouseX;\n                stage.lastMousePosition.y = mouseY;\n            };\n            document.onmouseup = function () {\n                document.onmousemove = null;\n                stage.isPanning = false;\n                stage.dragOver = true;\n            };\n            document.onmouseover = function () {\n                if (stage.dragOver === false)\n                    stage.isPanning = true;\n            };\n            element.onmouseup = function () {\n                stage.dragOver = true;\n            };\n            // Text will not be selected when it is being dragged\n            element.onselectstart = function () {\n                return false;\n            };\n        };\n    };\n    /**\n     * Places the camera at a given location in world space\n     *\n     * @param {number} x The x-coordinate for the camera in world space\n     * @param {number} y The x-coordinate for the camera in world space\n     */\n    WebGLSurface.prototype.positionCamera = function (x, y) {\n        if (this.camera) {\n            this.camera.position.set(x, y, this.camera.position.z);\n        }\n    };\n    /**\n     * Projects a screen coordinate to a world coordinate\n     *\n     * @param {number} x The x coord within the screen to project into the world\n     * @param {number} y The y coord within the screen to project into the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenToWorld = function (x, y, obj) {\n        // Get the coordinates in normalized screen space\n        vector.set((x / this.ctx.width) * 2 - 1, -(y / this.ctx.height) * 2 + 1, 0.0);\n        // Unproject the normalized space to the world. It will project\n        // The vector to a REALLY far away z coordinate, but it does not matter\n        // Since we are utilizing an orthographic camera (no perspective distortion)\n        vector.unproject(this.camera);\n        obj = obj || { x: 0, y: 0 };\n        obj.x = vector.x;\n        obj.y = vector.y;\n        return obj;\n    };\n    /**\n     * Projects a size on the screen to the size represented in the world\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenSizeToWorld = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        obj.height = h / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        return obj;\n    };\n    /**\n     * Projects a world coordinate to the screen\n     *\n     * @param {number} x The x coord in the world to project to the screen\n     * @param {number} y The y coord in the world to project to the screen\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {IPoint} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldToScreen = function (x, y, obj) {\n        // This projects to NORMALIZED screen space (-1, 1) range for x and y\n        vector.set(x, y, 0);\n        vector.project(this.camera);\n        // Use the window dimensions to denormalize the vector\n        obj = ramda_1.merge(obj || {}, {\n            x: (vector.x * this.ctx.widthHalf) + this.ctx.widthHalf,\n            y: -(vector.y * this.ctx.heightHalf) + this.ctx.heightHalf,\n        });\n        return obj;\n    };\n    /**\n     * Projects a size within the world to how it would appear on the screen\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldSizeToScreen = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w * this.sizeCamera.zoom;\n        obj.height = h * this.sizeCamera.zoom;\n        return obj;\n    };\n    /**\n     * Sets the zoom level the camera will view the world with\n     *\n     * @param {number} zoom The zoom level. Must be > 0\n     */\n    WebGLSurface.prototype.zoomCamera = function (zoom) {\n        this.camera.zoom = zoom;\n        this.sizeCamera.zoom = zoom;\n        this.camera.updateProjectionMatrix();\n        this.sizeCamera.updateProjectionMatrix();\n    };\n    /**\n     * This is a hook allowing a sub class to update uniforms when the camera is changed in\n     * any way\n     */\n    WebGLSurface.prototype.updateCameraUniforms = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * @override\n     * Only re-render if the dimensions of the component have changed. All other\n     * internal render updates are handled internally\n     *\n     * @param {T} nextProps The next properties injected\n     */\n    WebGLSurface.prototype.shouldComponentUpdate = function (nextProps) {\n        return this.props.width !== nextProps.width || this.props.height !== nextProps.height;\n    };\n    /**\n     * Hook to allow subclasses some control over panning distances\n     *\n     * @param {number} distanceX The distance to pan in the x direction\n     * @param {number} distanceY The distance to pan in the y direction\n     *\n     * @return {Vector3} The vector indicating the direction to pan\n     */\n    WebGLSurface.prototype.willPan = function (distanceX, distanceY) {\n        return new three_1.Vector3(distanceX, distanceY, 0.0);\n    };\n    // -----[ Render ]---------------------------------------------\n    //\n    // In a React app, it's nice to put the render function at the bottom of the\n    // File\n    /**\n     * This should only attempt rendering when the canvas DOM element needs to be resized.\n     * You will note shouldComponentUpdate helps facilitate this.\n     */\n    WebGLSurface.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, width = _a.width, height = _a.height;\n        if (!webgl_stat_1.WebGLStat.WEBGL_SUPPORTED) {\n            return React.createElement(\"div\", null, this.props.children || 'Web GL not supported');\n        }\n        return (React.createElement(\"div\", { id: \"div\", onMouseDown: this.handleMouseDown, onMouseOut: this.handleMouseOut, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseOut, onMouseMove: this.handleMouseMove, onDoubleClick: function (e) {\n                if (_this.props.onDoubleClick) {\n                    _this.props.onDoubleClick(e);\n                }\n            }, style: { position: 'relative', width: width, height: height } },\n            React.createElement(\"div\", { ref: this.applyRef })));\n    };\n    return WebGLSurface;\n}(React.Component));\nexports.WebGLSurface = WebGLSurface;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/webgl-surface.tsx\n// module id = 27\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_28__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 28\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3-color\"\n// module id = 29\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 30\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/debug.js\n// module id = 31\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms/index.js\n// module id = 32\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_33__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bowser\"\n// module id = 33\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./animated/shared-control-curved-line-buffer-ants\"));\n__export(require(\"./animated/shared-control-curved-line-colors-buffer\"));\n__export(require(\"./animated/uniform-instance-arc-buffer-ants\"));\n__export(require(\"./base-buffer\"));\n__export(require(\"./static/shared-control-curved-line-buffer\"));\n__export(require(\"./static/simple-bezier-line-buffer\"));\n__export(require(\"./static/simple-circle-buffer\"));\n__export(require(\"./static/simple-label-buffer\"));\n__export(require(\"./static/simple-line-buffer\"));\n__export(require(\"./static/simple-straight-line-buffer\"));\n__export(require(\"./static/uniform-instance-arc-buffer\"));\n__export(require(\"./static/uniform-instance-edge-buffer\"));\n__export(require(\"./static/uniform-ribbon-buffer\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/index.ts\n// module id = 34\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBufferAnts = (function (_super) {\n    __extends(SharedControlCurvedLineBufferAnts, _super);\n    function SharedControlCurvedLineBufferAnts() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBufferAnts.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'marching',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBufferAnts.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer && buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var marchingAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var antLength;\n        var antGap;\n        var antSpeed;\n        var controlPoint;\n        var controlRef;\n        // We can not accurately send very large numbers via float point into the attributes\n        // So we trim down our time sent to the attribute down to a number that is less than\n        // 16,777,217 which means we can only reliably grab the last 7 digits of the date's time\n        var antStartTime = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            // We will not render the curved line with this buffer if the marching ants are not provided\n            if (!curvedLine.marchingAnts) {\n                console.error('Attempted to render a curved line shape with a marching ant buffer but provided no marching ant metrics. This curved line shape will be skipped', curvedLine);\n                return \"continue\";\n            }\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            antGap = curvedLine.marchingAnts.gapLength;\n            antSpeed = curvedLine.marchingAnts.speed;\n            antLength = curvedLine.marchingAnts.strokeLength + curvedLine.marchingAnts.gapLength;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, marching, mpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                marching[mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, buffer_1 = buffer; _i < buffer_1.length; _i++) {\n            var curvedLine = buffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBufferAnts;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBufferAnts = SharedControlCurvedLineBufferAnts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/animated/shared-control-curved-line-buffer-ants.ts\n// module id = 35\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineColorsBuffer = (function (_super) {\n    __extends(SharedControlCurvedLineColorsBuffer, _super);\n    function SharedControlCurvedLineColorsBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'colorPicks',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'timing',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (shapeBuffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var uniforms;\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\n            var colorRef = shapeBuffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var timingAttributeSize = 2;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorStartStop;\n        var colorEnd;\n        var colorEndStop;\n        var alpha;\n        var startTime;\n        var duration;\n        var controlRef;\n        var controlPoint;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorEnd = curvedLine.endColor.base.colorIndex;\n            colorEndStop = curvedLine.endColorStop.base.colorIndex;\n            colorStart = curvedLine.startColor.base.colorIndex;\n            colorStartStop = curvedLine.startColorStop.base.colorIndex;\n            duration = curvedLine.duration;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.currentStart;\n            p2 = curvedLine.currentEnd;\n            startTime = curvedLine.startTime;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colorPicks, cpos, controlPick, ctpos, timing, tpos, normals, npos, endPoints, epos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                controlPick[ctpos] = controlRef;\n                cpos += colorAttributeSize;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[wpos] = halfWidthSize;\n                normals[npos] = 1;\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                tpos += timingAttributeSize;\n                // TR\n                colorPicks[cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[tpos] = startTime;\n                timing[++tpos] = duration;\n                // BR\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // TL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // BL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++ctpos] = controlRef;\n            }, \n            // We force updates for this buffer since it has animated properties\n            // Such as currentStartStop and currentEndStop which calculates\n            // Animations on the CPU side.\n            true);\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineColorsBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineColorsBuffer = SharedControlCurvedLineColorsBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/animated/shared-control-curved-line-colors-buffer.ts\n// module id = 36\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceArcBufferAnts = (function (_super) {\n    __extends(UniformInstanceArcBufferAnts, _super);\n    function UniformInstanceArcBufferAnts() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    UniformInstanceArcBufferAnts.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'halfLineWidth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'maxResolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 3,\n                name: 'marching',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            // Commit static curved lines\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceArcBufferAnts.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        // This let's us know if we're maxing out the instances this buffer can handle\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, halfLineWidth, resolution, maxResolution, depth, endpoints, marching) {\n            var curve = buffer[instance];\n            var antLength = curve.marchingAnts.strokeLength + curve.marchingAnts.gapLength;\n            controlPoints.x = curve.controlPoints[controlPointSource].x;\n            controlPoints.y = curve.controlPoints[controlPointSource].y;\n            startColor.z = curve.startColor.base.colorIndex;\n            endColor.w = curve.endColor.base.colorIndex;\n            halfLineWidth.x = curve.lineWidth / 2.0;\n            resolution.y = curve.resolution;\n            maxResolution.z = MAX_SEGMENTS_PER_CURVE;\n            depth.w = curve.depth;\n            endpoints.x = curve.start.x;\n            endpoints.y = curve.start.y;\n            endpoints.z = curve.end.x;\n            endpoints.w = curve.end.y;\n            marching.x = 0;\n            marching.y = curve.marchingAnts.speed;\n            marching.z = curve.marchingAnts.gapLength;\n            marching.w = antLength;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformInstanceArcBufferAnts;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceArcBufferAnts = UniformInstanceArcBufferAnts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/animated/uniform-instance-arc-buffer-ants.ts\n// module id = 37\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBuffer = (function (_super) {\n    __extends(SharedControlCurvedLineBuffer, _super);\n    function SharedControlCurvedLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var controlPoint;\n        var controlRef;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, buffer_1 = buffer; _i < buffer_1.length; _i++) {\n            var curvedLine = buffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBuffer = SharedControlCurvedLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/shared-control-curved-line-buffer.ts\n// module id = 38\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This ONLY supports a single color\n */\nvar SimpleStaticBezierLineBuffer = (function (_super) {\n    __extends(SimpleStaticBezierLineBuffer, _super);\n    function SimpleStaticBezierLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticBezierLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0, 0],\n                name: 'controlPoint',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticBezierLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var color;\n        var alpha;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            color = curvedLine.startColor.base.color;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colors, cpos, normals, npos, endPoints, epos, controlPoints, copos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                cpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticBezierLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticBezierLineBuffer = SimpleStaticBezierLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-bezier-line-buffer.ts\n// module id = 39\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(value) {\n    return Array.isArray(value[0]);\n}\nvar SimpleStaticCircleBuffer = (function (_super) {\n    __extends(SimpleStaticCircleBuffer, _super);\n    function SimpleStaticCircleBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticCircleBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'radius',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'innerRadius',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'innerColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 1;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Points(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticCircleBuffer.prototype.update = function (shapeBuffer, atlasManager, camera) {\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (!buffer || buffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        if (atlasManager) {\n            var colorRef = buffer[0].outerColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n            if (camera) {\n                uniforms.zoom.value = camera.zoom;\n            }\n        }\n        var needsUpdate = false;\n        var circle;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, 1, buffer.length, function (i, positions, ppos, radius, rpos, innerRadius, irpos, color, cpos, innerColor, icpos) {\n            circle = buffer[i];\n            // These are point sprites, so just update a single vertex\n            positions[ppos] = circle._centerX;\n            positions[++ppos] = circle._centerY;\n            positions[++ppos] = circle.depth;\n            radius[rpos] = circle._radius;\n            innerRadius[irpos] = circle.innerRadius || 0.0;\n            color[cpos] = circle.outerColor.base.colorIndex;\n            innerColor[icpos] = circle.innerColor ? circle.innerColor.base.colorIndex : 0;\n        });\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, buffer.length);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticCircleBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticCircleBuffer = SimpleStaticCircleBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-circle-buffer.ts\n// module id = 40\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticLabelBuffer = (function (_super) {\n    __extends(SimpleStaticLabelBuffer, _super);\n    function SimpleStaticLabelBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLabelBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 1],\n                name: 'texCoord',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'size',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0, 0],\n                name: 'anchor',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLabelBuffer.prototype.update = function (shapeBuffer, atlasManager, startFade, endFade, labelMaxSize) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // Make some constants and props for our buffer update loop\n        var numVerticesPerQuad = 6;\n        var label;\n        var texture;\n        var color;\n        var alpha;\n        var anchor;\n        var labelSize;\n        if (atlasManager && buffer.length > 0) {\n            var colorRef = buffer[0].color;\n            var labelBase = buffer[0].baseLabel;\n            if (colorRef && labelBase) {\n                var colorBase = colorRef.base;\n                var material = this.bufferItems.system.material;\n                var uniforms = material.uniforms;\n                var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n                var texture_1 = atlasManager.getAtlasTexture(labelBase.rasterizedLabel.atlasReferenceID);\n                if (uniforms.colorAtlas.value !== atlas) {\n                    uniforms.colorAtlas.value = atlas;\n                    uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n                    uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n                    uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n                    atlas.needsUpdate = true;\n                }\n                if (uniforms.atlasTexture.value !== texture_1) {\n                    uniforms.atlasTexture.value = texture_1;\n                    texture_1.needsUpdate = true;\n                    texture_1.anisotropy = 2;\n                }\n                if (startFade || endFade || labelMaxSize) {\n                    material = this.bufferItems.system.material;\n                    uniforms = material.uniforms;\n                    uniforms.startFade.value = startFade || 0;\n                    uniforms.endFade.value = endFade || 0;\n                    uniforms.maxLabelSize.value = labelMaxSize || 0;\n                }\n            }\n        }\n        var updated = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerQuad, buffer.length, function (i, positions, ppos, colors, cpos, texCoords, tpos, sizes, spos, anchors, apos) {\n            label = buffer[i];\n            texture = label.rasterizedLabel;\n            color = label.color.base;\n            alpha = label.color.base.opacity;\n            anchor = {\n                x: label.getLocation().x,\n                y: label.getLocation().y,\n            };\n            labelSize = label.getSize();\n            // Make sure the label is updated with it's latest metrics\n            label.update();\n            // Copy first vertex twice for intro degenerate tri\n            positions[ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[cpos] = color.colorIndex;\n            sizes[spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TR\n            positions[++ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BR\n            positions[++ppos] = label.BR.x;\n            positions[++ppos] = label.BR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBR.x;\n            texCoords[++tpos] = texture.atlasBR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TL\n            positions[++ppos] = label.TL.x;\n            positions[++ppos] = label.TL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTL.x;\n            texCoords[++tpos] = texture.atlasTL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BL\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // Copy last vertex again for degenerate tri\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n        });\n        this.bufferItems.geometry.setDrawRange(0, numVerticesPerQuad * buffer.length);\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return updated;\n    };\n    return SimpleStaticLabelBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLabelBuffer = SimpleStaticLabelBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-label-buffer.ts\n// module id = 41\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nvar SimpleStaticLineBuffer = (function (_super) {\n    __extends(SimpleStaticLineBuffer, _super);\n    function SimpleStaticLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var colorAttributeSize = 4;\n        var stripPos = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var TR;\n        var BR;\n        var TL;\n        var BL;\n        var color;\n        var alpha;\n        var _loop_1 = function (curvedLine) {\n            var strip = curvedLine.getTriangleStrip();\n            color = curvedLine.startColor.base.color;\n            alpha = curvedLine.startColor.base.opacity;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, strip.length / 4, function (i, positions, ppos, colors, cpos) {\n                stripPos = i * 4;\n                TR = strip[stripPos];\n                BR = strip[stripPos + 1];\n                TL = strip[stripPos + 2];\n                BL = strip[stripPos + 3];\n                // 1\n                positions[ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n                // 2\n                positions[++ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 3\n                positions[++ppos] = BR.x;\n                positions[++ppos] = BR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 4\n                positions[++ppos] = TL.x;\n                positions[++ppos] = TL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 5\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 6\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n            });\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLineBuffer = SimpleStaticLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-line-buffer.ts\n// module id = 42\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar point_1 = require(\"../../primitives/point\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticStraightLineBuffer = (function (_super) {\n    __extends(SimpleStaticStraightLineBuffer, _super);\n    function SimpleStaticStraightLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticStraightLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticStraightLineBuffer.prototype.update = function (shapeBuffer, atlasManager) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var TR = point_1.Point.zero();\n        var BR = point_1.Point.zero();\n        var TL = point_1.Point.zero();\n        var BL = point_1.Point.zero();\n        var startColor = 0;\n        var endColor = 0;\n        var line;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerSegment, buffer.length, function (i, positions, ppos, color, cpos) {\n            line = buffer[i];\n            startColor = line.startColor.base.colorIndex;\n            endColor = line.endColor.base.colorIndex;\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TR);\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BR);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TL);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BL);\n            // 1\n            positions[ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            cpos += 1.0;\n            // 2\n            positions[++ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            color[cpos] = endColor;\n            // 3\n            positions[++ppos] = BR.x;\n            positions[++ppos] = BR.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = endColor;\n            // 4\n            positions[++ppos] = TL.x;\n            positions[++ppos] = TL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 5\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 6\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n        });\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n            // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n            // Come into existance) we must explicitly ensure the current data is set to the actual\n            // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n            if (isCluster(shapeBuffer)) {\n                this.bufferItems.currentData = shapeBuffer;\n            }\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticStraightLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticStraightLineBuffer = SimpleStaticStraightLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-straight-line-buffer.ts\n// module id = 43\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceArcBuffer = (function (_super) {\n    __extends(UniformInstanceArcBuffer, _super);\n    function UniformInstanceArcBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    UniformInstanceArcBuffer.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'halfLineWidth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'maxResolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            // Commit static curved lines\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceArcBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        // This let's us know if we're maxing out the instances this buffer can handle\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, halfLineWidth, resolution, maxResolution, depth, endpoints) {\n            var curve = buffer[instance];\n            controlPoints.x = curve.controlPoints[controlPointSource].x;\n            controlPoints.y = curve.controlPoints[controlPointSource].y;\n            startColor.z = curve.startColor.base.colorIndex;\n            endColor.w = curve.endColor.base.colorIndex;\n            halfLineWidth.x = curve.lineWidth / 2.0;\n            resolution.y = curve.resolution;\n            maxResolution.z = MAX_SEGMENTS_PER_CURVE;\n            depth.w = curve.depth;\n            endpoints.x = curve.start.x;\n            endpoints.y = curve.start.y;\n            endpoints.z = curve.end.x;\n            endpoints.w = curve.end.y;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformInstanceArcBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceArcBuffer = UniformInstanceArcBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/uniform-instance-arc-buffer.ts\n// module id = 44\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceEdgeBuffer = (function (_super) {\n    __extends(UniformInstanceEdgeBuffer, _super);\n    function UniformInstanceEdgeBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    UniformInstanceEdgeBuffer.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'sizes',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 1,\n                name: 'maxResolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            // Commit static curved lines\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedEdgeShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceEdgeBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        // This let's us know if we're maxing out the instances this buffer can handle\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, sizes, maxResolution, depth, endpoints) {\n            var curve = buffer[instance];\n            controlPoints.x = curve.controlPoints[controlPointSource].x;\n            controlPoints.y = curve.controlPoints[controlPointSource].y;\n            startColor.z = curve.startColor.base.colorIndex;\n            endColor.w = curve.endColor.base.colorIndex;\n            sizes.x = curve.startWidth / 2.0;\n            sizes.y = curve.endWidth / 2.0;\n            maxResolution.z = MAX_SEGMENTS_PER_CURVE;\n            depth.w = curve.depth;\n            endpoints.x = curve.start.x;\n            endpoints.y = curve.start.y;\n            endpoints.z = curve.end.x;\n            endpoints.w = curve.end.y;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformInstanceEdgeBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceEdgeBuffer = UniformInstanceEdgeBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/uniform-instance-edge-buffer.ts\n// module id = 45\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\n// CONSTANT\nvar MAX_SEGMENTS_PER_CURVE = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = VERTICES_PER_SEGMENT * MAX_SEGMENTS_PER_CURVE;\n/**\n * THRESHOLD sets the number of instance to render both ends of ribbon\n * In order to make both ends round\n */\nvar THRESHOLD = 30;\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\nvar UniformRibbonBuffer = (function (_super) {\n    __extends(UniformRibbonBuffer, _super);\n    function UniformRibbonBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    UniformRibbonBuffer.prototype.init = function (material, unitCount, shared) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'endPoints1',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 2,\n                name: 'endPoints2',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 3,\n                name: 'centers',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 4,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 4,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 4,\n                name: 'threshold',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n        ];\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n        ];\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        if (shared) {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.shareBuffer(this.bufferItems.attributes, shared.bufferItems.geometry);\n        }\n        else {\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances, this.bufferItems.attributes);\n            buffer_util_1.BufferUtil.beginUpdates();\n            var _loop_1 = function (instance) {\n                buffer_util_1.BufferUtil.updateBuffer([], this_1.bufferItems, VERTICES_PER_SEGMENT, MAX_SEGMENTS_PER_CURVE, function (i, positions, ppos) {\n                    // Copy first vertex twice for intro degenerate tri\n                    // Skip over degenerate tris color\n                    positions[ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TR\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // BR\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i + 1;\n                    positions[++ppos] = instance;\n                    // TL\n                    positions[++ppos] = 1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // BL\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                    // Copy last vertex again for degenerate tri\n                    // Skip over degenerate tris for color\n                    positions[++ppos] = -1;\n                    positions[++ppos] = i;\n                    positions[++ppos] = instance;\n                });\n            };\n            var this_1 = this;\n            for (var instance = 0; instance < this.bufferItems.uniformBuffer.maxInstances; ++instance) {\n                _loop_1(instance);\n            }\n            buffer_util_1.BufferUtil.endUpdates();\n            this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances);\n        }\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    UniformRibbonBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        if (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n            console.warn('Too many shapes provided for a uniform instancing buffer.', 'Max supported:', this.bufferItems.uniformBuffer.maxInstances, 'Shapes provided:', buffer.length, 'This shape buffer should be split across more uniform instancing buffers to render correctly.', 'Consider using the MultiShapeBufferCache. If this is already in use:', 'Consider raising the number of buffers it splits across');\n        }\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        buffer_util_1.BufferUtil.updateUniformBuffer(buffer, this.bufferItems, buffer.length, function (instance, controlPoints, startColor, endColor, endPoints1, endPoints2, centers, depth, resolution, threshold) {\n            var ribbon = buffer[instance];\n            controlPoints.x = ribbon.controlPoints[controlPointSource].x;\n            controlPoints.y = ribbon.controlPoints[controlPointSource].y;\n            startColor.z = ribbon.startColor.base.colorIndex;\n            endColor.w = ribbon.endColor.base.colorIndex;\n            endPoints1.x = ribbon.start.x;\n            endPoints1.y = ribbon.start.y;\n            endPoints1.z = ribbon.start2.x;\n            endPoints1.w = ribbon.start2.y;\n            endPoints2.x = ribbon.end.x;\n            endPoints2.y = ribbon.end.y;\n            endPoints2.z = ribbon.end2.x;\n            endPoints2.w = ribbon.end2.y;\n            centers.x = ribbon.center1.x;\n            centers.y = ribbon.center1.y;\n            centers.z = ribbon.center2.x;\n            centers.w = ribbon.center2.y;\n            depth.x = ribbon.depth;\n            resolution.y = MAX_SEGMENTS_PER_CURVE;\n            threshold.z = THRESHOLD;\n            threshold.w = THRESHOLD;\n        });\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        this.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE * buffer.length);\n        return true;\n    };\n    return UniformRibbonBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformRibbonBuffer = UniformRibbonBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/uniform-ribbon-buffer.ts\n// module id = 46\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./reference/reference-color\"));\n__export(require(\"./animation/animated-curved-line-shape\"));\n__export(require(\"./shape/circle-shape\"));\n__export(require(\"./shape/curved-edge-shape\"));\n__export(require(\"./shape/curved-line-shape\"));\n__export(require(\"./shape/edge-shape\"));\n__export(require(\"./shape/image-shape\"));\n__export(require(\"./shape/label\"));\n__export(require(\"./shape/line-shape\"));\n__export(require(\"./shape/quad-shape\"));\n__export(require(\"./shape/ribbon-shape\"));\n__export(require(\"./texture/atlas-color\"));\n__export(require(\"./texture/atlas-manager\"));\n__export(require(\"./texture/atlas-texture\"));\n__export(require(\"./texture/sprite\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/index.ts\n// module id = 47\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines a reference to a color that has been rendered to a texture\n * (See AtlasColor). This exposes the only properties that MAY be utilized\n * in a shader to modify the existing values without altering what is rendered\n * on the texture.\n */\nvar ReferenceColor = (function () {\n    /**\n     * Creates an instance of ReferenceColor.\n     *\n     * @param {AtlasColor} base The color to be based off of\n     */\n    function ReferenceColor(base) {\n        this.base = base;\n    }\n    return ReferenceColor;\n}());\nexports.ReferenceColor = ReferenceColor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/reference/reference-color.ts\n// module id = 48\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar easing_1 = require(\"../../util/easing\");\nvar frame_info_1 = require(\"../../util/frame-info\");\nvar interpolation_1 = require(\"../../util/interpolation\");\nvar curved_line_shape_1 = require(\"../shape/curved-line-shape\");\n/**\n * This represents curved lines and what it would take to animate various properties.\n * While this provides helpers to aid in animating the properties, it is up to\n * buffers, shaders and materials to render those changes appropriately.\n */\nvar AnimatedCurvedLineShape = (function (_super) {\n    __extends(AnimatedCurvedLineShape, _super);\n    function AnimatedCurvedLineShape(options) {\n        var _this = _super.call(this, options) || this;\n        /**\n         * This defines the suggested easing for the animation for any of\n         * the values.\n         */\n        _this.easing = easing_1.linear;\n        _this._startColorChange = new three_1.Color(0, 0, 0);\n        _this._endColorChange = new three_1.Color(0, 0, 0);\n        /** The starting end point's destination */\n        _this.startStop = { x: 0, y: 0 };\n        _this.endStop = { x: 0, y: 0 };\n        /**\n         * This calculates the current start color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentStartColor = new three_1.Color(0, 0, 0);\n        /**\n         * This calculates the current end color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentEndColor = new three_1.Color(0, 0, 0);\n        if (options) {\n            _this.startStop = options.startStop || { x: 0, y: 0 };\n            _this.endStop = options.endStop || { x: 0, y: 0 };\n            if (options.startColorStop) {\n                _this.startColorStop = options.startColorStop;\n            }\n            if (options.endColorStop) {\n                _this.endColorStop = options.endColorStop;\n            }\n        }\n        return _this;\n    }\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"startColorStop\", {\n        get: function () {\n            return this._startColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._startColorStop = value;\n            this._startColorChange.r = newBase.r - startBase.r;\n            this._startColorChange.g = newBase.g - startBase.g;\n            this._startColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"endColorStop\", {\n        get: function () {\n            return this._endColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._endColorStop = value;\n            this._endColorChange.r = newBase.r - startBase.r;\n            this._endColorChange.g = newBase.g - startBase.g;\n            this._endColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStartColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var startBase = this.startColor.base.color;\n            this._currentStartColor.r = this.easing(time, startBase.r, this._startColorChange.r, this.duration);\n            this._currentStartColor.g = this.easing(time, startBase.g, this._startColorChange.g, this.duration);\n            this._currentStartColor.b = this.easing(time, startBase.b, this._startColorChange.b, this.duration);\n            return this._currentStartColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEndColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var endBase = this.endColor.base.color;\n            this._currentEndColor.r = this.easing(time, endBase.r, this._endColorChange.r, this.duration);\n            this._currentEndColor.g = this.easing(time, endBase.g, this._endColorChange.g, this.duration);\n            this._currentEndColor.b = this.easing(time, endBase.b, this._endColorChange.b, this.duration);\n            return this._currentEndColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStart\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            var newStart = interpolation_1.circular(easedTime, this.start, this.startStop, this.controlPoints[1]);\n            return newStart;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEnd\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            // Apply the circular interpolation to the points\n            return interpolation_1.circular(easedTime, this.end, this.endStop, this.controlPoints[1]);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AnimatedCurvedLineShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.AnimatedCurvedLineShape = AnimatedCurvedLineShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/animation/animated-curved-line-shape.ts\n// module id = 49\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar circle_1 = require(\"../../primitives/circle\");\n/**\n * Defines a circular shape that can be drawn\n */\nvar CircleShape = (function (_super) {\n    __extends(CircleShape, _super);\n    /**\n     * Sets the properties of the shape to be drawn\n     *\n     * @param {ICircleShapeOptions} options The options for the shape\n     */\n    function CircleShape(options) {\n        var _this = _super.call(this, options) || this;\n        _this.depth = options.depth || 0;\n        _this.innerColor = options.innerColor;\n        _this.innerRadius = options.innerRadius;\n        _this.outerColor = options.outerColor;\n        return _this;\n    }\n    /**\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this circleshape\n     */\n    CircleShape.prototype.clone = function (newProperties) {\n        var instance = new CircleShape(this);\n        instance.d = this.d;\n        return instance;\n    };\n    return CircleShape;\n}(circle_1.Circle));\nexports.CircleShape = CircleShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/circle-shape.ts\n// module id = 50\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar curved_line_shape_1 = require(\"./curved-line-shape\");\n/**\n * A curved edge will be the same as a curved line, but it will have the properties to properly\n * define a curved shape that interpolates between two widths from start to end.\n */\nvar CurvedEdgeShape = (function (_super) {\n    __extends(CurvedEdgeShape, _super);\n    function CurvedEdgeShape(options) {\n        var _this = _super.call(this, options) || this;\n        _this.startWidth = options.startWidth;\n        _this.endWidth = options.endWidth;\n        return _this;\n    }\n    return CurvedEdgeShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.CurvedEdgeShape = CurvedEdgeShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/curved-edge-shape.ts\n// module id = 51\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"../../primitives/line\");\nvar line_shape_1 = require(\"./line-shape\");\n/**\n * This defines an edge that can be drawn.\n * This type of edge is a quad with distorted ends. The quad will represent a\n * line with each end having potentially different sizes thus giving a four sided\n * polygon rather than a parallelogram.\n *\n * The edge shape also doubles up as a simple line shape should it be desired to\n * render differently.\n */\nvar EdgeShape = (function (_super) {\n    __extends(EdgeShape, _super);\n    /**\n     * Constructor with basic parameters to declare an edge\n     *\n     * @param p1 The point the edge begins at\n     * @param p2 The point the edge terminates at\n     * @param d The data associated with the edge\n     * @param p1Col The color at the start point\n     * @param p2Col The color at the end point\n     * @param p1Width The width at the start point. Example: if you specify 4, then\n     *                the start part of the edge will fan out 2 on either side of the\n     *                start point\n     * @param p2Width The width at the end point. Example: if you specify 4, then\n     *                the end part of the edge will fan out 2 on either side of the\n     *                end point\n     */\n    function EdgeShape(options) {\n        var _this = \n        // Set up all of our line shape based metrics\n        _super.call(this, Object.assign(options, {\n            thickness: options.startWidth,\n        })) || this;\n        /** Top left of the quad to generate this edge */\n        _this.tl = { x: 0, y: 0 };\n        /** Bottom left of the quad to generate this edge */\n        _this.bl = { x: 0, y: 0 };\n        /** Top right of the quad to generate this edge */\n        _this.tr = { x: 0, y: 0 };\n        /** Bottom Right of the quad to generate this edge */\n        _this.br = { x: 0, y: 0 };\n        /** The width of the edge at the termination point */\n        _this.endWidth = 1;\n        _this.endWidth = options.endWidth || 1.0;\n        _this.setPoints(options.p1, options.p2);\n        return _this;\n    }\n    /**\n     * Clones this instance of the edge shape and creates a new instance of an edge shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {EdgeShape} A newly cloned instance of this edgeshape\n     */\n    EdgeShape.prototype.clone = function (newProperties) {\n        return Object.assign(new EdgeShape(Object.assign(this, {\n            startWidth: this.thickness,\n        })), newProperties);\n    };\n    /**\n     * Algorithm provided by\n     * https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n     * Adapted to Javascript by Chris @ VoidRay co\n     *\n     * Remember the point must be in the same\n     * coordinate system that the edge is using\n     *\n     * @param {number} point The point to test\n     *\n     * @return {boolean} True if the point is inside the edge\n     */\n    EdgeShape.prototype.pointInside = function (point) {\n        var testx = point.x;\n        var testy = point.y;\n        // This is an algortihm to handle any number of points for a polygon. In this\n        // Case our polygon is simply the points that make this fat edge. Note:\n        // The points MUST be in CW order\n        var points = [this.tl, this.tr, this.br, this.bl];\n        var numberVertices = points.length;\n        var isClockwise = false;\n        for (var i = 0, j = numberVertices - 1; i < numberVertices; j = i++) {\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\n                    (points[j].y - points[i].y) + points[i].x)) {\n                isClockwise = !isClockwise;\n            }\n        }\n        return isClockwise;\n    };\n    /**\n     * @override\n     * This sets the two endpoints for this edge and recalculates the bounds\n     * of the edge accordingly.\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    EdgeShape.prototype.setPoints = function (p1, p2) {\n        _super.prototype.setPoints.call(this, p1, p2);\n        if (this.tl) {\n            // Get the distance from the points we will go based on specified widths\n            var p1Dx = this.thickness / 2;\n            var p2Dx = this.endWidth / 2;\n            // Calculate the deltas to get from point to quad edge\n            var p1DeltaX = this.perpendicular.x * p1Dx;\n            var p1DeltaY = this.perpendicular.y * p1Dx;\n            var p2DeltaX = this.perpendicular.x * p2Dx;\n            var p2DeltaY = this.perpendicular.y * p2Dx;\n            // Apply the metrics to our quad points\n            // Start side of the edge\n            this.tl.x = this.p1.x + p1DeltaX;\n            this.tl.y = this.p1.y + p1DeltaY;\n            this.bl.x = this.p1.x - p1DeltaX;\n            this.bl.y = this.p1.y - p1DeltaY;\n            // End side of the edge\n            this.tr.x = this.p2.x + p2DeltaX;\n            this.tr.y = this.p2.y + p2DeltaY;\n            this.br.x = this.p2.x - p2DeltaX;\n            this.br.y = this.p2.y - p2DeltaY;\n            // Create lines for the edges for computations and faster hit detections\n            this.topEdge = new line_1.Line(this.tl, this.tr);\n            this.bottomEdge = new line_1.Line(this.bl, this.br);\n            // Make sure our bounds reflects the entirety of the fat edge\n            this.encapsulatePoints([this.tl, this.tr, this.bl, this.br]);\n        }\n    };\n    return EdgeShape;\n}(line_shape_1.LineShape));\nexports.EdgeShape = EdgeShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/edge-shape.ts\n// module id = 52\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../../primitives/bounds\");\n/**\n * Defines an image that can be rendered by the gpu. This is an axis oriented\n * image only (no rotations)\n */\nvar ImageShape = (function (_super) {\n    __extends(ImageShape, _super);\n    /**\n     * Generates a new ImageShape that can be rendered\n     *\n     * @param {AtlasTexture} image The AtlasTexture to use when rendering this image\n     * @param {number} size This is the size of the longest edge of the image while\n     *                      retaining aspect ratio.\n     */\n    function ImageShape(image, size) {\n        var _this = _super.call(this, 0, 0, size, size) || this;\n        /** This is the level of opacity the image will be rendered with */\n        _this.opacity = 1.0;\n        _this.texture = image;\n        _this.size = size;\n        return _this;\n    }\n    Object.defineProperty(ImageShape.prototype, \"size\", {\n        /**\n         * Returns the largest edge of the image\n         */\n        get: function () {\n            return Math.max(this.width, this.height);\n        },\n        /**\n         * This is the size the image will be rendered within World Space. The size\n         * correlates to the largest edge of the image\n         */\n        set: function (val) {\n            if (this.texture.aspectRatio > 1) {\n                this.width = val;\n                this.height = val / this.texture.aspectRatio;\n            }\n            else {\n                this.width = val * this.texture.aspectRatio;\n                this.height = val;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Centers this image on a provided location\n     *\n     * @param {number} x The x coordinate in world space\n     * @param {number} y The y coordinate in world space\n     */\n    ImageShape.prototype.centerOn = function (x, y) {\n        this.x = x - (this.width / 2.0);\n        this.y = y - (this.height / 2.0);\n    };\n    return ImageShape;\n}(bounds_1.Bounds));\nexports.ImageShape = ImageShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/image-shape.ts\n// module id = 53\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../../primitives/bounds\");\nvar QuadShape = (function (_super) {\n    __extends(QuadShape, _super);\n    function QuadShape(bounds, color) {\n        var _this = _super.call(this, bounds.x, bounds.right, bounds.y, bounds.bottom) || this;\n        _this.r = 1.0;\n        _this.g = 0.0;\n        _this.b = 0.0;\n        _this.a = 1.0;\n        return _this;\n    }\n    return QuadShape;\n}(bounds_1.Bounds));\nexports.QuadShape = QuadShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/quad-shape.ts\n// module id = 54\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interpolation_1 = require(\"../../util/interpolation\");\nvar curved_line_shape_1 = require(\"../shape/curved-line-shape\");\n/**\n * This defines a drawable ribbon shape.  It contains the information necessary\n * to efficiently render the ribbon.\n *\n * @export\n * @class RibbonShape\n * @extends {CurvedLineShape<T>}\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\n *             with the shape easier\n */\nvar RibbonShape = (function (_super) {\n    __extends(RibbonShape, _super);\n    /**\n     *\n     * Creates and instance of RibbonShape\n     *\n     * @param {IRibbonOptions} options  The options for creating this ribbon\n     *\n     */\n    function RibbonShape(options) {\n        var _this = _super.call(this, options) || this;\n        /** Depeth of draw location */\n        _this.depth = 0;\n        _this.cachesQuadSegments = options.cachedQuadSegments || true;\n        _this.depth = options.depth || 0;\n        _this.start2 = options.start2;\n        _this.end2 = options.end2;\n        _this.encapsulatePoints(_this.getRibbonStrip());\n        _this.center1 = options.center1;\n        _this.center2 = options.center2;\n        return _this;\n    }\n    /**\n     * Returns a new instance of this object that mimicks the properties of this Object\n     *\n     * @returns {RibbonShape<T>} The cloned object\n     */\n    RibbonShape.prototype.clone = function () {\n        // Perform the clone\n        var clone = new RibbonShape({\n            center1: this.center1,\n            center2: this.center2,\n            controlPoints: this.controlPoints,\n            end: this.end,\n            end2: this.end2,\n            endColor: this.endColor,\n            resolution: this.resolution,\n            start: this.start,\n            start2: this.start2,\n            startColor: this.startColor,\n            type: this.type,\n        });\n        clone.d = this.d;\n        return clone;\n    };\n    /**\n     * @override\n     * Return distance from a point to ribbon. If the point is in ribbon, return 0\n     * Otherwise use method of superclass.\n     */\n    RibbonShape.prototype.distanceTo = function (point) {\n        if (this.pointInside(point))\n            return 0;\n        return _super.prototype.distanceTo.call(this, point);\n    };\n    /**\n     * Test whether a point is in the ribbon using Point Inclusion in Polygon Test method\n     * @param point\n     */\n    RibbonShape.prototype.pointInside = function (point) {\n        var points = this.getRibbonStrip();\n        var nvert = points.length;\n        var i;\n        var j;\n        var c = false;\n        var testx = point.x;\n        var testy = point.y;\n        for (i = 0, j = nvert - 1; i < nvert; j = i++) {\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\n                    (points[j].y - points[i].y) + points[i].x)) {\n                c = !c;\n            }\n        }\n        return c;\n    };\n    /**\n     * This prodeuces all the points along the two bezier lines.\n     * The order of all the points pushed should be clockwise.\n     *\n     * @return {IPoint[]} The points to create the quads that make each segment of the ribbon.\n     *\n     */\n    RibbonShape.prototype.getRibbonStrip = function () {\n        var strip = [];\n        var dt = 1 / this.resolution;\n        var c1 = this.controlPoints[0];\n        for (var i = 0; i <= this.resolution; i++) {\n            strip.push(interpolation_1.bezier2(dt * i, this.start, this.end, c1));\n        }\n        for (var i = this.resolution; i >= 0; i--) {\n            strip.push(interpolation_1.bezier2(dt * i, this.start2, this.end2, c1));\n        }\n        return strip;\n    };\n    return RibbonShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.RibbonShape = RibbonShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/ribbon-shape.ts\n// module id = 55\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\n/**\n * Defines a color that is located on an atlas\n */\nvar AtlasColor = (function () {\n    /**\n     * Constructor implementation\n     */\n    function AtlasColor(color, g, b, a) {\n        if (a === void 0) { a = 1.0; }\n        // Value between 1 - 0 for the opacity of the color\n        this.opacity = 1.0;\n        // The pixel width and height of the color rendered onto the atlas\n        // This will always be a 2x2 so the color can be sampled in the middle\n        // For a guaranteed pure color regardless of gl sampling states\n        this.pixelWidth = 2;\n        this.pixelHeight = 2;\n        if (color instanceof three_1.Color) {\n            this.color = color.clone();\n            this.opacity = g === undefined ? 1.0 : g;\n        }\n        else {\n            this.color = new three_1.Color(color, g, b);\n            this.opacity = a;\n        }\n    }\n    return AtlasColor;\n}());\nexports.AtlasColor = AtlasColor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-color.ts\n// module id = 56\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./bounds\"));\n__export(require(\"./circle\"));\n__export(require(\"./curved-line\"));\n__export(require(\"./line\"));\n__export(require(\"./point\"));\n__export(require(\"./rotateable-quad\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/index.ts\n// module id = 57\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./animate\"));\n__export(require(\"./animated-shape-buffer-cache\"));\n__export(require(\"./buffer-util\"));\n__export(require(\"./custom-selection\"));\n__export(require(\"./easing\"));\n__export(require(\"./frame-info\"));\n__export(require(\"./get-font-metrics\"));\n__export(require(\"./interpolation\"));\n__export(require(\"./mouse\"));\n__export(require(\"./multi-shape-buffer-cache\"));\n__export(require(\"./pack-node\"));\n__export(require(\"./quad-tree\"));\n__export(require(\"./shape-buffer-cache\"));\n__export(require(\"./webgl-stat\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/index.ts\n// module id = 58\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"PLAY\"] = 0] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 1] = \"STOP\";\n})(PlayState || (PlayState = {}));\nvar Animate = (function () {\n    function Animate() {\n    }\n    Animate.animate = function () {\n        if (Animate.playState === PlayState.PLAY) {\n            requestAnimationFrame(Animate.animate);\n        }\n        this.animating.forEach(function (propToItem) {\n            propToItem.forEach(function (animate) {\n                // TODO\n            });\n        });\n    };\n    Animate.cancel = function (container, prop) {\n        // TODO\n    };\n    Animate.value = function (container, prop, start, end, duration, ease) {\n        // TODO\n    };\n    Animate.point = function (container) {\n        // TODO\n    };\n    Animate.start = function () {\n        // TODO\n    };\n    Animate.stop = function () {\n        // TODO\n    };\n    Animate.playState = PlayState.PLAY;\n    Animate.animating = new Map();\n    return Animate;\n}());\nexports.Animate = Animate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/animate.ts\n// module id = 59\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar multi_shape_buffer_cache_1 = require(\"./multi-shape-buffer-cache\");\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"INIT\"] = 0] = \"INIT\";\n    PlayState[PlayState[\"PLAY\"] = 1] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 2] = \"STOP\";\n})(PlayState = exports.PlayState || (exports.PlayState = {}));\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar AnimatedShapeBufferCache = (function (_super) {\n    __extends(AnimatedShapeBufferCache, _super);\n    function AnimatedShapeBufferCache() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.playState = PlayState.INIT;\n        _this.buffer = [];\n        _this.bustCache = true;\n        /**\n         * This is the internal control for managing execution of the animate method\n         */\n        _this.doAnimate = function () {\n            if (_this.playState === PlayState.PLAY) {\n                requestAnimationFrame(_this.doAnimate);\n            }\n            _this.animate();\n        };\n        return _this;\n    }\n    /**\n     * This is the method that will execute with the frame rate. Subclasses can\n     * override this to implement animated changes\n     */\n    AnimatedShapeBufferCache.prototype.animate = function () {\n        // Implemented by subclasses\n    };\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    AnimatedShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        if (this.bustCache) {\n            this.buildCache.apply(this, arguments);\n            this.bustCache = false;\n            if (this.playState === PlayState.INIT) {\n                this.start();\n                requestAnimationFrame(this.doAnimate);\n            }\n        }\n        // We always invalidate and commit all of our buffers for animations\n        this.flagBuffersDirty();\n        // Make sure our buffers are updated so they will commit to vertex buffers\n        this.processDirtyBuffers();\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    AnimatedShapeBufferCache.prototype.buildCache = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Begins executing the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.start = function () {\n        this.playState = PlayState.PLAY;\n    };\n    /**\n     * Ceases the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.stop = function () {\n        this.playState = PlayState.STOP;\n    };\n    return AnimatedShapeBufferCache;\n}(multi_shape_buffer_cache_1.MultiShapeBufferCache));\nexports.AnimatedShapeBufferCache = AnimatedShapeBufferCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/animated-shape-buffer-cache.ts\n// module id = 60\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Takes a map of the form <T, boolean> and returns an array of the keys,\n * excluding entries who's mapped value is false.\n *\n * @param map The map to convert to a list\n *\n * @return T[] A list of the keys, exluding false mappings\n */\nfunction boolMapToArray(map) {\n    return Array\n        .from(map)\n        .filter(function (item) { return item[1]; })\n        .map(function (item) { return item[0]; });\n}\nexports.boolMapToArray = boolMapToArray;\n/**\n * Defines a selection control for custom types and categories\n */\nvar CustomSelection = (function () {\n    function CustomSelection() {\n        /** This caches the list generation of a selection */\n        this.cachedSelection = new Map();\n        /** Map of the custom categories to the selection state */\n        this.selections = new Map();\n        /** Keeps flags indicating if a selection for a given category has changed or not */\n        this._didSelectionChange = new Map();\n    }\n    /**\n     * Clears out all custom selections for every category\n     */\n    CustomSelection.prototype.clearAllSelections = function () {\n        for (var _i = 0, _a = Array.from(this.selections.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this.clearSelection(key);\n        }\n    };\n    /**\n     * Clears the selection for the category specified\n     *\n     * @param {string} category Name of the category of selection\n     */\n    CustomSelection.prototype.clearSelection = function (category) {\n        // We must have selected items to clear the selection\n        if (this.getSelection(category).length) {\n            this.selections.set(category, null);\n            this.cachedSelection.set(category, null);\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Makes an item no longer flaged as selected within the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to remove from being selected\n     */\n    CustomSelection.prototype.deselect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        // See if the item is selected already, if it is, clear the selection and bust caches\n        if (selectionMap && selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, false);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Checks if a selection from a category has been modified\n     *\n     * @param {string} category The selection category to check\n     */\n    CustomSelection.prototype.didSelectionCategoryChange = function (category) {\n        return this._didSelectionChange.get(category);\n    };\n    /**\n     * Checks if ANY selection has changed\n     *\n     * @return {boolean} True if any selection has changed\n     */\n    CustomSelection.prototype.didSelectionChange = function () {\n        return boolMapToArray(this._didSelectionChange).length > 0;\n    };\n    /**\n     * This indicates that updates have taken place to account for selection\n     * changes.\n     */\n    CustomSelection.prototype.finalizeUpdate = function () {\n        for (var _i = 0, _a = Array.from(this._didSelectionChange.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this._didSelectionChange.set(key, false);\n        }\n    };\n    /**\n     * This retrieves a list of the items that are selected\n     *\n     * @param category The selection category to check on\n     *\n     * @return {T} Returns a list of items that are currently selected\n     */\n    CustomSelection.prototype.getSelection = function (category) {\n        if (!this.cachedSelection.get(category)) {\n            var theSelection = this.selections.get(category);\n            if (theSelection) {\n                this.cachedSelection.set(category, boolMapToArray(theSelection));\n            }\n            else {\n                this.cachedSelection.set(category, []);\n            }\n        }\n        return this.cachedSelection.get(category);\n    };\n    /**\n     * Specifies an item to flag as selected for the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.select = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        if (!selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, true);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Specifies an item to toggle it's selection status for the provided category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.toggleSelect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        // Clear the cache for the selection list\n        this.cachedSelection.set(category, null);\n        // Toggle the selection off if already selected\n        if (selectionMap.get(item)) {\n            this.deselect(category, item);\n        }\n        else {\n            this.select(category, item);\n        }\n        // Flag the category of selections as changed\n        this._didSelectionChange.set(category, true);\n    };\n    return CustomSelection;\n}());\nexports.CustomSelection = CustomSelection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/custom-selection.ts\n// module id = 61\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getFontMetrics(props) {\n    var ctx = props.ctx;\n    var text = props.text;\n    var bboxHeight = props.bboxHeight;\n    var canvasHeight = props.ctx.canvas.height;\n    var baseline = props.baseline || 'alphabetic';\n    var flip = props.flip || false;\n    var drawBaseline = props.drawBaseline || false;\n    var fontFamily = 'Arial, san-serif';\n    var fontSize = 14;\n    if (props.fontFamily) {\n        fontFamily = props.fontFamily;\n    }\n    if (props.fontSize) {\n        fontSize = props.fontSize;\n    }\n    // Setting up the canvas\n    ctx.save(); // Create canvas to use as buffer\n    ctx.font = fontSize + \"px \" + fontFamily;\n    var textWidth = ctx.measureText(text).width;\n    // This keeps font in-screen, measureText().width doesn't\n    // Quite do it in some cases. For instance \"j\", or the letter \"f\"\n    // In the font \"Zapfino\".\n    var offsetx = fontSize * 2;\n    var offsety = fontSize * 2;\n    var cwidth = ctx.canvas.width = Math.round(textWidth + offsetx * 2);\n    var cheight = ctx.canvas.height = canvasHeight ? canvasHeight : Math.round(offsety * 2);\n    if (typeof (baseline) === 'string') {\n        offsety = 0; // Using <canvas> baseline\n        ctx.textBaseline = baseline;\n    }\n    // Ctx.font has to be called twice because resetting the size resets the state\n    if (flip) {\n        ctx.scale(1, -1);\n    }\n    ctx.font = fontSize + \"px \" + fontFamily;\n    ctx.fillText(text, offsetx, (typeof (bboxHeight) === 'number' ? bboxHeight : offsety));\n    // Drawing baseline\n    if (drawBaseline) {\n        ctx.fillRect(0, canvasHeight / 2, ctx.canvas.width, 1);\n    }\n    // Grabbing image data\n    var imageData = ctx.getImageData(0, 0, cwidth, cheight);\n    var data = imageData.data;\n    // Calculating top\n    var top = 0;\n    var pos = data.length;\n    var bottom = 0;\n    var realBottom = 0;\n    var left = 0;\n    var right = 0;\n    while (pos > 0) {\n        if (data[pos + 3]) {\n            pos -= pos % (cwidth * 4); // Back to beginning of the line top = (pos / 4) / cwidth; // calculate pixel position top -= offsety - fontSize; pos = data.length; // exit loop } pos += 4; } // calculating bottom var bottom = 0; var pos = data.length; while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                bottom = (pos / 4) / cwidth;\n                bottom -= offsety - fontSize;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Calculating left\n        left = 0;\n        var col = 0;\n        var row = 0; // Left bounds\n        while (row < cheight && col < cwidth) {\n            var px = data[(row * cwidth * 4) + (col * 4) + 3];\n            if (px) {\n                left = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col++;\n            }\n        }\n        // Calculating right\n        right = 0;\n        col = cwidth;\n        row = 0; // Right bounds\n        while (row < cheight && col > 0) {\n            if (data[(row * cwidth * 4) + (col * 4) + 3]) {\n                right = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col--;\n            }\n        }\n        // Calculating real-bottom\n        realBottom = 0;\n        pos = data.length;\n        while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                realBottom = (pos / 4) / cwidth;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Restoring state\n        ctx.restore();\n    }\n    // Returning raw-metrics\n    return {\n        bottom: realBottom,\n        height: (bottom - top),\n        left: (-left),\n        top: (fontSize - top),\n        width: (right - left),\n    };\n}\nexports.getFontMetrics = getFontMetrics;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/get-font-metrics.ts\n// module id = 62\n// module chunks = 0"],"sourceRoot":""}