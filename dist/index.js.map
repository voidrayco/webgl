{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 57397711a2cfc6486dbf","webpack:///external \"three\"","webpack:///./src/webgl-surface/primitives/bounds.ts","webpack:///./node_modules/debug/src/browser.js","webpack:///./src/webgl-surface/util/buffer-util.ts","webpack:///./src/webgl-surface/buffers/base-buffer.ts","webpack:///./src/webgl-surface/primitives/line.ts","webpack:///external \"ramda\"","webpack:///external \"d3-color\"","webpack:///./src/webgl-surface/drawing/texture/atlas-texture.ts","webpack:///./src/webgl-surface/primitives/point.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-manager.ts","webpack:///./src/webgl-surface/util/pack-node.ts","webpack:///./src/webgl-surface/drawing/shape/label.ts","webpack:///./src/webgl-surface/primitives/rotateable-quad.ts","webpack:///./src/webgl-surface/drawing/texture/sprite.ts","webpack:///./src/webgl-surface/util/mouse.ts","webpack:///./src/webgl-surface/util/quad-tree.ts","webpack:///./src/webgl-surface/primitives/circle.ts","webpack:///./src/webgl-surface/primitives/curved-line.ts","webpack:///./src/webgl-surface/util/interpolation.ts","webpack:///./src/webgl-surface/drawing/shape/line-shape.ts","webpack:///./src/index.ts","webpack:///./src/webgl-surface/webgl-surface.tsx","webpack:///external \"react\"","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/debug/src/debug.js","webpack:///./node_modules/ms/index.js","webpack:///external \"bowser\"","webpack:///./src/webgl-surface/buffers/index.ts","webpack:///./src/webgl-surface/buffers/animated/shared-control-curved-line-buffer-ants.ts","webpack:///./src/webgl-surface/buffers/static/shared-control-curved-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-bezier-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-label-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-line-buffer.ts","webpack:///./src/webgl-surface/drawing/index.ts","webpack:///./src/webgl-surface/drawing/reference/reference-color.ts","webpack:///./src/webgl-surface/drawing/shape/circle-shape.ts","webpack:///./src/webgl-surface/drawing/shape/curved-line-shape.ts","webpack:///./src/webgl-surface/drawing/shape/edge-shape.ts","webpack:///./src/webgl-surface/drawing/shape/image-shape.ts","webpack:///./src/webgl-surface/drawing/shape/quad-shape.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-color.ts","webpack:///./src/webgl-surface/primitives/index.ts","webpack:///./src/webgl-surface/util/index.ts","webpack:///./src/webgl-surface/util/custom-selection.ts","webpack:///./src/webgl-surface/util/get-font-metrics.ts","webpack:///./src/webgl-surface/util/shape-buffer-cache.ts","webpack:///./src/webgl-surface/util/time.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_6__","__WEBPACK_EXTERNAL_MODULE_7__","__WEBPACK_EXTERNAL_MODULE_23__","__WEBPACK_EXTERNAL_MODULE_27__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","Bounds","left","right","top","bottom","height","width","x","y","arguments","length","containsPoint","point","copyBounds","b","encapsulate","bounds","encapsulateBounds","sizeToFirst","minX","Number","MAX_VALUE","maxX","minY","maxY","forEach","encapsulatePoint","encapsulatePoints","points","undefined","fits","inner","hitBounds","pointInside","isBounds","isInside","maxBounds","MIN_VALUE","process","useColors","window","type","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","navigator","userAgent","toLowerCase","match","parseInt","RegExp","$1","formatArgs","args","namespace","humanize","diff","color","splice","index","lastC","replace","log","Function","apply","save","namespaces","storage","removeItem","debug","e","load","r","env","DEBUG","chrome","local","localStorage","colors","formatters","j","v","JSON","stringify","err","message","enable","applyAttributeRegisters","attributeBuffers","incrementValues","attrRegister0","attrRegister1","attrRegister2","attrRegister3","attrRegister4","attrRegister5","attrRegister6","attrIndexIncr0","attrIndexIncr1","attrIndexIncr2","attrIndexIncr3","attrIndexIncr4","attrIndexIncr5","attrIndexIncr6","updateBuffer1","numBatches","updateAccessor","lastBatchRegister","attrIndex0","updateBuffer2","attrIndex1","updateBuffer3","attrIndex2","updateBuffer4","attrIndex3","updateBuffer5","attrIndex4","updateBuffer6","attrIndex5","updateBuffer7","attrIndex6","applyDefaultsHolders","defaults","defaultsHolder0","defaultsHolder1","defaultsHolder2","defaultsHolder3","fillSize1","buffer","start","fillSize2","fillSize3","fillSize4","AttributeSize","three_1","isStreamUpdatingRegister","fillMethodLookUp","_a","ONE","TWO","THREE","FOUR","updateBufferLookUp","1","2","3","4","5","6","7","BufferUtil","beginUpdates","endUpdates","totalBatches","makeBuffer","numVertices","attributes","iMax","geometry","BufferGeometry","attribute","attributeSize","size","Float32Array","fillMethod","name_1","k","addAttribute","BufferAttribute","updateBuffer","newData","bufferItems","vertexBatch","testPerformed","currentData","bufferAttributes","map","attr","array","updateMethod","needsUpdate","makeBufferItems","system","BaseBuffer","init","material","unitCount","update","shapeBuffer","__extends","extendStatics","setPrototypeOf","__proto__","Array","__","constructor","create","bounds_1","Line","_super","p1","p2","_this","setPoints","directionTo","vector","perpendicular","distanceTo","Math","abs","getClosest","lines","closestLine","closestDistance","distance","line","dx","dy","slope","magnitude","sqrt","mag","AtlasTexture","path","label","aspectRatio","imagePath","rasterizedLabel","squareDistance","Point","add","out","testPoint","closestPoint","findClosest","getClosestIndex","getDirection","normalize","getDistance","squared","getMidpoint","direction","make","scale","zero","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","__generator","body","verb","op","f","TypeError","_","t","ops","pop","trys","push","g","sent","throw","return","Symbol","iterator","d3_color_1","pack_node_1","label_1","atlas_texture_1","debugLabels","ZERO_IMAGE","atlasBL","atlasBR","atlasTL","atlasTR","Label","text","pixelHeight","pixelWidth","AtlasManager","atlasImages","atlasMap","atlasTexture","textureWidth","textureHeight","createAtlas","atlasName","images","canvas","_i","images_1","image","texture","_b","PackNode","createElement","getContext","draw","drawColors","Texture","premultiplyAlpha","generateMipmaps","destroyAtlas","dispose","destroy","none_1","atlasReferenceID","isValidImage","isValid","setDefaultImage","assign","loadedImage","rect","dimensions","node","insertedNode","ux","uy","uw","uh","atlasDimensions","loadImage","first","second","insert","nodeImage","nodeDimensions","drawImage","error","colorWidth","colorHeight","maxPerRow","rowWidth","rowCount","colCount","renderHeight","renderSpace","startX","startY","nextX","nextY","beginX","beginY","col","row","colors_1","min","ceil","colorIndex","colorsPerRow","firstColor","nextColor","fillStyle","round","opacity","fillRect","Error","getAtlasTexture","Image","onload","onerror","src","labelSize","getSize","ctx","rasterizationOffset","fontSize","rgb","base","font","makeCSSFont","textAlign","textBaseline","toString","fillText","image_1","setSize","toDataURL","child","isLeaf","hasChild","newNode","fitFlag","imgWidth","imgHeight","dWidth","dHeight","remove","removed","ramda_1","rotateable_quad_1","sprite_1","measurement","Sprite","options","AnchorPosition","TopLeft","depth","fontWeight","maxWidth","id","zoomable","rasterizationPadding","setFontSize","_baseLabel","set","baseLabel","_rasterizedLabel","copyLabel","omit","setText","getText","position","lbl","baseSize","context","size_1","measureText","RotateableQuad","anchorCalculations","BottomLeft","quad","BottomRight","Custom","Middle","MiddleBottom","MiddleLeft","MiddleRight","MiddleTop","TopRight","location","rotation","anchor","setAnchor","setLocation","setRotation","calculateAnchor","custom","anchorType","getAnchor","getAnchorType","getLocation","getRotation","angle","cos","sin","Vector4","anchorMat","Matrix4","makeTranslation","rotationMat","makeRotationZ","locationMat","transform","multiply","TL","clone","applyMatrix4","TR","BL","BR","w","h","contentScaleX","contentScaleY","scaleX","scaleY","getContentScale","getContentSize","getWidth","getHeight","normalizeFirefoxWheel","wheel","nativeEvent","deltaX","deltaY","sign","lowPassY","MAX_FIREFOX_WHEELDELTA","LOW_PASS_U0","LOW_PASS_U1","LOW_PASS_U2","LOW_PASS_U3","unshift","Vector2","normalizeChromeWheel","normalizeIE11Wheel","wheelDeltaX","IE_ADJUSTMENT","wheelDeltaY","wheelDelta","detail","OLD_IE_ADJUSTMENT","normalizeIE12Wheel","multiplyScalar","eventElementPosition","relative","mouseX","mouseY","eventX","eventY","target","event","pageX","pageY","clientX","clientY","scrollLeft","scrollTop","offsetParent","offsetLeft","offsetTop","normalizeWheel","browser","firefox","msie","version","msedge","filterQuery","queryValues","filtered","obj","find","Quadrants","mid","Node","children","childrenProps","nodes","props","doAdd","cover","addAll","allChildren","gatherChildren","split","isNaN","area","list","concat","gatherProps","query","visit","queryBounds","queryPoint","cb","finished","Boolean","QuadTree","UID","Circle","_id","_radius","_centerX","_centerY","updateBounds","radius","val","boundsInside","r2","dy2","dx2","notSquared","circles","closestCircle","circle","hitCircle","totalDistance","hitPoint","bezierDistance","straightLine","lineStrip","getLineStrip","closestIndex","point_1","line_1","circularDistance","straightDistance","makeBezier2Segments","cachesSegments","cachedSegments","segments","dt","resolution","c1","controlPoints","end","interpolation_1","bezier2","makeBezier3Segments","c2","bezier3","makeCircularCWSegments","midPoint","minRadius","circleCenter","direction1","theta1","atan2","direction2","theta2","PI","dTheta","makeCircularCCWSegments","makeStraightSegments","CurveType","pickSegmentMethod","Bezier","CircularCW","CircularCCW","Straight","pickDistanceMethod","CurvedLine","cacheSegments","distanceMethod","segmentMethod","segmentMethods","numControlPoints","t2","mt","mt2","t3","mt3","LineShape","a","g2","b2","a2","thickness","cull","newProperties","__export","BaseApplyPropsMethods","React","atlas_manager_1","mouse_1","quad_tree_1","debugCam","BaseAnimatedMethods","BACKGROUND_COLOR","Color","setRGB","Vector3","WEBGL_SUPPORTED","WebGLRenderingContext","WebGLSurface","atlasManager","atlasNames","labels","animatedMethodList","animatedMethodBreak","camera","disableMouseInteraction","sizeCamera","currentZoom","destinationX","destinationY","destinationZoom","isPanning","lastMousePosition","propsMethodList","inertia","inertiaBuild","inertiaDecay","inertiaMax","quadTree","shiftIsDown","stop","currentX","currentY","targetZoom","previousZoomToFit","zoomTargetX","zoomTargetY","animating","labelsReady","labelsCurrentLoadedId","labelsLoadId","colorsReady","currentHoverItems","animate","requestAnimationFrame","response","doDraw","some","method","break","updateCameraUniforms","forceDraw","emitViewport","applyProps","renderer","render","scene","el","renderEl","heightHalf","widthHalf","initCamera","Scene","initBuffers","WebGLRenderer","antialias","devicePixelRatio","setPixelRatio","setClearColor","setFaceCulling","CullFaceNone","appendChild","domElement","viewSize","viewport","far","near","OrthographicCamera","z","resizeContext","renderSize","zoom","updateProjectionMatrix","tl","screenToWorld","br","updateMatrixWorld","visible","onViewport","projection","handleMouseDown","onMouseDown","handleMouseOut","onMouseOut","handleMouseUp","mouse","world","hitInside","hitItems","hitItems_1","item","onMouseUp","handleMouseMove","onMouse","xDistance","yDistance","pan","willPan","maxInertia","hitItems_2","onMouseHover","indexOf","onMouseLeave","applyRef","animatedMethods","baseAnimatedMethods","orderedBaseAnimatedMethods","animatedMethodsBase","CONTEXT","INERTIA","POSITION","positionCamera","ZOOM","destZoom","dZoom","screenZoomTarget","worldToScreen","zoomCamera","newScreenZoomTarget","zoomDX","zoomDY","applyColorBufferChanges","applyLabelBufferChanges","applyPropsMethods","basePropsMethods","orderedBasePropsMethods","applyPropsMethodsBase","INITIALIZE","LABELS","textures","COLORS","BUFFERCHANGES","applyBufferChanges","CAMERA","appliedViewport","zoomToFitViewH","zoomToFitViewV","zoomToFit","onZoomRequest","componentDidMount","componentWillMount","screenSizeToWorld","bind","worldSizeToScreen","componentWillReceiveProps","componentWillUnmount","floor","unproject","project","merge","shouldComponentUpdate","nextProps","distanceX","distanceY","onMouseMove","onDoubleClick","ref","Component","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","noop","nextTick","title","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","selectColor","hash","charCodeAt","createDebug","enabled","self","curr","Date","ms","prevTime","prev","coerce","format","formatter","names","skips","substr","disable","test","stack","parse","str","String","exec","parseFloat","fmtShort","fmtLong","plural","long","buffer_util_1","base_buffer_1","SharedControlCurvedLineBufferAnts","numQuads","Mesh","frustumCulled","drawMode","TriangleStripDrawMode","sharedControl","colorRef","startColor","colorBase","uniforms","atlas","colorAtlas","controlPoint","colorStart","colorEnd","alpha","antLength","antGap","antSpeed","halfWidthSize","this_1","shapeBuffer_1","curvedLine","marchingAnts","endColor","lineWidth","gapLength","speed","strokeLength","positions","ppos","scpos","ecpos","normals","npos","endPoints","epos","halfWidth","wpos","marching","mpos","setDrawRange","SharedControlCurvedLineBuffer","SimpleStaticBezierLineBuffer","cpos","copos","SimpleStaticLabelBuffer","startFade","endFade","labelMaxSize","maxLabelSize","updated","texCoords","tpos","sizes","spos","anchors","apos","SimpleStaticLineBuffer","stripPos","strip","getTriangleStrip","ReferenceColor","circle_1","CircleShape","innerColor","innerR","innerRadius","ringWidth","ringPad","outline","r_1","setOuterColor","setInnerColor","cloneWithData","curved_line_1","CurvedLineShape","cachesQuadSegments","max","cachedQuadSegments","normal","lineWidthHalf","scaledPoint","temp","previous","current","line_shape_1","EdgeShape","p1Col","p2Col","p1Width","p2Width","bl","tr","endWidth","testx","testy","numberVertices","isClockwise","p1Dx","p2Dx","p1DeltaX","p1DeltaY","p2DeltaX","p2DeltaY","topEdge","bottomEdge","ImageShape","centerOn","QuadShape","AtlasColor","boolMapToArray","from","filter","CustomSelection","cachedSelection","Map","selections","_didSelectionChange","clearAllSelections","keys","key","clearSelection","category","getSelection","deselect","selectionMap","didSelectionCategoryChange","didSelectionChange","finalizeUpdate","theSelection","select","toggleSelect","getFontMetrics","bboxHeight","canvasHeight","baseline","flip","drawBaseline","fontFamily","textWidth","offsetx","offsety","cwidth","cheight","imageData","getImageData","data","pos","realBottom","restore","ShapeBufferCache","bustCache","generate","buildCache","getBuffer","getAttributeCurrentTime","time","now"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"ramda\"), require(\"d3-color\"), require(\"react\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"ramda\", \"d3-color\", \"react\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"voidgl\"] = factory(require(\"three\"), require(\"ramda\"), require(\"d3-color\"), require(\"react\"), require(\"bowser\"));\n\telse\n\t\troot[\"voidgl\"] = factory(root[\"three\"], root[\"ramda\"], root[\"d3-color\"], root[\"react\"], root[\"bowser\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_23__, __WEBPACK_EXTERNAL_MODULE_27__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"ramda\"), require(\"d3-color\"), require(\"react\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"ramda\", \"d3-color\", \"react\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"voidgl\"] = factory(require(\"three\"), require(\"ramda\"), require(\"d3-color\"), require(\"react\"), require(\"bowser\"));\n\telse\n\t\troot[\"voidgl\"] = factory(root[\"three\"], root[\"ramda\"], root[\"d3-color\"], root[\"react\"], root[\"bowser\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_23__, __WEBPACK_EXTERNAL_MODULE_27__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Class to manage the x, y, width, and height of an object\r\n *\r\n * @template T This specifies the data type associated with this shape and is accessible\r\n *             via the property 'd'\r\n */\r\nvar Bounds = (function () {\r\n    /**\r\n     * Create a new instance\r\n     *\r\n     * @param left  The left side (x coordinate) of the instance\r\n     * @param right The right side of the instance\r\n     * @param top The top (y coordinate) of the instance\r\n     * @param bottom The bottom of the instance\r\n     */\r\n    function Bounds(left, right, top, bottom) {\r\n        this.height = 0;\r\n        this.width = 0;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        if (arguments.length === 4) {\r\n            this.x = left;\r\n            this.width = right - left;\r\n            this.y = top;\r\n            this.height = top - bottom;\r\n        }\r\n    }\r\n    Object.defineProperty(Bounds.prototype, \"area\", {\r\n        /** The total rectangular surface area of this instance */\r\n        get: function () {\r\n            return this.width * this.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bounds.prototype, \"bottom\", {\r\n        /** The bottom coordinate for this instance (y + height) */\r\n        get: function () {\r\n            return this.y - this.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bounds.prototype, \"mid\", {\r\n        /** An x, y coordinate pair representing the center of this object */\r\n        get: function () {\r\n            return {\r\n                x: this.x + (this.width / 2),\r\n                y: this.y - (this.height / 2),\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bounds.prototype, \"right\", {\r\n        get: function () {\r\n            return this.x + this.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Check to see if a given point lies within the bounds of this instance\r\n     *\r\n     * @param point The point to check\r\n     */\r\n    Bounds.prototype.containsPoint = function (point) {\r\n        if (point.x < this.x) {\r\n            return false;\r\n        }\r\n        if (point.y > this.y) {\r\n            return false;\r\n        }\r\n        if (point.x > this.right) {\r\n            return false;\r\n        }\r\n        if (point.y < this.bottom) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Copies the properties of the bounds specified\r\n     *\r\n     * @param b The bounds whose dimensions we wish to copy\r\n     */\r\n    Bounds.prototype.copyBounds = function (b) {\r\n        this.height = b.height;\r\n        this.width = b.width;\r\n        this.x = b.x;\r\n        this.y = b.y;\r\n    };\r\n    /**\r\n     * Ensure that this object contains the smaller bounds\r\n     *\r\n     * This method will not shrink this class, but only grow it as necessary to\r\n     * fit the destination object\r\n     *\r\n     * @param bounds The bounds to encapsulate\r\n     */\r\n    Bounds.prototype.encapsulate = function (bounds) {\r\n        if (bounds.x < this.x) {\r\n            this.width += this.x - bounds.x;\r\n            this.x = bounds.x;\r\n        }\r\n        if (bounds.y > this.y) {\r\n            this.height += bounds.y - this.y;\r\n            this.y = bounds.y;\r\n        }\r\n        if (bounds.right > this.right) {\r\n            this.width = bounds.right - this.x;\r\n        }\r\n        if (bounds.bottom < this.bottom) {\r\n            this.height = this.y - bounds.bottom;\r\n        }\r\n    };\r\n    /**\r\n     * Ensure that this object contains the provided list of bounds\r\n     *\r\n     * This will never shrink or modify the original area covered by this bounds\r\n     * but will instead stay the same or include the original area plus the specified\r\n     * list of bounds.\r\n     *\r\n     * @param {Bounds<any>[]} bounds The list of bounds objects to encapsulate\r\n     * @param {boolean} sizeToFirst If this is set, the procedure will start by making this bounds\r\n     *                              be a clone of the first bounds object in the list\r\n     */\r\n    Bounds.prototype.encapsulateBounds = function (bounds, sizeToFirst) {\r\n        if (sizeToFirst && bounds.length) {\r\n            this.copyBounds(bounds[0]);\r\n        }\r\n        if (bounds.length === 0) {\r\n            return;\r\n        }\r\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\r\n        bounds.forEach(function (p) {\r\n            if (p.x < minX) {\r\n                minX = p.x;\r\n            }\r\n            if (p.right > maxX) {\r\n                maxX = p.right;\r\n            }\r\n            if (p.bottom < minY) {\r\n                minY = p.bottom;\r\n            }\r\n            if (p.y > maxY) {\r\n                maxY = p.y;\r\n            }\r\n        });\r\n        // Make bounds that encompasses the bounds list, then we encapsulate\r\n        // Those bounds\r\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\r\n    };\r\n    /**\r\n     * Grow this class to contain the specified point\r\n     *\r\n     * This method will not shrink this instance. It will only grow it as\r\n     * necessary.\r\n     *\r\n     * @param point The point to encapsulate\r\n     */\r\n    Bounds.prototype.encapsulatePoint = function (point) {\r\n        if (point.x < this.x) {\r\n            this.width += this.x - point.x;\r\n            this.x = point.x;\r\n        }\r\n        if (point.y > this.y) {\r\n            this.height += point.y - this.y;\r\n            this.y = point.y;\r\n        }\r\n        if (point.x > this.right) {\r\n            this.width = point.x - this.x;\r\n        }\r\n        if (point.y < this.bottom) {\r\n            this.height = this.y - point.y;\r\n        }\r\n    };\r\n    /**\r\n     * Efficiently encapsulates a set of points by growing the current dimensions\r\n     * of the bounds until the points are enclosed. This will perform faster than\r\n     * running encapsulatePoint for a list of points.\r\n     *\r\n     * @param points An array of points that Can be of format {x, y} or [x, y]\r\n     *\r\n     * @memberOf Bounds\r\n     */\r\n    Bounds.prototype.encapsulatePoints = function (points) {\r\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\r\n        if (points[0] !== undefined && points[0].x) {\r\n            points.forEach(function (p) {\r\n                if (p.x < minX) {\r\n                    minX = p.x;\r\n                }\r\n                else if (p.x > maxX) {\r\n                    maxX = p.x;\r\n                }\r\n                if (p.y < minY) {\r\n                    minY = p.y;\r\n                }\r\n                else if (p.y > maxY) {\r\n                    maxY = p.y;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            points.forEach(function (p) {\r\n                if (p[0] < minX) {\r\n                    minX = p[0];\r\n                }\r\n                else if (p[0] > maxX) {\r\n                    maxX = p[0];\r\n                }\r\n                if (p[1] < minY) {\r\n                    minY = p[1];\r\n                }\r\n                else if (p[1] > maxY) {\r\n                    maxY = p[1];\r\n                }\r\n            });\r\n        }\r\n        // Make bounds that encompasses the points, then we encapsulate\r\n        // Those bounds\r\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\r\n    };\r\n    /**\r\n     * Checks to see if another bounds fits in itself.\r\n     *\r\n     * @param {Bounds} inner The bounds to test against\r\n     *\r\n     * @return {number} int 1 is an exact fit, 2 it fits with space, 0 it doesn't fit\r\n     */\r\n    Bounds.prototype.fits = function (inner) {\r\n        if (this.width === inner.width) {\r\n            if (this.height === inner.height) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (this.width >= inner.width) {\r\n            if (this.height >= inner.height) {\r\n                return 2;\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    /**\r\n     * Check to see if the provided bounds intersects with this instance\r\n     *\r\n     * @param bounds The bounds to test against this instance\r\n     *\r\n     * @return True if the other object intersects with this instance\r\n     */\r\n    Bounds.prototype.hitBounds = function (bounds) {\r\n        if (bounds.right < this.x) {\r\n            return false;\r\n        }\r\n        if (bounds.x > this.right) {\r\n            return false;\r\n        }\r\n        if (bounds.bottom > this.y) {\r\n            return false;\r\n        }\r\n        if (bounds.y < this.bottom) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Tests if a point is inside this bounds\r\n     *\r\n     * @param p The point to test\r\n     *\r\n     * @return boolean The point to test\r\n     */\r\n    Bounds.prototype.pointInside = function (p) {\r\n        if (p.x < this.x) {\r\n            return false;\r\n        }\r\n        if (p.y > this.y) {\r\n            return false;\r\n        }\r\n        if (p.x > this.right) {\r\n            return false;\r\n        }\r\n        if (p.y < this.bottom) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Test function to type check the provided value\r\n     *\r\n     * @return True if value is a bounds object\r\n     */\r\n    Bounds.isBounds = function (value) {\r\n        // Falsy values aren't bounds objects\r\n        if (!value) {\r\n            return false;\r\n        }\r\n        // Direct test for bounds objects\r\n        if (value instanceof this) {\r\n            return true;\r\n        }\r\n        // Duck-typing check\r\n        return value &&\r\n            'containsPoint' in value &&\r\n            'encapsulate' in value &&\r\n            'hitTest' in value;\r\n    };\r\n    /**\r\n     * Check if this instance is completely inside the provided bounds\r\n     *\r\n     * @param bounds The bounds to test against this instance\r\n     *\r\n     * @return True if this instance is inside the provided bounds\r\n     */\r\n    Bounds.prototype.isInside = function (bounds) {\r\n        return (bounds.x <= this.x &&\r\n            bounds.right >= this.right &&\r\n            bounds.y >= this.y &&\r\n            bounds.bottom <= this.bottom);\r\n    };\r\n    /**\r\n     * Generates a Bounds object covering max extents\r\n     *\r\n     * @return {Bounds} bounds covering as wide of a range as possible\r\n     */\r\n    Bounds.maxBounds = function () {\r\n        return new Bounds(Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE);\r\n    };\r\n    return Bounds;\r\n}());\r\nexports.Bounds = Bounds;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(25);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (window && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\nvar debug = __webpack_require__(2)('WebGLSurface:BufferUtil');\r\nvar AttributeSize;\r\n(function (AttributeSize) {\r\n    AttributeSize[AttributeSize[\"ONE\"] = 0] = \"ONE\";\r\n    AttributeSize[AttributeSize[\"TWO\"] = 1] = \"TWO\";\r\n    AttributeSize[AttributeSize[\"THREE\"] = 2] = \"THREE\";\r\n    AttributeSize[AttributeSize[\"FOUR\"] = 3] = \"FOUR\";\r\n})(AttributeSize = exports.AttributeSize || (exports.AttributeSize = {}));\r\n/**\r\n * These are for fast look ups of the default values provided\r\n * Doing this fashion avoids array look ups in the defaults values\r\n */\r\nvar defaultsHolder0 = 0;\r\nvar defaultsHolder1 = 0;\r\nvar defaultsHolder2 = 0;\r\nvar defaultsHolder3 = 0;\r\n/**\r\n * These are for fast look ups of attribute buffers that are going\r\n * through the update process. We do everything to mitigate array look ups\r\n * when and where we can\r\n */\r\nvar attrRegister0 = [];\r\nvar attrRegister1 = [];\r\nvar attrRegister2 = [];\r\nvar attrRegister3 = [];\r\nvar attrRegister4 = [];\r\nvar attrRegister5 = [];\r\nvar attrRegister6 = [];\r\nvar attrIndex0 = 0;\r\nvar attrIndex1 = 0;\r\nvar attrIndex2 = 0;\r\nvar attrIndex3 = 0;\r\nvar attrIndex4 = 0;\r\nvar attrIndex5 = 0;\r\nvar attrIndex6 = 0;\r\nvar attrIndexIncr0 = 0;\r\nvar attrIndexIncr1 = 0;\r\nvar attrIndexIncr2 = 0;\r\nvar attrIndexIncr3 = 0;\r\nvar attrIndexIncr4 = 0;\r\nvar attrIndexIncr5 = 0;\r\nvar attrIndexIncr6 = 0;\r\n/** This is used to define a starting batch location to aid in continuing batch updates */\r\nvar lastBatchRegister = 0;\r\nvar isStreamUpdatingRegister = false;\r\n/**\r\n * This takes our list of attribute buffers and applies them to the registers for rapid lookups\r\n *\r\n * @param {number[][]} attributeBuffers The buffers for each attribute to be updated\r\n * @param {number[]} incrementValues How much each batch increments it's lookup index\r\n */\r\nfunction applyAttributeRegisters(attributeBuffers, incrementValues) {\r\n    attrRegister0 = attributeBuffers[0];\r\n    attrRegister1 = attributeBuffers[1];\r\n    attrRegister2 = attributeBuffers[2];\r\n    attrRegister3 = attributeBuffers[3];\r\n    attrRegister4 = attributeBuffers[4];\r\n    attrRegister5 = attributeBuffers[5];\r\n    attrRegister6 = attributeBuffers[6];\r\n    attrIndexIncr0 = incrementValues[0];\r\n    attrIndexIncr1 = incrementValues[1];\r\n    attrIndexIncr2 = incrementValues[2];\r\n    attrIndexIncr3 = incrementValues[3];\r\n    attrIndexIncr4 = incrementValues[4];\r\n    attrIndexIncr5 = incrementValues[5];\r\n    attrIndexIncr6 = incrementValues[6];\r\n}\r\n/**\r\n * The following methods are targetted at executing the update accessor with varying number\r\n * of parameters while mitigating array look ups.\r\n *\r\n * @param {number} numBatches The number of batches to execute\r\n * @param {Function} updateAccessor The accessor function that will update the buffer values\r\n */\r\nfunction updateBuffer1(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0);\r\n    }\r\n}\r\nfunction updateBuffer2(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1);\r\n    }\r\n}\r\nfunction updateBuffer3(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2);\r\n    }\r\n}\r\nfunction updateBuffer4(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3);\r\n    }\r\n}\r\nfunction updateBuffer5(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        attrIndex4 = i * attrIndexIncr4;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4);\r\n    }\r\n}\r\nfunction updateBuffer6(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        attrIndex4 = i * attrIndexIncr4;\r\n        attrIndex5 = i * attrIndexIncr5;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5);\r\n    }\r\n}\r\nfunction updateBuffer7(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        attrIndex4 = i * attrIndexIncr4;\r\n        attrIndex5 = i * attrIndexIncr5;\r\n        attrIndex6 = i * attrIndexIncr6;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6);\r\n    }\r\n}\r\n/**\r\n * This takes the defaults array provided and loads them into our default\r\n * lookup values\r\n *\r\n * @param {number[]} defaults The array with the default values in them for our buffer attribute\r\n */\r\nfunction applyDefaultsHolders(defaults) {\r\n    defaultsHolder0 = defaults[0] || 0;\r\n    defaultsHolder1 = defaults[1] || 0;\r\n    defaultsHolder2 = defaults[2] || 0;\r\n    defaultsHolder3 = defaults[3] || 0;\r\n}\r\n/**\r\n * The following methods are rapid ways of populating the buffer without\r\n * setting up a generic loop. This saves on performance by not creating a loop\r\n * nor allocating the variables necessary for the generic loop.\r\n *\r\n * @param {Float32Array} buffer The buffer to populate\r\n * @param {number} start The index the data should be populated into\r\n */\r\nfunction fillSize1(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n}\r\nfunction fillSize2(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n    buffer[++start] = defaultsHolder1;\r\n}\r\nfunction fillSize3(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n    buffer[++start] = defaultsHolder1;\r\n    buffer[++start] = defaultsHolder2;\r\n}\r\nfunction fillSize4(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n    buffer[++start] = defaultsHolder1;\r\n    buffer[++start] = defaultsHolder2;\r\n    buffer[++start] = defaultsHolder3;\r\n}\r\n/**\r\n * This is a quick lookup to find the correct filler method for the given attribute size\r\n */\r\nvar fillMethodLookUp = (_a = {},\r\n    _a[AttributeSize.ONE] = fillSize1,\r\n    _a[AttributeSize.TWO] = fillSize2,\r\n    _a[AttributeSize.THREE] = fillSize3,\r\n    _a[AttributeSize.FOUR] = fillSize4,\r\n    _a);\r\nvar updateBufferLookUp = {\r\n    1: updateBuffer1,\r\n    2: updateBuffer2,\r\n    3: updateBuffer3,\r\n    4: updateBuffer4,\r\n    5: updateBuffer5,\r\n    6: updateBuffer6,\r\n    7: updateBuffer7,\r\n};\r\n/**\r\n * This provides methods for handling common buffer tasks such as construction\r\n * and population.\r\n */\r\nvar BufferUtil = (function () {\r\n    function BufferUtil() {\r\n    }\r\n    /**\r\n     * This places our updateBuffer into a mode where the updates start at index 0 of the\r\n     * buffer. Subsequent calls will start where the previous call left off. This lets\r\n     * you stream in updates to the buffer rather than just update the entire buffer\r\n     * all at once.\r\n     */\r\n    BufferUtil.beginUpdates = function () {\r\n        isStreamUpdatingRegister = true;\r\n        lastBatchRegister = 0;\r\n    };\r\n    /**\r\n     * This stops updates streaming into the buffers and makes it where an update\r\n     * will always just start at the beginning of the buffer.\r\n     */\r\n    BufferUtil.endUpdates = function () {\r\n        var totalBatches = lastBatchRegister;\r\n        isStreamUpdatingRegister = false;\r\n        lastBatchRegister = 0;\r\n        return totalBatches;\r\n    };\r\n    /**\r\n     * @static\r\n     * This handles many of the common tasks associated with constructing a new buffer\r\n     * such as applying the name, generating the buffer, and populating default values to\r\n     * that buffer.\r\n     *\r\n     * @param {number} numVertices The number of vertices this buffer will have\r\n     * @param {IAttributeInfo[]} attributes A description of each attribute in the buffer\r\n     *\r\n     * @returns {BufferGeometry} The newly made buffer\r\n     */\r\n    BufferUtil.makeBuffer = function (numVertices, attributes) {\r\n        var iMax = attributes.length;\r\n        var geometry = new three_1.BufferGeometry();\r\n        for (var i = 0; i < iMax; ++i) {\r\n            var attribute = attributes[i];\r\n            var attributeSize = attribute.size + 1;\r\n            var buffer = new Float32Array(attributeSize * numVertices);\r\n            var fillMethod = fillMethodLookUp[attribute.size];\r\n            var name_1 = attribute.name;\r\n            // We set up our default value registers before executing the fill method\r\n            applyDefaultsHolders(attribute.defaults);\r\n            // Fill our buffer with the indicated default values\r\n            for (var k = 0; k < numVertices; ++k) {\r\n                fillMethod(buffer, k * attributeSize);\r\n            }\r\n            // Apply the buffer to our geometry buffer\r\n            geometry.addAttribute(name_1, new three_1.BufferAttribute(buffer, attributeSize));\r\n            debug('Made Buffer Attribute:', name_1, attributeSize);\r\n        }\r\n        return geometry;\r\n    };\r\n    /**\r\n     * @static\r\n     * This handles many of the common tasks associated with updating a buffer. You specify how many vertices\r\n     * to update in a batch and you specify how many batches are present.\r\n     *\r\n     * Batches are used to represent your full shape object that is being loaded from the cpu:\r\n     *\r\n     * IE- you have a rectangle object you wish to update in your buffer. This takes around 6 vertices typically\r\n     * so you make your vertexBatch 6 and the numBatches the number of quads you need to update in the buffer.\r\n     *\r\n     * You then provide an accessor which aids in pointing to the buffer items that need updating. The accessor has\r\n     * variable arguments depending on the attributes you inject in.\r\n     *\r\n     * If you have attributes like:\r\n     * [\r\n     *  {name: position, size: AttributeSize.Three},\r\n     *  {name: color, size: AttributeSize.Four},\r\n     * ]\r\n     *\r\n     * Then your accessor will be delievered arguments in this form:\r\n     *\r\n     * function(batchIndex: number, positionBuffer: number[], positionIndex: number, colorBuffer: number[], colorIndex: number)\r\n     *\r\n     * NOTE: The params handed in ARE ORDERED BY the attributes injected in\r\n     *\r\n     * You then can update the buffers based on the index information handed alongside each buffer\r\n     *\r\n     * @param {T[]} newData The new data that is going to be injected into the buffer. This must be a NEW REFERENCE of data\r\n     *                      that does NOT match the reference in the bufferItems.currentData. So newData !== bufferItems.currentData\r\n     *                      in order for the update to occur.\r\n     * @param {BufferGeometry} bufferItems The buffer related items used to identify how to update the buffer\r\n     * @param {number} vertexBatch The number of vertices to include per update batch\r\n     * @param {number} numBatches The number of batches to execute\r\n     * @param {Function} updateAccessor The accessor for performing the data update to the buffer\r\n     *\r\n     * @return {boolean} True if the buffer was updated with this call\r\n     */\r\n    BufferUtil.updateBuffer = function (newData, bufferItems, vertexBatch, numBatches, updateAccessor) {\r\n        var attributes = bufferItems.attributes;\r\n        var buffer = bufferItems.geometry;\r\n        // If we passed the data check on the first pass, then all future streamed updates\r\n        // Should pass as well\r\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\r\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\r\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed) {\r\n            // If we aren't streaming updates, then we always start at the beginning\r\n            if (!isStreamUpdatingRegister) {\r\n                // Reset out last batch register as this is an entriely new update\r\n                lastBatchRegister = 0;\r\n            }\r\n            // Flag the newly rendered data as our current data\r\n            bufferItems.currentData = newData;\r\n            // Get the attributes by name out of the three js buffer\r\n            var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\r\n            // Get the raw number buffers\r\n            var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\r\n            // Determine what kind of buffer pointer increments we will need\r\n            var incrementValues = attributes.map(function (attr) { return (attr.size + 1) * vertexBatch; });\r\n            // Apply all data needed to any registers we need\r\n            applyAttributeRegisters(attributeBuffers, incrementValues);\r\n            // Get the method that will perform the update based on number of attributes\r\n            var updateMethod = updateBufferLookUp[attributes.length];\r\n            // Execute the update method\r\n            updateMethod(numBatches + lastBatchRegister, updateAccessor);\r\n            // Flag each buffer attribute for needing an update\r\n            bufferAttributes.forEach(function (attr) { return attr.needsUpdate = true; });\r\n            // Move our register forward in case we are in a stream update\r\n            lastBatchRegister += numBatches;\r\n            return true;\r\n        }\r\n        else {\r\n            // Move our register forward in case we are in a stream update\r\n            lastBatchRegister += numBatches;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * This makes all of the typical items used in creating and managing a buffer of items rendered to the screen\r\n     *\r\n     * @returns {IBufferItems<T>} An empty object of the particular buffer items needed\r\n     */\r\n    BufferUtil.makeBufferItems = function () {\r\n        return {\r\n            attributes: [],\r\n            currentData: [],\r\n            geometry: null,\r\n            system: null,\r\n        };\r\n    };\r\n    return BufferUtil;\r\n}());\r\nexports.BufferUtil = BufferUtil;\r\nvar _a;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This deinfes the minimal set of methods that should be implemented to create\r\n * a reusable buffer object that can be initialized and populated.\r\n */\r\nvar BaseBuffer = (function () {\r\n    function BaseBuffer() {\r\n    }\r\n    /**\r\n     * This initializes the buffer and generates the buffer items object.\r\n     */\r\n    BaseBuffer.prototype.init = function (material, unitCount) {\r\n        // To be implemented by a subclass\r\n    };\r\n    /**\r\n     * This updates the buffer by providing the shape buffer needed to update\r\n     * the internal buffer items\r\n     *\r\n     * @param {T[]} shapeBuffer The shape buffer containing all of the shape data\r\n     *                          to be placed into the buffer.\r\n     *\r\n     * @return {boolean} Retrusn true if this pushed up any updates\r\n     */\r\n    BaseBuffer.prototype.update = function (shapeBuffer) {\r\n        // To be implemented by a subclass\r\n        return false;\r\n    };\r\n    return BaseBuffer;\r\n}());\r\nexports.BaseBuffer = BaseBuffer;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = __webpack_require__(1);\r\n/**\r\n * Represents a line with a given slope\r\n */\r\nvar Line = (function (_super) {\r\n    __extends(Line, _super);\r\n    /**\r\n     * Creates a new line that passes through the two specified points\r\n     *\r\n     * @param {IPoint} p1 The start point\r\n     * @param {IPoint} p2 The end point\r\n     */\r\n    function Line(p1, p2) {\r\n        var _this = _super.call(this, 0, 1, 1, 0) || this;\r\n        _this.setPoints(p1, p2);\r\n        return _this;\r\n    }\r\n    /**\r\n     * This calculates the distance to a point from the provided line\r\n     * BUT this ALSO retains the directionality of that distance. So one side of\r\n     * the line will be positive while the other negative\r\n     *\r\n     * @param {IPoint} p The Point to see how far from the line we are\r\n     *\r\n     * @return {number} The calculated distance to the provided point\r\n     */\r\n    Line.prototype.directionTo = function (p) {\r\n        // Make a vector from a line point to the indicated point\r\n        var vector = {\r\n            x: this.p1.x - p.x,\r\n            y: this.p1.y - p.y,\r\n        };\r\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\r\n        // Line, but we won't take the absolute to retain the direction\r\n        return this.perpendicular.x * vector.x + this.perpendicular.y * vector.y;\r\n    };\r\n    /**\r\n     * This calculates the distance to a point from the provided line\r\n     *\r\n     * @param {IPoint} p The Point to see how far from the line we are\r\n     *\r\n     * @return {number} The calculated distance to the provided point\r\n     */\r\n    Line.prototype.distanceTo = function (p) {\r\n        // Make a vector from a line point to the indicated point\r\n        var vector = {\r\n            x: this.p1.x - p.x,\r\n            y: this.p1.y - p.y,\r\n        };\r\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\r\n        // Line\r\n        return Math.abs(this.perpendicular.x * vector.x +\r\n            this.perpendicular.y * vector.y);\r\n    };\r\n    /**\r\n     * Picks the closest line in the list to a given point\r\n     *\r\n     * @param {Array} lines The lines to compare\r\n     * @param {IPoint} p The point to compare against\r\n     *\r\n     * @return {Line} The nearest line to the point\r\n     */\r\n    Line.getClosest = function (lines, p) {\r\n        var closestLine;\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var distance = 0;\r\n        lines.forEach(function (line) {\r\n            distance = line.distanceTo(p);\r\n            if (distance < closestDistance) {\r\n                closestLine = line;\r\n                closestDistance = distance;\r\n            }\r\n        });\r\n        return closestLine;\r\n    };\r\n    /**\r\n     * This sets the two endpoints for this line and recalculates the bounds\r\n     * of the line accordingly\r\n     *\r\n     * @param {IPoint} p1 The start point\r\n     * @param {IPoint} p2 The end point\r\n     */\r\n    Line.prototype.setPoints = function (p1, p2) {\r\n        this.x = p1.x - 1;\r\n        this.y = p1.y - 1;\r\n        this.width = 2;\r\n        this.height = 2;\r\n        this.encapsulatePoint(p2);\r\n        var dx = p2.x - p1.x;\r\n        var dy = p2.y - p1.y;\r\n        this.slope = dy / dx;\r\n        this.p1 = p1;\r\n        this.p2 = p2;\r\n        this.magnitude = Math.sqrt(dx * dx + dy * dy);\r\n        this.perpendicular = {\r\n            x: this.p2.y - this.p1.y,\r\n            y: -(this.p2.x - this.p1.x),\r\n        };\r\n        // Normalize the perpendicular line\r\n        var mag = Math.sqrt(this.perpendicular.x * this.perpendicular.x +\r\n            this.perpendicular.y * this.perpendicular.y);\r\n        this.perpendicular.x /= mag;\r\n        this.perpendicular.y /= mag;\r\n    };\r\n    return Line;\r\n}(bounds_1.Bounds));\r\nexports.Line = Line;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Defines a texture that is located on an atlas\r\n */\r\nvar AtlasTexture = (function () {\r\n    /**\r\n     * Generates a new atlas texture that points to a specific image resource.\r\n     *\r\n     * @param path The path to the image resource to be loaded into the atlas.\r\n     */\r\n    function AtlasTexture(path, label) {\r\n        /** Stores the aspect ratio of the image for quick reference */\r\n        this.aspectRatio = 1.0;\r\n        this.imagePath = path;\r\n        this.label = label;\r\n        // Let the label keep track of it's rasterization\r\n        if (label) {\r\n            this.label.rasterizedLabel = this;\r\n        }\r\n    }\r\n    return AtlasTexture;\r\n}());\r\nexports.AtlasTexture = AtlasTexture;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates the distance between two points, but keeps the distance in dquared form\r\n * thus performing Math.sqrt() on the output of this distance would provide the true\r\n * distance between the points.\r\n *\r\n * It is often faster and all that is needed to compare squared distances vs real distances\r\n * thus eliminating multiple Math.sqrt operations\r\n *\r\n * NOTE: For vectors this is the same as (pseudo code):\r\n * let vector3 = vector2.subtract(vector1)\r\n * return vector3.dot(vector3)\r\n *\r\n * @param p1 The point to find the distance from the second point\r\n * @param p2 The point to find the distance from the first point\r\n *\r\n * @return {number} The distance * distance between the two points\r\n */\r\nfunction squareDistance(p1, p2) {\r\n    var dx = p1.x - p2.x;\r\n    var dy = p1.y - p2.y;\r\n    return dx * dx + dy * dy;\r\n}\r\n/**\r\n * Contains methods for managing or manipulating points\r\n *\r\n * @export\r\n * @class Point\r\n */\r\nvar Point = (function () {\r\n    function Point() {\r\n    }\r\n    /**\r\n     * Adds two points together\r\n     *\r\n     * @static\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\r\n     *\r\n     * @return {IPoint} The two points added together\r\n     */\r\n    Point.add = function (p1, p2, out) {\r\n        if (out) {\r\n            out.x = p1.x + p2.x;\r\n            out.y = p1.y + p2.y;\r\n            return out;\r\n        }\r\n        return {\r\n            x: p1.x + p2.x,\r\n            y: p1.y + p2.y,\r\n        };\r\n    };\r\n    /**\r\n     * @static\r\n     * This analyzes a test point against a list of points and determines which of the points is\r\n     * the closest to the test point. If there are equi-distant points in the list, this will return\r\n     * the first found in the list.\r\n     *\r\n     * @param {IPoint} testPoint The point to compare against other points\r\n     * @param {IPoint[]} points The list of points to be compared against\r\n     *\r\n     * @return {IPoint} The closest point to the test point\r\n     */\r\n    Point.getClosest = function (testPoint, points) {\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var closestPoint = null;\r\n        var distance;\r\n        var findClosest = function (point) {\r\n            distance = squareDistance(point, testPoint);\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestPoint = point;\r\n            }\r\n        };\r\n        points.forEach(findClosest);\r\n        return closestPoint;\r\n    };\r\n    /**\r\n     * @static\r\n     * This analyzes a test point against a list of points and determines which of the points is\r\n     * the closest to the test point. If there are equi-distant points in the list, this will return\r\n     * the first found in the list.\r\n     *\r\n     * This just returns the index of the found point and not the point itself\r\n     *\r\n     * @param {IPoint} testPoint The point to compare against other points\r\n     * @param {IPoint[]} points The list of points to be compared against\r\n     *\r\n     * @return {number} The index of the closest point to the test point\r\n     */\r\n    Point.getClosestIndex = function (testPoint, points) {\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var closestPoint = 0;\r\n        var distance;\r\n        var findClosest = function (point, i) {\r\n            distance = squareDistance(point, testPoint);\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestPoint = i;\r\n            }\r\n        };\r\n        points.forEach(findClosest);\r\n        return closestPoint;\r\n    };\r\n    /**\r\n     * @static\r\n     * This will calculate a direction vector between two points that points toward p2\r\n     *\r\n     * @param {IPoint} p1 The start of the direction\r\n     * @param {IPoint} p2 The direction to point the vector towards\r\n     * @param {boolean} normalize If true, this will make the vector have a magnitude of 1\r\n     *\r\n     * @returns {number}\r\n     */\r\n    Point.getDirection = function (p1, p2, normalize) {\r\n        if (normalize === void 0) { normalize = false; }\r\n        var dx = p2.x - p1.x;\r\n        var dy = p2.y - p1.y;\r\n        if (normalize) {\r\n            var magnitude = Math.sqrt(dx * dx + dy * dy);\r\n            dx /= magnitude;\r\n            dy /= magnitude;\r\n        }\r\n        return {\r\n            x: dx,\r\n            y: dy,\r\n        };\r\n    };\r\n    /**\r\n     * @static\r\n     * Gets the distance between two points\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {boolean} squared If set to true, returns the distance * distance (performs faster)\r\n     *\r\n     * @returns {number} The real distance between two points\r\n     */\r\n    Point.getDistance = function (p1, p2, squared) {\r\n        if (squared === void 0) { squared = false; }\r\n        if (squared) {\r\n            return squareDistance(p1, p2);\r\n        }\r\n        return Math.sqrt(squareDistance(p1, p2));\r\n    };\r\n    /**\r\n     * @static\r\n     * Gets a point perfectly between two points\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     *\r\n     * @returns {IPoint} The point between the two provided points\r\n     */\r\n    Point.getMidpoint = function (p1, p2) {\r\n        var direction = Point.getDirection(p1, p2);\r\n        return {\r\n            x: direction.x / 2 + p1.x,\r\n            y: direction.y / 2 + p1.y,\r\n        };\r\n    };\r\n    Point.make = function (x, y) {\r\n        return { x: x, y: y };\r\n    };\r\n    /**\r\n     * Scales a point by a given amount\r\n     *\r\n     * @static\r\n     * @param {IPoint} p1\r\n     * @param {number} s The amount to scale the point by\r\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\r\n     *\r\n     * @memberof Point\r\n     */\r\n    Point.scale = function (p1, s, out) {\r\n        if (out) {\r\n            out.x = p1.x * s;\r\n            out.y = p1.y * s;\r\n            return out;\r\n        }\r\n        return {\r\n            x: p1.x * s,\r\n            y: p1.y * s,\r\n        };\r\n    };\r\n    /**\r\n     * Makes a new point initialized to {0,0}\r\n     *\r\n     * @static\r\n     * @returns {IPoint} A new point object at {0,0}\r\n     */\r\n    Point.zero = function () {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n    };\r\n    return Point;\r\n}());\r\nexports.Point = Point;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar d3_color_1 = __webpack_require__(7);\r\nvar three_1 = __webpack_require__(0);\r\nvar bounds_1 = __webpack_require__(1);\r\nvar pack_node_1 = __webpack_require__(11);\r\nvar label_1 = __webpack_require__(12);\r\nvar atlas_texture_1 = __webpack_require__(8);\r\nvar debug = __webpack_require__(2)('webgl-surface:Atlas');\r\nvar debugLabels = __webpack_require__(2)('webgl-surface:Labels');\r\nvar ZERO_IMAGE = {\r\n    atlasBL: { x: 0, y: 0 },\r\n    atlasBR: { x: 0, y: 0 },\r\n    atlasTL: { x: 0, y: 0 },\r\n    atlasTR: { x: 0, y: 0 },\r\n    label: new label_1.Label({ text: ' ' }),\r\n    pixelHeight: 0,\r\n    pixelWidth: 0,\r\n};\r\n/**\r\n * Defines a manager of atlas', which includes generating the atlas and producing\r\n * textures defining those pieces of atlas.\r\n */\r\nvar AtlasManager = (function () {\r\n    /**\r\n     * Generates a new manager for atlas'. This will create and destroy atlas' and\r\n     * ensure they have the correct settings applied. A manager will also aid in\r\n     * packing images into the atlas indicated.\r\n     *\r\n     * @param {number} width The width of all atlas' generated\r\n     * @param {number} height The height of all atlas' generated\r\n     */\r\n    function AtlasManager(width, height) {\r\n        /** Gives a reference of all of the images loaded for the atlas */\r\n        this.atlasImages = {};\r\n        /** Stores the current mapping of the atlas */\r\n        this.atlasMap = {};\r\n        /** Stores all of the textures that are our atlases */\r\n        this.atlasTexture = {};\r\n        this.textureWidth = width;\r\n        this.textureHeight = height;\r\n    }\r\n    /**\r\n     * Atlas' must be created from scratch to update them. In order to properly\r\n     * update an existing one, you must destroy it then recreate it again.\r\n     * This is from not knowing how to update a texture via three js.\r\n     *\r\n     * @param atlasName The unique name of the atlas so it can be retrieved/referenced easily\r\n     * @param images The images with their image path set to be loaded into the atlas.\r\n     *               Images that keep an atlas ID of null indicates the image did not load\r\n     *               correctly\r\n     *\r\n     * @return {Texture} The Threejs texture that is created as our atlas. The images injected\r\n     *                   into the texture will be populated with the atlas'\r\n     */\r\n    AtlasManager.prototype.createAtlas = function (atlasName, images, colors) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var atlasMap, canvas, _i, images_1, image, image, texture, _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        atlasMap = new pack_node_1.PackNode(0, 0, this.textureWidth, this.textureHeight);\r\n                        // Create the mapping element for the new atlas so we can track insertions / deletions\r\n                        this.atlasMap[atlasName] = atlasMap;\r\n                        // Make a listing of images that is within the atlas\r\n                        this.atlasImages[atlasName] = [];\r\n                        canvas = document.createElement('canvas').getContext('2d');\r\n                        // Size the canvas to the atlas size\r\n                        canvas.canvas.width = this.textureWidth;\r\n                        canvas.canvas.height = this.textureHeight;\r\n                        if (!images) return [3 /*break*/, 4];\r\n                        _i = 0, images_1 = images;\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        if (!(_i < images_1.length)) return [3 /*break*/, 4];\r\n                        image = images_1[_i];\r\n                        return [4 /*yield*/, this.draw(image, atlasName, canvas)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        _i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 4:\r\n                        if (!colors) return [3 /*break*/, 6];\r\n                        return [4 /*yield*/, this.drawColors(colors, atlasName, canvas)];\r\n                    case 5:\r\n                        image = _b.sent();\r\n                        // Add the dummy texture info as an image to our list of images\r\n                        if (image) {\r\n                            this.atlasImages[atlasName].push(image);\r\n                        }\r\n                        _b.label = 6;\r\n                    case 6:\r\n                        texture = new three_1.Texture(canvas.canvas);\r\n                        texture.premultiplyAlpha = true;\r\n                        texture.generateMipmaps = true;\r\n                        // Store the texture as the atlas.\r\n                        this.atlasTexture[atlasName] = texture;\r\n                        // Store the images as images within the atlas\r\n                        if (images) {\r\n                            (_a = this.atlasImages[atlasName]).push.apply(_a, images);\r\n                        }\r\n                        debug('Atlas Created-> texture: %o mapping: %o images: %o', texture, atlasMap, images);\r\n                        return [2 /*return*/, texture];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Disposes of the resources the atlas held and makes the atlas invalid for use\r\n     *\r\n     * @param atlasName\r\n     */\r\n    AtlasManager.prototype.destroyAtlas = function (atlasName) {\r\n        if (this.atlasTexture[atlasName]) {\r\n            this.atlasTexture[atlasName].dispose();\r\n            this.atlasTexture[atlasName] = null;\r\n        }\r\n        if (this.atlasMap[atlasName]) {\r\n            this.atlasMap[atlasName].destroy();\r\n            this.atlasMap[atlasName] = null;\r\n        }\r\n        if (this.atlasImages[atlasName]) {\r\n            var none_1 = { x: 0, y: 0 };\r\n            this.atlasImages[atlasName].forEach(function (image) {\r\n                image.atlasReferenceID = null;\r\n                image.pixelWidth = 0;\r\n                image.pixelHeight = 0;\r\n                image.atlasBL = none_1;\r\n                image.atlasBR = none_1;\r\n                image.atlasTL = none_1;\r\n                image.atlasTR = none_1;\r\n            });\r\n            this.atlasImages[atlasName] = null;\r\n        }\r\n    };\r\n    AtlasManager.prototype.isValidImage = function (image) {\r\n        var isValid = false;\r\n        if (image && (image.imagePath || (image.label && image.label.text))) {\r\n            if (image.pixelWidth && image.pixelHeight) {\r\n                isValid = true;\r\n            }\r\n        }\r\n        return isValid;\r\n    };\r\n    AtlasManager.prototype.setDefaultImage = function (image, atlasName) {\r\n        image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\r\n        return image;\r\n    };\r\n    /**\r\n     * This loads, packs, and draws the indicated image into the specified canvas\r\n     * using the metrics that exists for the specified atlas.\r\n     *\r\n     * @param image The image who should have it's image path loaded\r\n     * @param atlasName The name of the atlas to make the packing work\r\n     * @param canvas The canvas we will be drawing into to generate the complete image\r\n     *\r\n     * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\r\n     */\r\n    AtlasManager.prototype.draw = function (image, atlasName, canvas) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var loadedImage, rect, dimensions, node, insertedNode, ux, uy, uw, uh, atlasDimensions;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        // Validate the index\r\n                        if (!this.atlasMap[atlasName]) {\r\n                            debug('Can not load image, invalid Atlas Name: %o for atlasMaps: %o', atlasName, this.atlasMap);\r\n                            return [2 /*return*/, false];\r\n                        }\r\n                        return [4 /*yield*/, this.loadImage(image)];\r\n                    case 1:\r\n                        loadedImage = _a.sent();\r\n                        // Make sure at this point the image knows it is not affiliated with an atlas\r\n                        // If something goes wrong with loading or insertting this image, then a null\r\n                        // Atlas value will indicate the image can not be used appropriately\r\n                        image.atlasReferenceID = null;\r\n                        // Only a non-null image means the image loaded correctly\r\n                        if (loadedImage && this.isValidImage(image)) {\r\n                            debug('Image loaded: %o', image.imagePath);\r\n                            rect = new bounds_1.Bounds(0, image.pixelWidth, image.pixelHeight, 0);\r\n                            dimensions = {\r\n                                first: image,\r\n                                second: rect,\r\n                            };\r\n                            // Auto add a buffer in\r\n                            dimensions.second.width += 1;\r\n                            dimensions.second.height += 1;\r\n                            node = this.atlasMap[atlasName];\r\n                            insertedNode = node.insert(dimensions);\r\n                            // If the result was NULL we did not successfully insert the image into any map\r\n                            if (insertedNode) {\r\n                                debug('Atlas location determined: %o', insertedNode);\r\n                                if (image.label) {\r\n                                    debugLabels('Atlas location determined. PackNode: %o Dimensions: %o', insertedNode, dimensions);\r\n                                }\r\n                                // Apply the image to the node\r\n                                insertedNode.nodeImage = image;\r\n                                ux = insertedNode.nodeDimensions.x / this.textureWidth;\r\n                                uy = insertedNode.nodeDimensions.y / this.textureHeight;\r\n                                uw = insertedNode.nodeDimensions.width / this.textureWidth;\r\n                                uh = insertedNode.nodeDimensions.height / this.textureHeight;\r\n                                debugLabels('uy is %o', uy);\r\n                                atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\r\n                                image.atlasReferenceID = atlasName;\r\n                                image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\r\n                                image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\r\n                                image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\r\n                                image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\r\n                                // Now draw the image to the indicated canvas\r\n                                canvas.drawImage(loadedImage, insertedNode.nodeDimensions.x, insertedNode.nodeDimensions.y);\r\n                                // We have finished inserting\r\n                                return [2 /*return*/, true];\r\n                            }\r\n                            else {\r\n                                // Log an error\r\n                                console.error(\"Could not fit image into atlas \" + image.imagePath);\r\n                                image = this.setDefaultImage(image, atlasName);\r\n                                return [2 /*return*/, false];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Log an error and load a default image\r\n                            console.error(\"Could not load image \" + image.imagePath);\r\n                            image = this.setDefaultImage(image, atlasName);\r\n                            return [2 /*return*/, false];\r\n                        }\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * This renders a list of colors to the canvas. This using the same packing\r\n     * algorithm as any image so the rendering is placed correctly or determines\r\n     * if enough space is not available.\r\n     *\r\n     * @param {AtlasColor[]} colors The list of colors to be rendered to the atlas\r\n     * @param {string} atlasName The name of the atlas being rendered to\r\n     * @param {CanvasRenderingContext2D} canvas The canvas of the atlas being rendered to\r\n     *\r\n     * @returns {Promise<boolean>} Resolves to true if the operation was successful\r\n     */\r\n    AtlasManager.prototype.drawColors = function (colors, atlasName, canvas) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var colorWidth, colorHeight, maxPerRow, rowWidth, rowCount, colCount, renderHeight, dimensions, node, insertedNode, image, ux, uy, uw, uh, atlasDimensions, renderSpace, startX, startY, nextX, nextY, beginX, beginY, col, row, _i, colors_1, color, _a, r, g, b;\r\n            return __generator(this, function (_b) {\r\n                debug('Finding space for colors on the atlas: %o', colors);\r\n                colorWidth = 2;\r\n                colorHeight = 2;\r\n                maxPerRow = 1024 / colorWidth;\r\n                rowWidth = Math.min(this.textureWidth, maxPerRow * colorWidth);\r\n                rowCount = Math.ceil((colors.length * colorWidth) / rowWidth);\r\n                colCount = Math.ceil(rowWidth / colorWidth);\r\n                renderHeight = rowCount * colorHeight;\r\n                dimensions = {\r\n                    // Since the algorithm requires something to fill this slot, just make a\r\n                    // Dummy object\r\n                    first: new atlas_texture_1.AtlasTexture(null, null),\r\n                    // Set the dimensions we calculated for the space our colors will take up\r\n                    // Within the atlas\r\n                    second: new bounds_1.Bounds(0, rowWidth, renderHeight, 0),\r\n                };\r\n                // Auto add a buffer in\r\n                dimensions.second.width += 1;\r\n                dimensions.second.height += 1;\r\n                node = this.atlasMap[atlasName];\r\n                insertedNode = node.insert(dimensions);\r\n                // If the result was NULL we did not successfully insert the image into any map\r\n                if (insertedNode) {\r\n                    debug('Atlas location determined for colors: %o', insertedNode);\r\n                    image = insertedNode.nodeImage = dimensions.first;\r\n                    ux = insertedNode.nodeDimensions.x / this.textureWidth;\r\n                    uy = insertedNode.nodeDimensions.y / this.textureHeight;\r\n                    uw = insertedNode.nodeDimensions.width / this.textureWidth;\r\n                    uh = insertedNode.nodeDimensions.height / this.textureHeight;\r\n                    atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\r\n                    image.atlasReferenceID = atlasName;\r\n                    image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\r\n                    image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\r\n                    image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\r\n                    image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\r\n                    renderSpace = insertedNode.nodeDimensions;\r\n                    startX = renderSpace.x;\r\n                    startY = renderSpace.y;\r\n                    nextX = colorWidth / this.textureWidth;\r\n                    nextY = -colorHeight / this.textureHeight;\r\n                    beginX = (startX / this.textureWidth) + (nextX / 2.0);\r\n                    beginY = 1.0 - (startY / this.textureHeight) + (nextY / 2.0);\r\n                    col = 0;\r\n                    row = 0;\r\n                    // Loop through each color, establish metrics, draw to the atlas\r\n                    for (_i = 0, colors_1 = colors; _i < colors_1.length; _i++) {\r\n                        color = colors_1[_i];\r\n                        // Staore the info needed to make the color referenceable again\r\n                        color.atlasReferenceID = atlasName;\r\n                        color.colorIndex = col + (row * colCount);\r\n                        color.colorsPerRow = colCount;\r\n                        // The location of the middle of the first color\r\n                        color.firstColor = {\r\n                            x: beginX,\r\n                            y: beginY,\r\n                        };\r\n                        color.nextColor = {\r\n                            x: nextX,\r\n                            y: nextY,\r\n                        };\r\n                        _a = color.color, r = _a.r, g = _a.g, b = _a.b;\r\n                        // Draw the color to the canvas\r\n                        canvas.fillStyle = \"rgba(\" + Math.round(r * 255.0) + \", \" + Math.round(g * 255.0) + \", \" + Math.round(b * 255.0) + \", \" + color.opacity + \")\";\r\n                        canvas.fillRect(col * colorWidth + startX, row * colorHeight + startY, colorWidth, colorHeight);\r\n                        col++;\r\n                        if (col === colCount) {\r\n                            col = 0;\r\n                            row++;\r\n                        }\r\n                    }\r\n                    // We have finished inserting\r\n                    return [2 /*return*/, image];\r\n                }\r\n                else {\r\n                    // Log an error\r\n                    throw new Error('Could not fit colors into atlas');\r\n                }\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Retrieves the threejs texture for the atlas\r\n     *\r\n     * @param atlasName The identifier of the atlas\r\n     */\r\n    AtlasManager.prototype.getAtlasTexture = function (atlasName) {\r\n        return this.atlasTexture[atlasName];\r\n    };\r\n    /**\r\n     * This reads the input path and loads the image specified by the path\r\n     *\r\n     * @param {AtlasTexture} texture This is an atlas texture with the path set\r\n     *\r\n     * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\r\n     *                                     or null if there was an error\r\n     */\r\n    AtlasManager.prototype.loadImage = function (texture) {\r\n        if (texture.imagePath) {\r\n            return new Promise(function (resolve, reject) {\r\n                var image = new Image();\r\n                image.onload = function () {\r\n                    texture.pixelWidth = image.width;\r\n                    texture.pixelHeight = image.height;\r\n                    texture.aspectRatio = image.width / image.height;\r\n                    resolve(image);\r\n                };\r\n                image.onerror = function () {\r\n                    resolve(null);\r\n                };\r\n                image.src = texture.imagePath;\r\n            });\r\n        }\r\n        else if (texture.label) {\r\n            return new Promise(function (resolve, reject) {\r\n                var label = texture.label;\r\n                var labelSize = label.getSize();\r\n                var canvas = document.createElement('canvas');\r\n                var ctx = canvas.getContext('2d');\r\n                // Set the dimensions of the canvas/texture space we will be using to rasterize\r\n                // The label. Use the label's rasterization controls to aid in rendering the label\r\n                canvas.width = labelSize.width + texture.label.rasterizationOffset.x;\r\n                canvas.height = labelSize.height;\r\n                debug('label X %o', texture.label.rasterizationOffset.x);\r\n                if (ctx) {\r\n                    var fontSize = label.fontSize;\r\n                    var color = d3_color_1.rgb(label.color.base.color.r * 255, label.color.base.color.g * 255, label.color.base.color.b * 255, label.color.base.opacity);\r\n                    ctx.font = label.makeCSSFont(fontSize);\r\n                    ctx.textAlign = label.textAlign;\r\n                    ctx.textBaseline = label.textBaseline;\r\n                    ctx.fillStyle = color.toString();\r\n                    // Render the label to the canvas/texture space. This utilizes the label's\r\n                    // Rasterization metrics to aid in getting a clean render.\r\n                    ctx.fillText(label.text, texture.label.rasterizationOffset.x, texture.label.rasterizationOffset.y);\r\n                    var image_1 = new Image();\r\n                    image_1.onload = function () {\r\n                        // Here we use the canvas dimensions and NOT the image dimensions\r\n                        // As the image dimensions are unreliable here when setting the src\r\n                        // To a data url\r\n                        texture.pixelWidth = image_1.width;\r\n                        texture.pixelHeight = image_1.height;\r\n                        texture.aspectRatio = image_1.width / image_1.height;\r\n                        debugLabels('Applying size based on rasterization to the Label: w: %o h: %o', image_1.width, image_1.height);\r\n                        label.setSize({\r\n                            height: image_1.height,\r\n                            width: image_1.width,\r\n                        });\r\n                        resolve(image_1);\r\n                    };\r\n                    image_1.onerror = function () {\r\n                        resolve(null);\r\n                    };\r\n                    image_1.src = canvas.toDataURL('image/png');\r\n                }\r\n            });\r\n        }\r\n        return Promise.resolve(null);\r\n    };\r\n    return AtlasManager;\r\n}());\r\nexports.AtlasManager = AtlasManager;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = __webpack_require__(1);\r\n/**\r\n * This is used specifically by the atlas manager to aid in packing\r\n * in textures within an area. This will guarantee boundaries of textures are\r\n * not violated and provide proper feedback for where to draw a given image\r\n */\r\nvar PackNode = (function () {\r\n    function PackNode(x, y, width, height) {\r\n        this.child = [null, null];\r\n        this.isLeaf = true;\r\n        this.nodeImage = null;\r\n        this.nodeDimensions = new bounds_1.Bounds(x, x + width, y, y - height);\r\n    }\r\n    /**\r\n     * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\r\n     */\r\n    PackNode.prototype.destroy = function () {\r\n        this.nodeImage = null;\r\n        if (this.child[0]) {\r\n            this.child[0].destroy();\r\n        }\r\n        if (this.child[1]) {\r\n            this.child[1].destroy();\r\n        }\r\n        this.child[0] = undefined;\r\n        this.child[1] = undefined;\r\n    };\r\n    /**\r\n     * Indicates if there is a child\r\n     */\r\n    PackNode.prototype.hasChild = function () {\r\n        if (this.child[0] && !this.child[0].nodeImage) {\r\n            return !this.child[0].isLeaf;\r\n        }\r\n        if (this.child[1] && !this.child[1].nodeImage) {\r\n            return !this.child[1].isLeaf;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Inserts images into our mapping, fitting them appropriately\r\n     */\r\n    PackNode.prototype.insert = function (image) {\r\n        if (!this.isLeaf) {\r\n            // Try inserting into first child\r\n            var newNode = this.child[0].insert(image);\r\n            if (newNode !== null) {\r\n                return newNode;\r\n            }\r\n            // No room in first so insert into second\r\n            return this.child[1].insert(image);\r\n        }\r\n        else {\r\n            // If there's already an image here, return\r\n            if (this.nodeImage) {\r\n                return null;\r\n            }\r\n            // Check the fit status of the image in this nodes rectangle space\r\n            var fitFlag = this.nodeDimensions.fits(image.second);\r\n            // If we're too small, return null indicating can not fit\r\n            if (fitFlag === 0) {\r\n                return null;\r\n            }\r\n            // If we're just right, accept\r\n            if (fitFlag === 1) {\r\n                return this;\r\n            }\r\n            // Otherwise, gotta split this node and create some leaves\r\n            this.isLeaf = false;\r\n            // Get the image width\r\n            var imgWidth = image.second.width;\r\n            var imgHeight = image.second.height;\r\n            // Decide which way to split\r\n            var dWidth = this.nodeDimensions.width - imgWidth;\r\n            var dHeight = this.nodeDimensions.height - image.second.height;\r\n            if (dWidth > dHeight) {\r\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, imgWidth, this.nodeDimensions.height);\r\n                this.child[1] = new PackNode(this.nodeDimensions.x + imgWidth, this.nodeDimensions.y, dWidth, this.nodeDimensions.height);\r\n            }\r\n            else {\r\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, this.nodeDimensions.width, imgHeight);\r\n                this.child[1] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y + imgHeight, this.nodeDimensions.width, dHeight);\r\n            }\r\n        }\r\n        // Insert into first child we created\r\n        return this.child[0].insert(image);\r\n    };\r\n    /**\r\n     * Removes the image from the mapping and tries to open up as much space as possible.\r\n     *\r\n     * @param {AtlasTexture} image The image to insert into the\r\n     */\r\n    PackNode.prototype.remove = function (image) {\r\n        if (!this.isLeaf) {\r\n            // Try removing from first child\r\n            var removed = this.child[0].remove(image);\r\n            if (removed) {\r\n                return true;\r\n            }\r\n            // Try remove from second\r\n            removed = this.child[1].remove(image);\r\n            if (!this.child[0].hasChild()) {\r\n                if (!this.child[1].hasChild()) {\r\n                    this.child[0] = null;\r\n                    this.child[1] = null;\r\n                }\r\n            }\r\n            return removed;\r\n        }\r\n        else {\r\n            if (this.nodeImage === image) {\r\n                this.nodeImage = null;\r\n                image.atlasReferenceID = null;\r\n                image.pixelWidth = 0;\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n    return PackNode;\r\n}());\r\nexports.PackNode = PackNode;\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ramda_1 = __webpack_require__(6);\r\nvar rotateable_quad_1 = __webpack_require__(13);\r\nvar sprite_1 = __webpack_require__(14);\r\nvar measurement = new sprite_1.Sprite(200, 200, 1, 1);\r\nvar Label = (function (_super) {\r\n    __extends(Label, _super);\r\n    /**\r\n     * Creates an instance of Label.\r\n     *\r\n     * @param {Partial<Label<T>>} [options={}]\r\n     */\r\n    function Label(options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _this = _super.call(this, { x: 0, y: 1 }, { width: 1, height: 1 }, 0, rotateable_quad_1.AnchorPosition.TopLeft) || this;\r\n        _this.depth = 40;\r\n        _this.direction = 'inherit';\r\n        _this.font = 'serif';\r\n        _this.fontSize = 10;\r\n        _this.fontWeight = 400;\r\n        _this.maxWidth = undefined;\r\n        _this.text = '';\r\n        _this.id = '';\r\n        _this.textAlign = 'start';\r\n        _this.textBaseline = 'alphabetic';\r\n        _this.zoomable = false;\r\n        /**\r\n         * This contains an adjustment to aid in the rasterization process. Getting\r\n         * reliable dimensions for fonts and text can be incredibly challenging,\r\n         * thus, this allows you to offset the rasterization if you get pieces of\r\n         * the label cut off.\r\n         */\r\n        _this.rasterizationOffset = { x: 20, y: 0 };\r\n        /**\r\n         * This contains an adjustment to aid in the rasterization process. Getting\r\n         * reliable dimensions for fonts and text can be incredibly challenging,\r\n         * thus, this allows you to pad the rasterization space if you get pieces of\r\n         * the label cut off.\r\n         */\r\n        _this.rasterizationPadding = { width: 0, height: 0 };\r\n        // Set props\r\n        Object.assign(_this, options);\r\n        // Make sure our dimensions are set\r\n        _this.setFontSize(options.fontSize || 12);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Label.prototype, \"baseLabel\", {\r\n        get: function () {\r\n            return this._baseLabel;\r\n        },\r\n        set: function (value) {\r\n            this._baseLabel = value;\r\n            this.text = value.text;\r\n            this.fontSize = value.fontSize;\r\n            this.font = value.font;\r\n            this.textAlign = value.textAlign;\r\n            this.textBaseline = value.textBaseline;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"rasterizedLabel\", {\r\n        /**\r\n         * This getter ensures the rasterized label retrieved is either this labels own rasterization\r\n         * or from a base.\r\n         */\r\n        get: function () {\r\n            if (this.baseLabel) {\r\n                return this.baseLabel.rasterizedLabel;\r\n            }\r\n            return this._rasterizedLabel;\r\n        },\r\n        set: function (value) {\r\n            this._rasterizedLabel = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Copies all of the properties of a label and makes this label use them\r\n     *\r\n     * @param {Label} label The labels whose properties we wish to copy\r\n     */\r\n    Label.prototype.copyLabel = function (label) {\r\n        // Assign the properties of the other label to this\r\n        // Specifically, ONLY label properties\r\n        Object.assign(this, ramda_1.omit(['x', 'y', 'width', 'height'], label));\r\n        // Use this to set the text to make sure all of the metrics are re-calculated\r\n        this.setText(label.text);\r\n    };\r\n    /**\r\n     * This gets the actual text this label is capable of rendering\r\n     */\r\n    Label.prototype.getText = function () {\r\n        if (this._baseLabel) {\r\n            return this._baseLabel.getText();\r\n        }\r\n        return this.text;\r\n    };\r\n    /**\r\n     * Takes all of the current settings and makes a CSS font string\r\n     */\r\n    Label.prototype.makeCSSFont = function (fontSize) {\r\n        return this.fontWeight + \" \" + (fontSize || this.fontSize) + \"px \" + this.font;\r\n    };\r\n    /**\r\n     * Change the position this text is rendered to\r\n     *\r\n     * @param x X world coordinate\r\n     * @param y Y world coordinate\r\n     */\r\n    Label.prototype.position = function (x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    };\r\n    /**\r\n     * This sets the font size for the label based on the base text dimensions\r\n     *\r\n     * @param {number} fontSize\r\n     */\r\n    Label.prototype.setFontSize = function (fontSize) {\r\n        var lbl = this.getText();\r\n        var size = this.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n        if (this.baseLabel) {\r\n            var baseSize = this.baseLabel.getSize();\r\n            var scale = fontSize / this.baseLabel.fontSize;\r\n            height = baseSize.height * scale;\r\n            width = baseSize.width * scale;\r\n        }\r\n        else {\r\n            measurement.context.font = this.makeCSSFont();\r\n            var size_1 = measurement.context.measureText(lbl);\r\n            // Set our properties based on the calculated size\r\n            height = fontSize;\r\n            width = size_1.width;\r\n        }\r\n        this.fontSize = fontSize;\r\n        this.setSize({ width: width, height: height });\r\n    };\r\n    /**\r\n     * Change the text and the calculated bounding box for this label\r\n     */\r\n    Label.prototype.setText = function (lbl) {\r\n        this.text = lbl;\r\n        this.setFontSize(this.fontSize);\r\n    };\r\n    Label.prototype.update = function () {\r\n        this.setFontSize(this.fontSize);\r\n        _super.prototype.update.call(this);\r\n    };\r\n    return Label;\r\n}(rotateable_quad_1.RotateableQuad));\r\nexports.Label = Label;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\nvar bounds_1 = __webpack_require__(1);\r\nvar AnchorPosition;\r\n(function (AnchorPosition) {\r\n    AnchorPosition[AnchorPosition[\"BottomLeft\"] = 0] = \"BottomLeft\";\r\n    AnchorPosition[AnchorPosition[\"BottomRight\"] = 1] = \"BottomRight\";\r\n    AnchorPosition[AnchorPosition[\"Custom\"] = 2] = \"Custom\";\r\n    AnchorPosition[AnchorPosition[\"Middle\"] = 3] = \"Middle\";\r\n    AnchorPosition[AnchorPosition[\"MiddleBottom\"] = 4] = \"MiddleBottom\";\r\n    AnchorPosition[AnchorPosition[\"MiddleLeft\"] = 5] = \"MiddleLeft\";\r\n    AnchorPosition[AnchorPosition[\"MiddleRight\"] = 6] = \"MiddleRight\";\r\n    AnchorPosition[AnchorPosition[\"MiddleTop\"] = 7] = \"MiddleTop\";\r\n    AnchorPosition[AnchorPosition[\"TopLeft\"] = 8] = \"TopLeft\";\r\n    AnchorPosition[AnchorPosition[\"TopRight\"] = 9] = \"TopRight\";\r\n})(AnchorPosition = exports.AnchorPosition || (exports.AnchorPosition = {}));\r\nvar anchorCalculations = (_a = {},\r\n    _a[AnchorPosition.BottomLeft] = function (quad) { return ({\r\n        x: 0,\r\n        y: 0,\r\n    }); },\r\n    _a[AnchorPosition.BottomRight] = function (quad) { return ({\r\n        x: quad.getSize().width,\r\n        y: 0,\r\n    }); },\r\n    _a[AnchorPosition.Custom] = function (quad) { return ({\r\n        x: 0,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a[AnchorPosition.Middle] = function (quad) { return ({\r\n        x: quad.getSize().width / 2,\r\n        y: quad.getSize().height / 2,\r\n    }); },\r\n    _a[AnchorPosition.MiddleBottom] = function (quad) { return ({\r\n        x: quad.getSize().width / 2,\r\n        y: 0,\r\n    }); },\r\n    _a[AnchorPosition.MiddleLeft] = function (quad) { return ({\r\n        x: 0,\r\n        y: quad.getSize().height / 2,\r\n    }); },\r\n    _a[AnchorPosition.MiddleRight] = function (quad) { return ({\r\n        x: quad.getSize().width,\r\n        y: quad.getSize().height / 2,\r\n    }); },\r\n    _a[AnchorPosition.MiddleTop] = function (quad) { return ({\r\n        x: quad.getSize().width / 2,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a[AnchorPosition.TopLeft] = function (quad) { return ({\r\n        x: 0,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a[AnchorPosition.TopRight] = function (quad) { return ({\r\n        x: quad.getSize().width,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a);\r\nvar RotateableQuad = (function (_super) {\r\n    __extends(RotateableQuad, _super);\r\n    /**\r\n     * Generates a quad\r\n     *\r\n     * @param {IPoint} location The location of the quad (it's anchorpoint will be placed here)\r\n     * @param {number} width The width of the quad\r\n     * @param {number} height The height of the quad\r\n     * @param {AnchorPosition} anchor The anchor location of the quad.\r\n     *                                Location and rotation will be relative to this.\r\n     */\r\n    function RotateableQuad(location, size, rotation, anchor) {\r\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\r\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\r\n        // Apply our properties\r\n        _this.setSize(size);\r\n        _this.setAnchor(anchor);\r\n        _this.setLocation(location);\r\n        _this.setRotation(rotation);\r\n        // Update the transform and the corner vertices\r\n        _this.update();\r\n        return _this;\r\n    }\r\n    /**\r\n     * @private\r\n     * Recalculates this anchor position based on the anchor type\r\n     *\r\n     * @param {AnchorPosition} anchor\r\n     */\r\n    RotateableQuad.prototype.calculateAnchor = function (anchor) {\r\n        this.anchor = anchorCalculations[anchor](this);\r\n    };\r\n    /**\r\n     * Get the base size of the quad\r\n     *\r\n     * @returns {ISize} The base size of this quad\r\n     */\r\n    RotateableQuad.prototype.getSize = function () {\r\n        return this.size;\r\n    };\r\n    /**\r\n     * Sets the specified anchor position on the quad\r\n     *\r\n     * @param {AnchorPosition} anchor This specifies an auto calculated position for the anchor\r\n     * @param {IPoint} custom If specified, will set a custom anchor location rather\r\n     *                        than the calculated version.\r\n     */\r\n    RotateableQuad.prototype.setAnchor = function (anchor, custom) {\r\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\r\n        this.anchorType = anchor;\r\n        // Apply the custom position if present\r\n        if (custom) {\r\n            this.anchorType = AnchorPosition.Custom;\r\n            this.anchor = custom;\r\n            return;\r\n        }\r\n        this.calculateAnchor(anchor);\r\n    };\r\n    RotateableQuad.prototype.getAnchor = function () {\r\n        return this.anchor;\r\n    };\r\n    RotateableQuad.prototype.getAnchorType = function () {\r\n        return this.anchorType;\r\n    };\r\n    /**\r\n     * This sets the location of this quad to a given position where the anchor\r\n     * point will be located on top of the location provided.\r\n     *\r\n     * @param {IPoint} location The location to place the quad\r\n     */\r\n    RotateableQuad.prototype.setLocation = function (location) {\r\n        this.location = location;\r\n    };\r\n    RotateableQuad.prototype.getLocation = function () {\r\n        return this.location;\r\n    };\r\n    /**\r\n     * Sets the rotation of this quad, in radians, rotated around the anchor point.\r\n     *\r\n     * @param {number} rotation The rotation of the quad\r\n     */\r\n    RotateableQuad.prototype.setRotation = function (rotation) {\r\n        this.rotation = rotation;\r\n    };\r\n    /**\r\n     * get Rotation\r\n     */\r\n    RotateableQuad.prototype.getRotation = function () {\r\n        return this.rotation;\r\n    };\r\n    /**\r\n     * get direction as a point\r\n     */\r\n    RotateableQuad.prototype.getDirection = function () {\r\n        var angle = this.rotation;\r\n        return {\r\n            x: Math.cos(angle),\r\n            y: Math.sin(angle),\r\n        };\r\n    };\r\n    /**\r\n     * Applies the size to the base\r\n     *\r\n     * @param {ISize} size The size of the base quad\r\n     */\r\n    RotateableQuad.prototype.setSize = function (size) {\r\n        this.size = size;\r\n        this.base = [\r\n            new three_1.Vector4(0, size.height, 0, 1),\r\n            new three_1.Vector4(size.width, size.height, 0, 1),\r\n            new three_1.Vector4(0, 0, 0, 1),\r\n            new three_1.Vector4(size.width, 0, 0, 1),\r\n        ];\r\n        if (this.anchorType) {\r\n            this.calculateAnchor(this.anchorType);\r\n        }\r\n    };\r\n    /**\r\n     * This re-calculates the transform for this quad and applies the transform to\r\n     * the corners.\r\n     */\r\n    RotateableQuad.prototype.update = function () {\r\n        // Calculate the pieces of the transformation\r\n        var anchorMat = new three_1.Matrix4().makeTranslation(this.anchor.x, -this.anchor.y, 0);\r\n        var rotationMat = new three_1.Matrix4().makeRotationZ(this.rotation);\r\n        var locationMat = new three_1.Matrix4().makeTranslation(this.location.x, this.location.y, 0);\r\n        // Compose the transform based on the pieces and apply them\r\n        // In the proper compositing order\r\n        this.transform = new three_1.Matrix4()\r\n            .multiply(locationMat)\r\n            .multiply(rotationMat)\r\n            .multiply(anchorMat);\r\n        // Apply the transform to all of our base vertices\r\n        this.TL = this.base[0].clone().applyMatrix4(this.transform);\r\n        this.TR = this.base[1].clone().applyMatrix4(this.transform);\r\n        this.BL = this.base[2].clone().applyMatrix4(this.transform);\r\n        this.BR = this.base[3].clone().applyMatrix4(this.transform);\r\n        // Update the bounds of this object\r\n        this.x = this.TL.x;\r\n        this.y = this.TL.y;\r\n        this.width = 1;\r\n        this.height = 1;\r\n        this.encapsulatePoints([this.TR, this.BL, this.BR]);\r\n    };\r\n    return RotateableQuad;\r\n}(bounds_1.Bounds));\r\nexports.RotateableQuad = RotateableQuad;\r\nvar _a;\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * A canvas element wrapper that aids in tracking a canvas element along with\r\n * content scaling properties.\r\n *\r\n * @class Sprite\r\n */\r\nvar Sprite = (function () {\r\n    //\r\n    // Ctor at the top below props\r\n    //\r\n    /**\r\n     * Creates an instance of Sprite.\r\n     *\r\n     * @param w             The width of the context to create\r\n     * @param h             The height of the context to create\r\n     * @param contentScaleX The content scaling of the content\r\n     * @param contentScaleY The content scaling of the content\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    function Sprite(w, h, contentScaleX, contentScaleY) {\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        var canvas = document.createElement('canvas');\r\n        if (canvas) {\r\n            this.scaleX = contentScaleX || this.scaleX;\r\n            this.scaleY = contentScaleY || this.scaleY;\r\n            canvas.width = w * this.scaleX;\r\n            canvas.height = h * this.scaleY;\r\n            this.context = canvas.getContext('2d');\r\n            this.canvas = canvas;\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the content scaling of this object\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getContentScale = function () {\r\n        return {\r\n            x: this.scaleX,\r\n            y: this.scaleY,\r\n        };\r\n    };\r\n    /**\r\n     * Retrieves the size of the content ignoring scaling\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getContentSize = function () {\r\n        return {\r\n            height: this.canvas.height,\r\n            width: this.canvas.width,\r\n        };\r\n    };\r\n    /**\r\n     * Retrieves the dimensional width of the content applying scaling\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getWidth = function () {\r\n        return this.canvas.width / this.scaleX;\r\n    };\r\n    /**\r\n     * Retrieves the dimensional height of the content applying scaling\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getHeight = function () {\r\n        return this.canvas.height / this.scaleY;\r\n    };\r\n    return Sprite;\r\n}());\r\nexports.Sprite = Sprite;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar browser = __webpack_require__(27);\r\nvar three_1 = __webpack_require__(0);\r\nvar debug = __webpack_require__(2)('CommunicationsView:Mouse');\r\n/** Used to adjust the base whee delta for IE browsers */\r\nvar IE_ADJUSTMENT = 1 / 30;\r\n/** Used to adjust the rates for IE 11 */\r\nvar OLD_IE_ADJUSTMENT = -0.25;\r\n// This determines how large the delta can grow to in firefox\r\nvar MAX_FIREFOX_WHEELDELTA = 100;\r\n/**\r\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\r\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\r\n */\r\nvar lowPassY = [0, 0, 0, 0];\r\n// These coefficients represent the coefficients of a FIR filter.\r\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\r\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\r\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\r\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\r\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\r\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\r\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\r\n// Attained.\r\nvar LOW_PASS_U0 = 0.1;\r\nvar LOW_PASS_U1 = 0.2;\r\nvar LOW_PASS_U2 = 0.2;\r\nvar LOW_PASS_U3 = 0.5;\r\nfunction normalizeFirefoxWheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    var deltaX = 0;\r\n    var deltaY = 0;\r\n    // Reset the filter if the direction changes to prevent lag in directional change\r\n    if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\r\n        lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\r\n    }\r\n    deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\r\n    // Calculate the next value output from the FIR filter\r\n    deltaY = (wheel.deltaY * MAX_FIREFOX_WHEELDELTA) * LOW_PASS_U0 + lowPassY[0] * LOW_PASS_U1 + lowPassY[1] * LOW_PASS_U2 + lowPassY[2] * LOW_PASS_U3;\r\n    // Store the value of the filter in the FIR memory bank\r\n    lowPassY.unshift(deltaY);\r\n    // Keep our FIR memory clean and only the size of the number of coefficients\r\n    lowPassY.pop();\r\n    return new three_1.Vector2(-deltaX, -deltaY);\r\n}\r\nfunction normalizeChromeWheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    return new three_1.Vector2(wheel.deltaX, -wheel.deltaY);\r\n}\r\nfunction normalizeIE11Wheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    var deltaX = wheel.deltaX;\r\n    if (deltaX === undefined) {\r\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\r\n    }\r\n    var deltaY = wheel.deltaY;\r\n    if (deltaY === undefined) {\r\n        if (wheel.wheelDeltaY !== undefined) {\r\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\r\n        }\r\n        else {\r\n            deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\r\n        }\r\n    }\r\n    return new three_1.Vector2(-deltaX, -deltaY);\r\n}\r\nfunction normalizeIE12Wheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    var deltaX = wheel.deltaX, deltaY = wheel.deltaY;\r\n    if (deltaX === undefined) {\r\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\r\n    }\r\n    if (deltaY === undefined) {\r\n        if (wheel.wheelDeltaY !== undefined) {\r\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\r\n        }\r\n        else {\r\n            deltaY = wheel.wheelDelta || -wheel.detail;\r\n        }\r\n    }\r\n    var v = new three_1.Vector2(deltaX, -deltaY);\r\n    v.multiplyScalar(0.25);\r\n    return v;\r\n}\r\n// Determine this browsers version of wheel normalization and apply it\r\nvar normalizeWheel;\r\nexports.normalizeWheel = normalizeWheel;\r\nif (browser.firefox) {\r\n    debug('Using mouse wheel for firefox');\r\n    exports.normalizeWheel = normalizeWheel = normalizeFirefoxWheel;\r\n}\r\nelse if (browser.msie && +browser.version >= 11) {\r\n    debug('Using mouse wheel for IE 11');\r\n    exports.normalizeWheel = normalizeWheel = normalizeIE11Wheel;\r\n}\r\nelse if (browser.msedge) {\r\n    debug('Using mouse wheel for MS EDGE');\r\n    exports.normalizeWheel = normalizeWheel = normalizeIE12Wheel;\r\n}\r\nelse {\r\n    debug('Using mouse wheel for Chrome');\r\n    exports.normalizeWheel = normalizeWheel = normalizeChromeWheel;\r\n}\r\n/**\r\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\r\n */\r\nfunction eventElementPosition(e, relative) {\r\n    var mouseX = 0, mouseY = 0, eventX = 0, eventY = 0, object = relative || e.nativeEvent.target;\r\n    // Get mouse position on document crossbrowser\r\n    if (!e) {\r\n        e = window.event;\r\n    }\r\n    if (e.pageX || e.pageY) {\r\n        mouseX = e.pageX;\r\n        mouseY = e.pageY;\r\n    }\r\n    else if (e.clientX || e.clientY) {\r\n        mouseX = e.clientX + document.body.scrollLeft\r\n            + document.documentElement.scrollLeft;\r\n        mouseY = e.clientY + document.body.scrollTop\r\n            + document.documentElement.scrollTop;\r\n    }\r\n    // Get parent element position in document\r\n    if (object.offsetParent) {\r\n        do {\r\n            eventX += object.offsetLeft;\r\n            eventY += object.offsetTop;\r\n            object = object.offsetParent;\r\n        } while (object);\r\n    }\r\n    // Mouse position minus elm position is mouseposition relative to element:\r\n    return { x: mouseX - eventX, y: mouseY - eventY };\r\n}\r\nexports.eventElementPosition = eventElementPosition;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = __webpack_require__(1);\r\n// A configuration that controls how readily a quadtree will split to another level\r\n// Adjusting this number can improve or degrade your performance significantly and\r\n// Must be tested for specific use cases\r\nvar maxPopulation = 5;\r\nvar maxDepth = 10;\r\n/**\r\n * This filters a quad tree query by type\r\n *\r\n * @export\r\n * @template T\r\n */\r\nfunction filterQuery(type, queryValues) {\r\n    var filtered = [];\r\n    queryValues.forEach(function (obj) {\r\n        if (type.find(function (t) { return obj instanceof t; })) {\r\n            filtered.push(obj);\r\n        }\r\n    });\r\n    return filtered;\r\n}\r\nexports.filterQuery = filterQuery;\r\n/**\r\n * This is a class used specifically by the quad tree nodes to indicate split space\r\n * within the quad tree.\r\n *\r\n * @class Quadrants\r\n */\r\nvar Quadrants = (function () {\r\n    /**\r\n     * Creates an instance of Quadrants.\r\n     *\r\n     * @param bounds The bounds this will create quandrants for\r\n     * @param depth  The child depth of this element\r\n     *\r\n     * @memberOf Quadrants\r\n     */\r\n    function Quadrants(bounds, depth) {\r\n        this.TL = null;\r\n        this.TR = null;\r\n        this.BL = null;\r\n        this.BR = null;\r\n        var mid = bounds.mid;\r\n        this.TL = new Node(bounds.x, mid.x, bounds.y, mid.y, depth);\r\n        this.TR = new Node(mid.x, bounds.right, bounds.y, mid.y, depth);\r\n        this.BL = new Node(bounds.x, mid.x, mid.y, bounds.bottom, depth);\r\n        this.BR = new Node(mid.x, bounds.right, mid.y, bounds.bottom, depth);\r\n    }\r\n    /**\r\n     * Ensures all memory is released for all nodes and all references are removed\r\n     * to potentially high memory consumption items\r\n     *\r\n     * @memberOf Quadrants\r\n     */\r\n    Quadrants.prototype.destroy = function () {\r\n        this.TL.destroy();\r\n        this.TR.destroy();\r\n        this.BL.destroy();\r\n        this.BR.destroy();\r\n        this.TL = null;\r\n        this.TR = null;\r\n        this.BL = null;\r\n        this.BR = null;\r\n    };\r\n    return Quadrants;\r\n}());\r\nexports.Quadrants = Quadrants;\r\n/**\r\n * The quad tree node. This Node will take in a certain population before dividing itself into\r\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\r\n * does not completely get injected into one of the quadrants it remains as a member of this node.\r\n *\r\n * @export\r\n * @class Node\r\n */\r\nvar Node = (function () {\r\n    /**\r\n     * Creates an instance of Node.\r\n     *\r\n     * @param l     The bounding left wall of the space this node covers\r\n     * @param r     The bounding right wall of the space this node covers\r\n     * @param t     The bounding top wall of the space this node covers\r\n     * @param b     The bounding bottom wall of the space this node covers\r\n     * @param depth The depth within the quad tree this node resides\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    function Node(left, right, top, bottom, depth) {\r\n        this.bounds = null;\r\n        this.children = [];\r\n        this.childrenProps = [];\r\n        this.depth = 0;\r\n        this.nodes = null;\r\n        // If params insertted\r\n        if (arguments.length >= 4) {\r\n            this.bounds = new bounds_1.Bounds(left, right, top, bottom);\r\n        }\r\n        else {\r\n            this.bounds = new bounds_1.Bounds(0, 1, 1, 0);\r\n        }\r\n        // Ensure the depth is set\r\n        this.depth = depth || 0;\r\n    }\r\n    /**\r\n     * Destroys this node and ensures all child nodes are destroyed as well.\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.destroy = function () {\r\n        this.children = null;\r\n        this.bounds = null;\r\n        if (this.nodes) {\r\n            this.nodes.destroy();\r\n            this.nodes = null;\r\n        }\r\n    };\r\n    /**\r\n     * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\r\n     * or into a sub quadrant if this node is split already. If the child is outside the boundaries\r\n     * this quad tree spans (and this is the root node), the quad tree will expand to include\r\n     * the new child.\r\n     *\r\n     * @param child The Bounds type object to inject\r\n     * @param props Properties that can be retrieved with the child object if applicable\r\n     *\r\n     * @returns True if the insertion was successful\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.add = function (child, props) {\r\n        // This is the entry function for adding children, so we must first expand our top node\r\n        // To cover the area that the child is located.\r\n        // If we're in bounds, then let's just add the child\r\n        if (child.isInside(this.bounds)) {\r\n            return this.doAdd(child);\r\n        }\r\n        else {\r\n            this.cover(child);\r\n            return this.add(child, props);\r\n        }\r\n    };\r\n    /**\r\n     * Adds a list of new children to this quad tree. It performs the same operations as\r\n     * addChild for each child in the list, however, it more efficiently recalculates the\r\n     * bounds necessary to cover the area the children cover.\r\n     *\r\n     * @param children      List of Bounds objects to inject\r\n     * @param childrenProps List of props to associate with each element\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.addAll = function (children, childrenProps) {\r\n        var _this = this;\r\n        // Ensure the properties are at least defined\r\n        childrenProps = childrenProps || [];\r\n        // Make sure we cover the entire area of all the children.\r\n        // We can speed this up a lot if we first calculate the total bounds the new children covers\r\n        var minX = Number.MAX_VALUE;\r\n        var minY = Number.MAX_VALUE;\r\n        var maxX = -Number.MAX_VALUE;\r\n        var maxY = -Number.MAX_VALUE;\r\n        // Get the dimensions of the new bounds\r\n        children.forEach(function (child) {\r\n            if (child.x < minX) {\r\n                minX = child.x;\r\n            }\r\n            if (child.right > maxX) {\r\n                maxX = child.right;\r\n            }\r\n            if (child.bottom < minY) {\r\n                minY = child.bottom;\r\n            }\r\n            if (child.y > maxY) {\r\n                maxY = child.y;\r\n            }\r\n        });\r\n        // Make sure our bounds includes the specified bounds\r\n        this.cover(new bounds_1.Bounds(minX, maxX, maxY, minY));\r\n        // Add all of the children into the tree\r\n        children.forEach(function (child, index) { return _this.doAdd(child); });\r\n    };\r\n    /**\r\n     * Ensures this quad tree includes the bounds specified in it's spatial coverage.\r\n     * This will cause all children to be re-injected into the tree.\r\n     *\r\n     * @param bounds The bounds to include in the tree's coverage\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.cover = function (bounds) {\r\n        var _this = this;\r\n        // If we are already covering the area: abort\r\n        if (bounds.isInside(this.bounds)) {\r\n            return;\r\n        }\r\n        // Make our bounds cover the new area\r\n        this.bounds.encapsulate(bounds);\r\n        this.bounds.x -= 1;\r\n        this.bounds.y += 1;\r\n        this.bounds.width += 2;\r\n        this.bounds.height += 4;\r\n        // Get all of the children underneath this node\r\n        var allChildren = this.gatherChildren([]);\r\n        // Destroy the split nodes\r\n        if (this.nodes) {\r\n            // Completely...destroy...\r\n            this.nodes.destroy();\r\n            this.nodes = null;\r\n        }\r\n        // Reinsert all children with the new dimensions in place\r\n        allChildren.forEach(function (child, index) { return _this.doAdd(child); });\r\n    };\r\n    /**\r\n     * When adding children, this performs the actual action of injecting the child into the tree\r\n     * without the process of seeing if the tree needs a spatial adjustment to account for the child.\r\n     *\r\n     * @param child The Bounds item to inject into the tree\r\n     * @param props The props to remain associated with the child\r\n     *\r\n     * @returns True if the injection was successful\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.doAdd = function (child) {\r\n        // If nodes are present, then we have already exceeded the population of this node\r\n        if (this.nodes) {\r\n            if (child.isInside(this.nodes.TL.bounds)) {\r\n                return this.nodes.TL.doAdd(child);\r\n            }\r\n            if (child.isInside(this.nodes.TR.bounds)) {\r\n                return this.nodes.TR.doAdd(child);\r\n            }\r\n            if (child.isInside(this.nodes.BL.bounds)) {\r\n                return this.nodes.BL.doAdd(child);\r\n            }\r\n            if (child.isInside(this.nodes.BR.bounds)) {\r\n                return this.nodes.BR.doAdd(child);\r\n            }\r\n            // Otherwise, this is a child overlapping this border\r\n            this.children.push(child);\r\n            return true;\r\n        }\r\n        else if (child.isInside(this.bounds)) {\r\n            this.children.push(child);\r\n            // If we exceeded our population for this quadrant, it is time to split up\r\n            if (this.children.length > maxPopulation && this.depth < maxDepth) {\r\n                this.split();\r\n            }\r\n            return true;\r\n        }\r\n        // This is when there is something wrong with the insertted child. The bounds\r\n        // For the quad should have grown without issue, but in this case the bounds\r\n        // Could not grow to accomodate the child.\r\n        if (isNaN(child.width + child.height + child.x + child.y)) {\r\n            console.error('Child did not fit into bounds because a dimension is NaN', child);\r\n        }\r\n        else if (child.area === 0) {\r\n            console.error('Child did not fit into bounds because the area is zero', child);\r\n        }\r\n        // Don't insert the child and continue\r\n        return true;\r\n    };\r\n    /**\r\n     * Collects all children of all the current and sub nodes into a single list.\r\n     *\r\n     * @param list The list we must aggregate children into\r\n     *\r\n     * @return The list specified as the list parameter\r\n     */\r\n    Node.prototype.gatherChildren = function (list) {\r\n        list = list.concat(this.children);\r\n        if (this.nodes) {\r\n            this.nodes.TL.gatherChildren(list);\r\n            this.nodes.TR.gatherChildren(list);\r\n            this.nodes.BL.gatherChildren(list);\r\n            this.nodes.BR.gatherChildren(list);\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Collects all props associated with the children. This array of props will\r\n     * mirror the list retrieved with gatherChildren.\r\n     *\r\n     * @param list\r\n     *\r\n     * @returns The list specified as the list paramter\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.gatherProps = function (list) {\r\n        var _this = this;\r\n        this.children.forEach(function (c, index) {\r\n            list.push(_this.childrenProps[index]);\r\n        });\r\n        if (this.nodes) {\r\n            this.nodes.TL.gatherProps(list);\r\n            this.nodes.TR.gatherProps(list);\r\n            this.nodes.BL.gatherProps(list);\r\n            this.nodes.BR.gatherProps(list);\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Entry query for determining query type based on input object\r\n     *\r\n     * @param bounds Can be a Bounds or a Point object\r\n     * @param visit  A callback function that will receive the Node as it is analyzed. This gives\r\n     *               information on a spatial scale, how a query reaches it's target intersections.\r\n     *\r\n     * @return An array of children that intersects with the query\r\n     */\r\n    Node.prototype.query = function (bounds, visit) {\r\n        // Query a rectangle\r\n        if (bounds instanceof bounds_1.Bounds) {\r\n            if (bounds.hitBounds(this.bounds)) {\r\n                return this.queryBounds(bounds, [], visit);\r\n            }\r\n            // Return an empty array when nothing is collided with\r\n            return [];\r\n        }\r\n        // Query a point\r\n        if (this.bounds.containsPoint(bounds)) {\r\n            return this.queryPoint(bounds, [], visit);\r\n        }\r\n        // Return an empty array when nothing is collided with\r\n        return [];\r\n    };\r\n    /**\r\n     * Queries children for intersection with a bounds object\r\n     *\r\n     * @param b     The Bounds to test children against\r\n     * @param list  The list of children to aggregate into the query\r\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\r\n     *              information on a spatial scale, how a query reaches it's target intersections.\r\n     *\r\n     * @return     Returns the exact same list that was input as the list param\r\n     */\r\n    Node.prototype.queryBounds = function (b, list, visit) {\r\n        this.children.forEach(function (c, index) {\r\n            if (c.hitBounds(b)) {\r\n                list.push(c);\r\n            }\r\n        });\r\n        if (visit) {\r\n            visit(this);\r\n        }\r\n        if (this.nodes) {\r\n            if (b.hitBounds(this.nodes.TL.bounds)) {\r\n                this.nodes.TL.queryBounds(b, list, visit);\r\n            }\r\n            if (b.hitBounds(this.nodes.TR.bounds)) {\r\n                this.nodes.TR.queryBounds(b, list, visit);\r\n            }\r\n            if (b.hitBounds(this.nodes.BL.bounds)) {\r\n                this.nodes.BL.queryBounds(b, list, visit);\r\n            }\r\n            if (b.hitBounds(this.nodes.BR.bounds)) {\r\n                this.nodes.BR.queryBounds(b, list, visit);\r\n            }\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Queries children for intersection with a point\r\n     *\r\n     * @param p     The Point to test children against\r\n     * @param list  The list of children to aggregate into the query\r\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\r\n     *              information on a spatial scale, how a query reaches it's target intersections.\r\n     *\r\n     * @return      Returns the exact same list that was input as the list param\r\n     */\r\n    Node.prototype.queryPoint = function (p, list, visit) {\r\n        this.children.forEach(function (c, index) {\r\n            if (c.containsPoint(p)) {\r\n                list.push(c);\r\n            }\r\n        });\r\n        if (visit) {\r\n            visit(this);\r\n        }\r\n        if (this.nodes) {\r\n            if (this.nodes.TL.bounds.containsPoint(p)) {\r\n                this.nodes.TL.queryPoint(p, list, visit);\r\n            }\r\n            if (this.nodes.TR.bounds.containsPoint(p)) {\r\n                this.nodes.TR.queryPoint(p, list, visit);\r\n            }\r\n            if (this.nodes.BL.bounds.containsPoint(p)) {\r\n                this.nodes.BL.queryPoint(p, list, visit);\r\n            }\r\n            if (this.nodes.BR.bounds.containsPoint(p)) {\r\n                this.nodes.BR.queryPoint(p, list, visit);\r\n            }\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Creates four sub quadrants for this node.\r\n     */\r\n    Node.prototype.split = function () {\r\n        // Gather all items to be handed down\r\n        var allChildren = this.gatherChildren([]);\r\n        // Gather all props for the children to be handed down as well\r\n        this.nodes = new Quadrants(this.bounds, this.depth + 1);\r\n        this.children = [];\r\n        this.childrenProps = [];\r\n        while (allChildren.length > 0) {\r\n            this.doAdd(allChildren.pop());\r\n        }\r\n    };\r\n    /**\r\n     * Traverses the quad tree returning every quadrant encountered\r\n     *\r\n     * @param cb A callback that has the parameter (node) which is a quadrant in the tree\r\n     */\r\n    Node.prototype.visit = function (cb) {\r\n        var finished = Boolean(cb(this));\r\n        if (this.nodes && !finished) {\r\n            this.nodes.TL.visit(cb);\r\n            this.nodes.TR.visit(cb);\r\n            this.nodes.BL.visit(cb);\r\n            this.nodes.BR.visit(cb);\r\n        }\r\n    };\r\n    return Node;\r\n}());\r\nexports.Node = Node;\r\nvar QuadTree = (function (_super) {\r\n    __extends(QuadTree, _super);\r\n    function QuadTree() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return QuadTree;\r\n}(Node));\r\nexports.QuadTree = QuadTree;\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = __webpack_require__(1);\r\nvar UID = 0;\r\nvar Circle = (function (_super) {\r\n    __extends(Circle, _super);\r\n    /**\r\n     * Generate a new Circle object\r\n     *\r\n     * @param x The center of the circle\r\n     * @param y The center of the circle\r\n     * @param r The radius of the circle\r\n     * @param d A data object to associate with the circle\r\n     */\r\n    function Circle(x, y, r, d) {\r\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\r\n        /** a UID of the circle */\r\n        _this._id = ++UID;\r\n        /** Radius of the circle */\r\n        _this._radius = 0;\r\n        /** X coord of the center of the circle */\r\n        _this._centerX = 0;\r\n        /** Y coord of the center of the circle */\r\n        _this._centerY = 0;\r\n        _this._centerX = x;\r\n        _this._centerY = y;\r\n        _this._radius = r;\r\n        _this.d = d;\r\n        _this.updateBounds();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Circle.prototype, \"values\", {\r\n        get: function () {\r\n            return {\r\n                radius: this._radius,\r\n                x: this._centerX,\r\n                y: this._centerY,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Circle.prototype, \"radius\", {\r\n        get: function () {\r\n            return this._radius;\r\n        },\r\n        set: function (val) {\r\n            this._radius = val;\r\n            this.updateBounds();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Circle.prototype, \"centerX\", {\r\n        get: function () {\r\n            return this._centerX;\r\n        },\r\n        set: function (val) {\r\n            this._centerX = val;\r\n            this.updateBounds();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Circle.prototype, \"centerY\", {\r\n        get: function () {\r\n            return this._centerY;\r\n        },\r\n        set: function (val) {\r\n            this._centerY = val;\r\n            this.updateBounds();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Tests if the specified bounds is inside this circle\r\n     *\r\n     * @param b The bounds to test against\r\n     */\r\n    Circle.prototype.boundsInside = function (b) {\r\n        var r2 = this._radius * this._radius;\r\n        var dx = b.x - this._centerX;\r\n        var dy = b.y - this._centerY;\r\n        var dy2 = dy * dy;\r\n        var dx2 = dx * dx;\r\n        if ((dx2 + dy2) > r2) {\r\n            return false;\r\n        }\r\n        dx = b.right - this._centerX;\r\n        dx2 = dx * dx;\r\n        if ((dx2 + dy2) > r2) {\r\n            return false;\r\n        }\r\n        dy = b.bottom - this._centerY;\r\n        dy2 = dy * dy;\r\n        if ((dx2 + dy2) > r2) {\r\n            return false;\r\n        }\r\n        dx = b.x - this._centerX;\r\n        dx2 = dx * dx;\r\n        return (dx2 + dy2) < r2;\r\n    };\r\n    /**\r\n     * Calculates the distance to a provided point\r\n     *\r\n     * @param {IPoint} p The point to calculate the distance of the middle of the\r\n     *                   circle to\r\n     * @param {boolean} notSquared Flag true to prevent the Math.sqrt operation, leaving\r\n     *                             the result as distance^2\r\n     *\r\n     * @return {number} The distance from mid circle to the point\r\n     */\r\n    Circle.prototype.distanceTo = function (p, notSquared) {\r\n        var dx = this._centerX - p.x;\r\n        var dy = this._centerY - p.y;\r\n        if (notSquared) {\r\n            return dx * dx + dy * dy;\r\n        }\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    };\r\n    /**\r\n     * Retrieves the closest circle to a provided point\r\n     *\r\n     * @param {Array} circles The circles to see who is the nearest\r\n     * @param {IPoint} p The point to compare the circles against for nearness\r\n     *\r\n     * @return {Circle} The nearest circle\r\n     */\r\n    Circle.getClosest = function (circles, p) {\r\n        var closestCircle;\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var distance = 0;\r\n        circles.forEach(function (circle) {\r\n            distance = circle.distanceTo(p, true);\r\n            if (distance < closestDistance) {\r\n                closestCircle = circle;\r\n                closestDistance = distance;\r\n            }\r\n        });\r\n        return closestCircle;\r\n    };\r\n    /**\r\n     * Tests if this circle is colliding with the specified circle\r\n     *\r\n     * @param c The circle to test against\r\n     *\r\n     * @return {boolean} True if colliding\r\n     */\r\n    Circle.prototype.hitCircle = function (c) {\r\n        var totalDistance = c._radius + this._radius;\r\n        totalDistance *= totalDistance;\r\n        return this.distanceTo({ x: c._centerX, y: c._centerY }, true) < totalDistance;\r\n    };\r\n    /**\r\n     * @override\r\n     * This makes it so the test of a point tests based on a Circle shape\r\n     *\r\n     * @param p The point to test if inside the circle\r\n     *\r\n     * @return True if the point is inside\r\n     */\r\n    Circle.prototype.hitPoint = function (p) {\r\n        var r2 = this._radius * this._radius;\r\n        var dx = p.x - this._centerX;\r\n        var dy = p.y - this._centerY;\r\n        return (dx * dx + dy * dy) < r2;\r\n    };\r\n    /**\r\n     * If there are multiple metrics to update for the circle, this is the most\r\n     * efficient way to do that as it will update it's bounds only once.\r\n     *\r\n     * @param x\r\n     * @param y\r\n     * @param r\r\n     */\r\n    Circle.prototype.position = function (x, y, r) {\r\n        this._centerX = x;\r\n        this._centerY = y;\r\n        this._radius = r;\r\n        this.updateBounds();\r\n    };\r\n    /**\r\n     * @override\r\n     * Tests if a point is inside the circle\r\n     *\r\n     * @param p The point to test if inside the circle\r\n     *\r\n     * @return True if the point is inside\r\n     */\r\n    Circle.prototype.pointInside = function (p) {\r\n        var r2 = this._radius * this._radius;\r\n        var dx = p.x - this._centerX;\r\n        var dy = p.y - this._centerY;\r\n        return (dx * dx + dy * dy) < r2;\r\n    };\r\n    /**\r\n     * When the circle gains different circle metrics, it's Bounds must adjust\r\n     * accordingly, which is what this method recalculates.\r\n     */\r\n    Circle.prototype.updateBounds = function () {\r\n        var radius = this._radius;\r\n        this.x = this._centerX - radius;\r\n        this.y = this._centerY - radius;\r\n        this.height = radius * 2;\r\n        this.width = radius * 2;\r\n    };\r\n    /**\r\n     * Pretty print the metrics of this circle\r\n     */\r\n    Circle.prototype.toString = function () {\r\n        return \"[Circle {x: \" + this._centerX + \", y: \" + this._centerY + \", r: \" + this._radius + \"}]\";\r\n    };\r\n    return Circle;\r\n}(bounds_1.Bounds));\r\nexports.Circle = Circle;\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ramda_1 = __webpack_require__(6);\r\nvar interpolation_1 = __webpack_require__(19);\r\nvar bounds_1 = __webpack_require__(1);\r\nvar line_1 = __webpack_require__(5);\r\nvar point_1 = __webpack_require__(9);\r\nvar debug = __webpack_require__(2)('bezier');\r\n/**\r\n * This enum covers the type of curved lines that can be made. Making a specific curve\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nvar CurveType;\r\n(function (CurveType) {\r\n    /** This will make the curve be generated from interpolating between the end points and provided control points */\r\n    CurveType[CurveType[\"Bezier\"] = 0] = \"Bezier\";\r\n    /**\r\n     * This will draw a curve as though there is a circular arc passing over the two end points. The radius of the\r\n     * circular arc is determined by how far the control point is from the straight line that can be made from the two\r\n     * end points.\r\n     */\r\n    CurveType[CurveType[\"CircularCCW\"] = 1] = \"CircularCCW\";\r\n    CurveType[CurveType[\"CircularCW\"] = 2] = \"CircularCW\";\r\n    /**\r\n     * This ignores the control points altogether and just created a straight line with a single segment that consists\r\n     * of the specified endpoints\r\n     */\r\n    CurveType[CurveType[\"Straight\"] = 3] = \"Straight\";\r\n})(CurveType = exports.CurveType || (exports.CurveType = {}));\r\n// -------[ Distance Calculating Methods ]----------------------------\r\n/**\r\n * Calculates the distance to the bezier curve by testing all of the bezier curve's segment lines\r\n *\r\n * @param {CurvedLine<any>} line The curved bezier line type\r\n * @param {IPoint} testPoint The Point to test distance to\r\n *\r\n * @returns {number} The nearest distance from the curve to the test point\r\n */\r\nfunction bezierDistance(line, testPoint) {\r\n    // Get all of the points associated with the curve\r\n    var lineStrip = line.getLineStrip();\r\n    // Find the closest points to the mouse\r\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\r\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\r\n    // Find the closest distance and use it\r\n    var closestDistance = Number.MAX_VALUE;\r\n    var straightLine;\r\n    if (closestIndex > 0) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\r\n        closestDistance = straightLine.distanceTo(testPoint);\r\n    }\r\n    if (closestIndex < lineStrip.length - 1) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\r\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\r\n    }\r\n    return closestDistance;\r\n}\r\n/**\r\n * Calculates the nearness of the line by using the properties of a circle\r\n * TODO: Using the segment approach for now. Can be sped up by using circle math\r\n * instead\r\n *\r\n * @param {CurvedLine<any>} line The curved bezier line type\r\n * @param {IPoint} testPoint The Point to test distance to\r\n *\r\n * @returns {number} The nearest distance from the curve to the test point\r\n */\r\nfunction circularDistance(line, testPoint) {\r\n    // Get all of the points associated with the curve\r\n    var lineStrip = line.getLineStrip();\r\n    // Find the closest points to the mouse\r\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\r\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\r\n    // Find the closest distance and use it\r\n    var closestDistance = Number.MAX_VALUE;\r\n    var straightLine;\r\n    if (closestIndex > 0) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\r\n        closestDistance = straightLine.distanceTo(testPoint);\r\n    }\r\n    if (closestIndex < lineStrip.length - 1) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\r\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\r\n    }\r\n    return closestDistance;\r\n}\r\n/**\r\n * Calculates the nearness of the line by using the properties of a straight line\r\n *\r\n * @param {CurvedLine<any>} line The curved bezier line type\r\n * @param {IPoint} testPoint The Point to test distance to\r\n *\r\n * @returns {number} The nearest distance from the curve to the test point\r\n */\r\nfunction straightDistance(line, testPoint) {\r\n    return new line_1.Line(line.p1, line.p2).distanceTo(testPoint);\r\n}\r\n// -------[ Segment Generating Methods ]----------------------------\r\n/**\r\n * Uses quadratic bezier principles to create the segments for a quadratic bezier curve\r\n *\r\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\r\n *\r\n * @returns {IPoint[]} A line strip of all the calculated points along the line\r\n */\r\nfunction makeBezier2Segments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    var segments = [];\r\n    var dt = 1 / line.resolution;\r\n    var p1 = line.p1;\r\n    var p2 = line.p2;\r\n    var c1 = line.controlPoints[0];\r\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\r\n        segments.push(interpolation_1.bezier2(dt * i, p1, p2, c1));\r\n    }\r\n    if (line.cachesSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    return segments;\r\n}\r\n/**\r\n * Uses cubic bezier principles to create the segments for a cubic bezier curve\r\n *\r\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\r\n *\r\n * @returns {IPoint[]} A line strip of all the calculated points along the line\r\n */\r\nfunction makeBezier3Segments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    var segments = [];\r\n    var dt = 1 / line.resolution;\r\n    var p1 = line.p1;\r\n    var p2 = line.p2;\r\n    var c1 = line.controlPoints[0];\r\n    var c2 = line.controlPoints[1];\r\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\r\n        segments.push(interpolation_1.bezier3(dt * i, p1, p2, c1, c2));\r\n    }\r\n    if (line.cachesSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    return segments;\r\n}\r\n/**\r\n * Makes the segments for a line that follows along a circular path on the line.\r\n * The distance the control point is from the straight line that flows through the two\r\n * end points of the line determines the radius of the curvature of the line\r\n *\r\n * @param {CurvedLine<any>} line\r\n * @returns {IPoint[]}\r\n */\r\nfunction makeCircularCWSegments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    debug('CW');\r\n    // Generate a line so we can have a perpendicular calculation\r\n    var straightLine = new line_1.Line(line.p1, line.p2);\r\n    var radius = point_1.Point.getDistance(line.p1, line.controlPoints[0]);\r\n    // We get the midpoint of the line as we want to align the center of the circle with this point\r\n    var midPoint = point_1.Point.getMidpoint(line.p1, line.p2);\r\n    var minRadius = point_1.Point.getDistance(midPoint, line.p1);\r\n    // The shortest the radius can be is the distance from the line to the mid point\r\n    // Anything shorter will just result in a hemisphere being rendered\r\n    if (radius < minRadius) {\r\n        radius = point_1.Point.getDistance(midPoint, line.p1);\r\n    }\r\n    // Get the perpendicular direction to the line so we can calculate the center of our circle\r\n    // From the mid point\r\n    var perpendicular = straightLine.perpendicular;\r\n    var distance = Math.sqrt(radius * radius - minRadius * minRadius);\r\n    // Calculate the location of the center of the circle\r\n    var circleCenter = {\r\n        x: perpendicular.x * distance + midPoint.x,\r\n        y: perpendicular.y * distance + midPoint.y,\r\n    };\r\n    // Store the circle center as an extra control point in case the value is needed\r\n    // (which it often is)\r\n    line.controlPoints[1] = circleCenter;\r\n    debug(' center of circle is %o  %o', circleCenter.x, circleCenter.y);\r\n    // Get the direction vector from the circle center to the first end point\r\n    var direction1 = point_1.Point.getDirection(circleCenter, line.p1);\r\n    // Get the angle of the first vector\r\n    var theta1 = Math.atan2(direction1.y, direction1.x);\r\n    // Get the direction vector from the circle center to the second end point\r\n    var direction2 = point_1.Point.getDirection(circleCenter, line.p2);\r\n    // Get the angle of the second vector\r\n    var theta2 = Math.atan2(direction2.y, direction2.x);\r\n    // Calculate how much to increment theta in our parametric circular equation\r\n    if (theta1 < theta2)\r\n        theta1 += Math.PI * 2;\r\n    var dTheta = (theta1 - theta2) / line.resolution;\r\n    debug('theta1 is %o, theta2 is %o', theta1, theta2);\r\n    // Compute the segments based on the information we have gathered by applying it to a circular\r\n    // Parametric equation\r\n    var segments = [];\r\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\r\n        segments.push({\r\n            x: Math.cos(theta1 - (dTheta * i)) * radius + circleCenter.x,\r\n            y: Math.sin(theta1 - (dTheta * i)) * radius + circleCenter.y,\r\n        });\r\n    }\r\n    // Cache the segments if specified by the curved line\r\n    if (line.cachesSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    debug('Generated Circular Segments: %o dTheta: %o radius: %o', segments, dTheta, radius);\r\n    return segments;\r\n}\r\nfunction makeCircularCCWSegments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    var straightLine = new line_1.Line(line.p1, line.p2);\r\n    var radius = point_1.Point.getDistance(line.p1, line.controlPoints[0]);\r\n    var midPoint = point_1.Point.getMidpoint(line.p1, line.p2);\r\n    var minRadius = point_1.Point.getDistance(midPoint, line.p1);\r\n    if (radius < minRadius) {\r\n        radius = point_1.Point.getDistance(midPoint, line.p1);\r\n    }\r\n    var perpendicular = straightLine.perpendicular;\r\n    var distance = Math.sqrt(radius * radius - minRadius * minRadius);\r\n    var circleCenter = {\r\n        x: -perpendicular.x * distance + midPoint.x,\r\n        y: -perpendicular.y * distance + midPoint.y,\r\n    };\r\n    // Store the circle center as an extra control point in case the value is needed\r\n    // (which it often is)\r\n    line.controlPoints[1] = circleCenter;\r\n    var direction1 = point_1.Point.getDirection(circleCenter, line.p1);\r\n    var theta1 = Math.atan2(direction1.y, direction1.x);\r\n    var direction2 = point_1.Point.getDirection(circleCenter, line.p2);\r\n    var theta2 = Math.atan2(direction2.y, direction2.x);\r\n    if (theta2 < theta1)\r\n        theta2 += Math.PI * 2;\r\n    var dTheta = (theta2 - theta1) / line.resolution;\r\n    var segments = [];\r\n    // CCW, from p2 to p1\r\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\r\n        segments.push({\r\n            x: Math.cos(theta1 + (dTheta * i)) * radius + circleCenter.x,\r\n            y: Math.sin(theta1 + (dTheta * i)) * radius + circleCenter.y,\r\n        });\r\n    }\r\n    if (line.cachedSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    return segments;\r\n}\r\n/**\r\n * Makes the segments for a line that is straight, thus only 1 segments is needed\r\n * and will be generated.\r\n *\r\n * @param {CurvedLine<any>} line\r\n * @returns {IPoint[]}\r\n */\r\nfunction makeStraightSegments(line) {\r\n    return [line.p1, line.p2];\r\n}\r\n/** A quick lookup for a proper segment creating method for a curved line  */\r\nvar pickSegmentMethod = (_a = {},\r\n    _a[CurveType.Bezier] = [\r\n        null,\r\n        makeBezier2Segments,\r\n        makeBezier3Segments,\r\n    ],\r\n    _a[CurveType.CircularCW] = [\r\n        null,\r\n        makeCircularCWSegments,\r\n        makeCircularCWSegments,\r\n    ],\r\n    _a[CurveType.CircularCCW] = [\r\n        null,\r\n        makeCircularCCWSegments,\r\n        makeCircularCCWSegments,\r\n    ],\r\n    _a[CurveType.Straight] = [\r\n        makeStraightSegments,\r\n    ],\r\n    _a);\r\n/** A quick lookup for a proper distance calculating method for a curved line  */\r\nvar pickDistanceMethod = (_b = {},\r\n    _b[CurveType.Bezier] = bezierDistance,\r\n    _b[CurveType.CircularCW] = circularDistance,\r\n    _b[CurveType.CircularCCW] = circularDistance,\r\n    _b[CurveType.Straight] = straightDistance,\r\n    _b);\r\n/**\r\n * Defines an object which illustrates a curved line. Curved lines can be formed in many\r\n * ways but most often from two end points and some provided control points.\r\n *\r\n * @export\r\n * @class CurvedLine\r\n * @extends {Bounds<T>}\r\n * @template T An associated data type with this object. Use <never> if no data type is ever associated\r\n */\r\nvar CurvedLine = (function (_super) {\r\n    __extends(CurvedLine, _super);\r\n    /**\r\n     * Generates a primitive that describes a curved line, which is defined by the lines end points, type, and control points\r\n     *\r\n     * @param {ICurvedLineOptions} options The configuration options of this curved line\r\n     */\r\n    function CurvedLine(options) {\r\n        var _this = this;\r\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\r\n        _this = _super.call(this, minX, maxX, maxY, minY) || this;\r\n        // Apply the relevant properties to the curve\r\n        _this.cachesSegments = options.cacheSegments || false;\r\n        _this.type = options.type;\r\n        _this.resolution = options.resolution || 20;\r\n        // Set the metrics for this curved line\r\n        _this.setPoints(options.start, options.end, options.controlPoints);\r\n        // Set the method that will be used for calculating distance from a point\r\n        _this.distanceMethod = pickDistanceMethod[options.type];\r\n        return _this;\r\n    }\r\n    Object.defineProperty(CurvedLine.prototype, \"values\", {\r\n        get: function () {\r\n            return {\r\n                controlPoints: this.controlPoints,\r\n                p1: this.p1,\r\n                p2: this.p2,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Calculates the nearest distance from the provided point to this curved line\r\n     *\r\n     * @param {IPoint} point The point to test the distance from\r\n     *\r\n     * @returns {number} The calculated nearest distance from this curve to the point\r\n     */\r\n    CurvedLine.prototype.distanceTo = function (point) {\r\n        return this.distanceMethod(this, point);\r\n    };\r\n    /**\r\n     * Picks the closest line in the list to a given point\r\n     *\r\n     * @param {CurvedLine<any>[]} lines The lines to compare\r\n     * @param {IPoint} p The point to compare against\r\n     *\r\n     * @return {Line} The nearest line to the point\r\n     */\r\n    CurvedLine.getClosest = function (lines, point) {\r\n        var closestLine;\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var distance = 0;\r\n        lines.forEach(function (line) {\r\n            distance = line.distanceTo(point);\r\n            if (distance < closestDistance) {\r\n                closestLine = line;\r\n                closestDistance = distance;\r\n            }\r\n        });\r\n        return closestLine;\r\n    };\r\n    /**\r\n     * This returns the line strip that represents the curve. A line strip is specifically a group of points\r\n     * that forms line segments by taking the current point as one end and the previous point as the second end\r\n     * thus, you would start at index 1 and loop to the end to generate all of the lines composing this single\r\n     * line.\r\n     *\r\n     * @return {IPoint[]} All of the points in the line strip\r\n     */\r\n    CurvedLine.prototype.getLineStrip = function () {\r\n        return this.segmentMethod(this);\r\n    };\r\n    /**\r\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {IPoint[]} controlPoints\r\n     * @param {boolean} preventRebounding If set, this will prevent the bounds from being recalculated\r\n     */\r\n    CurvedLine.prototype.setPoints = function (p1, p2, controlPoints) {\r\n        // Apply the points\r\n        this.p1 = p1;\r\n        this.p2 = p2;\r\n        if (controlPoints.length === 0)\r\n            debug('p1: %o, p2:%o', p1, p2);\r\n        // Get the available segment methods for the given type\r\n        var segmentMethods = pickSegmentMethod[this.type];\r\n        // If we adjust the control points we need to re-evaluate the type of segment creation method we use\r\n        if (controlPoints) {\r\n            this.controlPoints = ramda_1.clone(controlPoints);\r\n            // Get the number of control points we want to base the curve off of\r\n            var numControlPoints = controlPoints.length;\r\n            // If we have more control points than the methods available, then we use the greatest method available to best\r\n            // Handle as many control points as possible\r\n            if (numControlPoints > segmentMethods.length) {\r\n                numControlPoints = segmentMethods.length - 1;\r\n            }\r\n            // Set the method that will be used for generating segments\r\n            this.segmentMethod = segmentMethods[numControlPoints];\r\n            // Make sure the input wasn't bad\r\n            if (!this.segmentMethod) {\r\n                throw new Error('An Invalid number of control points was provided to a curved line. You must have at LEAST 1 control point. Or 0 for a straight line');\r\n            }\r\n            if (this.type === CurveType.Bezier) {\r\n                this.encapsulatePoints(controlPoints);\r\n            }\r\n            else if (this.type === CurveType.CircularCCW || this.type === CurveType.CircularCW) {\r\n                this.encapsulatePoints(this.getLineStrip());\r\n            }\r\n        }\r\n        this.encapsulatePoint(p1);\r\n        this.encapsulatePoint(p2);\r\n        // Invalidate caches if they exist\r\n        this.cachedSegments = null;\r\n    };\r\n    return CurvedLine;\r\n}(bounds_1.Bounds));\r\nexports.CurvedLine = CurvedLine;\r\nvar _a, _b;\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This calculates a quadratic bezier curve.\r\n *\r\n * We use specific bezier curve implementations for low degree curves as it is\r\n * much much faster to calculate.\r\n *\r\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\r\n * @param {IPoint} p1 The First end point of the curve\r\n * @param {IPoint} p2 The second end point of the curve\r\n * @param {IPoint} c1 The control point of the curve\r\n *\r\n * @returns {IPoint} The calculated point on the curve for the provided time interval\r\n */\r\nfunction bezier2(t, p1, p2, c1) {\r\n    var t2 = t * t;\r\n    var mt = 1 - t;\r\n    var mt2 = mt * mt;\r\n    return {\r\n        x: p1.x * mt2 + c1.x * 2 * mt * t + p2.x * t2,\r\n        y: p1.y * mt2 + c1.y * 2 * mt * t + p2.y * t2,\r\n    };\r\n}\r\nexports.bezier2 = bezier2;\r\n/**\r\n * This calculates a cubic bezier curve.\r\n *\r\n * We use specific bezier curve implementations for low degree curves as it is\r\n * much much faster to calculate.\r\n *\r\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\r\n * @param {IPoint} p1 The First end point of the curve\r\n * @param {IPoint} p2 The second end point of the curve\r\n * @param {IPoint} c1 The first control point of the curve\r\n * @param {IPoint} c2 The second control point of the curve\r\n *\r\n * @returns {IPoint} The calculated point on the curve for the provided time interval\r\n */\r\nfunction bezier3(t, p1, p2, c1, c2) {\r\n    var t2 = t * t;\r\n    var t3 = t2 * t;\r\n    var mt = 1 - t;\r\n    var mt2 = mt * mt;\r\n    var mt3 = mt2 * mt;\r\n    return {\r\n        x: p1.x * mt3 + 3 * c1.x * mt2 * t + 3 * c2.x * mt * t2 + p2.x * t3,\r\n        y: p1.y * mt3 + 3 * c1.y * mt2 * t + 3 * c2.y * mt * t2 + p2.y * t3,\r\n    };\r\n}\r\nexports.bezier3 = bezier3;\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar line_1 = __webpack_require__(5);\r\n/**\r\n * Defines a line that can be drawn\r\n */\r\nvar LineShape = (function (_super) {\r\n    __extends(LineShape, _super);\r\n    /**\r\n     * Generate a new line that can be drawn\r\n     */\r\n    function LineShape(p1, p2, d, r, g, b, a, r2, g2, b2, a2, thickness) {\r\n        var _this = _super.call(this, p1, p2) || this;\r\n        // Color 1\r\n        _this.a = 0;\r\n        _this.b = 0;\r\n        _this.g = 0;\r\n        _this.r = 1;\r\n        // Color 2 ?\r\n        _this.a2 = 0;\r\n        _this.b2 = 0;\r\n        _this.g2 = 0;\r\n        _this.r2 = 1;\r\n        // Other properties\r\n        _this.cull = true;\r\n        _this.thickness = 1;\r\n        Object.assign(_this, {\r\n            a: a,\r\n            a2: a2,\r\n            b: b,\r\n            b2: b2,\r\n            d: d,\r\n            g: g,\r\n            g2: g2,\r\n            r: r,\r\n            r2: r2,\r\n        });\r\n        if (thickness !== undefined) {\r\n            _this.thickness = thickness;\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Clones this instance of the line shape and creates a new instance of a line shape that\r\n     * is identical to this one. The properties injected can be modifiers after the clone happens\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {CircleShape} A newly cloned instance of this line shape\r\n     */\r\n    LineShape.prototype.clone = function (newProperties) {\r\n        return Object.assign(new LineShape(this.p1, this.p2, this.d, this.r, this.g, this.b, this.a, this.r2, this.g2, this.b2, this.a2), this, newProperties);\r\n    };\r\n    return LineShape;\r\n}(line_1.Line));\r\nexports.LineShape = LineShape;\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(22));\r\n__export(__webpack_require__(28));\r\n__export(__webpack_require__(34));\r\n__export(__webpack_require__(42));\r\n__export(__webpack_require__(43));\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ramda_1 = __webpack_require__(6);\r\nvar React = __webpack_require__(23);\r\nvar three_1 = __webpack_require__(0);\r\nvar atlas_manager_1 = __webpack_require__(10);\r\nvar atlas_texture_1 = __webpack_require__(8);\r\nvar bounds_1 = __webpack_require__(1);\r\nvar mouse_1 = __webpack_require__(15);\r\nvar quad_tree_1 = __webpack_require__(16);\r\nvar debug = __webpack_require__(2)('webgl-surface:GPU');\r\nvar debugCam = __webpack_require__(2)('webgl-surface:Camera');\r\nvar debugLabels = __webpack_require__(2)('webgl-surface:Labels');\r\n/**\r\n * This enum names the base methods that are passed into the applyPropsMethods\r\n * method. This allows subclasses to easily pick the property setting methods they need\r\n * from the base\r\n */\r\nvar BaseApplyPropsMethods;\r\n(function (BaseApplyPropsMethods) {\r\n    /** Initializes any context that needs to be set up before the props are set */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"INITIALIZE\"] = 0] = \"INITIALIZE\";\r\n    /** Moment when any buffer changes should be applied */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"BUFFERCHANGES\"] = 1] = \"BUFFERCHANGES\";\r\n    /** Initializes camera properties to facilitate smoothe start up */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"CAMERA\"] = 2] = \"CAMERA\";\r\n    /** Generates the labels as images within the atlas manager */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"LABELS\"] = 3] = \"LABELS\";\r\n    /** Generates the colors within the atlas manager */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"COLORS\"] = 4] = \"COLORS\";\r\n})(BaseApplyPropsMethods = exports.BaseApplyPropsMethods || (exports.BaseApplyPropsMethods = {}));\r\n/**\r\n * This enum names the base methods that are passed into the animatedMethods\r\n * method. This allows subsclasses to easily pick the animated methods they need\r\n * from the base\r\n */\r\nvar BaseAnimatedMethods;\r\n(function (BaseAnimatedMethods) {\r\n    /** Sets up the base context needed to execute most methods */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"CONTEXT\"] = 0] = \"CONTEXT\";\r\n    /** Sets up the inertia method for inertial panning */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"INERTIA\"] = 1] = \"INERTIA\";\r\n    /** Animates the postion of the camera to a destination */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"POSITION\"] = 2] = \"POSITION\";\r\n    /** Zooms the camera based on a point of focus */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"ZOOM\"] = 3] = \"ZOOM\";\r\n})(BaseAnimatedMethods = exports.BaseAnimatedMethods || (exports.BaseAnimatedMethods = {}));\r\n/** This is the smallest increment the zoom can make. Anything less and nothing will happen */\r\nvar MIN_ZOOM_INCREMENT = 0.001;\r\nvar BYTE_MAX = 0xFF;\r\nvar BACKGROUND_COLOR = new three_1.Color().setRGB(38 / BYTE_MAX, 50 / BYTE_MAX, 78 / BYTE_MAX);\r\n// --[ CONSTANTS ]-------------------------------------------\r\n// Make a container vector for performing operations within\r\nvar vector = new three_1.Vector3();\r\n// --[ SHADERS ]-------------------------------------------\r\n/**\r\n * Equivalent of Math.sign, but faster, and works in all browsers\r\n *\r\n * @param {number} value The number to determine the sign\r\n *\r\n * @return {number} Returns zero if a sign can not be determined, -1 for a negative, 1 for a positive\r\n */\r\nfunction sign(value) {\r\n    if (!value) {\r\n        return 0;\r\n    }\r\n    if (value > 0) {\r\n        return 1;\r\n    }\r\n    if (value < 0) {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\r\nfunction isWebGLSupported() {\r\n    try {\r\n        var canvas = document.createElement('canvas');\r\n        return !!window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\nvar WEBGL_SUPPORTED = isWebGLSupported();\r\n/**\r\n * The base component for the communications view\r\n */\r\nvar WebGLSurface = (function (_super) {\r\n    __extends(WebGLSurface, _super);\r\n    function WebGLSurface() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /** This is the atlas manager for managing images and labels rendered as textures */\r\n        _this.atlasManager = new atlas_manager_1.AtlasManager(2048, 2048);\r\n        /** Tracks the names of the atlas' generated */\r\n        _this.atlasNames = {\r\n            colors: 'colors',\r\n            labels: 'labels',\r\n        };\r\n        /**\r\n         * List of methods that execute within the animation loop. Makes adding and removing these methods\r\n         * simpler to manage, as well as gives a clear and optimized way of overriding existing methods\r\n         * or reordering their execution\r\n         */\r\n        _this.animatedMethodList = [];\r\n        /**\r\n         * If this is set to true during an animated method's lifecycle, then all subsequent animated methods\r\n         * will not be executed for the current frame. Upon reaching the end of the frame, the break will reset\r\n         * and the animated methods will attempt executing again\r\n         */\r\n        _this.animatedMethodBreak = false;\r\n        /** Used to aid in mouse interactions */\r\n        _this.distance = 0;\r\n        /**\r\n         * The camera that 'looks' at our world and gives us the ability to convert\r\n         * screen coordinates to world coordinates, and vice versa\r\n         */\r\n        _this.camera = null;\r\n        /**\r\n         * While this number is positive it will be decremented every frame.\r\n         * While positive, mouse interactions will not occur. This utilizes frame ticks\r\n         * as SOME values and numbers settle per frame, not necessarily within timelapses.\r\n         * More often than not, there will only be a need for 1-2 frames of mouse disable to\r\n         * allow the camera to be positioned in a correct location before screen to world projections\r\n         * start taking place.\r\n         */\r\n        _this.disableMouseInteraction = 0;\r\n        _this.sizeCamera = null;\r\n        /** Keep track of the current zoom so it can be set in requestAnimationFrame */\r\n        _this.currentZoom = 1;\r\n        /** Horizontal destination the camera will pan to */\r\n        _this.destinationX = 0;\r\n        /** Vertical position the camera will pan to */\r\n        _this.destinationY = 0;\r\n        /** The destination zoom level the camera used during panning */\r\n        _this.destinationZoom = 1;\r\n        /** Is the camera currently in a panning state */\r\n        _this.isPanning = false;\r\n        /** Last known screen position of the mouse */\r\n        _this.lastMousePosition = { x: 0, y: 0 };\r\n        /** List of methods to execute when applying props */\r\n        _this.propsMethodList = [];\r\n        /** Inertial values for drag panning */\r\n        _this.inertia = null;\r\n        _this.inertiaBuild = 1.5;\r\n        _this.inertiaDecay = .9;\r\n        _this.inertiaMax = 100;\r\n        /**\r\n         * All data is put into this quad tree so we can query spatial regions for\r\n         * items\r\n         */\r\n        _this.quadTree = null;\r\n        /**\r\n         * True if the shift key is currently being held\r\n         *\r\n         * Panning is affected by whether or not the shift key is being held down, but\r\n         * I don't know how yet.\r\n         */\r\n        _this.shiftIsDown = false;\r\n        _this.stop = false;\r\n        /** The current rendered position and zoom */\r\n        _this.currentX = 0;\r\n        _this.currentY = 0;\r\n        _this.targetZoom = 1;\r\n        /** The (world) position the focus will zoom in and out of */\r\n        _this.previousZoomToFit = 0;\r\n        _this.zoomTargetX = 0;\r\n        _this.zoomTargetY = 0;\r\n        /** When this is set, the draw loop continues to run. Used by the draw loop to complete animations */\r\n        _this.animating = false;\r\n        _this.labels = [];\r\n        _this.labelsReady = false;\r\n        /**\r\n         * This is the latest labels loading identifier, used to determine if the labels\r\n         * last loaded matches the labels currently needing to be rendered.\r\n         */\r\n        _this.labelsCurrentLoadedId = 0;\r\n        _this.labelsLoadId = 0;\r\n        /** When this is set to true, the atlas with the colors is now ready to be referenced */\r\n        _this.colors = [];\r\n        _this.colorsReady = false;\r\n        /** Holds the items currently hovered over */\r\n        _this.currentHoverItems = [];\r\n        /** Flag for detecting whether or not webgl is supported at all */\r\n        /**\r\n         * This is the update loop that operates at the requestAnimationFrame speed.\r\n         * This updates the cameras current position and causes changes over time for\r\n         * any property that has a start and a destination.\r\n         */\r\n        _this.animate = function () {\r\n            if (_this.stop) {\r\n                return;\r\n            }\r\n            requestAnimationFrame(function () { return _this.animate(); });\r\n            var response;\r\n            var doDraw = false;\r\n            var didBreak = _this.animatedMethodList.some(function (method) {\r\n                response = method();\r\n                // Update our draw status based on response\r\n                if (!doDraw) {\r\n                    doDraw = response.doDraw;\r\n                }\r\n                // Stop the system if needed\r\n                if (response.stop) {\r\n                    _this.stop = true;\r\n                }\r\n                // Stop performing\r\n                if (response.break) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            // We prevent any animation loop execution if we did break\r\n            if (didBreak) {\r\n                return;\r\n            }\r\n            // Make sure all camera related uniforms are up to date\r\n            _this.updateCameraUniforms();\r\n            // Handle the deactivation period of mouse interactions by decrementing it\r\n            // If it's positive\r\n            if (_this.disableMouseInteraction > 0) {\r\n                _this.disableMouseInteraction--;\r\n            }\r\n            if (doDraw || _this.forceDraw) {\r\n                _this.forceDraw = false;\r\n                _this.emitViewport();\r\n                _this.draw();\r\n            }\r\n        };\r\n        /**\r\n         * Applies new props injected into this component.\r\n         *\r\n         * Applying new props does not entail that a re-render will happen so we\r\n         * handle application of props as a separate concept. Here we:\r\n         *\r\n         * set up zoom targetting and apply quested zoom levels\r\n         *\r\n         * Create our quad tree and associate properties to objects if a new dataset\r\n         * is provided\r\n         *\r\n         * Analyze our dataset for interesting and useful metrics such as max and mins\r\n         * to aid in visualization normalization\r\n         *\r\n         * @param {T} props The new properties for this component\r\n         */\r\n        _this.applyProps = function (props) {\r\n            debug('Applying props');\r\n            var response;\r\n            _this.propsMethodList.some(function (method) {\r\n                response = method(props);\r\n                // Stop performing\r\n                if (response.break) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            debugCam('current cam', _this.currentX, _this.currentY, _this.destinationX, _this.destinationY);\r\n            debugCam('Zoom Target: [%o, %o]', _this.zoomTargetX, _this.zoomTargetY);\r\n            debugCam('Last Mouse: [%o, %o]', _this.lastMousePosition.x, _this.lastMousePosition.y);\r\n        };\r\n        /**\r\n         * This is the draw method executed from the animation loop. Everytime, this is\r\n         * called, the webgl surface will be redrawn.\r\n         */\r\n        _this.draw = function () {\r\n            // Draw the 3D scene\r\n            _this.renderer.render(_this.scene, _this.camera);\r\n        };\r\n        /**\r\n         * This initializes the surface and calls for sub class classes to initialize\r\n         * their buffers\r\n         *\r\n         * @param {HTMLElement} el The DOM element this component is contained in\r\n         * @param {number} w The width of the rendering\r\n         * @param {number} h The height of the rendering\r\n         */\r\n        _this.init = function (el, w, h) {\r\n            if (!el || _this.scene) {\r\n                return;\r\n            }\r\n            _this.renderEl = el;\r\n            if (w === 0 || h === 0) {\r\n                return;\r\n            }\r\n            debug('Initializing GPU objects el: %o width: %o height: %o', el, w, h);\r\n            // Set up a ctx for our render space\r\n            _this.ctx = {\r\n                height: h,\r\n                heightHalf: h / 2.0,\r\n                width: w,\r\n                widthHalf: w / 2.0,\r\n            };\r\n            // Set up the camera now that the ctx is set up\r\n            _this.initCamera();\r\n            // Create a scene so we can add our buffer objects to it\r\n            // We also add the scene to the window to make threejs tools available\r\n            window.scene = _this.scene = new three_1.Scene();\r\n            // Fire our hook for starting up our specific buffer implementation\r\n            _this.initBuffers();\r\n            // FINALIZE SET UP\r\n            // Generate the renderer along with it's properties\r\n            _this.renderer = new three_1.WebGLRenderer({\r\n                antialias: true,\r\n            });\r\n            debug('Window Pixel Ratio: %o', window.devicePixelRatio);\r\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\r\n            _this.renderer.setSize(w, h);\r\n            _this.renderer.setClearColor(BACKGROUND_COLOR);\r\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\r\n            // Set up DOM interaction with the renderer\r\n            var container = el;\r\n            container.appendChild(_this.renderer.domElement);\r\n        };\r\n        /**\r\n         * Initializes the camera and any contexts associated with it\r\n         */\r\n        _this.initCamera = function () {\r\n            debug('Initializing Camera');\r\n            // INITIALIZE THE CAMERA\r\n            var h = _this.ctx.height;\r\n            var viewSize = h;\r\n            var w = _this.ctx.width;\r\n            var aspectRatio = w / h;\r\n            var viewport = {\r\n                aspectRatio: aspectRatio,\r\n                bottom: -viewSize / 2,\r\n                far: 10000000,\r\n                left: (-aspectRatio * viewSize) / 2,\r\n                near: -100,\r\n                right: (aspectRatio * viewSize) / 2,\r\n                top: viewSize / 2,\r\n                viewSize: viewSize,\r\n            };\r\n            _this.camera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\r\n            _this.sizeCamera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\r\n            _this.camera.position.z = 300;\r\n            _this.sizeCamera.position.set(0, 0, 300);\r\n        };\r\n        /**\r\n         * This is executed when our rendering surface (the canvas) changes in size in any\r\n         * way. It will make sure our renderer matches the context to prevent scaling\r\n         * and other deformations.\r\n         */\r\n        _this.resizeContext = function () {\r\n            var w = _this.props.width;\r\n            var h = _this.props.height;\r\n            // See if a renderer even exists yet\r\n            if (!_this.renderer) {\r\n                return false;\r\n            }\r\n            var renderSize = _this.renderer.getSize();\r\n            // Check if the resize is needed\r\n            if (renderSize.width === w && renderSize.height === h) {\r\n                return false;\r\n            }\r\n            debug('RENDERER RESIZE');\r\n            _this.ctx = {\r\n                height: h,\r\n                heightHalf: h / 2,\r\n                width: w,\r\n                widthHalf: w / 2,\r\n            };\r\n            var zoom = _this.camera.zoom;\r\n            var position = _this.camera.position.clone();\r\n            _this.initCamera();\r\n            _this.camera.zoom = zoom;\r\n            _this.camera.position.set(position.x, position.y, position.z);\r\n            _this.camera.updateProjectionMatrix();\r\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\r\n            _this.renderer.setSize(w, h);\r\n            _this.renderer.setClearColor(new three_1.Color().setRGB(38 / 255, 50 / 255, 78 / 255));\r\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\r\n            return true;\r\n        };\r\n        /**\r\n         * This method handles emitting the viewport and the current visible elements\r\n         * to the subclass that needs detailed information regarding the viewport.\r\n         */\r\n        _this.emitViewport = function () {\r\n            var tl = _this.screenToWorld(0, 0);\r\n            var br = _this.screenToWorld(_this.ctx.width, _this.ctx.height);\r\n            _this.camera.updateMatrixWorld(true);\r\n            var visible = _this.quadTree.query(new bounds_1.Bounds(tl.x, br.x, tl.y, br.y));\r\n            _this.onViewport(visible, _this.projection, _this.ctx);\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is pressed on the canvas. This\r\n         * engages panning.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseDown = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            _this.isPanning = true;\r\n            _this.distance = 0;\r\n            _this.onMouseDown();\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is release or left the canvas. This\r\n         * stops panning.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseOut = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            _this.isPanning = false;\r\n            _this.distance = 0;\r\n            _this.onMouseOut();\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is released on the canvas. This\r\n         * stops panning and engages click events.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseUp = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            _this.isPanning = false;\r\n            var mouse = mouse_1.eventElementPosition(e);\r\n            var world = _this.screenToWorld(mouse.x, mouse.y);\r\n            // Handle mouse interaction\r\n            if (_this.distance < 5) {\r\n                var hitInside = [];\r\n                // Circle Interaction\r\n                var hitItems = _this.quadTree.query(world);\r\n                for (var _i = 0, hitItems_1 = hitItems; _i < hitItems_1.length; _i++) {\r\n                    var item = hitItems_1[_i];\r\n                    // Fine tuning for interaction\r\n                    if (item.pointInside(world)) {\r\n                        hitInside.push(item);\r\n                    }\r\n                }\r\n                // Tell the listener that the user clicked on some items\r\n                if (hitInside.length) {\r\n                    _this.onMouseUp(e, hitInside, mouse, world, _this.projection);\r\n                }\r\n                else {\r\n                    _this.onMouseUp(e, null, mouse, world, _this.projection);\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is moving on the canvas. This\r\n         * causes panning and hover events.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseMove = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            var onMouse = _this.props.onMouse;\r\n            var zoom = _this.props.zoom;\r\n            var mouse = mouse_1.eventElementPosition(e);\r\n            var world = _this.screenToWorld(mouse.x, mouse.y);\r\n            _this.distance++;\r\n            debug('mouse X %o Y %o', mouse.x, mouse.y);\r\n            // Handle panning\r\n            if (_this.isPanning) {\r\n                var xDistance = (mouse.x - _this.lastMousePosition.x) / _this.targetZoom;\r\n                var yDistance = -(mouse.y - _this.lastMousePosition.y) / _this.targetZoom;\r\n                // Execute the hook to allow subclasses\r\n                var pan = _this.willPan(xDistance, yDistance);\r\n                xDistance = pan.x;\r\n                yDistance = pan.y;\r\n                _this.destinationX -= xDistance;\r\n                _this.destinationY -= yDistance;\r\n                _this.inertia = _this.inertia || { x: 0, y: 0 };\r\n                if (sign(xDistance) !== sign(_this.inertia.x)) {\r\n                    _this.inertia.x = 0;\r\n                }\r\n                if (sign(yDistance) !== sign(_this.inertia.y)) {\r\n                    _this.inertia.y = 0;\r\n                }\r\n                _this.inertia.x = xDistance * _this.inertiaBuild;\r\n                _this.inertia.y = yDistance * _this.inertiaBuild;\r\n                var maxInertia = _this.inertiaMax / zoom;\r\n                var mag = Math.sqrt(_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y);\r\n                // Make sure the magnitude of the inertia is less than our max allowed\r\n                if (mag > maxInertia) {\r\n                    // Since it's greater, let's confine the inertia's magnitude to the max magnitude\r\n                    // By normalizing the intertia vector and multilying it by the max\r\n                    _this.inertia.x = (_this.inertia.x / mag) * maxInertia;\r\n                    _this.inertia.y = (_this.inertia.y / mag) * maxInertia;\r\n                }\r\n            }\r\n            if (_this.quadTree && !_this.isPanning) {\r\n                // Empty the last hovered items to populate a new list\r\n                var currentHoverItems = [];\r\n                // Handle mouse interaction with items\r\n                // Interaction with circles\r\n                var hitItems = _this.quadTree.query(world);\r\n                var hitInside = [];\r\n                for (var _i = 0, hitItems_2 = hitItems; _i < hitItems_2.length; _i++) {\r\n                    var item = hitItems_2[_i];\r\n                    // Fine tuning for interaction\r\n                    if (item.pointInside(world)) {\r\n                        hitInside.push(item);\r\n                        currentHoverItems.push(item);\r\n                    }\r\n                }\r\n                // Inform of all items hit or hovered\r\n                _this.onMouseHover(hitInside, mouse, world, _this.projection);\r\n                // Diff the currently hovered items with the old ones to see what is\r\n                // No longer hit\r\n                var left = [];\r\n                for (var _a = 0, _b = _this.currentHoverItems; _a < _b.length; _a++) {\r\n                    var item = _b[_a];\r\n                    if (currentHoverItems.indexOf(item) < 0) {\r\n                        left.push(item);\r\n                    }\r\n                }\r\n                // Inform of all items no longer hovered\r\n                _this.onMouseLeave(left, mouse, world, _this.projection);\r\n                _this.currentHoverItems = currentHoverItems;\r\n            }\r\n            if (onMouse) {\r\n                _this.onMouse(mouse, world, _this.isPanning);\r\n            }\r\n            _this.lastMousePosition = mouse;\r\n        };\r\n        /**\r\n         * We make the ref application be a declared function so react does not find the need to execute the\r\n         * application numerous times for a detected changed method\r\n         *\r\n         * @param {HTMLElement} n This is the canvas element from the dom\r\n         */\r\n        _this.applyRef = function (n) {\r\n            _this.init(n, _this.props.width, _this.props.height);\r\n            _this.applyProps(_this.props);\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * This is a hook so subclasses can contribute animated methods to the animation loop and organize the base methods\r\n     * as desired.\r\n     *\r\n     * @param {AnimatedMethodLookup} baseAnimatedMethods The base animated methods referenceable by name\r\n     * @param {AnimatedMethod[]} orderedBaseAnimatedMethods The base animated methods in their default order for ease of use\r\n     *\r\n     * @return {AnimatedMethods[]} The list of animated methods in the order they are expected to be executed\r\n     */\r\n    WebGLSurface.prototype.animatedMethods = function (baseAnimatedMethods, orderedBaseAnimatedMethods) {\r\n        // Default functionality is to use the simple preordered list\r\n        return orderedBaseAnimatedMethods;\r\n    };\r\n    /**\r\n     * This generates the base animated methods lookup.\r\n     * We do not make these methods a part of the class as this is the base class\r\n     * We want the start up methods to be inconsequential to sub classes, thus allowing\r\n     * us to override, sort, or replace the initial methods and have the method get garbage\r\n     * collected and no longer a part of the object. It is recommended to make the sub classes\r\n     * actually point to class methods for better clarity\r\n     *\r\n     * @return {ANimatedMethodLookup} The base animated methods in a lookup\r\n     */\r\n    WebGLSurface.prototype.animatedMethodsBase = function () {\r\n        var _this = this;\r\n        return _a = {},\r\n            // Context changes and early checks\r\n            _a[BaseAnimatedMethods.CONTEXT] = function () {\r\n                var response = {\r\n                    break: false,\r\n                    doDraw: false,\r\n                };\r\n                if (_this.resizeContext()) {\r\n                    response.doDraw = true;\r\n                }\r\n                // Quadtree MUST be present to do proper computations\r\n                if (!_this.quadTree) {\r\n                    response.break = true;\r\n                }\r\n                return response;\r\n            },\r\n            // Apply inertia\r\n            _a[BaseAnimatedMethods.INERTIA] = function () {\r\n                if (!_this.isPanning) {\r\n                    if (_this.inertia) {\r\n                        // Disabled inertia for now\r\n                        // This.destinationX -= this.inertia.x\r\n                        // This.destinationY -= this.inertia.y\r\n                        _this.inertia.x *= _this.inertiaDecay;\r\n                        _this.inertia.y *= _this.inertiaDecay;\r\n                        if (_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y < 1) {\r\n                            _this.inertia = null;\r\n                        }\r\n                    }\r\n                }\r\n                // A non response\r\n                return {\r\n                    doDraw: false,\r\n                };\r\n            },\r\n            // Apply position\r\n            _a[BaseAnimatedMethods.POSITION] = function () {\r\n                // If values are transitioned rather than immediately applied, this is\r\n                // The value you would want the minimum change to be before cutting off\r\n                // The transition\r\n                // Const minAdjust = 1 / this.props.zoom\r\n                // If there is change in X apply the new position to the old\r\n                // This is where animated values were originally placed and can be placed\r\n                // Again if a transition is desired\r\n                var response = {\r\n                    doDraw: (_this.currentX !== _this.destinationX) || (_this.currentY !== _this.destinationY),\r\n                };\r\n                _this.currentX = _this.destinationX;\r\n                _this.currentY = _this.destinationY;\r\n                _this.positionCamera(_this.currentX, _this.currentY);\r\n                return response;\r\n            },\r\n            // Apply zooming\r\n            _a[BaseAnimatedMethods.ZOOM] = function () {\r\n                var response = {\r\n                    doDraw: false,\r\n                };\r\n                // Apply Zoom\r\n                // Const zoomToFitH = this.ctx.width / Math.max(this.quadTree.bounds.width, this.props.viewport.width);\r\n                // Const zoomToFitV = this.ctx.height / Math.max(this.quadTree.bounds.height, this.props.viewport.height);\r\n                // Const zoomToFit = Math.min(zoomToFitH, zoomToFitV);\r\n                var zoomToFit = 1;\r\n                var destZoom = _this.destinationZoom * zoomToFit;\r\n                var dZoom = Math.abs(destZoom - _this.targetZoom);\r\n                var minDZoom = MIN_ZOOM_INCREMENT;\r\n                var zoomRate = 3;\r\n                if (dZoom > minDZoom) {\r\n                    _this.targetZoom = _this.targetZoom + ((destZoom - _this.targetZoom) / zoomRate);\r\n                    response.doDraw = true;\r\n                }\r\n                else if (dZoom !== 0) {\r\n                    _this.targetZoom = destZoom;\r\n                    response.doDraw = true;\r\n                }\r\n                // Get the zoom target metrics before zooming\r\n                var zoomTargetX = _this.zoomTargetX;\r\n                var zoomTargetY = _this.zoomTargetY;\r\n                var screenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\r\n                // Update the camera zoom level\r\n                _this.zoomCamera(_this.targetZoom);\r\n                // After we have zoomed we see how much our target location moved on screen\r\n                var newScreenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\r\n                // Now we move our screen by the moved delta to keep it exactly where it was before hand\r\n                var zoomDX = -(newScreenZoomTarget.x - screenZoomTarget.x) / _this.targetZoom;\r\n                var zoomDY = (newScreenZoomTarget.y - screenZoomTarget.y) / _this.targetZoom;\r\n                _this.currentX -= zoomDX;\r\n                _this.currentY -= zoomDY;\r\n                _this.destinationX -= zoomDX;\r\n                _this.destinationY -= zoomDY;\r\n                _this.positionCamera(_this.currentX, _this.currentY);\r\n                return response;\r\n            },\r\n            _a;\r\n        var _a;\r\n    };\r\n    /**\r\n     * This is a hook for subclasses to be able to apply buffer changes that rely\r\n     * on colors rendered into the atlas after the system has prepped the colors for render.\r\n     */\r\n    WebGLSurface.prototype.applyColorBufferChanges = function (props) {\r\n        // Note: For subclasses\r\n    };\r\n    /**\r\n     * This is a hook for subclasses to be able to apply label buffer changes after the system has\r\n     * prepped the labels for render.\r\n     */\r\n    WebGLSurface.prototype.applyLabelBufferChanges = function (props) {\r\n        // Note: For subclasses\r\n    };\r\n    /**\r\n     * @override\r\n     * This is a hook so subclasses can contribute property application methods to the applyProps process and organize the base methods\r\n     * as desired.\r\n     *\r\n     * @param {ApplyPropsMethodLookup<T>} basePropsMethods The base props methods referenceable by name\r\n     * @param {ApplyPropsMethod<T>[]} orderedBasePropsMethods The base animated methods in their default order for ease of use\r\n     *\r\n     * @return {ApplyPropsMethod<T>[]} The list of property application methods in the order they are expected to be executed\r\n     */\r\n    WebGLSurface.prototype.applyPropsMethods = function (basePropsMethods, orderedBasePropsMethods) {\r\n        // Default functionality is to use the simple preordered list\r\n        return orderedBasePropsMethods;\r\n    };\r\n    /**\r\n     * This is a hook so subclasses can contribute methods to the applying props procedure and organize the base methods\r\n     * as desired.\r\n     *\r\n     * @return {ApplyPropsMethodLookup<T>} The base apply props method that are indexed for ease of reference\r\n     */\r\n    WebGLSurface.prototype.applyPropsMethodsBase = function () {\r\n        var _this = this;\r\n        return _a = {},\r\n            _a[BaseApplyPropsMethods.INITIALIZE] = function (props) {\r\n                var height = props.height, width = props.width;\r\n                _this.init(_this.renderEl, width, height);\r\n                if (!_this.renderEl || width === 0 || height === 0) {\r\n                    return {\r\n                        break: true,\r\n                    };\r\n                }\r\n                // Get the target for zooming\r\n                if (_this.camera) {\r\n                    var world = _this.screenToWorld(_this.lastMousePosition.x, _this.lastMousePosition.y);\r\n                    _this.zoomTargetX = world.x;\r\n                    _this.zoomTargetY = world.y;\r\n                }\r\n                debug('props', props);\r\n                return {};\r\n            },\r\n            _a[BaseApplyPropsMethods.LABELS] = function (props) {\r\n                var response = {};\r\n                // If we have a new labels reference we must regenerate the labels in our image lookup\r\n                if (props.labels && props.labels !== _this.labels) {\r\n                    debugLabels('Labels are being comitted to an Atlas %o', props.labels);\r\n                    // Flag the labels as incapable of rendering\r\n                    _this.labelsReady = false;\r\n                    _this.labelsLoadId++;\r\n                    // Store the set of labels we are rendering so that they do not get re-generated\r\n                    // In the atlas rapidly.\r\n                    _this.labels = props.labels;\r\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.labels)) {\r\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.labels);\r\n                    }\r\n                    var textures = props.labels.map(function (label) { return new atlas_texture_1.AtlasTexture(null, label); });\r\n                    debugLabels('Creating the atlas for labels based on these textures %o', textures);\r\n                    _this.atlasManager.createAtlas(_this.atlasNames.labels, textures)\r\n                        .then(function () {\r\n                        debugLabels('Labels rasterized within the atlas!');\r\n                        _this.forceDraw = true;\r\n                        _this.labelsCurrentLoadedId++;\r\n                        // If we are done loading AND we match up with the current load id, then labels\r\n                        // For the latest labels update are indeed ready for display\r\n                        if (_this.labelsCurrentLoadedId === _this.labelsLoadId) {\r\n                            _this.labelsReady = true;\r\n                        }\r\n                        // Reapply the props so any buffers that were not updating can update now\r\n                        _this.applyProps(_this.props);\r\n                    });\r\n                }\r\n                return response;\r\n            },\r\n            _a[BaseApplyPropsMethods.COLORS] = function (props) {\r\n                var response = {};\r\n                // If we have a new labels reference we must regenerate the labels in our image lookup\r\n                if (props.colors && props.colors !== _this.colors) {\r\n                    debugLabels('Colors are being comitted to an Atlas %o', props.colors);\r\n                    // Flag the labels as incapable of rendering\r\n                    _this.colorsReady = false;\r\n                    // Store the set of labels we are rendering so that they do not get re-generated\r\n                    // In the atlas rapidly.\r\n                    _this.colors = props.colors;\r\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.colors)) {\r\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.colors);\r\n                    }\r\n                    debugLabels('Creating the atlas for colors based on these colors %o', _this.colors);\r\n                    _this.atlasManager.createAtlas(_this.atlasNames.colors, null, _this.colors)\r\n                        .then(function () {\r\n                        debugLabels('Colors rasterized within the atlas!');\r\n                        _this.forceDraw = true;\r\n                        _this.colorsReady = true;\r\n                        // Reapply the props so any buffers that were not updating can update now\r\n                        _this.applyProps(_this.props);\r\n                    });\r\n                }\r\n                return response;\r\n            },\r\n            _a[BaseApplyPropsMethods.BUFFERCHANGES] = function (props) {\r\n                // Call the hook to allow sub componentry to have a place to update it's buffers\r\n                _this.applyBufferChanges(props);\r\n                // We call the label buffering when the labels are ready to render.\r\n                // Labels now utilize the color atlas as well, thus requiring colors\r\n                // To be loaded\r\n                if (_this.labelsReady && _this.colorsReady) {\r\n                    debugLabels('labels changed %o', props);\r\n                    _this.applyLabelBufferChanges(props);\r\n                }\r\n                // For resources that only need the color atlas to be ready\r\n                if (_this.colorsReady) {\r\n                    _this.applyColorBufferChanges(props);\r\n                }\r\n                return {};\r\n            },\r\n            _a[BaseApplyPropsMethods.CAMERA] = function (props) {\r\n                _this.destinationZoom = props.zoom;\r\n                // On initialization this should start with some base camera metrics\r\n                if (props.viewport && props.viewport !== _this.appliedViewport && _this.quadTree) {\r\n                    debugCam('Applying viewport to camera: %o World Space Bounds: %o Screen context: %o', props.viewport, _this.quadTree.bounds, { width: props.width, height: props.height });\r\n                    // Position the camera over the mid of the specified viewport\r\n                    var mid = props.viewport.mid;\r\n                    _this.currentX = _this.destinationX = mid.x;\r\n                    _this.currentY = _this.destinationY = mid.y;\r\n                    // Calculate the zoom level when the input zoom is at 1\r\n                    var zoomAtOne = 1;\r\n                    // Calculate the zoom needed for the viewport\r\n                    var zoomToFitViewH = props.width / props.viewport.width;\r\n                    var zoomToFitViewV = props.height / props.viewport.height;\r\n                    var zoomToFit = Math.min(zoomToFitViewH, zoomToFitViewV);\r\n                    // This adjusts the destination zxoom by a tiny amount so the view will redraw\r\n                    var microAdjustment = 1.001;\r\n                    // Make our destination zoom a zoom that will fit the dimensions of the viewport\r\n                    // Relative to the zoom at one level\r\n                    _this.destinationZoom = zoomToFit / zoomAtOne;\r\n                    _this.targetZoom = (_this.destinationZoom * zoomAtOne) * microAdjustment;\r\n                    // Make sure any zooming that happens occurs over the middle of the initial viewport\r\n                    _this.zoomTargetX = mid.x;\r\n                    _this.zoomTargetY = mid.y;\r\n                    // Make sure mouse position doesn't mess with the zooming focus either\r\n                    _this.lastMousePosition.x = props.width / 2.0;\r\n                    _this.lastMousePosition.y = props.height / 2.0;\r\n                    // Apply the values immediately to the camera\r\n                    _this.positionCamera(_this.currentX, _this.currentY);\r\n                    _this.zoomCamera(_this.targetZoom);\r\n                    _this.updateCameraUniforms();\r\n                    // We request the calculated zoom level so adjustments on the input can be made\r\n                    if (props.onZoomRequest) {\r\n                        props.onZoomRequest(_this.destinationZoom);\r\n                        debugCam('Requesting zoom level', _this.destinationZoom);\r\n                    }\r\n                    // Let's disable mouse interactions for a little bit until the camera has settled into place\r\n                    var framesToDisable = 10;\r\n                    _this.disableMouseInteraction = framesToDisable;\r\n                    _this.appliedViewport = props.viewport;\r\n                    debugCam('init cam', _this.currentX, _this.currentY);\r\n                }\r\n                // Ensure we have our quad tree available even if it is empty\r\n                if (!_this.quadTree) {\r\n                    _this.quadTree = new quad_tree_1.QuadTree(0, 1, 1, 0);\r\n                }\r\n                return {};\r\n            },\r\n            _a;\r\n        var _a;\r\n    };\r\n    /**\r\n     * This is a hook for sub components to have a location to update their buffers\r\n     *\r\n     * @param {T} props This is the next set of props that are going to be applied to this component\r\n     */\r\n    WebGLSurface.prototype.applyBufferChanges = function (props) {\r\n        // NOTE: This will be implemented by base classes\r\n    };\r\n    /**\r\n     * @override\r\n     * Start the update loop and register any interesting listeners\r\n     */\r\n    WebGLSurface.prototype.componentDidMount = function () {\r\n        this.animate();\r\n    };\r\n    /**\r\n     * @override\r\n     * This will set up any unchanging context as well as establish the set of methods\r\n     * that are to be used within constructed method loops.\r\n     */\r\n    WebGLSurface.prototype.componentWillMount = function () {\r\n        /** Create our context bound projection methods for handing to processes that may need them */\r\n        this.projection = {\r\n            screenSizeToWorld: this.screenSizeToWorld.bind(this),\r\n            screenToWorld: this.screenToWorld.bind(this),\r\n            worldSizeToScreen: this.worldSizeToScreen.bind(this),\r\n            worldToScreen: this.worldToScreen.bind(this),\r\n        };\r\n        /** Generate our applying props methods to execute within our applyProps process */\r\n        var basePropsMethods = this.applyPropsMethodsBase();\r\n        this.propsMethodList = this.applyPropsMethods(basePropsMethods, [\r\n            basePropsMethods[BaseApplyPropsMethods.INITIALIZE],\r\n            basePropsMethods[BaseApplyPropsMethods.LABELS],\r\n            basePropsMethods[BaseApplyPropsMethods.COLORS],\r\n            basePropsMethods[BaseApplyPropsMethods.BUFFERCHANGES],\r\n            basePropsMethods[BaseApplyPropsMethods.CAMERA],\r\n        ]);\r\n        /** Generate our animated methods to execute within our animation loop */\r\n        var baseAnimatedMethods = this.animatedMethodsBase();\r\n        this.animatedMethodList = this.animatedMethods(baseAnimatedMethods, [\r\n            baseAnimatedMethods[BaseAnimatedMethods.CONTEXT],\r\n            baseAnimatedMethods[BaseAnimatedMethods.INERTIA],\r\n            baseAnimatedMethods[BaseAnimatedMethods.POSITION],\r\n            baseAnimatedMethods[BaseAnimatedMethods.ZOOM],\r\n        ]);\r\n    };\r\n    /**\r\n     * @override\r\n     * Simply applies the new injected props\r\n     *\r\n     * @param {T} props The new properties to be applied to this component\r\n     */\r\n    WebGLSurface.prototype.componentWillReceiveProps = function (props) {\r\n        this.applyProps(props);\r\n    };\r\n    /**\r\n     * @override\r\n     * Release listeners and stop update loop\r\n     */\r\n    WebGLSurface.prototype.componentWillUnmount = function () {\r\n        this.stop = true;\r\n        if (this.quadTree) {\r\n            this.quadTree.destroy();\r\n        }\r\n        this.quadTree = null;\r\n        this.camera = null;\r\n        this.sizeCamera = null;\r\n        this.ctx = null;\r\n        this.renderEl = null;\r\n        this.renderer = null;\r\n        this.scene = null;\r\n    };\r\n    /**\r\n     * This is a hook allowing sub classes to have a place to initialize their buffers\r\n     * and materials etc.\r\n     */\r\n    WebGLSurface.prototype.initBuffers = function () {\r\n        // NOTE: This is to be implemented by subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to when the mouse moves. Provides some information\r\n     * about mouse location and interaction.\r\n     *\r\n     * @param {IPoint} mouse Position of the mouse relative to the canvas\r\n     * @param {IPoint} world Position of the mouse relative to the world space\r\n     * @param {boolean} isPanning The panning state of the mouse\r\n     */\r\n    WebGLSurface.prototype.onMouse = function (mouse, world, isPanning) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to mouse down events\r\n     */\r\n    WebGLSurface.prototype.onMouseDown = function () {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to mouse out events\r\n     */\r\n    WebGLSurface.prototype.onMouseOut = function () {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to mouse up events and the items that were interacted with in the process\r\n     *\r\n     * @param {React.MouseEvent} e The react synthetic event associated with the action\r\n     * @param {Bounds[]} hitInside The items the mouse interacted with\r\n     * @param {IPoint} mouse The location of the mouse on the screen\r\n     * @param {IPoint} world The location of the mouse projected into the world\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     */\r\n    WebGLSurface.prototype.onMouseUp = function (e, hitInside, mouse, world, projection) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to the mouse hovering over an item included in the quadtree\r\n     *\r\n     * @param {Bounds[]} hitInside The items hovered over by the mouse\r\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\r\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     */\r\n    WebGLSurface.prototype.onMouseHover = function (hitInside, mouse, world, projection) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to the mouse leaving an item included in the quadtree\r\n     *\r\n     * @param {Bounds[]} left The items no longer hovered over by the mouse\r\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\r\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     */\r\n    WebGLSurface.prototype.onMouseLeave = function (left, mouse, world, projection) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to changes in the viewport and currently visible items\r\n     *\r\n     * @param {Bounds[]} visible\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     * @param {IScreenContext} ctx\r\n     */\r\n    WebGLSurface.prototype.onViewport = function (visible, projection, ctx) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Places the camera at a given location in world space\r\n     *\r\n     * @param {number} x The x-coordinate for the camera in world space\r\n     * @param {number} y The x-coordinate for the camera in world space\r\n     */\r\n    WebGLSurface.prototype.positionCamera = function (x, y) {\r\n        if (this.camera) {\r\n            this.camera.position.set(Math.floor(x), Math.floor(y), this.camera.position.z);\r\n        }\r\n    };\r\n    /**\r\n     * Projects a screen coordinate to a world coordinate\r\n     *\r\n     * @param {number} x The x coord within the screen to project into the world\r\n     * @param {number} y The y coord within the screen to project into the world\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {object} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.screenToWorld = function (x, y, obj) {\r\n        // Get the coordinates in normalized screen space\r\n        vector.set((x / this.ctx.width) * 2 - 1, -(y / this.ctx.height) * 2 + 1, 0.0);\r\n        // Unproject the normalized space to the world. It will project\r\n        // The vector to a REALLY far away z coordinate, but it does not matter\r\n        // Since we are utilizing an orthographic camera (no perspective distortion)\r\n        vector.unproject(this.camera);\r\n        obj = obj || { x: 0, y: 0 };\r\n        obj.x = vector.x;\r\n        obj.y = vector.y;\r\n        return obj;\r\n    };\r\n    /**\r\n     * Projects a size on the screen to the size represented in the world\r\n     *\r\n     * @param {number} w The size of the width on the screen to project to the world\r\n     * @param {number} h The size of the height on the screen to project to the world\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {object} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.screenSizeToWorld = function (w, h, obj) {\r\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\r\n        obj.width = w / (this.sizeCamera ? this.sizeCamera.zoom : 1);\r\n        obj.height = h / (this.sizeCamera ? this.sizeCamera.zoom : 1);\r\n        return obj;\r\n    };\r\n    /**\r\n     * Projects a world coordinate to the screen\r\n     *\r\n     * @param {number} x The x coord in the world to project to the screen\r\n     * @param {number} y The y coord in the world to project to the screen\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {IPoint} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.worldToScreen = function (x, y, obj) {\r\n        // This projects to NORMALIZED screen space (-1, 1) range for x and y\r\n        vector.set(x, y, 0);\r\n        vector.project(this.camera);\r\n        // Use the window dimensions to denormalize the vector\r\n        obj = ramda_1.merge(obj || {}, {\r\n            x: (vector.x * this.ctx.widthHalf) + this.ctx.widthHalf,\r\n            y: -(vector.y * this.ctx.heightHalf) + this.ctx.heightHalf,\r\n        });\r\n        return obj;\r\n    };\r\n    /**\r\n     * Projects a size within the world to how it would appear on the screen\r\n     *\r\n     * @param {number} w The size of the width on the screen to project to the world\r\n     * @param {number} h The size of the height on the screen to project to the world\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {object} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.worldSizeToScreen = function (w, h, obj) {\r\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\r\n        obj.width = w * this.sizeCamera.zoom;\r\n        obj.height = h * this.sizeCamera.zoom;\r\n        return obj;\r\n    };\r\n    /**\r\n     * Sets the zoom level the camera will view the world with\r\n     *\r\n     * @param {number} zoom The zoom level. Must be > 0\r\n     */\r\n    WebGLSurface.prototype.zoomCamera = function (zoom) {\r\n        this.camera.zoom = zoom;\r\n        this.sizeCamera.zoom = zoom;\r\n        this.camera.updateProjectionMatrix();\r\n        this.sizeCamera.updateProjectionMatrix();\r\n    };\r\n    /**\r\n     * This is a hook allowing a sub class to update uniforms when the camera is changed in\r\n     * any way\r\n     */\r\n    WebGLSurface.prototype.updateCameraUniforms = function () {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * @override\r\n     * Only re-render if the dimensions of the component have changed. All other\r\n     * internal render updates are handled internally\r\n     *\r\n     * @param {T} nextProps The next properties injected\r\n     */\r\n    WebGLSurface.prototype.shouldComponentUpdate = function (nextProps) {\r\n        return this.props.width !== nextProps.width || this.props.height !== nextProps.height;\r\n    };\r\n    /**\r\n     * Hook to allow subclasses some control over panning distances\r\n     *\r\n     * @param {number} distanceX The distance to pan in the x direction\r\n     * @param {number} distanceY The distance to pan in the y direction\r\n     *\r\n     * @return {Vector3} The vector indicating the direction to pan\r\n     */\r\n    WebGLSurface.prototype.willPan = function (distanceX, distanceY) {\r\n        return new three_1.Vector3(distanceX, distanceY, 0.0);\r\n    };\r\n    // -----[ Render ]---------------------------------------------\r\n    //\r\n    // In a React app, it's nice to put the render function at the bottom of the\r\n    // File\r\n    /**\r\n     * This should only attempt rendering when the canvas DOM element needs to be resized.\r\n     * You will note shouldComponentUpdate helps facilitate this.\r\n     */\r\n    WebGLSurface.prototype.render = function () {\r\n        var _this = this;\r\n        var _a = this.props, width = _a.width, height = _a.height;\r\n        if (!WEBGL_SUPPORTED) {\r\n            return React.createElement(\"div\", null, this.props.children || 'Web GL not supported');\r\n        }\r\n        return (React.createElement(\"div\", { onMouseDown: this.handleMouseDown, onMouseOut: this.handleMouseOut, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseOut, onMouseMove: this.handleMouseMove, onDoubleClick: function (e) {\r\n                if (_this.props.onDoubleClick) {\r\n                    _this.props.onDoubleClick(e);\r\n                }\r\n            }, style: { position: 'relative', width: width, height: height } },\r\n            React.createElement(\"div\", { ref: this.applyRef })));\r\n    };\r\n    return WebGLSurface;\r\n}(React.Component));\r\nexports.WebGLSurface = WebGLSurface;\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_23__;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(26);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_27__;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(29));\r\n__export(__webpack_require__(4));\r\n__export(__webpack_require__(30));\r\n__export(__webpack_require__(31));\r\n__export(__webpack_require__(32));\r\n__export(__webpack_require__(33));\r\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\nvar buffer_util_1 = __webpack_require__(3);\r\nvar base_buffer_1 = __webpack_require__(4);\r\n/**\r\n * This renders a curved line by injecting all attributes needed to render it.\r\n * This naively includes all possible data in the vertex.\r\n *\r\n * This only supports atlas colors.\r\n */\r\nvar SharedControlCurvedLineBufferAnts = (function (_super) {\r\n    __extends(SharedControlCurvedLineBufferAnts, _super);\r\n    function SharedControlCurvedLineBufferAnts() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SharedControlCurvedLineBufferAnts.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'startColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'endColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [1],\r\n                name: 'normalDirection',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'endPoints',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'halfLinewidth',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'marching',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\r\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\r\n     *                                    needed for rendering with color picks.\r\n     */\r\n    SharedControlCurvedLineBufferAnts.prototype.update = function (shapeBuffer, atlasManager, sharedControl) {\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        // As this is a single material, we have to assume that the color atlas\r\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\r\n        // Information for one color will be valid for all colors\r\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\r\n            var colorRef = shapeBuffer[0].startColor;\r\n            var colorBase = colorRef.base;\r\n            // Update all uniforms for this material to utilize the atlas metrics for\r\n            // Picking colors\r\n            var material = this.bufferItems.system.material;\r\n            var uniforms = material.uniforms;\r\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\r\n            uniforms.colorAtlas.value = atlas;\r\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\r\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\r\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\r\n            // This is the shared control point for all of the vertices\r\n            uniforms.controlPoint.value = [sharedControl.x, sharedControl.y];\r\n            atlas.needsUpdate = true;\r\n        }\r\n        // Commit static curved lines\r\n        var colorAttributeSize = 1;\r\n        var marchingAttributeSize = 4;\r\n        var numVerticesPerSegment = 6;\r\n        var halfWidthSize = 1;\r\n        var length = 15;\r\n        var needsUpdate = false;\r\n        var p1;\r\n        var p2;\r\n        var colorStart;\r\n        var colorEnd;\r\n        var alpha;\r\n        var antLength;\r\n        var antGap;\r\n        var antSpeed;\r\n        // We can not accurately send very large numbers via float point into the attributes\r\n        // So we trim down our time sent to the attribute down to a number that is less than\r\n        // 16,777,217 which means we can only reliably grab the last 7 digits of the date's time\r\n        var antStartTime = 0;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var _loop_1 = function (curvedLine) {\r\n            // We will not render the curved line with this buffer if the marching ants are not provided\r\n            if (!curvedLine.marchingAnts) {\r\n                console.error('Attempted to render a curved line shape with a marching ant buffer but provided no marching ant metrics. This curved line shape will be skipped', curvedLine);\r\n                return \"continue\";\r\n            }\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            colorStart = curvedLine.startColor.base;\r\n            colorEnd = curvedLine.endColor.base;\r\n            halfWidthSize = curvedLine.lineWidth / 2.0;\r\n            length = curvedLine.resolution;\r\n            p1 = curvedLine.p1;\r\n            p2 = curvedLine.p2;\r\n            antGap = curvedLine.marchingAnts.gapLength;\r\n            antSpeed = curvedLine.marchingAnts.speed;\r\n            antLength = curvedLine.marchingAnts.strokeLength + curvedLine.marchingAnts.gapLength;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, marching, mpos) {\r\n                // Copy first vertex twice for intro degenerate tri\r\n                positions[ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[wpos] = halfWidthSize;\r\n                // Skip over degenerate tris color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                mpos += marchingAttributeSize;\r\n                normals[npos] = 1;\r\n                endPoints[epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                // TR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[scpos] = colorStart.colorIndex;\r\n                endColor[ecpos] = colorEnd.colorIndex;\r\n                marching[mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // BR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                marching[++mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // TL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                marching[++mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // BL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                marching[++mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // Copy last vertex again for degenerate tri\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                // Skip over degenerate tris for color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                mpos += marchingAttributeSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n            });\r\n            // If no updating is happening, just quit the loop\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        // Only if updates happened, should this change\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SharedControlCurvedLineBufferAnts;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SharedControlCurvedLineBufferAnts = SharedControlCurvedLineBufferAnts;\r\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\nvar buffer_util_1 = __webpack_require__(3);\r\nvar base_buffer_1 = __webpack_require__(4);\r\n/**\r\n * This renders a curved line by injecting all attributes needed to render it.\r\n * This naively includes all possible data in the vertex.\r\n *\r\n * This only supports atlas colors.\r\n */\r\nvar SharedControlCurvedLineBuffer = (function (_super) {\r\n    __extends(SharedControlCurvedLineBuffer, _super);\r\n    function SharedControlCurvedLineBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SharedControlCurvedLineBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'startColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'endColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [1],\r\n                name: 'normalDirection',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'endPoints',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'halfLinewidth',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\r\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\r\n     *                                    needed for rendering with color picks.\r\n     */\r\n    SharedControlCurvedLineBuffer.prototype.update = function (shapeBuffer, atlasManager, sharedControl) {\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        // As this is a single material, we have to assume that the color atlas\r\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\r\n        // Information for one color will be valid for all colors\r\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\r\n            var colorRef = shapeBuffer[0].startColor;\r\n            var colorBase = colorRef.base;\r\n            // Update all uniforms for this material to utilize the atlas metrics for\r\n            // Picking colors\r\n            var material = this.bufferItems.system.material;\r\n            var uniforms = material.uniforms;\r\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\r\n            uniforms.colorAtlas.value = atlas;\r\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\r\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\r\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\r\n            // This is the shared control point for all of the vertices\r\n            uniforms.controlPoint.value = [sharedControl.x, sharedControl.y];\r\n            atlas.needsUpdate = true;\r\n        }\r\n        // Commit static curved lines\r\n        var colorAttributeSize = 1;\r\n        var numVerticesPerSegment = 6;\r\n        var halfWidthSize = 1;\r\n        var length = 15;\r\n        var needsUpdate = false;\r\n        var p1;\r\n        var p2;\r\n        var colorStart;\r\n        var colorEnd;\r\n        var alpha;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var _loop_1 = function (curvedLine) {\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            colorStart = curvedLine.startColor.base;\r\n            colorEnd = curvedLine.endColor.base;\r\n            halfWidthSize = curvedLine.lineWidth / 2.0;\r\n            length = curvedLine.resolution;\r\n            p1 = curvedLine.p1;\r\n            p2 = curvedLine.p2;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos) {\r\n                // Copy first vertex twice for intro degenerate tri\r\n                positions[ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[wpos] = halfWidthSize;\r\n                // Skip over degenerate tris color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                normals[npos] = 1;\r\n                endPoints[epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                // TR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[scpos] = colorStart.colorIndex;\r\n                endColor[ecpos] = colorEnd.colorIndex;\r\n                // BR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                // TL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                // BL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                // Copy last vertex again for degenerate tri\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                // Skip over degenerate tris for color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n            });\r\n            // If no updating is happening, just quit the loop\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        // Only if updates happened, should this change\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SharedControlCurvedLineBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SharedControlCurvedLineBuffer = SharedControlCurvedLineBuffer;\r\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\nvar buffer_util_1 = __webpack_require__(3);\r\nvar base_buffer_1 = __webpack_require__(4);\r\n/**\r\n * This renders a curved line by injecting all attributes needed to render it.\r\n * This naively includes all possible data in the vertex.\r\n *\r\n * This ONLY supports a single color\r\n */\r\nvar SimpleStaticBezierLineBuffer = (function (_super) {\r\n    __extends(SimpleStaticBezierLineBuffer, _super);\r\n    function SimpleStaticBezierLineBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SimpleStaticBezierLineBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 1],\r\n                name: 'customColor',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [1],\r\n                name: 'normalDirection',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'endPoints',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [0, 0],\r\n                name: 'controlPoint',\r\n                size: buffer_util_1.AttributeSize.TWO,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'halfLinewidth',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param shapeBuffer\r\n     */\r\n    SimpleStaticBezierLineBuffer.prototype.update = function (shapeBuffer) {\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        // Commit static curved lines\r\n        var colorAttributeSize = 4;\r\n        var numVerticesPerSegment = 6;\r\n        var halfWidthSize = 1;\r\n        var length = 15;\r\n        var needsUpdate = false;\r\n        var p1;\r\n        var p2;\r\n        var color;\r\n        var alpha;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var _loop_1 = function (curvedLine) {\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            color = curvedLine.startColor.base.color;\r\n            halfWidthSize = curvedLine.lineWidth / 2.0;\r\n            length = curvedLine.resolution;\r\n            p1 = curvedLine.p1;\r\n            p2 = curvedLine.p2;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colors, cpos, normals, npos, endPoints, epos, controlPoints, copos, halfWidth, wpos) {\r\n                // Copy first vertex twice for intro degenerate tri\r\n                positions[ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[wpos] = halfWidthSize;\r\n                // Skip over degenerate tris color\r\n                cpos += colorAttributeSize;\r\n                normals[npos] = 1;\r\n                endPoints[epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                // TR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // BR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // TL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // BL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // Copy last vertex again for degenerate tri\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                // Skip over degenerate tris for color\r\n                cpos += colorAttributeSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n            });\r\n            // If no updating is happening, just quit the loop\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        // Only if updates happened, should this change\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SimpleStaticBezierLineBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SimpleStaticBezierLineBuffer = SimpleStaticBezierLineBuffer;\r\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\nvar buffer_util_1 = __webpack_require__(3);\r\nvar base_buffer_1 = __webpack_require__(4);\r\nvar SimpleStaticLabelBuffer = (function (_super) {\r\n    __extends(SimpleStaticLabelBuffer, _super);\r\n    function SimpleStaticLabelBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SimpleStaticLabelBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'customColor',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 1],\r\n                name: 'texCoord',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0],\r\n                name: 'size',\r\n                size: buffer_util_1.AttributeSize.TWO,\r\n            },\r\n            {\r\n                defaults: [0, 0],\r\n                name: 'anchor',\r\n                size: buffer_util_1.AttributeSize.TWO,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param shapeBuffer\r\n     */\r\n    SimpleStaticLabelBuffer.prototype.update = function (shapeBuffer, atlasManager, startFade, endFade, labelMaxSize) {\r\n        // Make some constants and props for our buffer update loop\r\n        var numVerticesPerQuad = 6;\r\n        var label;\r\n        var texture;\r\n        var color;\r\n        var alpha;\r\n        var anchor;\r\n        var labelSize;\r\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\r\n            var colorRef = shapeBuffer[0].color;\r\n            var colorBase = colorRef.base;\r\n            var material = this.bufferItems.system.material;\r\n            var uniforms = material.uniforms;\r\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\r\n            uniforms.colorAtlas.value = atlas;\r\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\r\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\r\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\r\n            atlas.needsUpdate = true;\r\n            if (startFade || endFade || labelMaxSize) {\r\n                material = this.bufferItems.system.material;\r\n                uniforms = material.uniforms;\r\n                if (startFade)\r\n                    uniforms.startFade.value = startFade;\r\n                if (endFade)\r\n                    uniforms.endFade.value = endFade;\r\n                if (labelMaxSize)\r\n                    uniforms.maxLabelSize.value = labelMaxSize;\r\n            }\r\n        }\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        var updated = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this.bufferItems, numVerticesPerQuad, shapeBuffer.length, function (i, positions, ppos, colors, cpos, texCoords, tpos, sizes, spos, anchors, apos) {\r\n            label = shapeBuffer[i];\r\n            texture = label.rasterizedLabel;\r\n            color = label.color.base;\r\n            alpha = label.color.base.opacity;\r\n            anchor = {\r\n                x: label.getLocation().x + label.getSize().width * Math.cos(label.getRotation()),\r\n                y: label.getLocation().y + label.getSize().width * Math.sin(label.getRotation()),\r\n            };\r\n            labelSize = label.getSize();\r\n            // Make sure the label is updated with it's latest metrics\r\n            label.update();\r\n            // Copy first vertex twice for intro degenerate tri\r\n            positions[ppos] = label.TR.x;\r\n            positions[++ppos] = label.TR.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[tpos] = texture.atlasTR.x;\r\n            texCoords[++tpos] = texture.atlasTR.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[cpos] = color.colorIndex;\r\n            sizes[spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // TR\r\n            positions[++ppos] = label.TR.x;\r\n            positions[++ppos] = label.TR.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasTR.x;\r\n            texCoords[++tpos] = texture.atlasTR.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // BR\r\n            positions[++ppos] = label.BR.x;\r\n            positions[++ppos] = label.BR.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasBR.x;\r\n            texCoords[++tpos] = texture.atlasBR.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // TL\r\n            positions[++ppos] = label.TL.x;\r\n            positions[++ppos] = label.TL.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasTL.x;\r\n            texCoords[++tpos] = texture.atlasTL.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // BL\r\n            positions[++ppos] = label.BL.x;\r\n            positions[++ppos] = label.BL.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasBL.x;\r\n            texCoords[++tpos] = texture.atlasBL.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // Copy last vertex again for degenerate tri\r\n            positions[++ppos] = label.BL.x;\r\n            positions[++ppos] = label.BL.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasBL.x;\r\n            texCoords[++tpos] = texture.atlasBL.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n        });\r\n        this.bufferItems.geometry.setDrawRange(0, numVerticesPerQuad * shapeBuffer.length);\r\n        return updated;\r\n    };\r\n    return SimpleStaticLabelBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SimpleStaticLabelBuffer = SimpleStaticLabelBuffer;\r\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\nvar buffer_util_1 = __webpack_require__(3);\r\nvar base_buffer_1 = __webpack_require__(4);\r\nvar SimpleStaticLineBuffer = (function (_super) {\r\n    __extends(SimpleStaticLineBuffer, _super);\r\n    function SimpleStaticLineBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SimpleStaticLineBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 1],\r\n                name: 'customColor',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param shapeBuffer\r\n     */\r\n    SimpleStaticLineBuffer.prototype.update = function (shapeBuffer) {\r\n        var needsUpdate = false;\r\n        var numVerticesPerSegment = 6;\r\n        var colorAttributeSize = 4;\r\n        var stripPos = 0;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var TR;\r\n        var BR;\r\n        var TL;\r\n        var BL;\r\n        var color;\r\n        var alpha;\r\n        var _loop_1 = function (curvedLine) {\r\n            var strip = curvedLine.getTriangleStrip();\r\n            color = curvedLine.startColor.base.color;\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, strip.length / 4, function (i, positions, ppos, colors, cpos) {\r\n                stripPos = i * 4;\r\n                TR = strip[stripPos];\r\n                BR = strip[stripPos + 1];\r\n                TL = strip[stripPos + 2];\r\n                BL = strip[stripPos + 3];\r\n                // 1\r\n                positions[ppos] = TR.x;\r\n                positions[++ppos] = TR.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                cpos += colorAttributeSize;\r\n                // 2\r\n                positions[++ppos] = TR.x;\r\n                positions[++ppos] = TR.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 3\r\n                positions[++ppos] = BR.x;\r\n                positions[++ppos] = BR.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 4\r\n                positions[++ppos] = TL.x;\r\n                positions[++ppos] = TL.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 5\r\n                positions[++ppos] = BL.x;\r\n                positions[++ppos] = BL.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 6\r\n                positions[++ppos] = BL.x;\r\n                positions[++ppos] = BL.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                cpos += colorAttributeSize;\r\n            });\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SimpleStaticLineBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SimpleStaticLineBuffer = SimpleStaticLineBuffer;\r\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(35));\r\n__export(__webpack_require__(36));\r\n__export(__webpack_require__(37));\r\n__export(__webpack_require__(38));\r\n__export(__webpack_require__(39));\r\n__export(__webpack_require__(12));\r\n__export(__webpack_require__(20));\r\n__export(__webpack_require__(40));\r\n__export(__webpack_require__(41));\r\n__export(__webpack_require__(10));\r\n__export(__webpack_require__(8));\r\n__export(__webpack_require__(14));\r\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This defines a reference to a color that has been rendered to a texture\r\n * (See AtlasColor). This exposes the only properties that MAY be utilized\r\n * in a shader to modify the existing values without altering what is rendered\r\n * on the texture.\r\n */\r\nvar ReferenceColor = (function () {\r\n    /**\r\n     * Creates an instance of ReferenceColor.\r\n     *\r\n     * @param {AtlasColor} base The color to be based off of\r\n     */\r\n    function ReferenceColor(base) {\r\n        this.base = base;\r\n    }\r\n    return ReferenceColor;\r\n}());\r\nexports.ReferenceColor = ReferenceColor;\r\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar d3_color_1 = __webpack_require__(7);\r\nvar circle_1 = __webpack_require__(17);\r\n/**\r\n * Defines a circular shape that can be drawn\r\n */\r\nvar CircleShape = (function (_super) {\r\n    __extends(CircleShape, _super);\r\n    /**\r\n     * Sets the properties of the shape to be drawn\r\n     *\r\n     * @param x Center of the circle\r\n     * @param y Center of the circle\r\n     * @param r The radius of the circle\r\n     * @param color The color of the circle\r\n     * @param color The color within the inner radius of the circle\r\n     * @param innerR The inner radius of the circle\r\n     * @param d A data object to associate with this circle\r\n     */\r\n    function CircleShape(x, y, r, color, innerColor, innerR, d) {\r\n        var _this = _super.call(this, x, y, r, d) || this;\r\n        // Color\r\n        _this.r = 0;\r\n        _this.g = 0;\r\n        _this.b = 0;\r\n        _this.a = 0;\r\n        // Inner radius color\r\n        _this.r2 = 0;\r\n        _this.g2 = 0;\r\n        _this.b2 = 0;\r\n        _this.a2 = 0;\r\n        // Other properties\r\n        _this.alpha = 0;\r\n        _this.innerRadius = 0;\r\n        _this.ringWidth = 0;\r\n        _this.ringPad = 0;\r\n        _this.outline = false;\r\n        if (color) {\r\n            // FIXME: This is solving a bizarre potential race condition (or other voodoo) where the numbers are not being\r\n            // Applied correctly to this object when applying the d3 color object properties to this.\r\n            var r_1 = color.r, g = color.g, b = color.b, opacity = color.opacity;\r\n            _this.setOuterColor({ r: r_1, g: g, b: b, opacity: opacity });\r\n        }\r\n        if (innerR === undefined) {\r\n            innerR = 0;\r\n        }\r\n        _this.innerRadius = innerR;\r\n        if (innerColor) {\r\n            _this.setInnerColor(innerColor);\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Sets the color of the outer drawn radius\r\n     *\r\n     * @param color\r\n     */\r\n    CircleShape.prototype.setOuterColor = function (color) {\r\n        var r = color.r, g = color.g, b = color.b, opacity = color.opacity;\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = opacity;\r\n    };\r\n    /**\r\n     * Sets the color of the inner drawn radius\r\n     *\r\n     * @param color\r\n     */\r\n    CircleShape.prototype.setInnerColor = function (color) {\r\n        this.r2 = color.r;\r\n        this.g2 = color.g;\r\n        this.b2 = color.b;\r\n        this.a2 = color.opacity;\r\n    };\r\n    /**\r\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\r\n     * is identical to this one. The properties injected can be modifiers after the clone happens\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {CircleShape} A newly cloned instance of this circleshape\r\n     */\r\n    CircleShape.prototype.clone = function (newProperties) {\r\n        return Object.assign(new CircleShape(this._centerX, this._centerY, this._radius, d3_color_1.rgb(this.r, this.g, this.b, this.a), d3_color_1.rgb(this.r2, this.g2, this.b2, this.a2), this.innerRadius, this.d), this, newProperties);\r\n    };\r\n    /**\r\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\r\n     * is identical to this one. This will perform the clone but will change the data type\r\n     * associated with the circle in the cloned instance\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {CircleShape} A newly cloned instance of this circleshape\r\n     */\r\n    CircleShape.prototype.cloneWithData = function (newProperties) {\r\n        return Object.assign(new CircleShape(this._centerX, this._centerY, this._radius, d3_color_1.rgb(this.r, this.g, this.b, this.a), d3_color_1.rgb(this.r2, this.g2, this.b2, this.a2), this.innerRadius), this, newProperties);\r\n    };\r\n    return CircleShape;\r\n}(circle_1.Circle));\r\nexports.CircleShape = CircleShape;\r\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar curved_line_1 = __webpack_require__(18);\r\nvar line_1 = __webpack_require__(5);\r\nvar point_1 = __webpack_require__(9);\r\n/**\r\n * This defines a drawable curved line shape. It contains the information necessary\r\n * to efficiently render the line.\r\n *\r\n * @export\r\n * @class CurvedLineShape\r\n * @extends {CurvedLine<T>}\r\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\r\n *             with the shape easier.\r\n */\r\nvar CurvedLineShape = (function (_super) {\r\n    __extends(CurvedLineShape, _super);\r\n    /**\r\n     * Creates an instance of CurvedLineShape.\r\n     *\r\n     * @param {ICurvedLineShapeOptions} options The options for creating this line\r\n     */\r\n    function CurvedLineShape(options) {\r\n        var _this = \r\n        // We pass our properties to the curve line but we do not let it cache it's version of the line segments\r\n        // As we will be constructing our own segmentation requiring a new type of cache\r\n        _super.call(this, options) || this;\r\n        /** Depeth of draw location */\r\n        _this.depth = 0;\r\n        /** How thick the line should be */\r\n        _this.lineWidth = 1;\r\n        _this.encapsulatePoints(_this.getTriangleStrip());\r\n        _this.cachesQuadSegments = options.cacheSegments;\r\n        _this.depth = options.depth || 0;\r\n        _this.lineWidth = options.lineWidth || 1;\r\n        _this.startColor = options.startColor;\r\n        _this.endColor = options.endColor;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns a new instance of this object that mimicks the properties of this Object\r\n     *\r\n     * @returns {CurvedLineShape<T>} The cloned object\r\n     */\r\n    CurvedLineShape.prototype.clone = function () {\r\n        // Perform the clone\r\n        var clone = new CurvedLineShape({\r\n            cacheSegments: this.cachesSegments,\r\n            controlPoints: this.controlPoints,\r\n            end: this.p2,\r\n            endColor: this.endColor,\r\n            lineWidth: this.lineWidth,\r\n            resolution: this.resolution,\r\n            start: this.p1,\r\n            startColor: this.startColor,\r\n            type: this.type,\r\n        });\r\n        clone.d = this.d;\r\n        return clone;\r\n    };\r\n    /**\r\n     * @override\r\n     * See base definition\r\n     */\r\n    CurvedLineShape.prototype.distanceTo = function (point) {\r\n        return Math.max(0, _super.prototype.distanceTo.call(this, point) - (this.lineWidth / 2.0));\r\n    };\r\n    /**\r\n     * This produces a triangle strip that represents the quads that composes this line. If caching is present,\r\n     * subsequent calls to this method will be much faster unless the cache gets invalidated.\r\n     *\r\n     * @return {IPoint[]} The Triangle Strip of points to create the quads that make each segment of the curve\r\n     */\r\n    CurvedLineShape.prototype.getTriangleStrip = function () {\r\n        if (this.cachesSegments && this.cachedQuadSegments) {\r\n            return this.cachedQuadSegments;\r\n        }\r\n        // Make a container to hold our triangle strip info\r\n        var strip = [];\r\n        var normal = [];\r\n        // Start with calculating the line strip so we can use the line segments\r\n        // To produce the quads we need to render\r\n        var lineStrip = this.getLineStrip();\r\n        var lineWidthHalf = this.lineWidth / 2.0;\r\n        var line = new line_1.Line(point_1.Point.zero(), point_1.Point.zero());\r\n        // We make a container point for the scaling operation to reduce allocations\r\n        var scaledPoint = point_1.Point.zero();\r\n        // If the line strip is empty, then there is nothing to produce and makes\r\n        // Us unable to reduce the lineStrip, so return empty here\r\n        if (lineStrip.length < 2) {\r\n            return [];\r\n        }\r\n        // Calculate bisecting normal or each node\r\n        for (var i = 0; i < lineStrip.length - 1; i++) {\r\n            line.setPoints(lineStrip[i], lineStrip[i + 1]);\r\n            if (normal.length === 0) {\r\n                normal.push(line.perpendicular);\r\n            }\r\n            else {\r\n                // Sum of two normals of a point\r\n                var temp = {\r\n                    x: normal[i].x + line.perpendicular.x,\r\n                    y: normal[i].y + line.perpendicular.y,\r\n                };\r\n                // Normalize the sum of two normals\r\n                var sqrt = Math.sqrt(temp.x * temp.x + temp.y * temp.y);\r\n                temp.x = temp.x / sqrt;\r\n                temp.y = temp.y / sqrt;\r\n                normal[i] = temp;\r\n            }\r\n            normal.push(line.perpendicular);\r\n        }\r\n        // Use the new normals to generate quads\r\n        for (var i = 0; i < lineStrip.length - 1; i++) {\r\n            var previous = lineStrip[i];\r\n            var current = lineStrip[i + 1];\r\n            // TR\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], -lineWidthHalf, scaledPoint), current));\r\n            // BR\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], lineWidthHalf, scaledPoint), current));\r\n            // TL\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], -lineWidthHalf, scaledPoint), previous));\r\n            // BL\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], lineWidthHalf, scaledPoint), previous));\r\n        }\r\n        return strip;\r\n    };\r\n    /**\r\n     * @override\r\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {IPoint[]} controlPoints\r\n     */\r\n    CurvedLineShape.prototype.setPoints = function (p1, p2, controlPoints) {\r\n        _super.prototype.setPoints.call(this, p1, p2, controlPoints);\r\n        this.cachedQuadSegments = [];\r\n    };\r\n    return CurvedLineShape;\r\n}(curved_line_1.CurvedLine));\r\nexports.CurvedLineShape = CurvedLineShape;\r\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar d3_color_1 = __webpack_require__(7);\r\nvar line_1 = __webpack_require__(5);\r\nvar line_shape_1 = __webpack_require__(20);\r\n/**\r\n * This defines an edge that can be drawn.\r\n * This type of edge is a quad with distorted ends. The quad will represent a\r\n * line with each end having potentially different sizes thus giving a four sided\r\n * polygon rather than a parallelogram.\r\n *\r\n * The edge shape also doubles up as a simple line shape should it be desired to\r\n * render differently.\r\n */\r\nvar EdgeShape = (function (_super) {\r\n    __extends(EdgeShape, _super);\r\n    /**\r\n     * Constructor with basic parameters to declare an edge\r\n     *\r\n     * @param p1 The point the edge begins at\r\n     * @param p2 The point the edge terminates at\r\n     * @param d The data associated with the edge\r\n     * @param p1Col The color at the start point\r\n     * @param p2Col The color at the end point\r\n     * @param p1Width The width at the start point. Example: if you specify 4, then\r\n     *                the start part of the edge will fan out 2 on either side of the\r\n     *                start point\r\n     * @param p2Width The width at the end point. Example: if you specify 4, then\r\n     *                the end part of the edge will fan out 2 on either side of the\r\n     *                end point\r\n     */\r\n    function EdgeShape(p1, p2, d, p1Col, p2Col, p1Width, p2Width) {\r\n        var _this = \r\n        // Set up all of our line shape based metrics\r\n        _super.call(this, p1, p2, d, p1Col.r, p1Col.g, p1Col.b, p1Col.opacity, p2Col.r, p2Col.g, p2Col.b, p2Col.opacity, p1Width) || this;\r\n        /** Top left of the quad to generate this edge */\r\n        _this.tl = { x: 0, y: 0 };\r\n        /** Bottom left of the quad to generate this edge */\r\n        _this.bl = { x: 0, y: 0 };\r\n        /** Top right of the quad to generate this edge */\r\n        _this.tr = { x: 0, y: 0 };\r\n        /** Bottom Right of the quad to generate this edge */\r\n        _this.br = { x: 0, y: 0 };\r\n        /** The width of the edge at the termination point */\r\n        _this.endWidth = 1;\r\n        _this.endWidth = p2Width;\r\n        _this.setPoints(p1, p2);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Clones this instance of the edge shape and creates a new instance of an edge shape that\r\n     * is identical to this one. The properties injected can be modifiers after the clone happens\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {EdgeShape} A newly cloned instance of this edgeshape\r\n     */\r\n    EdgeShape.prototype.clone = function (newProperties) {\r\n        return Object.assign(new EdgeShape(this.p1, this.p2, this.d, d3_color_1.rgb(this.r, this.g, this.b, this.a), d3_color_1.rgb(this.r2, this.g2, this.b2, this.a2), this.thickness, this.endWidth), this, newProperties);\r\n    };\r\n    /**\r\n     * Algorithm provided by\r\n     * https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\n     * Adapted to Javascript by Chris @ VoidRay co\r\n     *\r\n     * Remember the point must be in the same\r\n     * coordinate system that the edge is using\r\n     *\r\n     * @param {number} point The point to test\r\n     *\r\n     * @return {boolean} True if the point is inside the edge\r\n     */\r\n    EdgeShape.prototype.pointInside = function (point) {\r\n        var testx = point.x;\r\n        var testy = point.y;\r\n        // This is an algortihm to handle any number of points for a polygon. In this\r\n        // Case our polygon is simply the points that make this fat edge. Note:\r\n        // The points MUST be in CW order\r\n        var points = [this.tl, this.tr, this.br, this.bl];\r\n        var numberVertices = points.length;\r\n        var isClockwise = false;\r\n        for (var i = 0, j = numberVertices - 1; i < numberVertices; j = i++) {\r\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\r\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\r\n                    (points[j].y - points[i].y) + points[i].x)) {\r\n                isClockwise = !isClockwise;\r\n            }\r\n        }\r\n        return isClockwise;\r\n    };\r\n    /**\r\n     * @override\r\n     * This sets the two endpoints for this edge and recalculates the bounds\r\n     * of the edge accordingly.\r\n     *\r\n     * @param {IPoint} p1 The start point\r\n     * @param {IPoint} p2 The end point\r\n     */\r\n    EdgeShape.prototype.setPoints = function (p1, p2) {\r\n        _super.prototype.setPoints.call(this, p1, p2);\r\n        if (this.tl) {\r\n            // Get the distance from the points we will go based on specified widths\r\n            var p1Dx = this.thickness / 2;\r\n            var p2Dx = this.endWidth / 2;\r\n            // Calculate the deltas to get from point to quad edge\r\n            var p1DeltaX = this.perpendicular.x * p1Dx;\r\n            var p1DeltaY = this.perpendicular.y * p1Dx;\r\n            var p2DeltaX = this.perpendicular.x * p2Dx;\r\n            var p2DeltaY = this.perpendicular.y * p2Dx;\r\n            // Apply the metrics to our quad points\r\n            // Start side of the edge\r\n            this.tl.x = this.p1.x + p1DeltaX;\r\n            this.tl.y = this.p1.y + p1DeltaY;\r\n            this.bl.x = this.p1.x - p1DeltaX;\r\n            this.bl.y = this.p1.y - p1DeltaY;\r\n            // End side of the edge\r\n            this.tr.x = this.p2.x + p2DeltaX;\r\n            this.tr.y = this.p2.y + p2DeltaY;\r\n            this.br.x = this.p2.x - p2DeltaX;\r\n            this.br.y = this.p2.y - p2DeltaY;\r\n            // Create lines for the edges for computations and faster hit detections\r\n            this.topEdge = new line_1.Line(this.tl, this.tr);\r\n            this.bottomEdge = new line_1.Line(this.bl, this.br);\r\n            // Make sure our bounds reflects the entirety of the fat edge\r\n            this.encapsulatePoints([this.tl, this.tr, this.bl, this.br]);\r\n        }\r\n    };\r\n    return EdgeShape;\r\n}(line_shape_1.LineShape));\r\nexports.EdgeShape = EdgeShape;\r\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = __webpack_require__(1);\r\n/**\r\n * Defines an image that can be rendered by the gpu. This is an axis oriented\r\n * image only (no rotations)\r\n */\r\nvar ImageShape = (function (_super) {\r\n    __extends(ImageShape, _super);\r\n    /**\r\n     * Generates a new ImageShape that can be rendered\r\n     *\r\n     * @param {AtlasTexture} image The AtlasTexture to use when rendering this image\r\n     * @param {number} size This is the size of the longest edge of the image while\r\n     *                      retaining aspect ratio.\r\n     */\r\n    function ImageShape(image, size) {\r\n        var _this = _super.call(this, 0, 0, size, size) || this;\r\n        /** This is the level of opacity the image will be rendered with */\r\n        _this.opacity = 1.0;\r\n        _this.texture = image;\r\n        _this.size = size;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ImageShape.prototype, \"size\", {\r\n        /**\r\n         * Returns the largest edge of the image\r\n         */\r\n        get: function () {\r\n            return Math.max(this.width, this.height);\r\n        },\r\n        /**\r\n         * This is the size the image will be rendered within World Space. The size\r\n         * correlates to the largest edge of the image\r\n         */\r\n        set: function (val) {\r\n            if (this.texture.aspectRatio > 1) {\r\n                this.width = val;\r\n                this.height = val / this.texture.aspectRatio;\r\n            }\r\n            else {\r\n                this.width = val * this.texture.aspectRatio;\r\n                this.height = val;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Centers this image on a provided location\r\n     *\r\n     * @param {number} x The x coordinate in world space\r\n     * @param {number} y The y coordinate in world space\r\n     */\r\n    ImageShape.prototype.centerOn = function (x, y) {\r\n        this.x = x - (this.width / 2.0);\r\n        this.y = y - (this.height / 2.0);\r\n    };\r\n    return ImageShape;\r\n}(bounds_1.Bounds));\r\nexports.ImageShape = ImageShape;\r\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = __webpack_require__(1);\r\nvar QuadShape = (function (_super) {\r\n    __extends(QuadShape, _super);\r\n    function QuadShape(bounds, color) {\r\n        var _this = _super.call(this, bounds.x, bounds.right, bounds.y, bounds.bottom) || this;\r\n        _this.r = 1.0;\r\n        _this.g = 0.0;\r\n        _this.b = 0.0;\r\n        _this.a = 1.0;\r\n        return _this;\r\n    }\r\n    return QuadShape;\r\n}(bounds_1.Bounds));\r\nexports.QuadShape = QuadShape;\r\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = __webpack_require__(0);\r\n/**\r\n * Defines a color that is located on an atlas\r\n */\r\nvar AtlasColor = (function () {\r\n    /**\r\n     * Constructor implementation\r\n     */\r\n    function AtlasColor(color, g, b, a) {\r\n        if (a === void 0) { a = 1.0; }\r\n        // Value between 1 - 0 for the opacity of the color\r\n        this.opacity = 1.0;\r\n        // The pixel width and height of the color rendered onto the atlas\r\n        // This will always be a 2x2 so the color can be sampled in the middle\r\n        // For a guaranteed pure color regardless of gl sampling states\r\n        this.pixelWidth = 2;\r\n        this.pixelHeight = 2;\r\n        if (color instanceof three_1.Color) {\r\n            this.color = color.clone();\r\n            this.opacity = g === undefined ? 1.0 : g;\r\n        }\r\n        else {\r\n            this.color = new three_1.Color(color, g, b);\r\n            this.opacity = a;\r\n        }\r\n    }\r\n    return AtlasColor;\r\n}());\r\nexports.AtlasColor = AtlasColor;\r\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(1));\r\n__export(__webpack_require__(17));\r\n__export(__webpack_require__(18));\r\n__export(__webpack_require__(5));\r\n__export(__webpack_require__(9));\r\n__export(__webpack_require__(13));\r\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(3));\r\n__export(__webpack_require__(44));\r\n__export(__webpack_require__(45));\r\n__export(__webpack_require__(11));\r\n__export(__webpack_require__(16));\r\n__export(__webpack_require__(46));\r\n__export(__webpack_require__(19));\r\n__export(__webpack_require__(15));\r\n__export(__webpack_require__(47));\r\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Takes a map of the form <T, boolean> and returns an array of the keys,\r\n * excluding entries who's mapped value is false.\r\n *\r\n * @param map The map to convert to a list\r\n *\r\n * @return T[] A list of the keys, exluding false mappings\r\n */\r\nfunction boolMapToArray(map) {\r\n    return Array\r\n        .from(map)\r\n        .filter(function (item) { return item[1]; })\r\n        .map(function (item) { return item[0]; });\r\n}\r\nexports.boolMapToArray = boolMapToArray;\r\n/**\r\n * Defines a selection control for custom types and categories\r\n */\r\nvar CustomSelection = (function () {\r\n    function CustomSelection() {\r\n        /** This caches the list generation of a selection */\r\n        this.cachedSelection = new Map();\r\n        /** Map of the custom categories to the selection state */\r\n        this.selections = new Map();\r\n        /** Keeps flags indicating if a selection for a given category has changed or not */\r\n        this._didSelectionChange = new Map();\r\n    }\r\n    /**\r\n     * Clears out all custom selections for every category\r\n     */\r\n    CustomSelection.prototype.clearAllSelections = function () {\r\n        for (var _i = 0, _a = Array.from(this.selections.keys()); _i < _a.length; _i++) {\r\n            var key = _a[_i];\r\n            this.clearSelection(key);\r\n        }\r\n    };\r\n    /**\r\n     * Clears the selection for the category specified\r\n     *\r\n     * @param {string} category Name of the category of selection\r\n     */\r\n    CustomSelection.prototype.clearSelection = function (category) {\r\n        // We must have selected items to clear the selection\r\n        if (this.getSelection(category).length) {\r\n            this.selections.set(category, null);\r\n            this.cachedSelection.set(category, null);\r\n            this._didSelectionChange.set(category, true);\r\n        }\r\n    };\r\n    /**\r\n     * Makes an item no longer flaged as selected within the given category\r\n     *\r\n     * @param category The custom category of the selection\r\n     * @param item The item to remove from being selected\r\n     */\r\n    CustomSelection.prototype.deselect = function (category, item) {\r\n        var selectionMap = this.selections.get(category);\r\n        // See if the item is selected already, if it is, clear the selection and bust caches\r\n        if (selectionMap && selectionMap.get(item)) {\r\n            // Clear the cache for the selection list\r\n            this.cachedSelection.set(category, null);\r\n            // Set the selection\r\n            selectionMap.set(item, false);\r\n            // Flag the category of selections as changed\r\n            this._didSelectionChange.set(category, true);\r\n        }\r\n    };\r\n    /**\r\n     * Checks if a selection from a category has been modified\r\n     *\r\n     * @param {string} category The selection category to check\r\n     */\r\n    CustomSelection.prototype.didSelectionCategoryChange = function (category) {\r\n        return this._didSelectionChange.get(category);\r\n    };\r\n    /**\r\n     * Checks if ANY selection has changed\r\n     *\r\n     * @return {boolean} True if any selection has changed\r\n     */\r\n    CustomSelection.prototype.didSelectionChange = function () {\r\n        return boolMapToArray(this._didSelectionChange).length > 0;\r\n    };\r\n    /**\r\n     * This indicates that updates have taken place to account for selection\r\n     * changes.\r\n     */\r\n    CustomSelection.prototype.finalizeUpdate = function () {\r\n        for (var _i = 0, _a = Array.from(this._didSelectionChange.keys()); _i < _a.length; _i++) {\r\n            var key = _a[_i];\r\n            this._didSelectionChange.set(key, false);\r\n        }\r\n    };\r\n    /**\r\n     * This retrieves a list of the items that are selected\r\n     *\r\n     * @param category The selection category to check on\r\n     *\r\n     * @return {T} Returns a list of items that are currently selected\r\n     */\r\n    CustomSelection.prototype.getSelection = function (category) {\r\n        if (!this.cachedSelection.get(category)) {\r\n            var theSelection = this.selections.get(category);\r\n            if (theSelection) {\r\n                this.cachedSelection.set(category, boolMapToArray(theSelection));\r\n            }\r\n            else {\r\n                this.cachedSelection.set(category, []);\r\n            }\r\n        }\r\n        return this.cachedSelection.get(category);\r\n    };\r\n    /**\r\n     * Specifies an item to flag as selected for the given category\r\n     *\r\n     * @param category The custom category of the selection\r\n     * @param item The item to flag as selected\r\n     */\r\n    CustomSelection.prototype.select = function (category, item) {\r\n        var selectionMap = this.selections.get(category);\r\n        if (!selectionMap) {\r\n            selectionMap = new Map();\r\n            this.selections.set(category, selectionMap);\r\n        }\r\n        if (!selectionMap.get(item)) {\r\n            // Clear the cache for the selection list\r\n            this.cachedSelection.set(category, null);\r\n            // Set the selection\r\n            selectionMap.set(item, true);\r\n            // Flag the category of selections as changed\r\n            this._didSelectionChange.set(category, true);\r\n        }\r\n    };\r\n    /**\r\n     * Specifies an item to toggle it's selection status for the provided category\r\n     *\r\n     * @param category The custom category of the selection\r\n     * @param item The item to flag as selected\r\n     */\r\n    CustomSelection.prototype.toggleSelect = function (category, item) {\r\n        var selectionMap = this.selections.get(category);\r\n        if (!selectionMap) {\r\n            selectionMap = new Map();\r\n            this.selections.set(category, selectionMap);\r\n        }\r\n        // Clear the cache for the selection list\r\n        this.cachedSelection.set(category, null);\r\n        // Toggle the selection off if already selected\r\n        if (selectionMap.get(item)) {\r\n            this.deselect(category, item);\r\n        }\r\n        else {\r\n            this.select(category, item);\r\n        }\r\n        // Flag the category of selections as changed\r\n        this._didSelectionChange.set(category, true);\r\n    };\r\n    return CustomSelection;\r\n}());\r\nexports.CustomSelection = CustomSelection;\r\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getFontMetrics(props) {\r\n    var ctx = props.ctx;\r\n    var text = props.text;\r\n    var bboxHeight = props.bboxHeight;\r\n    var canvasHeight = props.ctx.canvas.height;\r\n    var baseline = props.baseline || 'alphabetic';\r\n    var flip = props.flip || false;\r\n    var drawBaseline = props.drawBaseline || false;\r\n    var fontFamily = 'Arial, san-serif';\r\n    var fontSize = 14;\r\n    if (props.fontFamily) {\r\n        fontFamily = props.fontFamily;\r\n    }\r\n    if (props.fontSize) {\r\n        fontSize = props.fontSize;\r\n    }\r\n    // Setting up the canvas\r\n    ctx.save(); // Create canvas to use as buffer\r\n    ctx.font = fontSize + \"px \" + fontFamily;\r\n    var textWidth = ctx.measureText(text).width;\r\n    // This keeps font in-screen, measureText().width doesn't\r\n    // Quite do it in some cases. For instance \"j\", or the letter \"f\"\r\n    // In the font \"Zapfino\".\r\n    var offsetx = fontSize * 2;\r\n    var offsety = fontSize * 2;\r\n    var cwidth = ctx.canvas.width = Math.round(textWidth + offsetx * 2);\r\n    var cheight = ctx.canvas.height = canvasHeight ? canvasHeight : Math.round(offsety * 2);\r\n    if (typeof (baseline) === 'string') {\r\n        offsety = 0; // Using <canvas> baseline\r\n        ctx.textBaseline = baseline;\r\n    }\r\n    // Ctx.font has to be called twice because resetting the size resets the state\r\n    if (flip) {\r\n        ctx.scale(1, -1);\r\n    }\r\n    ctx.font = fontSize + \"px \" + fontFamily;\r\n    ctx.fillText(text, offsetx, (typeof (bboxHeight) === 'number' ? bboxHeight : offsety));\r\n    // Drawing baseline\r\n    if (drawBaseline) {\r\n        ctx.fillRect(0, canvasHeight / 2, ctx.canvas.width, 1);\r\n    }\r\n    // Grabbing image data\r\n    var imageData = ctx.getImageData(0, 0, cwidth, cheight);\r\n    var data = imageData.data;\r\n    // Calculating top\r\n    var top = 0;\r\n    var pos = data.length;\r\n    var bottom = 0;\r\n    var realBottom = 0;\r\n    var left = 0;\r\n    var right = 0;\r\n    while (pos > 0) {\r\n        if (data[pos + 3]) {\r\n            pos -= pos % (cwidth * 4); // Back to beginning of the line top = (pos / 4) / cwidth; // calculate pixel position top -= offsety - fontSize; pos = data.length; // exit loop } pos += 4; } // calculating bottom var bottom = 0; var pos = data.length; while (pos > 0) {\r\n            if (data[pos + 3]) {\r\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\r\n                bottom = (pos / 4) / cwidth;\r\n                bottom -= offsety - fontSize;\r\n                pos = 0; // Exit loop\r\n            }\r\n            pos -= 4;\r\n        }\r\n        // Calculating left\r\n        left = 0;\r\n        var col = 0;\r\n        var row = 0; // Left bounds\r\n        while (row < cheight && col < cwidth) {\r\n            var px = data[(row * cwidth * 4) + (col * 4) + 3];\r\n            if (px) {\r\n                left = col - offsetx;\r\n                row = cheight;\r\n                col = cwidth;\r\n            }\r\n            row++;\r\n            if (row % cheight === 0) {\r\n                row = 0;\r\n                col++;\r\n            }\r\n        }\r\n        // Calculating right\r\n        right = 0;\r\n        col = cwidth;\r\n        row = 0; // Right bounds\r\n        while (row < cheight && col > 0) {\r\n            if (data[(row * cwidth * 4) + (col * 4) + 3]) {\r\n                right = col - offsetx;\r\n                row = cheight;\r\n                col = cwidth;\r\n            }\r\n            row++;\r\n            if (row % cheight === 0) {\r\n                row = 0;\r\n                col--;\r\n            }\r\n        }\r\n        // Calculating real-bottom\r\n        realBottom = 0;\r\n        pos = data.length;\r\n        while (pos > 0) {\r\n            if (data[pos + 3]) {\r\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\r\n                realBottom = (pos / 4) / cwidth;\r\n                pos = 0; // Exit loop\r\n            }\r\n            pos -= 4;\r\n        }\r\n        // Restoring state\r\n        ctx.restore();\r\n    }\r\n    // Returning raw-metrics\r\n    return {\r\n        bottom: realBottom,\r\n        height: (bottom - top),\r\n        left: (-left),\r\n        top: (fontSize - top),\r\n        width: (right - left),\r\n    };\r\n}\r\nexports.getFontMetrics = getFontMetrics;\r\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This defines an object that helps facilitate parts of or complete shape buffers that\r\n * need regenerating.\r\n */\r\nvar ShapeBufferCache = (function () {\r\n    function ShapeBufferCache() {\r\n        this.buffer = [];\r\n        this.bustCache = true;\r\n    }\r\n    /**\r\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\r\n     * it will not regenerate\r\n     */\r\n    ShapeBufferCache.prototype.generate = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this.bustCache) {\r\n            this.buildCache.apply(this, args);\r\n            this.bustCache = false;\r\n        }\r\n    };\r\n    /**\r\n     * Sub classes will implement this stub to perform what is necessary to produce\r\n     * a newly updated version of their cache.\r\n     */\r\n    ShapeBufferCache.prototype.buildCache = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        // Implemented by sub classes\r\n    };\r\n    /**\r\n     * Get the buffer the cache has generated\r\n     */\r\n    ShapeBufferCache.prototype.getBuffer = function () {\r\n        return this.buffer;\r\n    };\r\n    return ShapeBufferCache;\r\n}());\r\nexports.ShapeBufferCache = ShapeBufferCache;\r\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This gets an integer time value that can fit within an attribute. Be aware,\r\n * this only supports up to 7 digits of the millisecond time.\r\n */\r\nfunction getAttributeCurrentTime() {\r\n    var time = Date.now() / 1E7;\r\n    return Math.floor((time - Math.floor(time)) * 1E7);\r\n}\r\nexports.getAttributeCurrentTime = getAttributeCurrentTime;\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 57397711a2cfc6486dbf","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"three\"\n// module id = 0\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Class to manage the x, y, width, and height of an object\r\n *\r\n * @template T This specifies the data type associated with this shape and is accessible\r\n *             via the property 'd'\r\n */\r\nvar Bounds = (function () {\r\n    /**\r\n     * Create a new instance\r\n     *\r\n     * @param left  The left side (x coordinate) of the instance\r\n     * @param right The right side of the instance\r\n     * @param top The top (y coordinate) of the instance\r\n     * @param bottom The bottom of the instance\r\n     */\r\n    function Bounds(left, right, top, bottom) {\r\n        this.height = 0;\r\n        this.width = 0;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        if (arguments.length === 4) {\r\n            this.x = left;\r\n            this.width = right - left;\r\n            this.y = top;\r\n            this.height = top - bottom;\r\n        }\r\n    }\r\n    Object.defineProperty(Bounds.prototype, \"area\", {\r\n        /** The total rectangular surface area of this instance */\r\n        get: function () {\r\n            return this.width * this.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bounds.prototype, \"bottom\", {\r\n        /** The bottom coordinate for this instance (y + height) */\r\n        get: function () {\r\n            return this.y - this.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bounds.prototype, \"mid\", {\r\n        /** An x, y coordinate pair representing the center of this object */\r\n        get: function () {\r\n            return {\r\n                x: this.x + (this.width / 2),\r\n                y: this.y - (this.height / 2),\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bounds.prototype, \"right\", {\r\n        get: function () {\r\n            return this.x + this.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Check to see if a given point lies within the bounds of this instance\r\n     *\r\n     * @param point The point to check\r\n     */\r\n    Bounds.prototype.containsPoint = function (point) {\r\n        if (point.x < this.x) {\r\n            return false;\r\n        }\r\n        if (point.y > this.y) {\r\n            return false;\r\n        }\r\n        if (point.x > this.right) {\r\n            return false;\r\n        }\r\n        if (point.y < this.bottom) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Copies the properties of the bounds specified\r\n     *\r\n     * @param b The bounds whose dimensions we wish to copy\r\n     */\r\n    Bounds.prototype.copyBounds = function (b) {\r\n        this.height = b.height;\r\n        this.width = b.width;\r\n        this.x = b.x;\r\n        this.y = b.y;\r\n    };\r\n    /**\r\n     * Ensure that this object contains the smaller bounds\r\n     *\r\n     * This method will not shrink this class, but only grow it as necessary to\r\n     * fit the destination object\r\n     *\r\n     * @param bounds The bounds to encapsulate\r\n     */\r\n    Bounds.prototype.encapsulate = function (bounds) {\r\n        if (bounds.x < this.x) {\r\n            this.width += this.x - bounds.x;\r\n            this.x = bounds.x;\r\n        }\r\n        if (bounds.y > this.y) {\r\n            this.height += bounds.y - this.y;\r\n            this.y = bounds.y;\r\n        }\r\n        if (bounds.right > this.right) {\r\n            this.width = bounds.right - this.x;\r\n        }\r\n        if (bounds.bottom < this.bottom) {\r\n            this.height = this.y - bounds.bottom;\r\n        }\r\n    };\r\n    /**\r\n     * Ensure that this object contains the provided list of bounds\r\n     *\r\n     * This will never shrink or modify the original area covered by this bounds\r\n     * but will instead stay the same or include the original area plus the specified\r\n     * list of bounds.\r\n     *\r\n     * @param {Bounds<any>[]} bounds The list of bounds objects to encapsulate\r\n     * @param {boolean} sizeToFirst If this is set, the procedure will start by making this bounds\r\n     *                              be a clone of the first bounds object in the list\r\n     */\r\n    Bounds.prototype.encapsulateBounds = function (bounds, sizeToFirst) {\r\n        if (sizeToFirst && bounds.length) {\r\n            this.copyBounds(bounds[0]);\r\n        }\r\n        if (bounds.length === 0) {\r\n            return;\r\n        }\r\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\r\n        bounds.forEach(function (p) {\r\n            if (p.x < minX) {\r\n                minX = p.x;\r\n            }\r\n            if (p.right > maxX) {\r\n                maxX = p.right;\r\n            }\r\n            if (p.bottom < minY) {\r\n                minY = p.bottom;\r\n            }\r\n            if (p.y > maxY) {\r\n                maxY = p.y;\r\n            }\r\n        });\r\n        // Make bounds that encompasses the bounds list, then we encapsulate\r\n        // Those bounds\r\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\r\n    };\r\n    /**\r\n     * Grow this class to contain the specified point\r\n     *\r\n     * This method will not shrink this instance. It will only grow it as\r\n     * necessary.\r\n     *\r\n     * @param point The point to encapsulate\r\n     */\r\n    Bounds.prototype.encapsulatePoint = function (point) {\r\n        if (point.x < this.x) {\r\n            this.width += this.x - point.x;\r\n            this.x = point.x;\r\n        }\r\n        if (point.y > this.y) {\r\n            this.height += point.y - this.y;\r\n            this.y = point.y;\r\n        }\r\n        if (point.x > this.right) {\r\n            this.width = point.x - this.x;\r\n        }\r\n        if (point.y < this.bottom) {\r\n            this.height = this.y - point.y;\r\n        }\r\n    };\r\n    /**\r\n     * Efficiently encapsulates a set of points by growing the current dimensions\r\n     * of the bounds until the points are enclosed. This will perform faster than\r\n     * running encapsulatePoint for a list of points.\r\n     *\r\n     * @param points An array of points that Can be of format {x, y} or [x, y]\r\n     *\r\n     * @memberOf Bounds\r\n     */\r\n    Bounds.prototype.encapsulatePoints = function (points) {\r\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\r\n        if (points[0] !== undefined && points[0].x) {\r\n            points.forEach(function (p) {\r\n                if (p.x < minX) {\r\n                    minX = p.x;\r\n                }\r\n                else if (p.x > maxX) {\r\n                    maxX = p.x;\r\n                }\r\n                if (p.y < minY) {\r\n                    minY = p.y;\r\n                }\r\n                else if (p.y > maxY) {\r\n                    maxY = p.y;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            points.forEach(function (p) {\r\n                if (p[0] < minX) {\r\n                    minX = p[0];\r\n                }\r\n                else if (p[0] > maxX) {\r\n                    maxX = p[0];\r\n                }\r\n                if (p[1] < minY) {\r\n                    minY = p[1];\r\n                }\r\n                else if (p[1] > maxY) {\r\n                    maxY = p[1];\r\n                }\r\n            });\r\n        }\r\n        // Make bounds that encompasses the points, then we encapsulate\r\n        // Those bounds\r\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\r\n    };\r\n    /**\r\n     * Checks to see if another bounds fits in itself.\r\n     *\r\n     * @param {Bounds} inner The bounds to test against\r\n     *\r\n     * @return {number} int 1 is an exact fit, 2 it fits with space, 0 it doesn't fit\r\n     */\r\n    Bounds.prototype.fits = function (inner) {\r\n        if (this.width === inner.width) {\r\n            if (this.height === inner.height) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (this.width >= inner.width) {\r\n            if (this.height >= inner.height) {\r\n                return 2;\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    /**\r\n     * Check to see if the provided bounds intersects with this instance\r\n     *\r\n     * @param bounds The bounds to test against this instance\r\n     *\r\n     * @return True if the other object intersects with this instance\r\n     */\r\n    Bounds.prototype.hitBounds = function (bounds) {\r\n        if (bounds.right < this.x) {\r\n            return false;\r\n        }\r\n        if (bounds.x > this.right) {\r\n            return false;\r\n        }\r\n        if (bounds.bottom > this.y) {\r\n            return false;\r\n        }\r\n        if (bounds.y < this.bottom) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Tests if a point is inside this bounds\r\n     *\r\n     * @param p The point to test\r\n     *\r\n     * @return boolean The point to test\r\n     */\r\n    Bounds.prototype.pointInside = function (p) {\r\n        if (p.x < this.x) {\r\n            return false;\r\n        }\r\n        if (p.y > this.y) {\r\n            return false;\r\n        }\r\n        if (p.x > this.right) {\r\n            return false;\r\n        }\r\n        if (p.y < this.bottom) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Test function to type check the provided value\r\n     *\r\n     * @return True if value is a bounds object\r\n     */\r\n    Bounds.isBounds = function (value) {\r\n        // Falsy values aren't bounds objects\r\n        if (!value) {\r\n            return false;\r\n        }\r\n        // Direct test for bounds objects\r\n        if (value instanceof this) {\r\n            return true;\r\n        }\r\n        // Duck-typing check\r\n        return value &&\r\n            'containsPoint' in value &&\r\n            'encapsulate' in value &&\r\n            'hitTest' in value;\r\n    };\r\n    /**\r\n     * Check if this instance is completely inside the provided bounds\r\n     *\r\n     * @param bounds The bounds to test against this instance\r\n     *\r\n     * @return True if this instance is inside the provided bounds\r\n     */\r\n    Bounds.prototype.isInside = function (bounds) {\r\n        return (bounds.x <= this.x &&\r\n            bounds.right >= this.right &&\r\n            bounds.y >= this.y &&\r\n            bounds.bottom <= this.bottom);\r\n    };\r\n    /**\r\n     * Generates a Bounds object covering max extents\r\n     *\r\n     * @return {Bounds} bounds covering as wide of a range as possible\r\n     */\r\n    Bounds.maxBounds = function () {\r\n        return new Bounds(Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE);\r\n    };\r\n    return Bounds;\r\n}());\r\nexports.Bounds = Bounds;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/bounds.ts\n// module id = 1\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (window && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/browser.js\n// module id = 2\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\nvar debug = require('debug')('WebGLSurface:BufferUtil');\r\nvar AttributeSize;\r\n(function (AttributeSize) {\r\n    AttributeSize[AttributeSize[\"ONE\"] = 0] = \"ONE\";\r\n    AttributeSize[AttributeSize[\"TWO\"] = 1] = \"TWO\";\r\n    AttributeSize[AttributeSize[\"THREE\"] = 2] = \"THREE\";\r\n    AttributeSize[AttributeSize[\"FOUR\"] = 3] = \"FOUR\";\r\n})(AttributeSize = exports.AttributeSize || (exports.AttributeSize = {}));\r\n/**\r\n * These are for fast look ups of the default values provided\r\n * Doing this fashion avoids array look ups in the defaults values\r\n */\r\nvar defaultsHolder0 = 0;\r\nvar defaultsHolder1 = 0;\r\nvar defaultsHolder2 = 0;\r\nvar defaultsHolder3 = 0;\r\n/**\r\n * These are for fast look ups of attribute buffers that are going\r\n * through the update process. We do everything to mitigate array look ups\r\n * when and where we can\r\n */\r\nvar attrRegister0 = [];\r\nvar attrRegister1 = [];\r\nvar attrRegister2 = [];\r\nvar attrRegister3 = [];\r\nvar attrRegister4 = [];\r\nvar attrRegister5 = [];\r\nvar attrRegister6 = [];\r\nvar attrIndex0 = 0;\r\nvar attrIndex1 = 0;\r\nvar attrIndex2 = 0;\r\nvar attrIndex3 = 0;\r\nvar attrIndex4 = 0;\r\nvar attrIndex5 = 0;\r\nvar attrIndex6 = 0;\r\nvar attrIndexIncr0 = 0;\r\nvar attrIndexIncr1 = 0;\r\nvar attrIndexIncr2 = 0;\r\nvar attrIndexIncr3 = 0;\r\nvar attrIndexIncr4 = 0;\r\nvar attrIndexIncr5 = 0;\r\nvar attrIndexIncr6 = 0;\r\n/** This is used to define a starting batch location to aid in continuing batch updates */\r\nvar lastBatchRegister = 0;\r\nvar isStreamUpdatingRegister = false;\r\n/**\r\n * This takes our list of attribute buffers and applies them to the registers for rapid lookups\r\n *\r\n * @param {number[][]} attributeBuffers The buffers for each attribute to be updated\r\n * @param {number[]} incrementValues How much each batch increments it's lookup index\r\n */\r\nfunction applyAttributeRegisters(attributeBuffers, incrementValues) {\r\n    attrRegister0 = attributeBuffers[0];\r\n    attrRegister1 = attributeBuffers[1];\r\n    attrRegister2 = attributeBuffers[2];\r\n    attrRegister3 = attributeBuffers[3];\r\n    attrRegister4 = attributeBuffers[4];\r\n    attrRegister5 = attributeBuffers[5];\r\n    attrRegister6 = attributeBuffers[6];\r\n    attrIndexIncr0 = incrementValues[0];\r\n    attrIndexIncr1 = incrementValues[1];\r\n    attrIndexIncr2 = incrementValues[2];\r\n    attrIndexIncr3 = incrementValues[3];\r\n    attrIndexIncr4 = incrementValues[4];\r\n    attrIndexIncr5 = incrementValues[5];\r\n    attrIndexIncr6 = incrementValues[6];\r\n}\r\n/**\r\n * The following methods are targetted at executing the update accessor with varying number\r\n * of parameters while mitigating array look ups.\r\n *\r\n * @param {number} numBatches The number of batches to execute\r\n * @param {Function} updateAccessor The accessor function that will update the buffer values\r\n */\r\nfunction updateBuffer1(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0);\r\n    }\r\n}\r\nfunction updateBuffer2(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1);\r\n    }\r\n}\r\nfunction updateBuffer3(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2);\r\n    }\r\n}\r\nfunction updateBuffer4(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3);\r\n    }\r\n}\r\nfunction updateBuffer5(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        attrIndex4 = i * attrIndexIncr4;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4);\r\n    }\r\n}\r\nfunction updateBuffer6(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        attrIndex4 = i * attrIndexIncr4;\r\n        attrIndex5 = i * attrIndexIncr5;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5);\r\n    }\r\n}\r\nfunction updateBuffer7(numBatches, updateAccessor) {\r\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\r\n        attrIndex0 = i * attrIndexIncr0;\r\n        attrIndex1 = i * attrIndexIncr1;\r\n        attrIndex2 = i * attrIndexIncr2;\r\n        attrIndex3 = i * attrIndexIncr3;\r\n        attrIndex4 = i * attrIndexIncr4;\r\n        attrIndex5 = i * attrIndexIncr5;\r\n        attrIndex6 = i * attrIndexIncr6;\r\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6);\r\n    }\r\n}\r\n/**\r\n * This takes the defaults array provided and loads them into our default\r\n * lookup values\r\n *\r\n * @param {number[]} defaults The array with the default values in them for our buffer attribute\r\n */\r\nfunction applyDefaultsHolders(defaults) {\r\n    defaultsHolder0 = defaults[0] || 0;\r\n    defaultsHolder1 = defaults[1] || 0;\r\n    defaultsHolder2 = defaults[2] || 0;\r\n    defaultsHolder3 = defaults[3] || 0;\r\n}\r\n/**\r\n * The following methods are rapid ways of populating the buffer without\r\n * setting up a generic loop. This saves on performance by not creating a loop\r\n * nor allocating the variables necessary for the generic loop.\r\n *\r\n * @param {Float32Array} buffer The buffer to populate\r\n * @param {number} start The index the data should be populated into\r\n */\r\nfunction fillSize1(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n}\r\nfunction fillSize2(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n    buffer[++start] = defaultsHolder1;\r\n}\r\nfunction fillSize3(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n    buffer[++start] = defaultsHolder1;\r\n    buffer[++start] = defaultsHolder2;\r\n}\r\nfunction fillSize4(buffer, start) {\r\n    buffer[start] = defaultsHolder0;\r\n    buffer[++start] = defaultsHolder1;\r\n    buffer[++start] = defaultsHolder2;\r\n    buffer[++start] = defaultsHolder3;\r\n}\r\n/**\r\n * This is a quick lookup to find the correct filler method for the given attribute size\r\n */\r\nvar fillMethodLookUp = (_a = {},\r\n    _a[AttributeSize.ONE] = fillSize1,\r\n    _a[AttributeSize.TWO] = fillSize2,\r\n    _a[AttributeSize.THREE] = fillSize3,\r\n    _a[AttributeSize.FOUR] = fillSize4,\r\n    _a);\r\nvar updateBufferLookUp = {\r\n    1: updateBuffer1,\r\n    2: updateBuffer2,\r\n    3: updateBuffer3,\r\n    4: updateBuffer4,\r\n    5: updateBuffer5,\r\n    6: updateBuffer6,\r\n    7: updateBuffer7,\r\n};\r\n/**\r\n * This provides methods for handling common buffer tasks such as construction\r\n * and population.\r\n */\r\nvar BufferUtil = (function () {\r\n    function BufferUtil() {\r\n    }\r\n    /**\r\n     * This places our updateBuffer into a mode where the updates start at index 0 of the\r\n     * buffer. Subsequent calls will start where the previous call left off. This lets\r\n     * you stream in updates to the buffer rather than just update the entire buffer\r\n     * all at once.\r\n     */\r\n    BufferUtil.beginUpdates = function () {\r\n        isStreamUpdatingRegister = true;\r\n        lastBatchRegister = 0;\r\n    };\r\n    /**\r\n     * This stops updates streaming into the buffers and makes it where an update\r\n     * will always just start at the beginning of the buffer.\r\n     */\r\n    BufferUtil.endUpdates = function () {\r\n        var totalBatches = lastBatchRegister;\r\n        isStreamUpdatingRegister = false;\r\n        lastBatchRegister = 0;\r\n        return totalBatches;\r\n    };\r\n    /**\r\n     * @static\r\n     * This handles many of the common tasks associated with constructing a new buffer\r\n     * such as applying the name, generating the buffer, and populating default values to\r\n     * that buffer.\r\n     *\r\n     * @param {number} numVertices The number of vertices this buffer will have\r\n     * @param {IAttributeInfo[]} attributes A description of each attribute in the buffer\r\n     *\r\n     * @returns {BufferGeometry} The newly made buffer\r\n     */\r\n    BufferUtil.makeBuffer = function (numVertices, attributes) {\r\n        var iMax = attributes.length;\r\n        var geometry = new three_1.BufferGeometry();\r\n        for (var i = 0; i < iMax; ++i) {\r\n            var attribute = attributes[i];\r\n            var attributeSize = attribute.size + 1;\r\n            var buffer = new Float32Array(attributeSize * numVertices);\r\n            var fillMethod = fillMethodLookUp[attribute.size];\r\n            var name_1 = attribute.name;\r\n            // We set up our default value registers before executing the fill method\r\n            applyDefaultsHolders(attribute.defaults);\r\n            // Fill our buffer with the indicated default values\r\n            for (var k = 0; k < numVertices; ++k) {\r\n                fillMethod(buffer, k * attributeSize);\r\n            }\r\n            // Apply the buffer to our geometry buffer\r\n            geometry.addAttribute(name_1, new three_1.BufferAttribute(buffer, attributeSize));\r\n            debug('Made Buffer Attribute:', name_1, attributeSize);\r\n        }\r\n        return geometry;\r\n    };\r\n    /**\r\n     * @static\r\n     * This handles many of the common tasks associated with updating a buffer. You specify how many vertices\r\n     * to update in a batch and you specify how many batches are present.\r\n     *\r\n     * Batches are used to represent your full shape object that is being loaded from the cpu:\r\n     *\r\n     * IE- you have a rectangle object you wish to update in your buffer. This takes around 6 vertices typically\r\n     * so you make your vertexBatch 6 and the numBatches the number of quads you need to update in the buffer.\r\n     *\r\n     * You then provide an accessor which aids in pointing to the buffer items that need updating. The accessor has\r\n     * variable arguments depending on the attributes you inject in.\r\n     *\r\n     * If you have attributes like:\r\n     * [\r\n     *  {name: position, size: AttributeSize.Three},\r\n     *  {name: color, size: AttributeSize.Four},\r\n     * ]\r\n     *\r\n     * Then your accessor will be delievered arguments in this form:\r\n     *\r\n     * function(batchIndex: number, positionBuffer: number[], positionIndex: number, colorBuffer: number[], colorIndex: number)\r\n     *\r\n     * NOTE: The params handed in ARE ORDERED BY the attributes injected in\r\n     *\r\n     * You then can update the buffers based on the index information handed alongside each buffer\r\n     *\r\n     * @param {T[]} newData The new data that is going to be injected into the buffer. This must be a NEW REFERENCE of data\r\n     *                      that does NOT match the reference in the bufferItems.currentData. So newData !== bufferItems.currentData\r\n     *                      in order for the update to occur.\r\n     * @param {BufferGeometry} bufferItems The buffer related items used to identify how to update the buffer\r\n     * @param {number} vertexBatch The number of vertices to include per update batch\r\n     * @param {number} numBatches The number of batches to execute\r\n     * @param {Function} updateAccessor The accessor for performing the data update to the buffer\r\n     *\r\n     * @return {boolean} True if the buffer was updated with this call\r\n     */\r\n    BufferUtil.updateBuffer = function (newData, bufferItems, vertexBatch, numBatches, updateAccessor) {\r\n        var attributes = bufferItems.attributes;\r\n        var buffer = bufferItems.geometry;\r\n        // If we passed the data check on the first pass, then all future streamed updates\r\n        // Should pass as well\r\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\r\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\r\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed) {\r\n            // If we aren't streaming updates, then we always start at the beginning\r\n            if (!isStreamUpdatingRegister) {\r\n                // Reset out last batch register as this is an entriely new update\r\n                lastBatchRegister = 0;\r\n            }\r\n            // Flag the newly rendered data as our current data\r\n            bufferItems.currentData = newData;\r\n            // Get the attributes by name out of the three js buffer\r\n            var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\r\n            // Get the raw number buffers\r\n            var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\r\n            // Determine what kind of buffer pointer increments we will need\r\n            var incrementValues = attributes.map(function (attr) { return (attr.size + 1) * vertexBatch; });\r\n            // Apply all data needed to any registers we need\r\n            applyAttributeRegisters(attributeBuffers, incrementValues);\r\n            // Get the method that will perform the update based on number of attributes\r\n            var updateMethod = updateBufferLookUp[attributes.length];\r\n            // Execute the update method\r\n            updateMethod(numBatches + lastBatchRegister, updateAccessor);\r\n            // Flag each buffer attribute for needing an update\r\n            bufferAttributes.forEach(function (attr) { return attr.needsUpdate = true; });\r\n            // Move our register forward in case we are in a stream update\r\n            lastBatchRegister += numBatches;\r\n            return true;\r\n        }\r\n        else {\r\n            // Move our register forward in case we are in a stream update\r\n            lastBatchRegister += numBatches;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * This makes all of the typical items used in creating and managing a buffer of items rendered to the screen\r\n     *\r\n     * @returns {IBufferItems<T>} An empty object of the particular buffer items needed\r\n     */\r\n    BufferUtil.makeBufferItems = function () {\r\n        return {\r\n            attributes: [],\r\n            currentData: [],\r\n            geometry: null,\r\n            system: null,\r\n        };\r\n    };\r\n    return BufferUtil;\r\n}());\r\nexports.BufferUtil = BufferUtil;\r\nvar _a;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/buffer-util.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This deinfes the minimal set of methods that should be implemented to create\r\n * a reusable buffer object that can be initialized and populated.\r\n */\r\nvar BaseBuffer = (function () {\r\n    function BaseBuffer() {\r\n    }\r\n    /**\r\n     * This initializes the buffer and generates the buffer items object.\r\n     */\r\n    BaseBuffer.prototype.init = function (material, unitCount) {\r\n        // To be implemented by a subclass\r\n    };\r\n    /**\r\n     * This updates the buffer by providing the shape buffer needed to update\r\n     * the internal buffer items\r\n     *\r\n     * @param {T[]} shapeBuffer The shape buffer containing all of the shape data\r\n     *                          to be placed into the buffer.\r\n     *\r\n     * @return {boolean} Retrusn true if this pushed up any updates\r\n     */\r\n    BaseBuffer.prototype.update = function (shapeBuffer) {\r\n        // To be implemented by a subclass\r\n        return false;\r\n    };\r\n    return BaseBuffer;\r\n}());\r\nexports.BaseBuffer = BaseBuffer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/base-buffer.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = require(\"./bounds\");\r\n/**\r\n * Represents a line with a given slope\r\n */\r\nvar Line = (function (_super) {\r\n    __extends(Line, _super);\r\n    /**\r\n     * Creates a new line that passes through the two specified points\r\n     *\r\n     * @param {IPoint} p1 The start point\r\n     * @param {IPoint} p2 The end point\r\n     */\r\n    function Line(p1, p2) {\r\n        var _this = _super.call(this, 0, 1, 1, 0) || this;\r\n        _this.setPoints(p1, p2);\r\n        return _this;\r\n    }\r\n    /**\r\n     * This calculates the distance to a point from the provided line\r\n     * BUT this ALSO retains the directionality of that distance. So one side of\r\n     * the line will be positive while the other negative\r\n     *\r\n     * @param {IPoint} p The Point to see how far from the line we are\r\n     *\r\n     * @return {number} The calculated distance to the provided point\r\n     */\r\n    Line.prototype.directionTo = function (p) {\r\n        // Make a vector from a line point to the indicated point\r\n        var vector = {\r\n            x: this.p1.x - p.x,\r\n            y: this.p1.y - p.y,\r\n        };\r\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\r\n        // Line, but we won't take the absolute to retain the direction\r\n        return this.perpendicular.x * vector.x + this.perpendicular.y * vector.y;\r\n    };\r\n    /**\r\n     * This calculates the distance to a point from the provided line\r\n     *\r\n     * @param {IPoint} p The Point to see how far from the line we are\r\n     *\r\n     * @return {number} The calculated distance to the provided point\r\n     */\r\n    Line.prototype.distanceTo = function (p) {\r\n        // Make a vector from a line point to the indicated point\r\n        var vector = {\r\n            x: this.p1.x - p.x,\r\n            y: this.p1.y - p.y,\r\n        };\r\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\r\n        // Line\r\n        return Math.abs(this.perpendicular.x * vector.x +\r\n            this.perpendicular.y * vector.y);\r\n    };\r\n    /**\r\n     * Picks the closest line in the list to a given point\r\n     *\r\n     * @param {Array} lines The lines to compare\r\n     * @param {IPoint} p The point to compare against\r\n     *\r\n     * @return {Line} The nearest line to the point\r\n     */\r\n    Line.getClosest = function (lines, p) {\r\n        var closestLine;\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var distance = 0;\r\n        lines.forEach(function (line) {\r\n            distance = line.distanceTo(p);\r\n            if (distance < closestDistance) {\r\n                closestLine = line;\r\n                closestDistance = distance;\r\n            }\r\n        });\r\n        return closestLine;\r\n    };\r\n    /**\r\n     * This sets the two endpoints for this line and recalculates the bounds\r\n     * of the line accordingly\r\n     *\r\n     * @param {IPoint} p1 The start point\r\n     * @param {IPoint} p2 The end point\r\n     */\r\n    Line.prototype.setPoints = function (p1, p2) {\r\n        this.x = p1.x - 1;\r\n        this.y = p1.y - 1;\r\n        this.width = 2;\r\n        this.height = 2;\r\n        this.encapsulatePoint(p2);\r\n        var dx = p2.x - p1.x;\r\n        var dy = p2.y - p1.y;\r\n        this.slope = dy / dx;\r\n        this.p1 = p1;\r\n        this.p2 = p2;\r\n        this.magnitude = Math.sqrt(dx * dx + dy * dy);\r\n        this.perpendicular = {\r\n            x: this.p2.y - this.p1.y,\r\n            y: -(this.p2.x - this.p1.x),\r\n        };\r\n        // Normalize the perpendicular line\r\n        var mag = Math.sqrt(this.perpendicular.x * this.perpendicular.x +\r\n            this.perpendicular.y * this.perpendicular.y);\r\n        this.perpendicular.x /= mag;\r\n        this.perpendicular.y /= mag;\r\n    };\r\n    return Line;\r\n}(bounds_1.Bounds));\r\nexports.Line = Line;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/line.ts\n// module id = 5\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ramda\"\n// module id = 6\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3-color\"\n// module id = 7\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Defines a texture that is located on an atlas\r\n */\r\nvar AtlasTexture = (function () {\r\n    /**\r\n     * Generates a new atlas texture that points to a specific image resource.\r\n     *\r\n     * @param path The path to the image resource to be loaded into the atlas.\r\n     */\r\n    function AtlasTexture(path, label) {\r\n        /** Stores the aspect ratio of the image for quick reference */\r\n        this.aspectRatio = 1.0;\r\n        this.imagePath = path;\r\n        this.label = label;\r\n        // Let the label keep track of it's rasterization\r\n        if (label) {\r\n            this.label.rasterizedLabel = this;\r\n        }\r\n    }\r\n    return AtlasTexture;\r\n}());\r\nexports.AtlasTexture = AtlasTexture;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-texture.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates the distance between two points, but keeps the distance in dquared form\r\n * thus performing Math.sqrt() on the output of this distance would provide the true\r\n * distance between the points.\r\n *\r\n * It is often faster and all that is needed to compare squared distances vs real distances\r\n * thus eliminating multiple Math.sqrt operations\r\n *\r\n * NOTE: For vectors this is the same as (pseudo code):\r\n * let vector3 = vector2.subtract(vector1)\r\n * return vector3.dot(vector3)\r\n *\r\n * @param p1 The point to find the distance from the second point\r\n * @param p2 The point to find the distance from the first point\r\n *\r\n * @return {number} The distance * distance between the two points\r\n */\r\nfunction squareDistance(p1, p2) {\r\n    var dx = p1.x - p2.x;\r\n    var dy = p1.y - p2.y;\r\n    return dx * dx + dy * dy;\r\n}\r\n/**\r\n * Contains methods for managing or manipulating points\r\n *\r\n * @export\r\n * @class Point\r\n */\r\nvar Point = (function () {\r\n    function Point() {\r\n    }\r\n    /**\r\n     * Adds two points together\r\n     *\r\n     * @static\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\r\n     *\r\n     * @return {IPoint} The two points added together\r\n     */\r\n    Point.add = function (p1, p2, out) {\r\n        if (out) {\r\n            out.x = p1.x + p2.x;\r\n            out.y = p1.y + p2.y;\r\n            return out;\r\n        }\r\n        return {\r\n            x: p1.x + p2.x,\r\n            y: p1.y + p2.y,\r\n        };\r\n    };\r\n    /**\r\n     * @static\r\n     * This analyzes a test point against a list of points and determines which of the points is\r\n     * the closest to the test point. If there are equi-distant points in the list, this will return\r\n     * the first found in the list.\r\n     *\r\n     * @param {IPoint} testPoint The point to compare against other points\r\n     * @param {IPoint[]} points The list of points to be compared against\r\n     *\r\n     * @return {IPoint} The closest point to the test point\r\n     */\r\n    Point.getClosest = function (testPoint, points) {\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var closestPoint = null;\r\n        var distance;\r\n        var findClosest = function (point) {\r\n            distance = squareDistance(point, testPoint);\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestPoint = point;\r\n            }\r\n        };\r\n        points.forEach(findClosest);\r\n        return closestPoint;\r\n    };\r\n    /**\r\n     * @static\r\n     * This analyzes a test point against a list of points and determines which of the points is\r\n     * the closest to the test point. If there are equi-distant points in the list, this will return\r\n     * the first found in the list.\r\n     *\r\n     * This just returns the index of the found point and not the point itself\r\n     *\r\n     * @param {IPoint} testPoint The point to compare against other points\r\n     * @param {IPoint[]} points The list of points to be compared against\r\n     *\r\n     * @return {number} The index of the closest point to the test point\r\n     */\r\n    Point.getClosestIndex = function (testPoint, points) {\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var closestPoint = 0;\r\n        var distance;\r\n        var findClosest = function (point, i) {\r\n            distance = squareDistance(point, testPoint);\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestPoint = i;\r\n            }\r\n        };\r\n        points.forEach(findClosest);\r\n        return closestPoint;\r\n    };\r\n    /**\r\n     * @static\r\n     * This will calculate a direction vector between two points that points toward p2\r\n     *\r\n     * @param {IPoint} p1 The start of the direction\r\n     * @param {IPoint} p2 The direction to point the vector towards\r\n     * @param {boolean} normalize If true, this will make the vector have a magnitude of 1\r\n     *\r\n     * @returns {number}\r\n     */\r\n    Point.getDirection = function (p1, p2, normalize) {\r\n        if (normalize === void 0) { normalize = false; }\r\n        var dx = p2.x - p1.x;\r\n        var dy = p2.y - p1.y;\r\n        if (normalize) {\r\n            var magnitude = Math.sqrt(dx * dx + dy * dy);\r\n            dx /= magnitude;\r\n            dy /= magnitude;\r\n        }\r\n        return {\r\n            x: dx,\r\n            y: dy,\r\n        };\r\n    };\r\n    /**\r\n     * @static\r\n     * Gets the distance between two points\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {boolean} squared If set to true, returns the distance * distance (performs faster)\r\n     *\r\n     * @returns {number} The real distance between two points\r\n     */\r\n    Point.getDistance = function (p1, p2, squared) {\r\n        if (squared === void 0) { squared = false; }\r\n        if (squared) {\r\n            return squareDistance(p1, p2);\r\n        }\r\n        return Math.sqrt(squareDistance(p1, p2));\r\n    };\r\n    /**\r\n     * @static\r\n     * Gets a point perfectly between two points\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     *\r\n     * @returns {IPoint} The point between the two provided points\r\n     */\r\n    Point.getMidpoint = function (p1, p2) {\r\n        var direction = Point.getDirection(p1, p2);\r\n        return {\r\n            x: direction.x / 2 + p1.x,\r\n            y: direction.y / 2 + p1.y,\r\n        };\r\n    };\r\n    Point.make = function (x, y) {\r\n        return { x: x, y: y };\r\n    };\r\n    /**\r\n     * Scales a point by a given amount\r\n     *\r\n     * @static\r\n     * @param {IPoint} p1\r\n     * @param {number} s The amount to scale the point by\r\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\r\n     *\r\n     * @memberof Point\r\n     */\r\n    Point.scale = function (p1, s, out) {\r\n        if (out) {\r\n            out.x = p1.x * s;\r\n            out.y = p1.y * s;\r\n            return out;\r\n        }\r\n        return {\r\n            x: p1.x * s,\r\n            y: p1.y * s,\r\n        };\r\n    };\r\n    /**\r\n     * Makes a new point initialized to {0,0}\r\n     *\r\n     * @static\r\n     * @returns {IPoint} A new point object at {0,0}\r\n     */\r\n    Point.zero = function () {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n    };\r\n    return Point;\r\n}());\r\nexports.Point = Point;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/point.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar d3_color_1 = require(\"d3-color\");\r\nvar three_1 = require(\"three\");\r\nvar bounds_1 = require(\"../../primitives/bounds\");\r\nvar pack_node_1 = require(\"../../util/pack-node\");\r\nvar label_1 = require(\"../shape/label\");\r\nvar atlas_texture_1 = require(\"./atlas-texture\");\r\nvar debug = require('debug')('webgl-surface:Atlas');\r\nvar debugLabels = require('debug')('webgl-surface:Labels');\r\nvar ZERO_IMAGE = {\r\n    atlasBL: { x: 0, y: 0 },\r\n    atlasBR: { x: 0, y: 0 },\r\n    atlasTL: { x: 0, y: 0 },\r\n    atlasTR: { x: 0, y: 0 },\r\n    label: new label_1.Label({ text: ' ' }),\r\n    pixelHeight: 0,\r\n    pixelWidth: 0,\r\n};\r\n/**\r\n * Defines a manager of atlas', which includes generating the atlas and producing\r\n * textures defining those pieces of atlas.\r\n */\r\nvar AtlasManager = (function () {\r\n    /**\r\n     * Generates a new manager for atlas'. This will create and destroy atlas' and\r\n     * ensure they have the correct settings applied. A manager will also aid in\r\n     * packing images into the atlas indicated.\r\n     *\r\n     * @param {number} width The width of all atlas' generated\r\n     * @param {number} height The height of all atlas' generated\r\n     */\r\n    function AtlasManager(width, height) {\r\n        /** Gives a reference of all of the images loaded for the atlas */\r\n        this.atlasImages = {};\r\n        /** Stores the current mapping of the atlas */\r\n        this.atlasMap = {};\r\n        /** Stores all of the textures that are our atlases */\r\n        this.atlasTexture = {};\r\n        this.textureWidth = width;\r\n        this.textureHeight = height;\r\n    }\r\n    /**\r\n     * Atlas' must be created from scratch to update them. In order to properly\r\n     * update an existing one, you must destroy it then recreate it again.\r\n     * This is from not knowing how to update a texture via three js.\r\n     *\r\n     * @param atlasName The unique name of the atlas so it can be retrieved/referenced easily\r\n     * @param images The images with their image path set to be loaded into the atlas.\r\n     *               Images that keep an atlas ID of null indicates the image did not load\r\n     *               correctly\r\n     *\r\n     * @return {Texture} The Threejs texture that is created as our atlas. The images injected\r\n     *                   into the texture will be populated with the atlas'\r\n     */\r\n    AtlasManager.prototype.createAtlas = function (atlasName, images, colors) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var atlasMap, canvas, _i, images_1, image, image, texture, _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        atlasMap = new pack_node_1.PackNode(0, 0, this.textureWidth, this.textureHeight);\r\n                        // Create the mapping element for the new atlas so we can track insertions / deletions\r\n                        this.atlasMap[atlasName] = atlasMap;\r\n                        // Make a listing of images that is within the atlas\r\n                        this.atlasImages[atlasName] = [];\r\n                        canvas = document.createElement('canvas').getContext('2d');\r\n                        // Size the canvas to the atlas size\r\n                        canvas.canvas.width = this.textureWidth;\r\n                        canvas.canvas.height = this.textureHeight;\r\n                        if (!images) return [3 /*break*/, 4];\r\n                        _i = 0, images_1 = images;\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        if (!(_i < images_1.length)) return [3 /*break*/, 4];\r\n                        image = images_1[_i];\r\n                        return [4 /*yield*/, this.draw(image, atlasName, canvas)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        _i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 4:\r\n                        if (!colors) return [3 /*break*/, 6];\r\n                        return [4 /*yield*/, this.drawColors(colors, atlasName, canvas)];\r\n                    case 5:\r\n                        image = _b.sent();\r\n                        // Add the dummy texture info as an image to our list of images\r\n                        if (image) {\r\n                            this.atlasImages[atlasName].push(image);\r\n                        }\r\n                        _b.label = 6;\r\n                    case 6:\r\n                        texture = new three_1.Texture(canvas.canvas);\r\n                        texture.premultiplyAlpha = true;\r\n                        texture.generateMipmaps = true;\r\n                        // Store the texture as the atlas.\r\n                        this.atlasTexture[atlasName] = texture;\r\n                        // Store the images as images within the atlas\r\n                        if (images) {\r\n                            (_a = this.atlasImages[atlasName]).push.apply(_a, images);\r\n                        }\r\n                        debug('Atlas Created-> texture: %o mapping: %o images: %o', texture, atlasMap, images);\r\n                        return [2 /*return*/, texture];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Disposes of the resources the atlas held and makes the atlas invalid for use\r\n     *\r\n     * @param atlasName\r\n     */\r\n    AtlasManager.prototype.destroyAtlas = function (atlasName) {\r\n        if (this.atlasTexture[atlasName]) {\r\n            this.atlasTexture[atlasName].dispose();\r\n            this.atlasTexture[atlasName] = null;\r\n        }\r\n        if (this.atlasMap[atlasName]) {\r\n            this.atlasMap[atlasName].destroy();\r\n            this.atlasMap[atlasName] = null;\r\n        }\r\n        if (this.atlasImages[atlasName]) {\r\n            var none_1 = { x: 0, y: 0 };\r\n            this.atlasImages[atlasName].forEach(function (image) {\r\n                image.atlasReferenceID = null;\r\n                image.pixelWidth = 0;\r\n                image.pixelHeight = 0;\r\n                image.atlasBL = none_1;\r\n                image.atlasBR = none_1;\r\n                image.atlasTL = none_1;\r\n                image.atlasTR = none_1;\r\n            });\r\n            this.atlasImages[atlasName] = null;\r\n        }\r\n    };\r\n    AtlasManager.prototype.isValidImage = function (image) {\r\n        var isValid = false;\r\n        if (image && (image.imagePath || (image.label && image.label.text))) {\r\n            if (image.pixelWidth && image.pixelHeight) {\r\n                isValid = true;\r\n            }\r\n        }\r\n        return isValid;\r\n    };\r\n    AtlasManager.prototype.setDefaultImage = function (image, atlasName) {\r\n        image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\r\n        return image;\r\n    };\r\n    /**\r\n     * This loads, packs, and draws the indicated image into the specified canvas\r\n     * using the metrics that exists for the specified atlas.\r\n     *\r\n     * @param image The image who should have it's image path loaded\r\n     * @param atlasName The name of the atlas to make the packing work\r\n     * @param canvas The canvas we will be drawing into to generate the complete image\r\n     *\r\n     * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\r\n     */\r\n    AtlasManager.prototype.draw = function (image, atlasName, canvas) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var loadedImage, rect, dimensions, node, insertedNode, ux, uy, uw, uh, atlasDimensions;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        // Validate the index\r\n                        if (!this.atlasMap[atlasName]) {\r\n                            debug('Can not load image, invalid Atlas Name: %o for atlasMaps: %o', atlasName, this.atlasMap);\r\n                            return [2 /*return*/, false];\r\n                        }\r\n                        return [4 /*yield*/, this.loadImage(image)];\r\n                    case 1:\r\n                        loadedImage = _a.sent();\r\n                        // Make sure at this point the image knows it is not affiliated with an atlas\r\n                        // If something goes wrong with loading or insertting this image, then a null\r\n                        // Atlas value will indicate the image can not be used appropriately\r\n                        image.atlasReferenceID = null;\r\n                        // Only a non-null image means the image loaded correctly\r\n                        if (loadedImage && this.isValidImage(image)) {\r\n                            debug('Image loaded: %o', image.imagePath);\r\n                            rect = new bounds_1.Bounds(0, image.pixelWidth, image.pixelHeight, 0);\r\n                            dimensions = {\r\n                                first: image,\r\n                                second: rect,\r\n                            };\r\n                            // Auto add a buffer in\r\n                            dimensions.second.width += 1;\r\n                            dimensions.second.height += 1;\r\n                            node = this.atlasMap[atlasName];\r\n                            insertedNode = node.insert(dimensions);\r\n                            // If the result was NULL we did not successfully insert the image into any map\r\n                            if (insertedNode) {\r\n                                debug('Atlas location determined: %o', insertedNode);\r\n                                if (image.label) {\r\n                                    debugLabels('Atlas location determined. PackNode: %o Dimensions: %o', insertedNode, dimensions);\r\n                                }\r\n                                // Apply the image to the node\r\n                                insertedNode.nodeImage = image;\r\n                                ux = insertedNode.nodeDimensions.x / this.textureWidth;\r\n                                uy = insertedNode.nodeDimensions.y / this.textureHeight;\r\n                                uw = insertedNode.nodeDimensions.width / this.textureWidth;\r\n                                uh = insertedNode.nodeDimensions.height / this.textureHeight;\r\n                                debugLabels('uy is %o', uy);\r\n                                atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\r\n                                image.atlasReferenceID = atlasName;\r\n                                image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\r\n                                image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\r\n                                image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\r\n                                image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\r\n                                // Now draw the image to the indicated canvas\r\n                                canvas.drawImage(loadedImage, insertedNode.nodeDimensions.x, insertedNode.nodeDimensions.y);\r\n                                // We have finished inserting\r\n                                return [2 /*return*/, true];\r\n                            }\r\n                            else {\r\n                                // Log an error\r\n                                console.error(\"Could not fit image into atlas \" + image.imagePath);\r\n                                image = this.setDefaultImage(image, atlasName);\r\n                                return [2 /*return*/, false];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Log an error and load a default image\r\n                            console.error(\"Could not load image \" + image.imagePath);\r\n                            image = this.setDefaultImage(image, atlasName);\r\n                            return [2 /*return*/, false];\r\n                        }\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * This renders a list of colors to the canvas. This using the same packing\r\n     * algorithm as any image so the rendering is placed correctly or determines\r\n     * if enough space is not available.\r\n     *\r\n     * @param {AtlasColor[]} colors The list of colors to be rendered to the atlas\r\n     * @param {string} atlasName The name of the atlas being rendered to\r\n     * @param {CanvasRenderingContext2D} canvas The canvas of the atlas being rendered to\r\n     *\r\n     * @returns {Promise<boolean>} Resolves to true if the operation was successful\r\n     */\r\n    AtlasManager.prototype.drawColors = function (colors, atlasName, canvas) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var colorWidth, colorHeight, maxPerRow, rowWidth, rowCount, colCount, renderHeight, dimensions, node, insertedNode, image, ux, uy, uw, uh, atlasDimensions, renderSpace, startX, startY, nextX, nextY, beginX, beginY, col, row, _i, colors_1, color, _a, r, g, b;\r\n            return __generator(this, function (_b) {\r\n                debug('Finding space for colors on the atlas: %o', colors);\r\n                colorWidth = 2;\r\n                colorHeight = 2;\r\n                maxPerRow = 1024 / colorWidth;\r\n                rowWidth = Math.min(this.textureWidth, maxPerRow * colorWidth);\r\n                rowCount = Math.ceil((colors.length * colorWidth) / rowWidth);\r\n                colCount = Math.ceil(rowWidth / colorWidth);\r\n                renderHeight = rowCount * colorHeight;\r\n                dimensions = {\r\n                    // Since the algorithm requires something to fill this slot, just make a\r\n                    // Dummy object\r\n                    first: new atlas_texture_1.AtlasTexture(null, null),\r\n                    // Set the dimensions we calculated for the space our colors will take up\r\n                    // Within the atlas\r\n                    second: new bounds_1.Bounds(0, rowWidth, renderHeight, 0),\r\n                };\r\n                // Auto add a buffer in\r\n                dimensions.second.width += 1;\r\n                dimensions.second.height += 1;\r\n                node = this.atlasMap[atlasName];\r\n                insertedNode = node.insert(dimensions);\r\n                // If the result was NULL we did not successfully insert the image into any map\r\n                if (insertedNode) {\r\n                    debug('Atlas location determined for colors: %o', insertedNode);\r\n                    image = insertedNode.nodeImage = dimensions.first;\r\n                    ux = insertedNode.nodeDimensions.x / this.textureWidth;\r\n                    uy = insertedNode.nodeDimensions.y / this.textureHeight;\r\n                    uw = insertedNode.nodeDimensions.width / this.textureWidth;\r\n                    uh = insertedNode.nodeDimensions.height / this.textureHeight;\r\n                    atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\r\n                    image.atlasReferenceID = atlasName;\r\n                    image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\r\n                    image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\r\n                    image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\r\n                    image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\r\n                    renderSpace = insertedNode.nodeDimensions;\r\n                    startX = renderSpace.x;\r\n                    startY = renderSpace.y;\r\n                    nextX = colorWidth / this.textureWidth;\r\n                    nextY = -colorHeight / this.textureHeight;\r\n                    beginX = (startX / this.textureWidth) + (nextX / 2.0);\r\n                    beginY = 1.0 - (startY / this.textureHeight) + (nextY / 2.0);\r\n                    col = 0;\r\n                    row = 0;\r\n                    // Loop through each color, establish metrics, draw to the atlas\r\n                    for (_i = 0, colors_1 = colors; _i < colors_1.length; _i++) {\r\n                        color = colors_1[_i];\r\n                        // Staore the info needed to make the color referenceable again\r\n                        color.atlasReferenceID = atlasName;\r\n                        color.colorIndex = col + (row * colCount);\r\n                        color.colorsPerRow = colCount;\r\n                        // The location of the middle of the first color\r\n                        color.firstColor = {\r\n                            x: beginX,\r\n                            y: beginY,\r\n                        };\r\n                        color.nextColor = {\r\n                            x: nextX,\r\n                            y: nextY,\r\n                        };\r\n                        _a = color.color, r = _a.r, g = _a.g, b = _a.b;\r\n                        // Draw the color to the canvas\r\n                        canvas.fillStyle = \"rgba(\" + Math.round(r * 255.0) + \", \" + Math.round(g * 255.0) + \", \" + Math.round(b * 255.0) + \", \" + color.opacity + \")\";\r\n                        canvas.fillRect(col * colorWidth + startX, row * colorHeight + startY, colorWidth, colorHeight);\r\n                        col++;\r\n                        if (col === colCount) {\r\n                            col = 0;\r\n                            row++;\r\n                        }\r\n                    }\r\n                    // We have finished inserting\r\n                    return [2 /*return*/, image];\r\n                }\r\n                else {\r\n                    // Log an error\r\n                    throw new Error('Could not fit colors into atlas');\r\n                }\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Retrieves the threejs texture for the atlas\r\n     *\r\n     * @param atlasName The identifier of the atlas\r\n     */\r\n    AtlasManager.prototype.getAtlasTexture = function (atlasName) {\r\n        return this.atlasTexture[atlasName];\r\n    };\r\n    /**\r\n     * This reads the input path and loads the image specified by the path\r\n     *\r\n     * @param {AtlasTexture} texture This is an atlas texture with the path set\r\n     *\r\n     * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\r\n     *                                     or null if there was an error\r\n     */\r\n    AtlasManager.prototype.loadImage = function (texture) {\r\n        if (texture.imagePath) {\r\n            return new Promise(function (resolve, reject) {\r\n                var image = new Image();\r\n                image.onload = function () {\r\n                    texture.pixelWidth = image.width;\r\n                    texture.pixelHeight = image.height;\r\n                    texture.aspectRatio = image.width / image.height;\r\n                    resolve(image);\r\n                };\r\n                image.onerror = function () {\r\n                    resolve(null);\r\n                };\r\n                image.src = texture.imagePath;\r\n            });\r\n        }\r\n        else if (texture.label) {\r\n            return new Promise(function (resolve, reject) {\r\n                var label = texture.label;\r\n                var labelSize = label.getSize();\r\n                var canvas = document.createElement('canvas');\r\n                var ctx = canvas.getContext('2d');\r\n                // Set the dimensions of the canvas/texture space we will be using to rasterize\r\n                // The label. Use the label's rasterization controls to aid in rendering the label\r\n                canvas.width = labelSize.width + texture.label.rasterizationOffset.x;\r\n                canvas.height = labelSize.height;\r\n                debug('label X %o', texture.label.rasterizationOffset.x);\r\n                if (ctx) {\r\n                    var fontSize = label.fontSize;\r\n                    var color = d3_color_1.rgb(label.color.base.color.r * 255, label.color.base.color.g * 255, label.color.base.color.b * 255, label.color.base.opacity);\r\n                    ctx.font = label.makeCSSFont(fontSize);\r\n                    ctx.textAlign = label.textAlign;\r\n                    ctx.textBaseline = label.textBaseline;\r\n                    ctx.fillStyle = color.toString();\r\n                    // Render the label to the canvas/texture space. This utilizes the label's\r\n                    // Rasterization metrics to aid in getting a clean render.\r\n                    ctx.fillText(label.text, texture.label.rasterizationOffset.x, texture.label.rasterizationOffset.y);\r\n                    var image_1 = new Image();\r\n                    image_1.onload = function () {\r\n                        // Here we use the canvas dimensions and NOT the image dimensions\r\n                        // As the image dimensions are unreliable here when setting the src\r\n                        // To a data url\r\n                        texture.pixelWidth = image_1.width;\r\n                        texture.pixelHeight = image_1.height;\r\n                        texture.aspectRatio = image_1.width / image_1.height;\r\n                        debugLabels('Applying size based on rasterization to the Label: w: %o h: %o', image_1.width, image_1.height);\r\n                        label.setSize({\r\n                            height: image_1.height,\r\n                            width: image_1.width,\r\n                        });\r\n                        resolve(image_1);\r\n                    };\r\n                    image_1.onerror = function () {\r\n                        resolve(null);\r\n                    };\r\n                    image_1.src = canvas.toDataURL('image/png');\r\n                }\r\n            });\r\n        }\r\n        return Promise.resolve(null);\r\n    };\r\n    return AtlasManager;\r\n}());\r\nexports.AtlasManager = AtlasManager;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-manager.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = require(\"../primitives/bounds\");\r\n/**\r\n * This is used specifically by the atlas manager to aid in packing\r\n * in textures within an area. This will guarantee boundaries of textures are\r\n * not violated and provide proper feedback for where to draw a given image\r\n */\r\nvar PackNode = (function () {\r\n    function PackNode(x, y, width, height) {\r\n        this.child = [null, null];\r\n        this.isLeaf = true;\r\n        this.nodeImage = null;\r\n        this.nodeDimensions = new bounds_1.Bounds(x, x + width, y, y - height);\r\n    }\r\n    /**\r\n     * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\r\n     */\r\n    PackNode.prototype.destroy = function () {\r\n        this.nodeImage = null;\r\n        if (this.child[0]) {\r\n            this.child[0].destroy();\r\n        }\r\n        if (this.child[1]) {\r\n            this.child[1].destroy();\r\n        }\r\n        this.child[0] = undefined;\r\n        this.child[1] = undefined;\r\n    };\r\n    /**\r\n     * Indicates if there is a child\r\n     */\r\n    PackNode.prototype.hasChild = function () {\r\n        if (this.child[0] && !this.child[0].nodeImage) {\r\n            return !this.child[0].isLeaf;\r\n        }\r\n        if (this.child[1] && !this.child[1].nodeImage) {\r\n            return !this.child[1].isLeaf;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Inserts images into our mapping, fitting them appropriately\r\n     */\r\n    PackNode.prototype.insert = function (image) {\r\n        if (!this.isLeaf) {\r\n            // Try inserting into first child\r\n            var newNode = this.child[0].insert(image);\r\n            if (newNode !== null) {\r\n                return newNode;\r\n            }\r\n            // No room in first so insert into second\r\n            return this.child[1].insert(image);\r\n        }\r\n        else {\r\n            // If there's already an image here, return\r\n            if (this.nodeImage) {\r\n                return null;\r\n            }\r\n            // Check the fit status of the image in this nodes rectangle space\r\n            var fitFlag = this.nodeDimensions.fits(image.second);\r\n            // If we're too small, return null indicating can not fit\r\n            if (fitFlag === 0) {\r\n                return null;\r\n            }\r\n            // If we're just right, accept\r\n            if (fitFlag === 1) {\r\n                return this;\r\n            }\r\n            // Otherwise, gotta split this node and create some leaves\r\n            this.isLeaf = false;\r\n            // Get the image width\r\n            var imgWidth = image.second.width;\r\n            var imgHeight = image.second.height;\r\n            // Decide which way to split\r\n            var dWidth = this.nodeDimensions.width - imgWidth;\r\n            var dHeight = this.nodeDimensions.height - image.second.height;\r\n            if (dWidth > dHeight) {\r\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, imgWidth, this.nodeDimensions.height);\r\n                this.child[1] = new PackNode(this.nodeDimensions.x + imgWidth, this.nodeDimensions.y, dWidth, this.nodeDimensions.height);\r\n            }\r\n            else {\r\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, this.nodeDimensions.width, imgHeight);\r\n                this.child[1] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y + imgHeight, this.nodeDimensions.width, dHeight);\r\n            }\r\n        }\r\n        // Insert into first child we created\r\n        return this.child[0].insert(image);\r\n    };\r\n    /**\r\n     * Removes the image from the mapping and tries to open up as much space as possible.\r\n     *\r\n     * @param {AtlasTexture} image The image to insert into the\r\n     */\r\n    PackNode.prototype.remove = function (image) {\r\n        if (!this.isLeaf) {\r\n            // Try removing from first child\r\n            var removed = this.child[0].remove(image);\r\n            if (removed) {\r\n                return true;\r\n            }\r\n            // Try remove from second\r\n            removed = this.child[1].remove(image);\r\n            if (!this.child[0].hasChild()) {\r\n                if (!this.child[1].hasChild()) {\r\n                    this.child[0] = null;\r\n                    this.child[1] = null;\r\n                }\r\n            }\r\n            return removed;\r\n        }\r\n        else {\r\n            if (this.nodeImage === image) {\r\n                this.nodeImage = null;\r\n                image.atlasReferenceID = null;\r\n                image.pixelWidth = 0;\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n    return PackNode;\r\n}());\r\nexports.PackNode = PackNode;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/pack-node.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ramda_1 = require(\"ramda\");\r\nvar rotateable_quad_1 = require(\"../../primitives/rotateable-quad\");\r\nvar sprite_1 = require(\"../texture/sprite\");\r\nvar measurement = new sprite_1.Sprite(200, 200, 1, 1);\r\nvar Label = (function (_super) {\r\n    __extends(Label, _super);\r\n    /**\r\n     * Creates an instance of Label.\r\n     *\r\n     * @param {Partial<Label<T>>} [options={}]\r\n     */\r\n    function Label(options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _this = _super.call(this, { x: 0, y: 1 }, { width: 1, height: 1 }, 0, rotateable_quad_1.AnchorPosition.TopLeft) || this;\r\n        _this.depth = 40;\r\n        _this.direction = 'inherit';\r\n        _this.font = 'serif';\r\n        _this.fontSize = 10;\r\n        _this.fontWeight = 400;\r\n        _this.maxWidth = undefined;\r\n        _this.text = '';\r\n        _this.id = '';\r\n        _this.textAlign = 'start';\r\n        _this.textBaseline = 'alphabetic';\r\n        _this.zoomable = false;\r\n        /**\r\n         * This contains an adjustment to aid in the rasterization process. Getting\r\n         * reliable dimensions for fonts and text can be incredibly challenging,\r\n         * thus, this allows you to offset the rasterization if you get pieces of\r\n         * the label cut off.\r\n         */\r\n        _this.rasterizationOffset = { x: 20, y: 0 };\r\n        /**\r\n         * This contains an adjustment to aid in the rasterization process. Getting\r\n         * reliable dimensions for fonts and text can be incredibly challenging,\r\n         * thus, this allows you to pad the rasterization space if you get pieces of\r\n         * the label cut off.\r\n         */\r\n        _this.rasterizationPadding = { width: 0, height: 0 };\r\n        // Set props\r\n        Object.assign(_this, options);\r\n        // Make sure our dimensions are set\r\n        _this.setFontSize(options.fontSize || 12);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Label.prototype, \"baseLabel\", {\r\n        get: function () {\r\n            return this._baseLabel;\r\n        },\r\n        set: function (value) {\r\n            this._baseLabel = value;\r\n            this.text = value.text;\r\n            this.fontSize = value.fontSize;\r\n            this.font = value.font;\r\n            this.textAlign = value.textAlign;\r\n            this.textBaseline = value.textBaseline;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"rasterizedLabel\", {\r\n        /**\r\n         * This getter ensures the rasterized label retrieved is either this labels own rasterization\r\n         * or from a base.\r\n         */\r\n        get: function () {\r\n            if (this.baseLabel) {\r\n                return this.baseLabel.rasterizedLabel;\r\n            }\r\n            return this._rasterizedLabel;\r\n        },\r\n        set: function (value) {\r\n            this._rasterizedLabel = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Copies all of the properties of a label and makes this label use them\r\n     *\r\n     * @param {Label} label The labels whose properties we wish to copy\r\n     */\r\n    Label.prototype.copyLabel = function (label) {\r\n        // Assign the properties of the other label to this\r\n        // Specifically, ONLY label properties\r\n        Object.assign(this, ramda_1.omit(['x', 'y', 'width', 'height'], label));\r\n        // Use this to set the text to make sure all of the metrics are re-calculated\r\n        this.setText(label.text);\r\n    };\r\n    /**\r\n     * This gets the actual text this label is capable of rendering\r\n     */\r\n    Label.prototype.getText = function () {\r\n        if (this._baseLabel) {\r\n            return this._baseLabel.getText();\r\n        }\r\n        return this.text;\r\n    };\r\n    /**\r\n     * Takes all of the current settings and makes a CSS font string\r\n     */\r\n    Label.prototype.makeCSSFont = function (fontSize) {\r\n        return this.fontWeight + \" \" + (fontSize || this.fontSize) + \"px \" + this.font;\r\n    };\r\n    /**\r\n     * Change the position this text is rendered to\r\n     *\r\n     * @param x X world coordinate\r\n     * @param y Y world coordinate\r\n     */\r\n    Label.prototype.position = function (x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    };\r\n    /**\r\n     * This sets the font size for the label based on the base text dimensions\r\n     *\r\n     * @param {number} fontSize\r\n     */\r\n    Label.prototype.setFontSize = function (fontSize) {\r\n        var lbl = this.getText();\r\n        var size = this.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n        if (this.baseLabel) {\r\n            var baseSize = this.baseLabel.getSize();\r\n            var scale = fontSize / this.baseLabel.fontSize;\r\n            height = baseSize.height * scale;\r\n            width = baseSize.width * scale;\r\n        }\r\n        else {\r\n            measurement.context.font = this.makeCSSFont();\r\n            var size_1 = measurement.context.measureText(lbl);\r\n            // Set our properties based on the calculated size\r\n            height = fontSize;\r\n            width = size_1.width;\r\n        }\r\n        this.fontSize = fontSize;\r\n        this.setSize({ width: width, height: height });\r\n    };\r\n    /**\r\n     * Change the text and the calculated bounding box for this label\r\n     */\r\n    Label.prototype.setText = function (lbl) {\r\n        this.text = lbl;\r\n        this.setFontSize(this.fontSize);\r\n    };\r\n    Label.prototype.update = function () {\r\n        this.setFontSize(this.fontSize);\r\n        _super.prototype.update.call(this);\r\n    };\r\n    return Label;\r\n}(rotateable_quad_1.RotateableQuad));\r\nexports.Label = Label;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/label.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\nvar bounds_1 = require(\"./bounds\");\r\nvar AnchorPosition;\r\n(function (AnchorPosition) {\r\n    AnchorPosition[AnchorPosition[\"BottomLeft\"] = 0] = \"BottomLeft\";\r\n    AnchorPosition[AnchorPosition[\"BottomRight\"] = 1] = \"BottomRight\";\r\n    AnchorPosition[AnchorPosition[\"Custom\"] = 2] = \"Custom\";\r\n    AnchorPosition[AnchorPosition[\"Middle\"] = 3] = \"Middle\";\r\n    AnchorPosition[AnchorPosition[\"MiddleBottom\"] = 4] = \"MiddleBottom\";\r\n    AnchorPosition[AnchorPosition[\"MiddleLeft\"] = 5] = \"MiddleLeft\";\r\n    AnchorPosition[AnchorPosition[\"MiddleRight\"] = 6] = \"MiddleRight\";\r\n    AnchorPosition[AnchorPosition[\"MiddleTop\"] = 7] = \"MiddleTop\";\r\n    AnchorPosition[AnchorPosition[\"TopLeft\"] = 8] = \"TopLeft\";\r\n    AnchorPosition[AnchorPosition[\"TopRight\"] = 9] = \"TopRight\";\r\n})(AnchorPosition = exports.AnchorPosition || (exports.AnchorPosition = {}));\r\nvar anchorCalculations = (_a = {},\r\n    _a[AnchorPosition.BottomLeft] = function (quad) { return ({\r\n        x: 0,\r\n        y: 0,\r\n    }); },\r\n    _a[AnchorPosition.BottomRight] = function (quad) { return ({\r\n        x: quad.getSize().width,\r\n        y: 0,\r\n    }); },\r\n    _a[AnchorPosition.Custom] = function (quad) { return ({\r\n        x: 0,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a[AnchorPosition.Middle] = function (quad) { return ({\r\n        x: quad.getSize().width / 2,\r\n        y: quad.getSize().height / 2,\r\n    }); },\r\n    _a[AnchorPosition.MiddleBottom] = function (quad) { return ({\r\n        x: quad.getSize().width / 2,\r\n        y: 0,\r\n    }); },\r\n    _a[AnchorPosition.MiddleLeft] = function (quad) { return ({\r\n        x: 0,\r\n        y: quad.getSize().height / 2,\r\n    }); },\r\n    _a[AnchorPosition.MiddleRight] = function (quad) { return ({\r\n        x: quad.getSize().width,\r\n        y: quad.getSize().height / 2,\r\n    }); },\r\n    _a[AnchorPosition.MiddleTop] = function (quad) { return ({\r\n        x: quad.getSize().width / 2,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a[AnchorPosition.TopLeft] = function (quad) { return ({\r\n        x: 0,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a[AnchorPosition.TopRight] = function (quad) { return ({\r\n        x: quad.getSize().width,\r\n        y: quad.getSize().height,\r\n    }); },\r\n    _a);\r\nvar RotateableQuad = (function (_super) {\r\n    __extends(RotateableQuad, _super);\r\n    /**\r\n     * Generates a quad\r\n     *\r\n     * @param {IPoint} location The location of the quad (it's anchorpoint will be placed here)\r\n     * @param {number} width The width of the quad\r\n     * @param {number} height The height of the quad\r\n     * @param {AnchorPosition} anchor The anchor location of the quad.\r\n     *                                Location and rotation will be relative to this.\r\n     */\r\n    function RotateableQuad(location, size, rotation, anchor) {\r\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\r\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\r\n        // Apply our properties\r\n        _this.setSize(size);\r\n        _this.setAnchor(anchor);\r\n        _this.setLocation(location);\r\n        _this.setRotation(rotation);\r\n        // Update the transform and the corner vertices\r\n        _this.update();\r\n        return _this;\r\n    }\r\n    /**\r\n     * @private\r\n     * Recalculates this anchor position based on the anchor type\r\n     *\r\n     * @param {AnchorPosition} anchor\r\n     */\r\n    RotateableQuad.prototype.calculateAnchor = function (anchor) {\r\n        this.anchor = anchorCalculations[anchor](this);\r\n    };\r\n    /**\r\n     * Get the base size of the quad\r\n     *\r\n     * @returns {ISize} The base size of this quad\r\n     */\r\n    RotateableQuad.prototype.getSize = function () {\r\n        return this.size;\r\n    };\r\n    /**\r\n     * Sets the specified anchor position on the quad\r\n     *\r\n     * @param {AnchorPosition} anchor This specifies an auto calculated position for the anchor\r\n     * @param {IPoint} custom If specified, will set a custom anchor location rather\r\n     *                        than the calculated version.\r\n     */\r\n    RotateableQuad.prototype.setAnchor = function (anchor, custom) {\r\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\r\n        this.anchorType = anchor;\r\n        // Apply the custom position if present\r\n        if (custom) {\r\n            this.anchorType = AnchorPosition.Custom;\r\n            this.anchor = custom;\r\n            return;\r\n        }\r\n        this.calculateAnchor(anchor);\r\n    };\r\n    RotateableQuad.prototype.getAnchor = function () {\r\n        return this.anchor;\r\n    };\r\n    RotateableQuad.prototype.getAnchorType = function () {\r\n        return this.anchorType;\r\n    };\r\n    /**\r\n     * This sets the location of this quad to a given position where the anchor\r\n     * point will be located on top of the location provided.\r\n     *\r\n     * @param {IPoint} location The location to place the quad\r\n     */\r\n    RotateableQuad.prototype.setLocation = function (location) {\r\n        this.location = location;\r\n    };\r\n    RotateableQuad.prototype.getLocation = function () {\r\n        return this.location;\r\n    };\r\n    /**\r\n     * Sets the rotation of this quad, in radians, rotated around the anchor point.\r\n     *\r\n     * @param {number} rotation The rotation of the quad\r\n     */\r\n    RotateableQuad.prototype.setRotation = function (rotation) {\r\n        this.rotation = rotation;\r\n    };\r\n    /**\r\n     * get Rotation\r\n     */\r\n    RotateableQuad.prototype.getRotation = function () {\r\n        return this.rotation;\r\n    };\r\n    /**\r\n     * get direction as a point\r\n     */\r\n    RotateableQuad.prototype.getDirection = function () {\r\n        var angle = this.rotation;\r\n        return {\r\n            x: Math.cos(angle),\r\n            y: Math.sin(angle),\r\n        };\r\n    };\r\n    /**\r\n     * Applies the size to the base\r\n     *\r\n     * @param {ISize} size The size of the base quad\r\n     */\r\n    RotateableQuad.prototype.setSize = function (size) {\r\n        this.size = size;\r\n        this.base = [\r\n            new three_1.Vector4(0, size.height, 0, 1),\r\n            new three_1.Vector4(size.width, size.height, 0, 1),\r\n            new three_1.Vector4(0, 0, 0, 1),\r\n            new three_1.Vector4(size.width, 0, 0, 1),\r\n        ];\r\n        if (this.anchorType) {\r\n            this.calculateAnchor(this.anchorType);\r\n        }\r\n    };\r\n    /**\r\n     * This re-calculates the transform for this quad and applies the transform to\r\n     * the corners.\r\n     */\r\n    RotateableQuad.prototype.update = function () {\r\n        // Calculate the pieces of the transformation\r\n        var anchorMat = new three_1.Matrix4().makeTranslation(this.anchor.x, -this.anchor.y, 0);\r\n        var rotationMat = new three_1.Matrix4().makeRotationZ(this.rotation);\r\n        var locationMat = new three_1.Matrix4().makeTranslation(this.location.x, this.location.y, 0);\r\n        // Compose the transform based on the pieces and apply them\r\n        // In the proper compositing order\r\n        this.transform = new three_1.Matrix4()\r\n            .multiply(locationMat)\r\n            .multiply(rotationMat)\r\n            .multiply(anchorMat);\r\n        // Apply the transform to all of our base vertices\r\n        this.TL = this.base[0].clone().applyMatrix4(this.transform);\r\n        this.TR = this.base[1].clone().applyMatrix4(this.transform);\r\n        this.BL = this.base[2].clone().applyMatrix4(this.transform);\r\n        this.BR = this.base[3].clone().applyMatrix4(this.transform);\r\n        // Update the bounds of this object\r\n        this.x = this.TL.x;\r\n        this.y = this.TL.y;\r\n        this.width = 1;\r\n        this.height = 1;\r\n        this.encapsulatePoints([this.TR, this.BL, this.BR]);\r\n    };\r\n    return RotateableQuad;\r\n}(bounds_1.Bounds));\r\nexports.RotateableQuad = RotateableQuad;\r\nvar _a;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/rotateable-quad.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * A canvas element wrapper that aids in tracking a canvas element along with\r\n * content scaling properties.\r\n *\r\n * @class Sprite\r\n */\r\nvar Sprite = (function () {\r\n    //\r\n    // Ctor at the top below props\r\n    //\r\n    /**\r\n     * Creates an instance of Sprite.\r\n     *\r\n     * @param w             The width of the context to create\r\n     * @param h             The height of the context to create\r\n     * @param contentScaleX The content scaling of the content\r\n     * @param contentScaleY The content scaling of the content\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    function Sprite(w, h, contentScaleX, contentScaleY) {\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        var canvas = document.createElement('canvas');\r\n        if (canvas) {\r\n            this.scaleX = contentScaleX || this.scaleX;\r\n            this.scaleY = contentScaleY || this.scaleY;\r\n            canvas.width = w * this.scaleX;\r\n            canvas.height = h * this.scaleY;\r\n            this.context = canvas.getContext('2d');\r\n            this.canvas = canvas;\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the content scaling of this object\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getContentScale = function () {\r\n        return {\r\n            x: this.scaleX,\r\n            y: this.scaleY,\r\n        };\r\n    };\r\n    /**\r\n     * Retrieves the size of the content ignoring scaling\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getContentSize = function () {\r\n        return {\r\n            height: this.canvas.height,\r\n            width: this.canvas.width,\r\n        };\r\n    };\r\n    /**\r\n     * Retrieves the dimensional width of the content applying scaling\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getWidth = function () {\r\n        return this.canvas.width / this.scaleX;\r\n    };\r\n    /**\r\n     * Retrieves the dimensional height of the content applying scaling\r\n     *\r\n     * @readonly\r\n     *\r\n     * @memberOf Sprite\r\n     */\r\n    Sprite.prototype.getHeight = function () {\r\n        return this.canvas.height / this.scaleY;\r\n    };\r\n    return Sprite;\r\n}());\r\nexports.Sprite = Sprite;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/sprite.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar browser = require(\"bowser\");\r\nvar three_1 = require(\"three\");\r\nvar debug = require('debug')('CommunicationsView:Mouse');\r\n/** Used to adjust the base whee delta for IE browsers */\r\nvar IE_ADJUSTMENT = 1 / 30;\r\n/** Used to adjust the rates for IE 11 */\r\nvar OLD_IE_ADJUSTMENT = -0.25;\r\n// This determines how large the delta can grow to in firefox\r\nvar MAX_FIREFOX_WHEELDELTA = 100;\r\n/**\r\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\r\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\r\n */\r\nvar lowPassY = [0, 0, 0, 0];\r\n// These coefficients represent the coefficients of a FIR filter.\r\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\r\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\r\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\r\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\r\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\r\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\r\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\r\n// Attained.\r\nvar LOW_PASS_U0 = 0.1;\r\nvar LOW_PASS_U1 = 0.2;\r\nvar LOW_PASS_U2 = 0.2;\r\nvar LOW_PASS_U3 = 0.5;\r\nfunction normalizeFirefoxWheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    var deltaX = 0;\r\n    var deltaY = 0;\r\n    // Reset the filter if the direction changes to prevent lag in directional change\r\n    if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\r\n        lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\r\n    }\r\n    deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\r\n    // Calculate the next value output from the FIR filter\r\n    deltaY = (wheel.deltaY * MAX_FIREFOX_WHEELDELTA) * LOW_PASS_U0 + lowPassY[0] * LOW_PASS_U1 + lowPassY[1] * LOW_PASS_U2 + lowPassY[2] * LOW_PASS_U3;\r\n    // Store the value of the filter in the FIR memory bank\r\n    lowPassY.unshift(deltaY);\r\n    // Keep our FIR memory clean and only the size of the number of coefficients\r\n    lowPassY.pop();\r\n    return new three_1.Vector2(-deltaX, -deltaY);\r\n}\r\nfunction normalizeChromeWheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    return new three_1.Vector2(wheel.deltaX, -wheel.deltaY);\r\n}\r\nfunction normalizeIE11Wheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    var deltaX = wheel.deltaX;\r\n    if (deltaX === undefined) {\r\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\r\n    }\r\n    var deltaY = wheel.deltaY;\r\n    if (deltaY === undefined) {\r\n        if (wheel.wheelDeltaY !== undefined) {\r\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\r\n        }\r\n        else {\r\n            deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\r\n        }\r\n    }\r\n    return new three_1.Vector2(-deltaX, -deltaY);\r\n}\r\nfunction normalizeIE12Wheel(e) {\r\n    var wheel = e.nativeEvent;\r\n    var deltaX = wheel.deltaX, deltaY = wheel.deltaY;\r\n    if (deltaX === undefined) {\r\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\r\n    }\r\n    if (deltaY === undefined) {\r\n        if (wheel.wheelDeltaY !== undefined) {\r\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\r\n        }\r\n        else {\r\n            deltaY = wheel.wheelDelta || -wheel.detail;\r\n        }\r\n    }\r\n    var v = new three_1.Vector2(deltaX, -deltaY);\r\n    v.multiplyScalar(0.25);\r\n    return v;\r\n}\r\n// Determine this browsers version of wheel normalization and apply it\r\nvar normalizeWheel;\r\nexports.normalizeWheel = normalizeWheel;\r\nif (browser.firefox) {\r\n    debug('Using mouse wheel for firefox');\r\n    exports.normalizeWheel = normalizeWheel = normalizeFirefoxWheel;\r\n}\r\nelse if (browser.msie && +browser.version >= 11) {\r\n    debug('Using mouse wheel for IE 11');\r\n    exports.normalizeWheel = normalizeWheel = normalizeIE11Wheel;\r\n}\r\nelse if (browser.msedge) {\r\n    debug('Using mouse wheel for MS EDGE');\r\n    exports.normalizeWheel = normalizeWheel = normalizeIE12Wheel;\r\n}\r\nelse {\r\n    debug('Using mouse wheel for Chrome');\r\n    exports.normalizeWheel = normalizeWheel = normalizeChromeWheel;\r\n}\r\n/**\r\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\r\n */\r\nfunction eventElementPosition(e, relative) {\r\n    var mouseX = 0, mouseY = 0, eventX = 0, eventY = 0, object = relative || e.nativeEvent.target;\r\n    // Get mouse position on document crossbrowser\r\n    if (!e) {\r\n        e = window.event;\r\n    }\r\n    if (e.pageX || e.pageY) {\r\n        mouseX = e.pageX;\r\n        mouseY = e.pageY;\r\n    }\r\n    else if (e.clientX || e.clientY) {\r\n        mouseX = e.clientX + document.body.scrollLeft\r\n            + document.documentElement.scrollLeft;\r\n        mouseY = e.clientY + document.body.scrollTop\r\n            + document.documentElement.scrollTop;\r\n    }\r\n    // Get parent element position in document\r\n    if (object.offsetParent) {\r\n        do {\r\n            eventX += object.offsetLeft;\r\n            eventY += object.offsetTop;\r\n            object = object.offsetParent;\r\n        } while (object);\r\n    }\r\n    // Mouse position minus elm position is mouseposition relative to element:\r\n    return { x: mouseX - eventX, y: mouseY - eventY };\r\n}\r\nexports.eventElementPosition = eventElementPosition;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/mouse.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = require(\"../primitives/bounds\");\r\n// A configuration that controls how readily a quadtree will split to another level\r\n// Adjusting this number can improve or degrade your performance significantly and\r\n// Must be tested for specific use cases\r\nvar maxPopulation = 5;\r\nvar maxDepth = 10;\r\n/**\r\n * This filters a quad tree query by type\r\n *\r\n * @export\r\n * @template T\r\n */\r\nfunction filterQuery(type, queryValues) {\r\n    var filtered = [];\r\n    queryValues.forEach(function (obj) {\r\n        if (type.find(function (t) { return obj instanceof t; })) {\r\n            filtered.push(obj);\r\n        }\r\n    });\r\n    return filtered;\r\n}\r\nexports.filterQuery = filterQuery;\r\n/**\r\n * This is a class used specifically by the quad tree nodes to indicate split space\r\n * within the quad tree.\r\n *\r\n * @class Quadrants\r\n */\r\nvar Quadrants = (function () {\r\n    /**\r\n     * Creates an instance of Quadrants.\r\n     *\r\n     * @param bounds The bounds this will create quandrants for\r\n     * @param depth  The child depth of this element\r\n     *\r\n     * @memberOf Quadrants\r\n     */\r\n    function Quadrants(bounds, depth) {\r\n        this.TL = null;\r\n        this.TR = null;\r\n        this.BL = null;\r\n        this.BR = null;\r\n        var mid = bounds.mid;\r\n        this.TL = new Node(bounds.x, mid.x, bounds.y, mid.y, depth);\r\n        this.TR = new Node(mid.x, bounds.right, bounds.y, mid.y, depth);\r\n        this.BL = new Node(bounds.x, mid.x, mid.y, bounds.bottom, depth);\r\n        this.BR = new Node(mid.x, bounds.right, mid.y, bounds.bottom, depth);\r\n    }\r\n    /**\r\n     * Ensures all memory is released for all nodes and all references are removed\r\n     * to potentially high memory consumption items\r\n     *\r\n     * @memberOf Quadrants\r\n     */\r\n    Quadrants.prototype.destroy = function () {\r\n        this.TL.destroy();\r\n        this.TR.destroy();\r\n        this.BL.destroy();\r\n        this.BR.destroy();\r\n        this.TL = null;\r\n        this.TR = null;\r\n        this.BL = null;\r\n        this.BR = null;\r\n    };\r\n    return Quadrants;\r\n}());\r\nexports.Quadrants = Quadrants;\r\n/**\r\n * The quad tree node. This Node will take in a certain population before dividing itself into\r\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\r\n * does not completely get injected into one of the quadrants it remains as a member of this node.\r\n *\r\n * @export\r\n * @class Node\r\n */\r\nvar Node = (function () {\r\n    /**\r\n     * Creates an instance of Node.\r\n     *\r\n     * @param l     The bounding left wall of the space this node covers\r\n     * @param r     The bounding right wall of the space this node covers\r\n     * @param t     The bounding top wall of the space this node covers\r\n     * @param b     The bounding bottom wall of the space this node covers\r\n     * @param depth The depth within the quad tree this node resides\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    function Node(left, right, top, bottom, depth) {\r\n        this.bounds = null;\r\n        this.children = [];\r\n        this.childrenProps = [];\r\n        this.depth = 0;\r\n        this.nodes = null;\r\n        // If params insertted\r\n        if (arguments.length >= 4) {\r\n            this.bounds = new bounds_1.Bounds(left, right, top, bottom);\r\n        }\r\n        else {\r\n            this.bounds = new bounds_1.Bounds(0, 1, 1, 0);\r\n        }\r\n        // Ensure the depth is set\r\n        this.depth = depth || 0;\r\n    }\r\n    /**\r\n     * Destroys this node and ensures all child nodes are destroyed as well.\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.destroy = function () {\r\n        this.children = null;\r\n        this.bounds = null;\r\n        if (this.nodes) {\r\n            this.nodes.destroy();\r\n            this.nodes = null;\r\n        }\r\n    };\r\n    /**\r\n     * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\r\n     * or into a sub quadrant if this node is split already. If the child is outside the boundaries\r\n     * this quad tree spans (and this is the root node), the quad tree will expand to include\r\n     * the new child.\r\n     *\r\n     * @param child The Bounds type object to inject\r\n     * @param props Properties that can be retrieved with the child object if applicable\r\n     *\r\n     * @returns True if the insertion was successful\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.add = function (child, props) {\r\n        // This is the entry function for adding children, so we must first expand our top node\r\n        // To cover the area that the child is located.\r\n        // If we're in bounds, then let's just add the child\r\n        if (child.isInside(this.bounds)) {\r\n            return this.doAdd(child);\r\n        }\r\n        else {\r\n            this.cover(child);\r\n            return this.add(child, props);\r\n        }\r\n    };\r\n    /**\r\n     * Adds a list of new children to this quad tree. It performs the same operations as\r\n     * addChild for each child in the list, however, it more efficiently recalculates the\r\n     * bounds necessary to cover the area the children cover.\r\n     *\r\n     * @param children      List of Bounds objects to inject\r\n     * @param childrenProps List of props to associate with each element\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.addAll = function (children, childrenProps) {\r\n        var _this = this;\r\n        // Ensure the properties are at least defined\r\n        childrenProps = childrenProps || [];\r\n        // Make sure we cover the entire area of all the children.\r\n        // We can speed this up a lot if we first calculate the total bounds the new children covers\r\n        var minX = Number.MAX_VALUE;\r\n        var minY = Number.MAX_VALUE;\r\n        var maxX = -Number.MAX_VALUE;\r\n        var maxY = -Number.MAX_VALUE;\r\n        // Get the dimensions of the new bounds\r\n        children.forEach(function (child) {\r\n            if (child.x < minX) {\r\n                minX = child.x;\r\n            }\r\n            if (child.right > maxX) {\r\n                maxX = child.right;\r\n            }\r\n            if (child.bottom < minY) {\r\n                minY = child.bottom;\r\n            }\r\n            if (child.y > maxY) {\r\n                maxY = child.y;\r\n            }\r\n        });\r\n        // Make sure our bounds includes the specified bounds\r\n        this.cover(new bounds_1.Bounds(minX, maxX, maxY, minY));\r\n        // Add all of the children into the tree\r\n        children.forEach(function (child, index) { return _this.doAdd(child); });\r\n    };\r\n    /**\r\n     * Ensures this quad tree includes the bounds specified in it's spatial coverage.\r\n     * This will cause all children to be re-injected into the tree.\r\n     *\r\n     * @param bounds The bounds to include in the tree's coverage\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.cover = function (bounds) {\r\n        var _this = this;\r\n        // If we are already covering the area: abort\r\n        if (bounds.isInside(this.bounds)) {\r\n            return;\r\n        }\r\n        // Make our bounds cover the new area\r\n        this.bounds.encapsulate(bounds);\r\n        this.bounds.x -= 1;\r\n        this.bounds.y += 1;\r\n        this.bounds.width += 2;\r\n        this.bounds.height += 4;\r\n        // Get all of the children underneath this node\r\n        var allChildren = this.gatherChildren([]);\r\n        // Destroy the split nodes\r\n        if (this.nodes) {\r\n            // Completely...destroy...\r\n            this.nodes.destroy();\r\n            this.nodes = null;\r\n        }\r\n        // Reinsert all children with the new dimensions in place\r\n        allChildren.forEach(function (child, index) { return _this.doAdd(child); });\r\n    };\r\n    /**\r\n     * When adding children, this performs the actual action of injecting the child into the tree\r\n     * without the process of seeing if the tree needs a spatial adjustment to account for the child.\r\n     *\r\n     * @param child The Bounds item to inject into the tree\r\n     * @param props The props to remain associated with the child\r\n     *\r\n     * @returns True if the injection was successful\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.doAdd = function (child) {\r\n        // If nodes are present, then we have already exceeded the population of this node\r\n        if (this.nodes) {\r\n            if (child.isInside(this.nodes.TL.bounds)) {\r\n                return this.nodes.TL.doAdd(child);\r\n            }\r\n            if (child.isInside(this.nodes.TR.bounds)) {\r\n                return this.nodes.TR.doAdd(child);\r\n            }\r\n            if (child.isInside(this.nodes.BL.bounds)) {\r\n                return this.nodes.BL.doAdd(child);\r\n            }\r\n            if (child.isInside(this.nodes.BR.bounds)) {\r\n                return this.nodes.BR.doAdd(child);\r\n            }\r\n            // Otherwise, this is a child overlapping this border\r\n            this.children.push(child);\r\n            return true;\r\n        }\r\n        else if (child.isInside(this.bounds)) {\r\n            this.children.push(child);\r\n            // If we exceeded our population for this quadrant, it is time to split up\r\n            if (this.children.length > maxPopulation && this.depth < maxDepth) {\r\n                this.split();\r\n            }\r\n            return true;\r\n        }\r\n        // This is when there is something wrong with the insertted child. The bounds\r\n        // For the quad should have grown without issue, but in this case the bounds\r\n        // Could not grow to accomodate the child.\r\n        if (isNaN(child.width + child.height + child.x + child.y)) {\r\n            console.error('Child did not fit into bounds because a dimension is NaN', child);\r\n        }\r\n        else if (child.area === 0) {\r\n            console.error('Child did not fit into bounds because the area is zero', child);\r\n        }\r\n        // Don't insert the child and continue\r\n        return true;\r\n    };\r\n    /**\r\n     * Collects all children of all the current and sub nodes into a single list.\r\n     *\r\n     * @param list The list we must aggregate children into\r\n     *\r\n     * @return The list specified as the list parameter\r\n     */\r\n    Node.prototype.gatherChildren = function (list) {\r\n        list = list.concat(this.children);\r\n        if (this.nodes) {\r\n            this.nodes.TL.gatherChildren(list);\r\n            this.nodes.TR.gatherChildren(list);\r\n            this.nodes.BL.gatherChildren(list);\r\n            this.nodes.BR.gatherChildren(list);\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Collects all props associated with the children. This array of props will\r\n     * mirror the list retrieved with gatherChildren.\r\n     *\r\n     * @param list\r\n     *\r\n     * @returns The list specified as the list paramter\r\n     *\r\n     * @memberOf Node\r\n     */\r\n    Node.prototype.gatherProps = function (list) {\r\n        var _this = this;\r\n        this.children.forEach(function (c, index) {\r\n            list.push(_this.childrenProps[index]);\r\n        });\r\n        if (this.nodes) {\r\n            this.nodes.TL.gatherProps(list);\r\n            this.nodes.TR.gatherProps(list);\r\n            this.nodes.BL.gatherProps(list);\r\n            this.nodes.BR.gatherProps(list);\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Entry query for determining query type based on input object\r\n     *\r\n     * @param bounds Can be a Bounds or a Point object\r\n     * @param visit  A callback function that will receive the Node as it is analyzed. This gives\r\n     *               information on a spatial scale, how a query reaches it's target intersections.\r\n     *\r\n     * @return An array of children that intersects with the query\r\n     */\r\n    Node.prototype.query = function (bounds, visit) {\r\n        // Query a rectangle\r\n        if (bounds instanceof bounds_1.Bounds) {\r\n            if (bounds.hitBounds(this.bounds)) {\r\n                return this.queryBounds(bounds, [], visit);\r\n            }\r\n            // Return an empty array when nothing is collided with\r\n            return [];\r\n        }\r\n        // Query a point\r\n        if (this.bounds.containsPoint(bounds)) {\r\n            return this.queryPoint(bounds, [], visit);\r\n        }\r\n        // Return an empty array when nothing is collided with\r\n        return [];\r\n    };\r\n    /**\r\n     * Queries children for intersection with a bounds object\r\n     *\r\n     * @param b     The Bounds to test children against\r\n     * @param list  The list of children to aggregate into the query\r\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\r\n     *              information on a spatial scale, how a query reaches it's target intersections.\r\n     *\r\n     * @return     Returns the exact same list that was input as the list param\r\n     */\r\n    Node.prototype.queryBounds = function (b, list, visit) {\r\n        this.children.forEach(function (c, index) {\r\n            if (c.hitBounds(b)) {\r\n                list.push(c);\r\n            }\r\n        });\r\n        if (visit) {\r\n            visit(this);\r\n        }\r\n        if (this.nodes) {\r\n            if (b.hitBounds(this.nodes.TL.bounds)) {\r\n                this.nodes.TL.queryBounds(b, list, visit);\r\n            }\r\n            if (b.hitBounds(this.nodes.TR.bounds)) {\r\n                this.nodes.TR.queryBounds(b, list, visit);\r\n            }\r\n            if (b.hitBounds(this.nodes.BL.bounds)) {\r\n                this.nodes.BL.queryBounds(b, list, visit);\r\n            }\r\n            if (b.hitBounds(this.nodes.BR.bounds)) {\r\n                this.nodes.BR.queryBounds(b, list, visit);\r\n            }\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Queries children for intersection with a point\r\n     *\r\n     * @param p     The Point to test children against\r\n     * @param list  The list of children to aggregate into the query\r\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\r\n     *              information on a spatial scale, how a query reaches it's target intersections.\r\n     *\r\n     * @return      Returns the exact same list that was input as the list param\r\n     */\r\n    Node.prototype.queryPoint = function (p, list, visit) {\r\n        this.children.forEach(function (c, index) {\r\n            if (c.containsPoint(p)) {\r\n                list.push(c);\r\n            }\r\n        });\r\n        if (visit) {\r\n            visit(this);\r\n        }\r\n        if (this.nodes) {\r\n            if (this.nodes.TL.bounds.containsPoint(p)) {\r\n                this.nodes.TL.queryPoint(p, list, visit);\r\n            }\r\n            if (this.nodes.TR.bounds.containsPoint(p)) {\r\n                this.nodes.TR.queryPoint(p, list, visit);\r\n            }\r\n            if (this.nodes.BL.bounds.containsPoint(p)) {\r\n                this.nodes.BL.queryPoint(p, list, visit);\r\n            }\r\n            if (this.nodes.BR.bounds.containsPoint(p)) {\r\n                this.nodes.BR.queryPoint(p, list, visit);\r\n            }\r\n        }\r\n        return list;\r\n    };\r\n    /**\r\n     * Creates four sub quadrants for this node.\r\n     */\r\n    Node.prototype.split = function () {\r\n        // Gather all items to be handed down\r\n        var allChildren = this.gatherChildren([]);\r\n        // Gather all props for the children to be handed down as well\r\n        this.nodes = new Quadrants(this.bounds, this.depth + 1);\r\n        this.children = [];\r\n        this.childrenProps = [];\r\n        while (allChildren.length > 0) {\r\n            this.doAdd(allChildren.pop());\r\n        }\r\n    };\r\n    /**\r\n     * Traverses the quad tree returning every quadrant encountered\r\n     *\r\n     * @param cb A callback that has the parameter (node) which is a quadrant in the tree\r\n     */\r\n    Node.prototype.visit = function (cb) {\r\n        var finished = Boolean(cb(this));\r\n        if (this.nodes && !finished) {\r\n            this.nodes.TL.visit(cb);\r\n            this.nodes.TR.visit(cb);\r\n            this.nodes.BL.visit(cb);\r\n            this.nodes.BR.visit(cb);\r\n        }\r\n    };\r\n    return Node;\r\n}());\r\nexports.Node = Node;\r\nvar QuadTree = (function (_super) {\r\n    __extends(QuadTree, _super);\r\n    function QuadTree() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return QuadTree;\r\n}(Node));\r\nexports.QuadTree = QuadTree;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/quad-tree.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = require(\"./bounds\");\r\nvar UID = 0;\r\nvar Circle = (function (_super) {\r\n    __extends(Circle, _super);\r\n    /**\r\n     * Generate a new Circle object\r\n     *\r\n     * @param x The center of the circle\r\n     * @param y The center of the circle\r\n     * @param r The radius of the circle\r\n     * @param d A data object to associate with the circle\r\n     */\r\n    function Circle(x, y, r, d) {\r\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\r\n        /** a UID of the circle */\r\n        _this._id = ++UID;\r\n        /** Radius of the circle */\r\n        _this._radius = 0;\r\n        /** X coord of the center of the circle */\r\n        _this._centerX = 0;\r\n        /** Y coord of the center of the circle */\r\n        _this._centerY = 0;\r\n        _this._centerX = x;\r\n        _this._centerY = y;\r\n        _this._radius = r;\r\n        _this.d = d;\r\n        _this.updateBounds();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Circle.prototype, \"values\", {\r\n        get: function () {\r\n            return {\r\n                radius: this._radius,\r\n                x: this._centerX,\r\n                y: this._centerY,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Circle.prototype, \"radius\", {\r\n        get: function () {\r\n            return this._radius;\r\n        },\r\n        set: function (val) {\r\n            this._radius = val;\r\n            this.updateBounds();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Circle.prototype, \"centerX\", {\r\n        get: function () {\r\n            return this._centerX;\r\n        },\r\n        set: function (val) {\r\n            this._centerX = val;\r\n            this.updateBounds();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Circle.prototype, \"centerY\", {\r\n        get: function () {\r\n            return this._centerY;\r\n        },\r\n        set: function (val) {\r\n            this._centerY = val;\r\n            this.updateBounds();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Tests if the specified bounds is inside this circle\r\n     *\r\n     * @param b The bounds to test against\r\n     */\r\n    Circle.prototype.boundsInside = function (b) {\r\n        var r2 = this._radius * this._radius;\r\n        var dx = b.x - this._centerX;\r\n        var dy = b.y - this._centerY;\r\n        var dy2 = dy * dy;\r\n        var dx2 = dx * dx;\r\n        if ((dx2 + dy2) > r2) {\r\n            return false;\r\n        }\r\n        dx = b.right - this._centerX;\r\n        dx2 = dx * dx;\r\n        if ((dx2 + dy2) > r2) {\r\n            return false;\r\n        }\r\n        dy = b.bottom - this._centerY;\r\n        dy2 = dy * dy;\r\n        if ((dx2 + dy2) > r2) {\r\n            return false;\r\n        }\r\n        dx = b.x - this._centerX;\r\n        dx2 = dx * dx;\r\n        return (dx2 + dy2) < r2;\r\n    };\r\n    /**\r\n     * Calculates the distance to a provided point\r\n     *\r\n     * @param {IPoint} p The point to calculate the distance of the middle of the\r\n     *                   circle to\r\n     * @param {boolean} notSquared Flag true to prevent the Math.sqrt operation, leaving\r\n     *                             the result as distance^2\r\n     *\r\n     * @return {number} The distance from mid circle to the point\r\n     */\r\n    Circle.prototype.distanceTo = function (p, notSquared) {\r\n        var dx = this._centerX - p.x;\r\n        var dy = this._centerY - p.y;\r\n        if (notSquared) {\r\n            return dx * dx + dy * dy;\r\n        }\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    };\r\n    /**\r\n     * Retrieves the closest circle to a provided point\r\n     *\r\n     * @param {Array} circles The circles to see who is the nearest\r\n     * @param {IPoint} p The point to compare the circles against for nearness\r\n     *\r\n     * @return {Circle} The nearest circle\r\n     */\r\n    Circle.getClosest = function (circles, p) {\r\n        var closestCircle;\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var distance = 0;\r\n        circles.forEach(function (circle) {\r\n            distance = circle.distanceTo(p, true);\r\n            if (distance < closestDistance) {\r\n                closestCircle = circle;\r\n                closestDistance = distance;\r\n            }\r\n        });\r\n        return closestCircle;\r\n    };\r\n    /**\r\n     * Tests if this circle is colliding with the specified circle\r\n     *\r\n     * @param c The circle to test against\r\n     *\r\n     * @return {boolean} True if colliding\r\n     */\r\n    Circle.prototype.hitCircle = function (c) {\r\n        var totalDistance = c._radius + this._radius;\r\n        totalDistance *= totalDistance;\r\n        return this.distanceTo({ x: c._centerX, y: c._centerY }, true) < totalDistance;\r\n    };\r\n    /**\r\n     * @override\r\n     * This makes it so the test of a point tests based on a Circle shape\r\n     *\r\n     * @param p The point to test if inside the circle\r\n     *\r\n     * @return True if the point is inside\r\n     */\r\n    Circle.prototype.hitPoint = function (p) {\r\n        var r2 = this._radius * this._radius;\r\n        var dx = p.x - this._centerX;\r\n        var dy = p.y - this._centerY;\r\n        return (dx * dx + dy * dy) < r2;\r\n    };\r\n    /**\r\n     * If there are multiple metrics to update for the circle, this is the most\r\n     * efficient way to do that as it will update it's bounds only once.\r\n     *\r\n     * @param x\r\n     * @param y\r\n     * @param r\r\n     */\r\n    Circle.prototype.position = function (x, y, r) {\r\n        this._centerX = x;\r\n        this._centerY = y;\r\n        this._radius = r;\r\n        this.updateBounds();\r\n    };\r\n    /**\r\n     * @override\r\n     * Tests if a point is inside the circle\r\n     *\r\n     * @param p The point to test if inside the circle\r\n     *\r\n     * @return True if the point is inside\r\n     */\r\n    Circle.prototype.pointInside = function (p) {\r\n        var r2 = this._radius * this._radius;\r\n        var dx = p.x - this._centerX;\r\n        var dy = p.y - this._centerY;\r\n        return (dx * dx + dy * dy) < r2;\r\n    };\r\n    /**\r\n     * When the circle gains different circle metrics, it's Bounds must adjust\r\n     * accordingly, which is what this method recalculates.\r\n     */\r\n    Circle.prototype.updateBounds = function () {\r\n        var radius = this._radius;\r\n        this.x = this._centerX - radius;\r\n        this.y = this._centerY - radius;\r\n        this.height = radius * 2;\r\n        this.width = radius * 2;\r\n    };\r\n    /**\r\n     * Pretty print the metrics of this circle\r\n     */\r\n    Circle.prototype.toString = function () {\r\n        return \"[Circle {x: \" + this._centerX + \", y: \" + this._centerY + \", r: \" + this._radius + \"}]\";\r\n    };\r\n    return Circle;\r\n}(bounds_1.Bounds));\r\nexports.Circle = Circle;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/circle.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ramda_1 = require(\"ramda\");\r\nvar interpolation_1 = require(\"../util/interpolation\");\r\nvar bounds_1 = require(\"./bounds\");\r\nvar line_1 = require(\"./line\");\r\nvar point_1 = require(\"./point\");\r\nvar debug = require('debug')('bezier');\r\n/**\r\n * This enum covers the type of curved lines that can be made. Making a specific curve\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nvar CurveType;\r\n(function (CurveType) {\r\n    /** This will make the curve be generated from interpolating between the end points and provided control points */\r\n    CurveType[CurveType[\"Bezier\"] = 0] = \"Bezier\";\r\n    /**\r\n     * This will draw a curve as though there is a circular arc passing over the two end points. The radius of the\r\n     * circular arc is determined by how far the control point is from the straight line that can be made from the two\r\n     * end points.\r\n     */\r\n    CurveType[CurveType[\"CircularCCW\"] = 1] = \"CircularCCW\";\r\n    CurveType[CurveType[\"CircularCW\"] = 2] = \"CircularCW\";\r\n    /**\r\n     * This ignores the control points altogether and just created a straight line with a single segment that consists\r\n     * of the specified endpoints\r\n     */\r\n    CurveType[CurveType[\"Straight\"] = 3] = \"Straight\";\r\n})(CurveType = exports.CurveType || (exports.CurveType = {}));\r\n// -------[ Distance Calculating Methods ]----------------------------\r\n/**\r\n * Calculates the distance to the bezier curve by testing all of the bezier curve's segment lines\r\n *\r\n * @param {CurvedLine<any>} line The curved bezier line type\r\n * @param {IPoint} testPoint The Point to test distance to\r\n *\r\n * @returns {number} The nearest distance from the curve to the test point\r\n */\r\nfunction bezierDistance(line, testPoint) {\r\n    // Get all of the points associated with the curve\r\n    var lineStrip = line.getLineStrip();\r\n    // Find the closest points to the mouse\r\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\r\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\r\n    // Find the closest distance and use it\r\n    var closestDistance = Number.MAX_VALUE;\r\n    var straightLine;\r\n    if (closestIndex > 0) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\r\n        closestDistance = straightLine.distanceTo(testPoint);\r\n    }\r\n    if (closestIndex < lineStrip.length - 1) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\r\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\r\n    }\r\n    return closestDistance;\r\n}\r\n/**\r\n * Calculates the nearness of the line by using the properties of a circle\r\n * TODO: Using the segment approach for now. Can be sped up by using circle math\r\n * instead\r\n *\r\n * @param {CurvedLine<any>} line The curved bezier line type\r\n * @param {IPoint} testPoint The Point to test distance to\r\n *\r\n * @returns {number} The nearest distance from the curve to the test point\r\n */\r\nfunction circularDistance(line, testPoint) {\r\n    // Get all of the points associated with the curve\r\n    var lineStrip = line.getLineStrip();\r\n    // Find the closest points to the mouse\r\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\r\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\r\n    // Find the closest distance and use it\r\n    var closestDistance = Number.MAX_VALUE;\r\n    var straightLine;\r\n    if (closestIndex > 0) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\r\n        closestDistance = straightLine.distanceTo(testPoint);\r\n    }\r\n    if (closestIndex < lineStrip.length - 1) {\r\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\r\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\r\n    }\r\n    return closestDistance;\r\n}\r\n/**\r\n * Calculates the nearness of the line by using the properties of a straight line\r\n *\r\n * @param {CurvedLine<any>} line The curved bezier line type\r\n * @param {IPoint} testPoint The Point to test distance to\r\n *\r\n * @returns {number} The nearest distance from the curve to the test point\r\n */\r\nfunction straightDistance(line, testPoint) {\r\n    return new line_1.Line(line.p1, line.p2).distanceTo(testPoint);\r\n}\r\n// -------[ Segment Generating Methods ]----------------------------\r\n/**\r\n * Uses quadratic bezier principles to create the segments for a quadratic bezier curve\r\n *\r\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\r\n *\r\n * @returns {IPoint[]} A line strip of all the calculated points along the line\r\n */\r\nfunction makeBezier2Segments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    var segments = [];\r\n    var dt = 1 / line.resolution;\r\n    var p1 = line.p1;\r\n    var p2 = line.p2;\r\n    var c1 = line.controlPoints[0];\r\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\r\n        segments.push(interpolation_1.bezier2(dt * i, p1, p2, c1));\r\n    }\r\n    if (line.cachesSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    return segments;\r\n}\r\n/**\r\n * Uses cubic bezier principles to create the segments for a cubic bezier curve\r\n *\r\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\r\n *\r\n * @returns {IPoint[]} A line strip of all the calculated points along the line\r\n */\r\nfunction makeBezier3Segments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    var segments = [];\r\n    var dt = 1 / line.resolution;\r\n    var p1 = line.p1;\r\n    var p2 = line.p2;\r\n    var c1 = line.controlPoints[0];\r\n    var c2 = line.controlPoints[1];\r\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\r\n        segments.push(interpolation_1.bezier3(dt * i, p1, p2, c1, c2));\r\n    }\r\n    if (line.cachesSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    return segments;\r\n}\r\n/**\r\n * Makes the segments for a line that follows along a circular path on the line.\r\n * The distance the control point is from the straight line that flows through the two\r\n * end points of the line determines the radius of the curvature of the line\r\n *\r\n * @param {CurvedLine<any>} line\r\n * @returns {IPoint[]}\r\n */\r\nfunction makeCircularCWSegments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    debug('CW');\r\n    // Generate a line so we can have a perpendicular calculation\r\n    var straightLine = new line_1.Line(line.p1, line.p2);\r\n    var radius = point_1.Point.getDistance(line.p1, line.controlPoints[0]);\r\n    // We get the midpoint of the line as we want to align the center of the circle with this point\r\n    var midPoint = point_1.Point.getMidpoint(line.p1, line.p2);\r\n    var minRadius = point_1.Point.getDistance(midPoint, line.p1);\r\n    // The shortest the radius can be is the distance from the line to the mid point\r\n    // Anything shorter will just result in a hemisphere being rendered\r\n    if (radius < minRadius) {\r\n        radius = point_1.Point.getDistance(midPoint, line.p1);\r\n    }\r\n    // Get the perpendicular direction to the line so we can calculate the center of our circle\r\n    // From the mid point\r\n    var perpendicular = straightLine.perpendicular;\r\n    var distance = Math.sqrt(radius * radius - minRadius * minRadius);\r\n    // Calculate the location of the center of the circle\r\n    var circleCenter = {\r\n        x: perpendicular.x * distance + midPoint.x,\r\n        y: perpendicular.y * distance + midPoint.y,\r\n    };\r\n    // Store the circle center as an extra control point in case the value is needed\r\n    // (which it often is)\r\n    line.controlPoints[1] = circleCenter;\r\n    debug(' center of circle is %o  %o', circleCenter.x, circleCenter.y);\r\n    // Get the direction vector from the circle center to the first end point\r\n    var direction1 = point_1.Point.getDirection(circleCenter, line.p1);\r\n    // Get the angle of the first vector\r\n    var theta1 = Math.atan2(direction1.y, direction1.x);\r\n    // Get the direction vector from the circle center to the second end point\r\n    var direction2 = point_1.Point.getDirection(circleCenter, line.p2);\r\n    // Get the angle of the second vector\r\n    var theta2 = Math.atan2(direction2.y, direction2.x);\r\n    // Calculate how much to increment theta in our parametric circular equation\r\n    if (theta1 < theta2)\r\n        theta1 += Math.PI * 2;\r\n    var dTheta = (theta1 - theta2) / line.resolution;\r\n    debug('theta1 is %o, theta2 is %o', theta1, theta2);\r\n    // Compute the segments based on the information we have gathered by applying it to a circular\r\n    // Parametric equation\r\n    var segments = [];\r\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\r\n        segments.push({\r\n            x: Math.cos(theta1 - (dTheta * i)) * radius + circleCenter.x,\r\n            y: Math.sin(theta1 - (dTheta * i)) * radius + circleCenter.y,\r\n        });\r\n    }\r\n    // Cache the segments if specified by the curved line\r\n    if (line.cachesSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    debug('Generated Circular Segments: %o dTheta: %o radius: %o', segments, dTheta, radius);\r\n    return segments;\r\n}\r\nfunction makeCircularCCWSegments(line) {\r\n    if (line.cachesSegments && line.cachedSegments) {\r\n        return line.cachedSegments;\r\n    }\r\n    var straightLine = new line_1.Line(line.p1, line.p2);\r\n    var radius = point_1.Point.getDistance(line.p1, line.controlPoints[0]);\r\n    var midPoint = point_1.Point.getMidpoint(line.p1, line.p2);\r\n    var minRadius = point_1.Point.getDistance(midPoint, line.p1);\r\n    if (radius < minRadius) {\r\n        radius = point_1.Point.getDistance(midPoint, line.p1);\r\n    }\r\n    var perpendicular = straightLine.perpendicular;\r\n    var distance = Math.sqrt(radius * radius - minRadius * minRadius);\r\n    var circleCenter = {\r\n        x: -perpendicular.x * distance + midPoint.x,\r\n        y: -perpendicular.y * distance + midPoint.y,\r\n    };\r\n    // Store the circle center as an extra control point in case the value is needed\r\n    // (which it often is)\r\n    line.controlPoints[1] = circleCenter;\r\n    var direction1 = point_1.Point.getDirection(circleCenter, line.p1);\r\n    var theta1 = Math.atan2(direction1.y, direction1.x);\r\n    var direction2 = point_1.Point.getDirection(circleCenter, line.p2);\r\n    var theta2 = Math.atan2(direction2.y, direction2.x);\r\n    if (theta2 < theta1)\r\n        theta2 += Math.PI * 2;\r\n    var dTheta = (theta2 - theta1) / line.resolution;\r\n    var segments = [];\r\n    // CCW, from p2 to p1\r\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\r\n        segments.push({\r\n            x: Math.cos(theta1 + (dTheta * i)) * radius + circleCenter.x,\r\n            y: Math.sin(theta1 + (dTheta * i)) * radius + circleCenter.y,\r\n        });\r\n    }\r\n    if (line.cachedSegments) {\r\n        line.cachedSegments = segments;\r\n    }\r\n    return segments;\r\n}\r\n/**\r\n * Makes the segments for a line that is straight, thus only 1 segments is needed\r\n * and will be generated.\r\n *\r\n * @param {CurvedLine<any>} line\r\n * @returns {IPoint[]}\r\n */\r\nfunction makeStraightSegments(line) {\r\n    return [line.p1, line.p2];\r\n}\r\n/** A quick lookup for a proper segment creating method for a curved line  */\r\nvar pickSegmentMethod = (_a = {},\r\n    _a[CurveType.Bezier] = [\r\n        null,\r\n        makeBezier2Segments,\r\n        makeBezier3Segments,\r\n    ],\r\n    _a[CurveType.CircularCW] = [\r\n        null,\r\n        makeCircularCWSegments,\r\n        makeCircularCWSegments,\r\n    ],\r\n    _a[CurveType.CircularCCW] = [\r\n        null,\r\n        makeCircularCCWSegments,\r\n        makeCircularCCWSegments,\r\n    ],\r\n    _a[CurveType.Straight] = [\r\n        makeStraightSegments,\r\n    ],\r\n    _a);\r\n/** A quick lookup for a proper distance calculating method for a curved line  */\r\nvar pickDistanceMethod = (_b = {},\r\n    _b[CurveType.Bezier] = bezierDistance,\r\n    _b[CurveType.CircularCW] = circularDistance,\r\n    _b[CurveType.CircularCCW] = circularDistance,\r\n    _b[CurveType.Straight] = straightDistance,\r\n    _b);\r\n/**\r\n * Defines an object which illustrates a curved line. Curved lines can be formed in many\r\n * ways but most often from two end points and some provided control points.\r\n *\r\n * @export\r\n * @class CurvedLine\r\n * @extends {Bounds<T>}\r\n * @template T An associated data type with this object. Use <never> if no data type is ever associated\r\n */\r\nvar CurvedLine = (function (_super) {\r\n    __extends(CurvedLine, _super);\r\n    /**\r\n     * Generates a primitive that describes a curved line, which is defined by the lines end points, type, and control points\r\n     *\r\n     * @param {ICurvedLineOptions} options The configuration options of this curved line\r\n     */\r\n    function CurvedLine(options) {\r\n        var _this = this;\r\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\r\n        _this = _super.call(this, minX, maxX, maxY, minY) || this;\r\n        // Apply the relevant properties to the curve\r\n        _this.cachesSegments = options.cacheSegments || false;\r\n        _this.type = options.type;\r\n        _this.resolution = options.resolution || 20;\r\n        // Set the metrics for this curved line\r\n        _this.setPoints(options.start, options.end, options.controlPoints);\r\n        // Set the method that will be used for calculating distance from a point\r\n        _this.distanceMethod = pickDistanceMethod[options.type];\r\n        return _this;\r\n    }\r\n    Object.defineProperty(CurvedLine.prototype, \"values\", {\r\n        get: function () {\r\n            return {\r\n                controlPoints: this.controlPoints,\r\n                p1: this.p1,\r\n                p2: this.p2,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Calculates the nearest distance from the provided point to this curved line\r\n     *\r\n     * @param {IPoint} point The point to test the distance from\r\n     *\r\n     * @returns {number} The calculated nearest distance from this curve to the point\r\n     */\r\n    CurvedLine.prototype.distanceTo = function (point) {\r\n        return this.distanceMethod(this, point);\r\n    };\r\n    /**\r\n     * Picks the closest line in the list to a given point\r\n     *\r\n     * @param {CurvedLine<any>[]} lines The lines to compare\r\n     * @param {IPoint} p The point to compare against\r\n     *\r\n     * @return {Line} The nearest line to the point\r\n     */\r\n    CurvedLine.getClosest = function (lines, point) {\r\n        var closestLine;\r\n        var closestDistance = Number.MAX_VALUE;\r\n        var distance = 0;\r\n        lines.forEach(function (line) {\r\n            distance = line.distanceTo(point);\r\n            if (distance < closestDistance) {\r\n                closestLine = line;\r\n                closestDistance = distance;\r\n            }\r\n        });\r\n        return closestLine;\r\n    };\r\n    /**\r\n     * This returns the line strip that represents the curve. A line strip is specifically a group of points\r\n     * that forms line segments by taking the current point as one end and the previous point as the second end\r\n     * thus, you would start at index 1 and loop to the end to generate all of the lines composing this single\r\n     * line.\r\n     *\r\n     * @return {IPoint[]} All of the points in the line strip\r\n     */\r\n    CurvedLine.prototype.getLineStrip = function () {\r\n        return this.segmentMethod(this);\r\n    };\r\n    /**\r\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {IPoint[]} controlPoints\r\n     * @param {boolean} preventRebounding If set, this will prevent the bounds from being recalculated\r\n     */\r\n    CurvedLine.prototype.setPoints = function (p1, p2, controlPoints) {\r\n        // Apply the points\r\n        this.p1 = p1;\r\n        this.p2 = p2;\r\n        if (controlPoints.length === 0)\r\n            debug('p1: %o, p2:%o', p1, p2);\r\n        // Get the available segment methods for the given type\r\n        var segmentMethods = pickSegmentMethod[this.type];\r\n        // If we adjust the control points we need to re-evaluate the type of segment creation method we use\r\n        if (controlPoints) {\r\n            this.controlPoints = ramda_1.clone(controlPoints);\r\n            // Get the number of control points we want to base the curve off of\r\n            var numControlPoints = controlPoints.length;\r\n            // If we have more control points than the methods available, then we use the greatest method available to best\r\n            // Handle as many control points as possible\r\n            if (numControlPoints > segmentMethods.length) {\r\n                numControlPoints = segmentMethods.length - 1;\r\n            }\r\n            // Set the method that will be used for generating segments\r\n            this.segmentMethod = segmentMethods[numControlPoints];\r\n            // Make sure the input wasn't bad\r\n            if (!this.segmentMethod) {\r\n                throw new Error('An Invalid number of control points was provided to a curved line. You must have at LEAST 1 control point. Or 0 for a straight line');\r\n            }\r\n            if (this.type === CurveType.Bezier) {\r\n                this.encapsulatePoints(controlPoints);\r\n            }\r\n            else if (this.type === CurveType.CircularCCW || this.type === CurveType.CircularCW) {\r\n                this.encapsulatePoints(this.getLineStrip());\r\n            }\r\n        }\r\n        this.encapsulatePoint(p1);\r\n        this.encapsulatePoint(p2);\r\n        // Invalidate caches if they exist\r\n        this.cachedSegments = null;\r\n    };\r\n    return CurvedLine;\r\n}(bounds_1.Bounds));\r\nexports.CurvedLine = CurvedLine;\r\nvar _a, _b;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/curved-line.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This calculates a quadratic bezier curve.\r\n *\r\n * We use specific bezier curve implementations for low degree curves as it is\r\n * much much faster to calculate.\r\n *\r\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\r\n * @param {IPoint} p1 The First end point of the curve\r\n * @param {IPoint} p2 The second end point of the curve\r\n * @param {IPoint} c1 The control point of the curve\r\n *\r\n * @returns {IPoint} The calculated point on the curve for the provided time interval\r\n */\r\nfunction bezier2(t, p1, p2, c1) {\r\n    var t2 = t * t;\r\n    var mt = 1 - t;\r\n    var mt2 = mt * mt;\r\n    return {\r\n        x: p1.x * mt2 + c1.x * 2 * mt * t + p2.x * t2,\r\n        y: p1.y * mt2 + c1.y * 2 * mt * t + p2.y * t2,\r\n    };\r\n}\r\nexports.bezier2 = bezier2;\r\n/**\r\n * This calculates a cubic bezier curve.\r\n *\r\n * We use specific bezier curve implementations for low degree curves as it is\r\n * much much faster to calculate.\r\n *\r\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\r\n * @param {IPoint} p1 The First end point of the curve\r\n * @param {IPoint} p2 The second end point of the curve\r\n * @param {IPoint} c1 The first control point of the curve\r\n * @param {IPoint} c2 The second control point of the curve\r\n *\r\n * @returns {IPoint} The calculated point on the curve for the provided time interval\r\n */\r\nfunction bezier3(t, p1, p2, c1, c2) {\r\n    var t2 = t * t;\r\n    var t3 = t2 * t;\r\n    var mt = 1 - t;\r\n    var mt2 = mt * mt;\r\n    var mt3 = mt2 * mt;\r\n    return {\r\n        x: p1.x * mt3 + 3 * c1.x * mt2 * t + 3 * c2.x * mt * t2 + p2.x * t3,\r\n        y: p1.y * mt3 + 3 * c1.y * mt2 * t + 3 * c2.y * mt * t2 + p2.y * t3,\r\n    };\r\n}\r\nexports.bezier3 = bezier3;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/interpolation.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar line_1 = require(\"../../primitives/line\");\r\n/**\r\n * Defines a line that can be drawn\r\n */\r\nvar LineShape = (function (_super) {\r\n    __extends(LineShape, _super);\r\n    /**\r\n     * Generate a new line that can be drawn\r\n     */\r\n    function LineShape(p1, p2, d, r, g, b, a, r2, g2, b2, a2, thickness) {\r\n        var _this = _super.call(this, p1, p2) || this;\r\n        // Color 1\r\n        _this.a = 0;\r\n        _this.b = 0;\r\n        _this.g = 0;\r\n        _this.r = 1;\r\n        // Color 2 ?\r\n        _this.a2 = 0;\r\n        _this.b2 = 0;\r\n        _this.g2 = 0;\r\n        _this.r2 = 1;\r\n        // Other properties\r\n        _this.cull = true;\r\n        _this.thickness = 1;\r\n        Object.assign(_this, {\r\n            a: a,\r\n            a2: a2,\r\n            b: b,\r\n            b2: b2,\r\n            d: d,\r\n            g: g,\r\n            g2: g2,\r\n            r: r,\r\n            r2: r2,\r\n        });\r\n        if (thickness !== undefined) {\r\n            _this.thickness = thickness;\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Clones this instance of the line shape and creates a new instance of a line shape that\r\n     * is identical to this one. The properties injected can be modifiers after the clone happens\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {CircleShape} A newly cloned instance of this line shape\r\n     */\r\n    LineShape.prototype.clone = function (newProperties) {\r\n        return Object.assign(new LineShape(this.p1, this.p2, this.d, this.r, this.g, this.b, this.a, this.r2, this.g2, this.b2, this.a2), this, newProperties);\r\n    };\r\n    return LineShape;\r\n}(line_1.Line));\r\nexports.LineShape = LineShape;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/line-shape.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./webgl-surface/webgl-surface\"));\r\n__export(require(\"./webgl-surface/buffers\"));\r\n__export(require(\"./webgl-surface/drawing\"));\r\n__export(require(\"./webgl-surface/primitives\"));\r\n__export(require(\"./webgl-surface/util\"));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ramda_1 = require(\"ramda\");\r\nvar React = require(\"react\");\r\nvar three_1 = require(\"three\");\r\nvar atlas_manager_1 = require(\"./drawing/texture/atlas-manager\");\r\nvar atlas_texture_1 = require(\"./drawing/texture/atlas-texture\");\r\nvar bounds_1 = require(\"./primitives/bounds\");\r\nvar mouse_1 = require(\"./util/mouse\");\r\nvar quad_tree_1 = require(\"./util/quad-tree\");\r\nvar debug = require('debug')('webgl-surface:GPU');\r\nvar debugCam = require('debug')('webgl-surface:Camera');\r\nvar debugLabels = require('debug')('webgl-surface:Labels');\r\n/**\r\n * This enum names the base methods that are passed into the applyPropsMethods\r\n * method. This allows subclasses to easily pick the property setting methods they need\r\n * from the base\r\n */\r\nvar BaseApplyPropsMethods;\r\n(function (BaseApplyPropsMethods) {\r\n    /** Initializes any context that needs to be set up before the props are set */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"INITIALIZE\"] = 0] = \"INITIALIZE\";\r\n    /** Moment when any buffer changes should be applied */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"BUFFERCHANGES\"] = 1] = \"BUFFERCHANGES\";\r\n    /** Initializes camera properties to facilitate smoothe start up */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"CAMERA\"] = 2] = \"CAMERA\";\r\n    /** Generates the labels as images within the atlas manager */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"LABELS\"] = 3] = \"LABELS\";\r\n    /** Generates the colors within the atlas manager */\r\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"COLORS\"] = 4] = \"COLORS\";\r\n})(BaseApplyPropsMethods = exports.BaseApplyPropsMethods || (exports.BaseApplyPropsMethods = {}));\r\n/**\r\n * This enum names the base methods that are passed into the animatedMethods\r\n * method. This allows subsclasses to easily pick the animated methods they need\r\n * from the base\r\n */\r\nvar BaseAnimatedMethods;\r\n(function (BaseAnimatedMethods) {\r\n    /** Sets up the base context needed to execute most methods */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"CONTEXT\"] = 0] = \"CONTEXT\";\r\n    /** Sets up the inertia method for inertial panning */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"INERTIA\"] = 1] = \"INERTIA\";\r\n    /** Animates the postion of the camera to a destination */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"POSITION\"] = 2] = \"POSITION\";\r\n    /** Zooms the camera based on a point of focus */\r\n    BaseAnimatedMethods[BaseAnimatedMethods[\"ZOOM\"] = 3] = \"ZOOM\";\r\n})(BaseAnimatedMethods = exports.BaseAnimatedMethods || (exports.BaseAnimatedMethods = {}));\r\n/** This is the smallest increment the zoom can make. Anything less and nothing will happen */\r\nvar MIN_ZOOM_INCREMENT = 0.001;\r\nvar BYTE_MAX = 0xFF;\r\nvar BACKGROUND_COLOR = new three_1.Color().setRGB(38 / BYTE_MAX, 50 / BYTE_MAX, 78 / BYTE_MAX);\r\n// --[ CONSTANTS ]-------------------------------------------\r\n// Make a container vector for performing operations within\r\nvar vector = new three_1.Vector3();\r\n// --[ SHADERS ]-------------------------------------------\r\n/**\r\n * Equivalent of Math.sign, but faster, and works in all browsers\r\n *\r\n * @param {number} value The number to determine the sign\r\n *\r\n * @return {number} Returns zero if a sign can not be determined, -1 for a negative, 1 for a positive\r\n */\r\nfunction sign(value) {\r\n    if (!value) {\r\n        return 0;\r\n    }\r\n    if (value > 0) {\r\n        return 1;\r\n    }\r\n    if (value < 0) {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\r\nfunction isWebGLSupported() {\r\n    try {\r\n        var canvas = document.createElement('canvas');\r\n        return !!window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\nvar WEBGL_SUPPORTED = isWebGLSupported();\r\n/**\r\n * The base component for the communications view\r\n */\r\nvar WebGLSurface = (function (_super) {\r\n    __extends(WebGLSurface, _super);\r\n    function WebGLSurface() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /** This is the atlas manager for managing images and labels rendered as textures */\r\n        _this.atlasManager = new atlas_manager_1.AtlasManager(2048, 2048);\r\n        /** Tracks the names of the atlas' generated */\r\n        _this.atlasNames = {\r\n            colors: 'colors',\r\n            labels: 'labels',\r\n        };\r\n        /**\r\n         * List of methods that execute within the animation loop. Makes adding and removing these methods\r\n         * simpler to manage, as well as gives a clear and optimized way of overriding existing methods\r\n         * or reordering their execution\r\n         */\r\n        _this.animatedMethodList = [];\r\n        /**\r\n         * If this is set to true during an animated method's lifecycle, then all subsequent animated methods\r\n         * will not be executed for the current frame. Upon reaching the end of the frame, the break will reset\r\n         * and the animated methods will attempt executing again\r\n         */\r\n        _this.animatedMethodBreak = false;\r\n        /** Used to aid in mouse interactions */\r\n        _this.distance = 0;\r\n        /**\r\n         * The camera that 'looks' at our world and gives us the ability to convert\r\n         * screen coordinates to world coordinates, and vice versa\r\n         */\r\n        _this.camera = null;\r\n        /**\r\n         * While this number is positive it will be decremented every frame.\r\n         * While positive, mouse interactions will not occur. This utilizes frame ticks\r\n         * as SOME values and numbers settle per frame, not necessarily within timelapses.\r\n         * More often than not, there will only be a need for 1-2 frames of mouse disable to\r\n         * allow the camera to be positioned in a correct location before screen to world projections\r\n         * start taking place.\r\n         */\r\n        _this.disableMouseInteraction = 0;\r\n        _this.sizeCamera = null;\r\n        /** Keep track of the current zoom so it can be set in requestAnimationFrame */\r\n        _this.currentZoom = 1;\r\n        /** Horizontal destination the camera will pan to */\r\n        _this.destinationX = 0;\r\n        /** Vertical position the camera will pan to */\r\n        _this.destinationY = 0;\r\n        /** The destination zoom level the camera used during panning */\r\n        _this.destinationZoom = 1;\r\n        /** Is the camera currently in a panning state */\r\n        _this.isPanning = false;\r\n        /** Last known screen position of the mouse */\r\n        _this.lastMousePosition = { x: 0, y: 0 };\r\n        /** List of methods to execute when applying props */\r\n        _this.propsMethodList = [];\r\n        /** Inertial values for drag panning */\r\n        _this.inertia = null;\r\n        _this.inertiaBuild = 1.5;\r\n        _this.inertiaDecay = .9;\r\n        _this.inertiaMax = 100;\r\n        /**\r\n         * All data is put into this quad tree so we can query spatial regions for\r\n         * items\r\n         */\r\n        _this.quadTree = null;\r\n        /**\r\n         * True if the shift key is currently being held\r\n         *\r\n         * Panning is affected by whether or not the shift key is being held down, but\r\n         * I don't know how yet.\r\n         */\r\n        _this.shiftIsDown = false;\r\n        _this.stop = false;\r\n        /** The current rendered position and zoom */\r\n        _this.currentX = 0;\r\n        _this.currentY = 0;\r\n        _this.targetZoom = 1;\r\n        /** The (world) position the focus will zoom in and out of */\r\n        _this.previousZoomToFit = 0;\r\n        _this.zoomTargetX = 0;\r\n        _this.zoomTargetY = 0;\r\n        /** When this is set, the draw loop continues to run. Used by the draw loop to complete animations */\r\n        _this.animating = false;\r\n        _this.labels = [];\r\n        _this.labelsReady = false;\r\n        /**\r\n         * This is the latest labels loading identifier, used to determine if the labels\r\n         * last loaded matches the labels currently needing to be rendered.\r\n         */\r\n        _this.labelsCurrentLoadedId = 0;\r\n        _this.labelsLoadId = 0;\r\n        /** When this is set to true, the atlas with the colors is now ready to be referenced */\r\n        _this.colors = [];\r\n        _this.colorsReady = false;\r\n        /** Holds the items currently hovered over */\r\n        _this.currentHoverItems = [];\r\n        /** Flag for detecting whether or not webgl is supported at all */\r\n        /**\r\n         * This is the update loop that operates at the requestAnimationFrame speed.\r\n         * This updates the cameras current position and causes changes over time for\r\n         * any property that has a start and a destination.\r\n         */\r\n        _this.animate = function () {\r\n            if (_this.stop) {\r\n                return;\r\n            }\r\n            requestAnimationFrame(function () { return _this.animate(); });\r\n            var response;\r\n            var doDraw = false;\r\n            var didBreak = _this.animatedMethodList.some(function (method) {\r\n                response = method();\r\n                // Update our draw status based on response\r\n                if (!doDraw) {\r\n                    doDraw = response.doDraw;\r\n                }\r\n                // Stop the system if needed\r\n                if (response.stop) {\r\n                    _this.stop = true;\r\n                }\r\n                // Stop performing\r\n                if (response.break) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            // We prevent any animation loop execution if we did break\r\n            if (didBreak) {\r\n                return;\r\n            }\r\n            // Make sure all camera related uniforms are up to date\r\n            _this.updateCameraUniforms();\r\n            // Handle the deactivation period of mouse interactions by decrementing it\r\n            // If it's positive\r\n            if (_this.disableMouseInteraction > 0) {\r\n                _this.disableMouseInteraction--;\r\n            }\r\n            if (doDraw || _this.forceDraw) {\r\n                _this.forceDraw = false;\r\n                _this.emitViewport();\r\n                _this.draw();\r\n            }\r\n        };\r\n        /**\r\n         * Applies new props injected into this component.\r\n         *\r\n         * Applying new props does not entail that a re-render will happen so we\r\n         * handle application of props as a separate concept. Here we:\r\n         *\r\n         * set up zoom targetting and apply quested zoom levels\r\n         *\r\n         * Create our quad tree and associate properties to objects if a new dataset\r\n         * is provided\r\n         *\r\n         * Analyze our dataset for interesting and useful metrics such as max and mins\r\n         * to aid in visualization normalization\r\n         *\r\n         * @param {T} props The new properties for this component\r\n         */\r\n        _this.applyProps = function (props) {\r\n            debug('Applying props');\r\n            var response;\r\n            _this.propsMethodList.some(function (method) {\r\n                response = method(props);\r\n                // Stop performing\r\n                if (response.break) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            debugCam('current cam', _this.currentX, _this.currentY, _this.destinationX, _this.destinationY);\r\n            debugCam('Zoom Target: [%o, %o]', _this.zoomTargetX, _this.zoomTargetY);\r\n            debugCam('Last Mouse: [%o, %o]', _this.lastMousePosition.x, _this.lastMousePosition.y);\r\n        };\r\n        /**\r\n         * This is the draw method executed from the animation loop. Everytime, this is\r\n         * called, the webgl surface will be redrawn.\r\n         */\r\n        _this.draw = function () {\r\n            // Draw the 3D scene\r\n            _this.renderer.render(_this.scene, _this.camera);\r\n        };\r\n        /**\r\n         * This initializes the surface and calls for sub class classes to initialize\r\n         * their buffers\r\n         *\r\n         * @param {HTMLElement} el The DOM element this component is contained in\r\n         * @param {number} w The width of the rendering\r\n         * @param {number} h The height of the rendering\r\n         */\r\n        _this.init = function (el, w, h) {\r\n            if (!el || _this.scene) {\r\n                return;\r\n            }\r\n            _this.renderEl = el;\r\n            if (w === 0 || h === 0) {\r\n                return;\r\n            }\r\n            debug('Initializing GPU objects el: %o width: %o height: %o', el, w, h);\r\n            // Set up a ctx for our render space\r\n            _this.ctx = {\r\n                height: h,\r\n                heightHalf: h / 2.0,\r\n                width: w,\r\n                widthHalf: w / 2.0,\r\n            };\r\n            // Set up the camera now that the ctx is set up\r\n            _this.initCamera();\r\n            // Create a scene so we can add our buffer objects to it\r\n            // We also add the scene to the window to make threejs tools available\r\n            window.scene = _this.scene = new three_1.Scene();\r\n            // Fire our hook for starting up our specific buffer implementation\r\n            _this.initBuffers();\r\n            // FINALIZE SET UP\r\n            // Generate the renderer along with it's properties\r\n            _this.renderer = new three_1.WebGLRenderer({\r\n                antialias: true,\r\n            });\r\n            debug('Window Pixel Ratio: %o', window.devicePixelRatio);\r\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\r\n            _this.renderer.setSize(w, h);\r\n            _this.renderer.setClearColor(BACKGROUND_COLOR);\r\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\r\n            // Set up DOM interaction with the renderer\r\n            var container = el;\r\n            container.appendChild(_this.renderer.domElement);\r\n        };\r\n        /**\r\n         * Initializes the camera and any contexts associated with it\r\n         */\r\n        _this.initCamera = function () {\r\n            debug('Initializing Camera');\r\n            // INITIALIZE THE CAMERA\r\n            var h = _this.ctx.height;\r\n            var viewSize = h;\r\n            var w = _this.ctx.width;\r\n            var aspectRatio = w / h;\r\n            var viewport = {\r\n                aspectRatio: aspectRatio,\r\n                bottom: -viewSize / 2,\r\n                far: 10000000,\r\n                left: (-aspectRatio * viewSize) / 2,\r\n                near: -100,\r\n                right: (aspectRatio * viewSize) / 2,\r\n                top: viewSize / 2,\r\n                viewSize: viewSize,\r\n            };\r\n            _this.camera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\r\n            _this.sizeCamera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\r\n            _this.camera.position.z = 300;\r\n            _this.sizeCamera.position.set(0, 0, 300);\r\n        };\r\n        /**\r\n         * This is executed when our rendering surface (the canvas) changes in size in any\r\n         * way. It will make sure our renderer matches the context to prevent scaling\r\n         * and other deformations.\r\n         */\r\n        _this.resizeContext = function () {\r\n            var w = _this.props.width;\r\n            var h = _this.props.height;\r\n            // See if a renderer even exists yet\r\n            if (!_this.renderer) {\r\n                return false;\r\n            }\r\n            var renderSize = _this.renderer.getSize();\r\n            // Check if the resize is needed\r\n            if (renderSize.width === w && renderSize.height === h) {\r\n                return false;\r\n            }\r\n            debug('RENDERER RESIZE');\r\n            _this.ctx = {\r\n                height: h,\r\n                heightHalf: h / 2,\r\n                width: w,\r\n                widthHalf: w / 2,\r\n            };\r\n            var zoom = _this.camera.zoom;\r\n            var position = _this.camera.position.clone();\r\n            _this.initCamera();\r\n            _this.camera.zoom = zoom;\r\n            _this.camera.position.set(position.x, position.y, position.z);\r\n            _this.camera.updateProjectionMatrix();\r\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\r\n            _this.renderer.setSize(w, h);\r\n            _this.renderer.setClearColor(new three_1.Color().setRGB(38 / 255, 50 / 255, 78 / 255));\r\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\r\n            return true;\r\n        };\r\n        /**\r\n         * This method handles emitting the viewport and the current visible elements\r\n         * to the subclass that needs detailed information regarding the viewport.\r\n         */\r\n        _this.emitViewport = function () {\r\n            var tl = _this.screenToWorld(0, 0);\r\n            var br = _this.screenToWorld(_this.ctx.width, _this.ctx.height);\r\n            _this.camera.updateMatrixWorld(true);\r\n            var visible = _this.quadTree.query(new bounds_1.Bounds(tl.x, br.x, tl.y, br.y));\r\n            _this.onViewport(visible, _this.projection, _this.ctx);\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is pressed on the canvas. This\r\n         * engages panning.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseDown = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            _this.isPanning = true;\r\n            _this.distance = 0;\r\n            _this.onMouseDown();\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is release or left the canvas. This\r\n         * stops panning.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseOut = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            _this.isPanning = false;\r\n            _this.distance = 0;\r\n            _this.onMouseOut();\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is released on the canvas. This\r\n         * stops panning and engages click events.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseUp = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            _this.isPanning = false;\r\n            var mouse = mouse_1.eventElementPosition(e);\r\n            var world = _this.screenToWorld(mouse.x, mouse.y);\r\n            // Handle mouse interaction\r\n            if (_this.distance < 5) {\r\n                var hitInside = [];\r\n                // Circle Interaction\r\n                var hitItems = _this.quadTree.query(world);\r\n                for (var _i = 0, hitItems_1 = hitItems; _i < hitItems_1.length; _i++) {\r\n                    var item = hitItems_1[_i];\r\n                    // Fine tuning for interaction\r\n                    if (item.pointInside(world)) {\r\n                        hitInside.push(item);\r\n                    }\r\n                }\r\n                // Tell the listener that the user clicked on some items\r\n                if (hitInside.length) {\r\n                    _this.onMouseUp(e, hitInside, mouse, world, _this.projection);\r\n                }\r\n                else {\r\n                    _this.onMouseUp(e, null, mouse, world, _this.projection);\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Handles mouse interactions when the mouse is moving on the canvas. This\r\n         * causes panning and hover events.\r\n         *\r\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\r\n         */\r\n        _this.handleMouseMove = function (e) {\r\n            // Quick quit if mouse interactions are disabled\r\n            if (_this.disableMouseInteraction > 0) {\r\n                return;\r\n            }\r\n            var onMouse = _this.props.onMouse;\r\n            var zoom = _this.props.zoom;\r\n            var mouse = mouse_1.eventElementPosition(e);\r\n            var world = _this.screenToWorld(mouse.x, mouse.y);\r\n            _this.distance++;\r\n            debug('mouse X %o Y %o', mouse.x, mouse.y);\r\n            // Handle panning\r\n            if (_this.isPanning) {\r\n                var xDistance = (mouse.x - _this.lastMousePosition.x) / _this.targetZoom;\r\n                var yDistance = -(mouse.y - _this.lastMousePosition.y) / _this.targetZoom;\r\n                // Execute the hook to allow subclasses\r\n                var pan = _this.willPan(xDistance, yDistance);\r\n                xDistance = pan.x;\r\n                yDistance = pan.y;\r\n                _this.destinationX -= xDistance;\r\n                _this.destinationY -= yDistance;\r\n                _this.inertia = _this.inertia || { x: 0, y: 0 };\r\n                if (sign(xDistance) !== sign(_this.inertia.x)) {\r\n                    _this.inertia.x = 0;\r\n                }\r\n                if (sign(yDistance) !== sign(_this.inertia.y)) {\r\n                    _this.inertia.y = 0;\r\n                }\r\n                _this.inertia.x = xDistance * _this.inertiaBuild;\r\n                _this.inertia.y = yDistance * _this.inertiaBuild;\r\n                var maxInertia = _this.inertiaMax / zoom;\r\n                var mag = Math.sqrt(_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y);\r\n                // Make sure the magnitude of the inertia is less than our max allowed\r\n                if (mag > maxInertia) {\r\n                    // Since it's greater, let's confine the inertia's magnitude to the max magnitude\r\n                    // By normalizing the intertia vector and multilying it by the max\r\n                    _this.inertia.x = (_this.inertia.x / mag) * maxInertia;\r\n                    _this.inertia.y = (_this.inertia.y / mag) * maxInertia;\r\n                }\r\n            }\r\n            if (_this.quadTree && !_this.isPanning) {\r\n                // Empty the last hovered items to populate a new list\r\n                var currentHoverItems = [];\r\n                // Handle mouse interaction with items\r\n                // Interaction with circles\r\n                var hitItems = _this.quadTree.query(world);\r\n                var hitInside = [];\r\n                for (var _i = 0, hitItems_2 = hitItems; _i < hitItems_2.length; _i++) {\r\n                    var item = hitItems_2[_i];\r\n                    // Fine tuning for interaction\r\n                    if (item.pointInside(world)) {\r\n                        hitInside.push(item);\r\n                        currentHoverItems.push(item);\r\n                    }\r\n                }\r\n                // Inform of all items hit or hovered\r\n                _this.onMouseHover(hitInside, mouse, world, _this.projection);\r\n                // Diff the currently hovered items with the old ones to see what is\r\n                // No longer hit\r\n                var left = [];\r\n                for (var _a = 0, _b = _this.currentHoverItems; _a < _b.length; _a++) {\r\n                    var item = _b[_a];\r\n                    if (currentHoverItems.indexOf(item) < 0) {\r\n                        left.push(item);\r\n                    }\r\n                }\r\n                // Inform of all items no longer hovered\r\n                _this.onMouseLeave(left, mouse, world, _this.projection);\r\n                _this.currentHoverItems = currentHoverItems;\r\n            }\r\n            if (onMouse) {\r\n                _this.onMouse(mouse, world, _this.isPanning);\r\n            }\r\n            _this.lastMousePosition = mouse;\r\n        };\r\n        /**\r\n         * We make the ref application be a declared function so react does not find the need to execute the\r\n         * application numerous times for a detected changed method\r\n         *\r\n         * @param {HTMLElement} n This is the canvas element from the dom\r\n         */\r\n        _this.applyRef = function (n) {\r\n            _this.init(n, _this.props.width, _this.props.height);\r\n            _this.applyProps(_this.props);\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * This is a hook so subclasses can contribute animated methods to the animation loop and organize the base methods\r\n     * as desired.\r\n     *\r\n     * @param {AnimatedMethodLookup} baseAnimatedMethods The base animated methods referenceable by name\r\n     * @param {AnimatedMethod[]} orderedBaseAnimatedMethods The base animated methods in their default order for ease of use\r\n     *\r\n     * @return {AnimatedMethods[]} The list of animated methods in the order they are expected to be executed\r\n     */\r\n    WebGLSurface.prototype.animatedMethods = function (baseAnimatedMethods, orderedBaseAnimatedMethods) {\r\n        // Default functionality is to use the simple preordered list\r\n        return orderedBaseAnimatedMethods;\r\n    };\r\n    /**\r\n     * This generates the base animated methods lookup.\r\n     * We do not make these methods a part of the class as this is the base class\r\n     * We want the start up methods to be inconsequential to sub classes, thus allowing\r\n     * us to override, sort, or replace the initial methods and have the method get garbage\r\n     * collected and no longer a part of the object. It is recommended to make the sub classes\r\n     * actually point to class methods for better clarity\r\n     *\r\n     * @return {ANimatedMethodLookup} The base animated methods in a lookup\r\n     */\r\n    WebGLSurface.prototype.animatedMethodsBase = function () {\r\n        var _this = this;\r\n        return _a = {},\r\n            // Context changes and early checks\r\n            _a[BaseAnimatedMethods.CONTEXT] = function () {\r\n                var response = {\r\n                    break: false,\r\n                    doDraw: false,\r\n                };\r\n                if (_this.resizeContext()) {\r\n                    response.doDraw = true;\r\n                }\r\n                // Quadtree MUST be present to do proper computations\r\n                if (!_this.quadTree) {\r\n                    response.break = true;\r\n                }\r\n                return response;\r\n            },\r\n            // Apply inertia\r\n            _a[BaseAnimatedMethods.INERTIA] = function () {\r\n                if (!_this.isPanning) {\r\n                    if (_this.inertia) {\r\n                        // Disabled inertia for now\r\n                        // This.destinationX -= this.inertia.x\r\n                        // This.destinationY -= this.inertia.y\r\n                        _this.inertia.x *= _this.inertiaDecay;\r\n                        _this.inertia.y *= _this.inertiaDecay;\r\n                        if (_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y < 1) {\r\n                            _this.inertia = null;\r\n                        }\r\n                    }\r\n                }\r\n                // A non response\r\n                return {\r\n                    doDraw: false,\r\n                };\r\n            },\r\n            // Apply position\r\n            _a[BaseAnimatedMethods.POSITION] = function () {\r\n                // If values are transitioned rather than immediately applied, this is\r\n                // The value you would want the minimum change to be before cutting off\r\n                // The transition\r\n                // Const minAdjust = 1 / this.props.zoom\r\n                // If there is change in X apply the new position to the old\r\n                // This is where animated values were originally placed and can be placed\r\n                // Again if a transition is desired\r\n                var response = {\r\n                    doDraw: (_this.currentX !== _this.destinationX) || (_this.currentY !== _this.destinationY),\r\n                };\r\n                _this.currentX = _this.destinationX;\r\n                _this.currentY = _this.destinationY;\r\n                _this.positionCamera(_this.currentX, _this.currentY);\r\n                return response;\r\n            },\r\n            // Apply zooming\r\n            _a[BaseAnimatedMethods.ZOOM] = function () {\r\n                var response = {\r\n                    doDraw: false,\r\n                };\r\n                // Apply Zoom\r\n                // Const zoomToFitH = this.ctx.width / Math.max(this.quadTree.bounds.width, this.props.viewport.width);\r\n                // Const zoomToFitV = this.ctx.height / Math.max(this.quadTree.bounds.height, this.props.viewport.height);\r\n                // Const zoomToFit = Math.min(zoomToFitH, zoomToFitV);\r\n                var zoomToFit = 1;\r\n                var destZoom = _this.destinationZoom * zoomToFit;\r\n                var dZoom = Math.abs(destZoom - _this.targetZoom);\r\n                var minDZoom = MIN_ZOOM_INCREMENT;\r\n                var zoomRate = 3;\r\n                if (dZoom > minDZoom) {\r\n                    _this.targetZoom = _this.targetZoom + ((destZoom - _this.targetZoom) / zoomRate);\r\n                    response.doDraw = true;\r\n                }\r\n                else if (dZoom !== 0) {\r\n                    _this.targetZoom = destZoom;\r\n                    response.doDraw = true;\r\n                }\r\n                // Get the zoom target metrics before zooming\r\n                var zoomTargetX = _this.zoomTargetX;\r\n                var zoomTargetY = _this.zoomTargetY;\r\n                var screenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\r\n                // Update the camera zoom level\r\n                _this.zoomCamera(_this.targetZoom);\r\n                // After we have zoomed we see how much our target location moved on screen\r\n                var newScreenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\r\n                // Now we move our screen by the moved delta to keep it exactly where it was before hand\r\n                var zoomDX = -(newScreenZoomTarget.x - screenZoomTarget.x) / _this.targetZoom;\r\n                var zoomDY = (newScreenZoomTarget.y - screenZoomTarget.y) / _this.targetZoom;\r\n                _this.currentX -= zoomDX;\r\n                _this.currentY -= zoomDY;\r\n                _this.destinationX -= zoomDX;\r\n                _this.destinationY -= zoomDY;\r\n                _this.positionCamera(_this.currentX, _this.currentY);\r\n                return response;\r\n            },\r\n            _a;\r\n        var _a;\r\n    };\r\n    /**\r\n     * This is a hook for subclasses to be able to apply buffer changes that rely\r\n     * on colors rendered into the atlas after the system has prepped the colors for render.\r\n     */\r\n    WebGLSurface.prototype.applyColorBufferChanges = function (props) {\r\n        // Note: For subclasses\r\n    };\r\n    /**\r\n     * This is a hook for subclasses to be able to apply label buffer changes after the system has\r\n     * prepped the labels for render.\r\n     */\r\n    WebGLSurface.prototype.applyLabelBufferChanges = function (props) {\r\n        // Note: For subclasses\r\n    };\r\n    /**\r\n     * @override\r\n     * This is a hook so subclasses can contribute property application methods to the applyProps process and organize the base methods\r\n     * as desired.\r\n     *\r\n     * @param {ApplyPropsMethodLookup<T>} basePropsMethods The base props methods referenceable by name\r\n     * @param {ApplyPropsMethod<T>[]} orderedBasePropsMethods The base animated methods in their default order for ease of use\r\n     *\r\n     * @return {ApplyPropsMethod<T>[]} The list of property application methods in the order they are expected to be executed\r\n     */\r\n    WebGLSurface.prototype.applyPropsMethods = function (basePropsMethods, orderedBasePropsMethods) {\r\n        // Default functionality is to use the simple preordered list\r\n        return orderedBasePropsMethods;\r\n    };\r\n    /**\r\n     * This is a hook so subclasses can contribute methods to the applying props procedure and organize the base methods\r\n     * as desired.\r\n     *\r\n     * @return {ApplyPropsMethodLookup<T>} The base apply props method that are indexed for ease of reference\r\n     */\r\n    WebGLSurface.prototype.applyPropsMethodsBase = function () {\r\n        var _this = this;\r\n        return _a = {},\r\n            _a[BaseApplyPropsMethods.INITIALIZE] = function (props) {\r\n                var height = props.height, width = props.width;\r\n                _this.init(_this.renderEl, width, height);\r\n                if (!_this.renderEl || width === 0 || height === 0) {\r\n                    return {\r\n                        break: true,\r\n                    };\r\n                }\r\n                // Get the target for zooming\r\n                if (_this.camera) {\r\n                    var world = _this.screenToWorld(_this.lastMousePosition.x, _this.lastMousePosition.y);\r\n                    _this.zoomTargetX = world.x;\r\n                    _this.zoomTargetY = world.y;\r\n                }\r\n                debug('props', props);\r\n                return {};\r\n            },\r\n            _a[BaseApplyPropsMethods.LABELS] = function (props) {\r\n                var response = {};\r\n                // If we have a new labels reference we must regenerate the labels in our image lookup\r\n                if (props.labels && props.labels !== _this.labels) {\r\n                    debugLabels('Labels are being comitted to an Atlas %o', props.labels);\r\n                    // Flag the labels as incapable of rendering\r\n                    _this.labelsReady = false;\r\n                    _this.labelsLoadId++;\r\n                    // Store the set of labels we are rendering so that they do not get re-generated\r\n                    // In the atlas rapidly.\r\n                    _this.labels = props.labels;\r\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.labels)) {\r\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.labels);\r\n                    }\r\n                    var textures = props.labels.map(function (label) { return new atlas_texture_1.AtlasTexture(null, label); });\r\n                    debugLabels('Creating the atlas for labels based on these textures %o', textures);\r\n                    _this.atlasManager.createAtlas(_this.atlasNames.labels, textures)\r\n                        .then(function () {\r\n                        debugLabels('Labels rasterized within the atlas!');\r\n                        _this.forceDraw = true;\r\n                        _this.labelsCurrentLoadedId++;\r\n                        // If we are done loading AND we match up with the current load id, then labels\r\n                        // For the latest labels update are indeed ready for display\r\n                        if (_this.labelsCurrentLoadedId === _this.labelsLoadId) {\r\n                            _this.labelsReady = true;\r\n                        }\r\n                        // Reapply the props so any buffers that were not updating can update now\r\n                        _this.applyProps(_this.props);\r\n                    });\r\n                }\r\n                return response;\r\n            },\r\n            _a[BaseApplyPropsMethods.COLORS] = function (props) {\r\n                var response = {};\r\n                // If we have a new labels reference we must regenerate the labels in our image lookup\r\n                if (props.colors && props.colors !== _this.colors) {\r\n                    debugLabels('Colors are being comitted to an Atlas %o', props.colors);\r\n                    // Flag the labels as incapable of rendering\r\n                    _this.colorsReady = false;\r\n                    // Store the set of labels we are rendering so that they do not get re-generated\r\n                    // In the atlas rapidly.\r\n                    _this.colors = props.colors;\r\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.colors)) {\r\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.colors);\r\n                    }\r\n                    debugLabels('Creating the atlas for colors based on these colors %o', _this.colors);\r\n                    _this.atlasManager.createAtlas(_this.atlasNames.colors, null, _this.colors)\r\n                        .then(function () {\r\n                        debugLabels('Colors rasterized within the atlas!');\r\n                        _this.forceDraw = true;\r\n                        _this.colorsReady = true;\r\n                        // Reapply the props so any buffers that were not updating can update now\r\n                        _this.applyProps(_this.props);\r\n                    });\r\n                }\r\n                return response;\r\n            },\r\n            _a[BaseApplyPropsMethods.BUFFERCHANGES] = function (props) {\r\n                // Call the hook to allow sub componentry to have a place to update it's buffers\r\n                _this.applyBufferChanges(props);\r\n                // We call the label buffering when the labels are ready to render.\r\n                // Labels now utilize the color atlas as well, thus requiring colors\r\n                // To be loaded\r\n                if (_this.labelsReady && _this.colorsReady) {\r\n                    debugLabels('labels changed %o', props);\r\n                    _this.applyLabelBufferChanges(props);\r\n                }\r\n                // For resources that only need the color atlas to be ready\r\n                if (_this.colorsReady) {\r\n                    _this.applyColorBufferChanges(props);\r\n                }\r\n                return {};\r\n            },\r\n            _a[BaseApplyPropsMethods.CAMERA] = function (props) {\r\n                _this.destinationZoom = props.zoom;\r\n                // On initialization this should start with some base camera metrics\r\n                if (props.viewport && props.viewport !== _this.appliedViewport && _this.quadTree) {\r\n                    debugCam('Applying viewport to camera: %o World Space Bounds: %o Screen context: %o', props.viewport, _this.quadTree.bounds, { width: props.width, height: props.height });\r\n                    // Position the camera over the mid of the specified viewport\r\n                    var mid = props.viewport.mid;\r\n                    _this.currentX = _this.destinationX = mid.x;\r\n                    _this.currentY = _this.destinationY = mid.y;\r\n                    // Calculate the zoom level when the input zoom is at 1\r\n                    var zoomAtOne = 1;\r\n                    // Calculate the zoom needed for the viewport\r\n                    var zoomToFitViewH = props.width / props.viewport.width;\r\n                    var zoomToFitViewV = props.height / props.viewport.height;\r\n                    var zoomToFit = Math.min(zoomToFitViewH, zoomToFitViewV);\r\n                    // This adjusts the destination zxoom by a tiny amount so the view will redraw\r\n                    var microAdjustment = 1.001;\r\n                    // Make our destination zoom a zoom that will fit the dimensions of the viewport\r\n                    // Relative to the zoom at one level\r\n                    _this.destinationZoom = zoomToFit / zoomAtOne;\r\n                    _this.targetZoom = (_this.destinationZoom * zoomAtOne) * microAdjustment;\r\n                    // Make sure any zooming that happens occurs over the middle of the initial viewport\r\n                    _this.zoomTargetX = mid.x;\r\n                    _this.zoomTargetY = mid.y;\r\n                    // Make sure mouse position doesn't mess with the zooming focus either\r\n                    _this.lastMousePosition.x = props.width / 2.0;\r\n                    _this.lastMousePosition.y = props.height / 2.0;\r\n                    // Apply the values immediately to the camera\r\n                    _this.positionCamera(_this.currentX, _this.currentY);\r\n                    _this.zoomCamera(_this.targetZoom);\r\n                    _this.updateCameraUniforms();\r\n                    // We request the calculated zoom level so adjustments on the input can be made\r\n                    if (props.onZoomRequest) {\r\n                        props.onZoomRequest(_this.destinationZoom);\r\n                        debugCam('Requesting zoom level', _this.destinationZoom);\r\n                    }\r\n                    // Let's disable mouse interactions for a little bit until the camera has settled into place\r\n                    var framesToDisable = 10;\r\n                    _this.disableMouseInteraction = framesToDisable;\r\n                    _this.appliedViewport = props.viewport;\r\n                    debugCam('init cam', _this.currentX, _this.currentY);\r\n                }\r\n                // Ensure we have our quad tree available even if it is empty\r\n                if (!_this.quadTree) {\r\n                    _this.quadTree = new quad_tree_1.QuadTree(0, 1, 1, 0);\r\n                }\r\n                return {};\r\n            },\r\n            _a;\r\n        var _a;\r\n    };\r\n    /**\r\n     * This is a hook for sub components to have a location to update their buffers\r\n     *\r\n     * @param {T} props This is the next set of props that are going to be applied to this component\r\n     */\r\n    WebGLSurface.prototype.applyBufferChanges = function (props) {\r\n        // NOTE: This will be implemented by base classes\r\n    };\r\n    /**\r\n     * @override\r\n     * Start the update loop and register any interesting listeners\r\n     */\r\n    WebGLSurface.prototype.componentDidMount = function () {\r\n        this.animate();\r\n    };\r\n    /**\r\n     * @override\r\n     * This will set up any unchanging context as well as establish the set of methods\r\n     * that are to be used within constructed method loops.\r\n     */\r\n    WebGLSurface.prototype.componentWillMount = function () {\r\n        /** Create our context bound projection methods for handing to processes that may need them */\r\n        this.projection = {\r\n            screenSizeToWorld: this.screenSizeToWorld.bind(this),\r\n            screenToWorld: this.screenToWorld.bind(this),\r\n            worldSizeToScreen: this.worldSizeToScreen.bind(this),\r\n            worldToScreen: this.worldToScreen.bind(this),\r\n        };\r\n        /** Generate our applying props methods to execute within our applyProps process */\r\n        var basePropsMethods = this.applyPropsMethodsBase();\r\n        this.propsMethodList = this.applyPropsMethods(basePropsMethods, [\r\n            basePropsMethods[BaseApplyPropsMethods.INITIALIZE],\r\n            basePropsMethods[BaseApplyPropsMethods.LABELS],\r\n            basePropsMethods[BaseApplyPropsMethods.COLORS],\r\n            basePropsMethods[BaseApplyPropsMethods.BUFFERCHANGES],\r\n            basePropsMethods[BaseApplyPropsMethods.CAMERA],\r\n        ]);\r\n        /** Generate our animated methods to execute within our animation loop */\r\n        var baseAnimatedMethods = this.animatedMethodsBase();\r\n        this.animatedMethodList = this.animatedMethods(baseAnimatedMethods, [\r\n            baseAnimatedMethods[BaseAnimatedMethods.CONTEXT],\r\n            baseAnimatedMethods[BaseAnimatedMethods.INERTIA],\r\n            baseAnimatedMethods[BaseAnimatedMethods.POSITION],\r\n            baseAnimatedMethods[BaseAnimatedMethods.ZOOM],\r\n        ]);\r\n    };\r\n    /**\r\n     * @override\r\n     * Simply applies the new injected props\r\n     *\r\n     * @param {T} props The new properties to be applied to this component\r\n     */\r\n    WebGLSurface.prototype.componentWillReceiveProps = function (props) {\r\n        this.applyProps(props);\r\n    };\r\n    /**\r\n     * @override\r\n     * Release listeners and stop update loop\r\n     */\r\n    WebGLSurface.prototype.componentWillUnmount = function () {\r\n        this.stop = true;\r\n        if (this.quadTree) {\r\n            this.quadTree.destroy();\r\n        }\r\n        this.quadTree = null;\r\n        this.camera = null;\r\n        this.sizeCamera = null;\r\n        this.ctx = null;\r\n        this.renderEl = null;\r\n        this.renderer = null;\r\n        this.scene = null;\r\n    };\r\n    /**\r\n     * This is a hook allowing sub classes to have a place to initialize their buffers\r\n     * and materials etc.\r\n     */\r\n    WebGLSurface.prototype.initBuffers = function () {\r\n        // NOTE: This is to be implemented by subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to when the mouse moves. Provides some information\r\n     * about mouse location and interaction.\r\n     *\r\n     * @param {IPoint} mouse Position of the mouse relative to the canvas\r\n     * @param {IPoint} world Position of the mouse relative to the world space\r\n     * @param {boolean} isPanning The panning state of the mouse\r\n     */\r\n    WebGLSurface.prototype.onMouse = function (mouse, world, isPanning) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to mouse down events\r\n     */\r\n    WebGLSurface.prototype.onMouseDown = function () {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to mouse out events\r\n     */\r\n    WebGLSurface.prototype.onMouseOut = function () {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to mouse up events and the items that were interacted with in the process\r\n     *\r\n     * @param {React.MouseEvent} e The react synthetic event associated with the action\r\n     * @param {Bounds[]} hitInside The items the mouse interacted with\r\n     * @param {IPoint} mouse The location of the mouse on the screen\r\n     * @param {IPoint} world The location of the mouse projected into the world\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     */\r\n    WebGLSurface.prototype.onMouseUp = function (e, hitInside, mouse, world, projection) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to the mouse hovering over an item included in the quadtree\r\n     *\r\n     * @param {Bounds[]} hitInside The items hovered over by the mouse\r\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\r\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     */\r\n    WebGLSurface.prototype.onMouseHover = function (hitInside, mouse, world, projection) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to the mouse leaving an item included in the quadtree\r\n     *\r\n     * @param {Bounds[]} left The items no longer hovered over by the mouse\r\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\r\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     */\r\n    WebGLSurface.prototype.onMouseLeave = function (left, mouse, world, projection) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Hook for subclasses to respond to changes in the viewport and currently visible items\r\n     *\r\n     * @param {Bounds[]} visible\r\n     * @param {IProjection} projection The projection methods to go between the screen and world space\r\n     * @param {IScreenContext} ctx\r\n     */\r\n    WebGLSurface.prototype.onViewport = function (visible, projection, ctx) {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * Places the camera at a given location in world space\r\n     *\r\n     * @param {number} x The x-coordinate for the camera in world space\r\n     * @param {number} y The x-coordinate for the camera in world space\r\n     */\r\n    WebGLSurface.prototype.positionCamera = function (x, y) {\r\n        if (this.camera) {\r\n            this.camera.position.set(Math.floor(x), Math.floor(y), this.camera.position.z);\r\n        }\r\n    };\r\n    /**\r\n     * Projects a screen coordinate to a world coordinate\r\n     *\r\n     * @param {number} x The x coord within the screen to project into the world\r\n     * @param {number} y The y coord within the screen to project into the world\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {object} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.screenToWorld = function (x, y, obj) {\r\n        // Get the coordinates in normalized screen space\r\n        vector.set((x / this.ctx.width) * 2 - 1, -(y / this.ctx.height) * 2 + 1, 0.0);\r\n        // Unproject the normalized space to the world. It will project\r\n        // The vector to a REALLY far away z coordinate, but it does not matter\r\n        // Since we are utilizing an orthographic camera (no perspective distortion)\r\n        vector.unproject(this.camera);\r\n        obj = obj || { x: 0, y: 0 };\r\n        obj.x = vector.x;\r\n        obj.y = vector.y;\r\n        return obj;\r\n    };\r\n    /**\r\n     * Projects a size on the screen to the size represented in the world\r\n     *\r\n     * @param {number} w The size of the width on the screen to project to the world\r\n     * @param {number} h The size of the height on the screen to project to the world\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {object} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.screenSizeToWorld = function (w, h, obj) {\r\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\r\n        obj.width = w / (this.sizeCamera ? this.sizeCamera.zoom : 1);\r\n        obj.height = h / (this.sizeCamera ? this.sizeCamera.zoom : 1);\r\n        return obj;\r\n    };\r\n    /**\r\n     * Projects a world coordinate to the screen\r\n     *\r\n     * @param {number} x The x coord in the world to project to the screen\r\n     * @param {number} y The y coord in the world to project to the screen\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {IPoint} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.worldToScreen = function (x, y, obj) {\r\n        // This projects to NORMALIZED screen space (-1, 1) range for x and y\r\n        vector.set(x, y, 0);\r\n        vector.project(this.camera);\r\n        // Use the window dimensions to denormalize the vector\r\n        obj = ramda_1.merge(obj || {}, {\r\n            x: (vector.x * this.ctx.widthHalf) + this.ctx.widthHalf,\r\n            y: -(vector.y * this.ctx.heightHalf) + this.ctx.heightHalf,\r\n        });\r\n        return obj;\r\n    };\r\n    /**\r\n     * Projects a size within the world to how it would appear on the screen\r\n     *\r\n     * @param {number} w The size of the width on the screen to project to the world\r\n     * @param {number} h The size of the height on the screen to project to the world\r\n     * @param {object} obj An optional object in which the projected dimensions will\r\n     *                     be injected to\r\n     *\r\n     * @return {object} Either a new object with the projected dimensions or the object\r\n     *                  Insertted as a param that has the properties injected into\r\n     */\r\n    WebGLSurface.prototype.worldSizeToScreen = function (w, h, obj) {\r\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\r\n        obj.width = w * this.sizeCamera.zoom;\r\n        obj.height = h * this.sizeCamera.zoom;\r\n        return obj;\r\n    };\r\n    /**\r\n     * Sets the zoom level the camera will view the world with\r\n     *\r\n     * @param {number} zoom The zoom level. Must be > 0\r\n     */\r\n    WebGLSurface.prototype.zoomCamera = function (zoom) {\r\n        this.camera.zoom = zoom;\r\n        this.sizeCamera.zoom = zoom;\r\n        this.camera.updateProjectionMatrix();\r\n        this.sizeCamera.updateProjectionMatrix();\r\n    };\r\n    /**\r\n     * This is a hook allowing a sub class to update uniforms when the camera is changed in\r\n     * any way\r\n     */\r\n    WebGLSurface.prototype.updateCameraUniforms = function () {\r\n        // NOTE: For subclasses\r\n    };\r\n    /**\r\n     * @override\r\n     * Only re-render if the dimensions of the component have changed. All other\r\n     * internal render updates are handled internally\r\n     *\r\n     * @param {T} nextProps The next properties injected\r\n     */\r\n    WebGLSurface.prototype.shouldComponentUpdate = function (nextProps) {\r\n        return this.props.width !== nextProps.width || this.props.height !== nextProps.height;\r\n    };\r\n    /**\r\n     * Hook to allow subclasses some control over panning distances\r\n     *\r\n     * @param {number} distanceX The distance to pan in the x direction\r\n     * @param {number} distanceY The distance to pan in the y direction\r\n     *\r\n     * @return {Vector3} The vector indicating the direction to pan\r\n     */\r\n    WebGLSurface.prototype.willPan = function (distanceX, distanceY) {\r\n        return new three_1.Vector3(distanceX, distanceY, 0.0);\r\n    };\r\n    // -----[ Render ]---------------------------------------------\r\n    //\r\n    // In a React app, it's nice to put the render function at the bottom of the\r\n    // File\r\n    /**\r\n     * This should only attempt rendering when the canvas DOM element needs to be resized.\r\n     * You will note shouldComponentUpdate helps facilitate this.\r\n     */\r\n    WebGLSurface.prototype.render = function () {\r\n        var _this = this;\r\n        var _a = this.props, width = _a.width, height = _a.height;\r\n        if (!WEBGL_SUPPORTED) {\r\n            return React.createElement(\"div\", null, this.props.children || 'Web GL not supported');\r\n        }\r\n        return (React.createElement(\"div\", { onMouseDown: this.handleMouseDown, onMouseOut: this.handleMouseOut, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseOut, onMouseMove: this.handleMouseMove, onDoubleClick: function (e) {\r\n                if (_this.props.onDoubleClick) {\r\n                    _this.props.onDoubleClick(e);\r\n                }\r\n            }, style: { position: 'relative', width: width, height: height } },\r\n            React.createElement(\"div\", { ref: this.applyRef })));\r\n    };\r\n    return WebGLSurface;\r\n}(React.Component));\r\nexports.WebGLSurface = WebGLSurface;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/webgl-surface.tsx\n// module id = 22\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_23__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 23\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 24\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/debug.js\n// module id = 25\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms/index.js\n// module id = 26\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_27__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bowser\"\n// module id = 27\n// module chunks = 0","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./animated/shared-control-curved-line-buffer-ants\"));\r\n__export(require(\"./base-buffer\"));\r\n__export(require(\"./static/shared-control-curved-line-buffer\"));\r\n__export(require(\"./static/simple-bezier-line-buffer\"));\r\n__export(require(\"./static/simple-label-buffer\"));\r\n__export(require(\"./static/simple-line-buffer\"));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/index.ts\n// module id = 28\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\nvar buffer_util_1 = require(\"../../util/buffer-util\");\r\nvar base_buffer_1 = require(\"../base-buffer\");\r\n/**\r\n * This renders a curved line by injecting all attributes needed to render it.\r\n * This naively includes all possible data in the vertex.\r\n *\r\n * This only supports atlas colors.\r\n */\r\nvar SharedControlCurvedLineBufferAnts = (function (_super) {\r\n    __extends(SharedControlCurvedLineBufferAnts, _super);\r\n    function SharedControlCurvedLineBufferAnts() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SharedControlCurvedLineBufferAnts.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'startColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'endColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [1],\r\n                name: 'normalDirection',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'endPoints',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'halfLinewidth',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'marching',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\r\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\r\n     *                                    needed for rendering with color picks.\r\n     */\r\n    SharedControlCurvedLineBufferAnts.prototype.update = function (shapeBuffer, atlasManager, sharedControl) {\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        // As this is a single material, we have to assume that the color atlas\r\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\r\n        // Information for one color will be valid for all colors\r\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\r\n            var colorRef = shapeBuffer[0].startColor;\r\n            var colorBase = colorRef.base;\r\n            // Update all uniforms for this material to utilize the atlas metrics for\r\n            // Picking colors\r\n            var material = this.bufferItems.system.material;\r\n            var uniforms = material.uniforms;\r\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\r\n            uniforms.colorAtlas.value = atlas;\r\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\r\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\r\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\r\n            // This is the shared control point for all of the vertices\r\n            uniforms.controlPoint.value = [sharedControl.x, sharedControl.y];\r\n            atlas.needsUpdate = true;\r\n        }\r\n        // Commit static curved lines\r\n        var colorAttributeSize = 1;\r\n        var marchingAttributeSize = 4;\r\n        var numVerticesPerSegment = 6;\r\n        var halfWidthSize = 1;\r\n        var length = 15;\r\n        var needsUpdate = false;\r\n        var p1;\r\n        var p2;\r\n        var colorStart;\r\n        var colorEnd;\r\n        var alpha;\r\n        var antLength;\r\n        var antGap;\r\n        var antSpeed;\r\n        // We can not accurately send very large numbers via float point into the attributes\r\n        // So we trim down our time sent to the attribute down to a number that is less than\r\n        // 16,777,217 which means we can only reliably grab the last 7 digits of the date's time\r\n        var antStartTime = 0;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var _loop_1 = function (curvedLine) {\r\n            // We will not render the curved line with this buffer if the marching ants are not provided\r\n            if (!curvedLine.marchingAnts) {\r\n                console.error('Attempted to render a curved line shape with a marching ant buffer but provided no marching ant metrics. This curved line shape will be skipped', curvedLine);\r\n                return \"continue\";\r\n            }\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            colorStart = curvedLine.startColor.base;\r\n            colorEnd = curvedLine.endColor.base;\r\n            halfWidthSize = curvedLine.lineWidth / 2.0;\r\n            length = curvedLine.resolution;\r\n            p1 = curvedLine.p1;\r\n            p2 = curvedLine.p2;\r\n            antGap = curvedLine.marchingAnts.gapLength;\r\n            antSpeed = curvedLine.marchingAnts.speed;\r\n            antLength = curvedLine.marchingAnts.strokeLength + curvedLine.marchingAnts.gapLength;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, marching, mpos) {\r\n                // Copy first vertex twice for intro degenerate tri\r\n                positions[ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[wpos] = halfWidthSize;\r\n                // Skip over degenerate tris color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                mpos += marchingAttributeSize;\r\n                normals[npos] = 1;\r\n                endPoints[epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                // TR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[scpos] = colorStart.colorIndex;\r\n                endColor[ecpos] = colorEnd.colorIndex;\r\n                marching[mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // BR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                marching[++mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // TL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                marching[++mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // BL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                marching[++mpos] = antStartTime;\r\n                marching[++mpos] = antSpeed;\r\n                marching[++mpos] = antGap;\r\n                marching[++mpos] = antLength;\r\n                // Copy last vertex again for degenerate tri\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                // Skip over degenerate tris for color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                mpos += marchingAttributeSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n            });\r\n            // If no updating is happening, just quit the loop\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        // Only if updates happened, should this change\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SharedControlCurvedLineBufferAnts;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SharedControlCurvedLineBufferAnts = SharedControlCurvedLineBufferAnts;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/animated/shared-control-curved-line-buffer-ants.ts\n// module id = 29\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\nvar buffer_util_1 = require(\"../../util/buffer-util\");\r\nvar base_buffer_1 = require(\"../base-buffer\");\r\n/**\r\n * This renders a curved line by injecting all attributes needed to render it.\r\n * This naively includes all possible data in the vertex.\r\n *\r\n * This only supports atlas colors.\r\n */\r\nvar SharedControlCurvedLineBuffer = (function (_super) {\r\n    __extends(SharedControlCurvedLineBuffer, _super);\r\n    function SharedControlCurvedLineBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SharedControlCurvedLineBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'startColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'endColorPick',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [1],\r\n                name: 'normalDirection',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'endPoints',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'halfLinewidth',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\r\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\r\n     *                                    needed for rendering with color picks.\r\n     */\r\n    SharedControlCurvedLineBuffer.prototype.update = function (shapeBuffer, atlasManager, sharedControl) {\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        // As this is a single material, we have to assume that the color atlas\r\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\r\n        // Information for one color will be valid for all colors\r\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\r\n            var colorRef = shapeBuffer[0].startColor;\r\n            var colorBase = colorRef.base;\r\n            // Update all uniforms for this material to utilize the atlas metrics for\r\n            // Picking colors\r\n            var material = this.bufferItems.system.material;\r\n            var uniforms = material.uniforms;\r\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\r\n            uniforms.colorAtlas.value = atlas;\r\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\r\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\r\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\r\n            // This is the shared control point for all of the vertices\r\n            uniforms.controlPoint.value = [sharedControl.x, sharedControl.y];\r\n            atlas.needsUpdate = true;\r\n        }\r\n        // Commit static curved lines\r\n        var colorAttributeSize = 1;\r\n        var numVerticesPerSegment = 6;\r\n        var halfWidthSize = 1;\r\n        var length = 15;\r\n        var needsUpdate = false;\r\n        var p1;\r\n        var p2;\r\n        var colorStart;\r\n        var colorEnd;\r\n        var alpha;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var _loop_1 = function (curvedLine) {\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            colorStart = curvedLine.startColor.base;\r\n            colorEnd = curvedLine.endColor.base;\r\n            halfWidthSize = curvedLine.lineWidth / 2.0;\r\n            length = curvedLine.resolution;\r\n            p1 = curvedLine.p1;\r\n            p2 = curvedLine.p2;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos) {\r\n                // Copy first vertex twice for intro degenerate tri\r\n                positions[ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[wpos] = halfWidthSize;\r\n                // Skip over degenerate tris color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                normals[npos] = 1;\r\n                endPoints[epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                // TR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[scpos] = colorStart.colorIndex;\r\n                endColor[ecpos] = colorEnd.colorIndex;\r\n                // BR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                // TL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                // BL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                startColor[++scpos] = colorStart.colorIndex;\r\n                endColor[++ecpos] = colorEnd.colorIndex;\r\n                // Copy last vertex again for degenerate tri\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                // Skip over degenerate tris for color\r\n                scpos += colorAttributeSize;\r\n                ecpos += colorAttributeSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n            });\r\n            // If no updating is happening, just quit the loop\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        // Only if updates happened, should this change\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SharedControlCurvedLineBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SharedControlCurvedLineBuffer = SharedControlCurvedLineBuffer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/shared-control-curved-line-buffer.ts\n// module id = 30\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\nvar buffer_util_1 = require(\"../../util/buffer-util\");\r\nvar base_buffer_1 = require(\"../base-buffer\");\r\n/**\r\n * This renders a curved line by injecting all attributes needed to render it.\r\n * This naively includes all possible data in the vertex.\r\n *\r\n * This ONLY supports a single color\r\n */\r\nvar SimpleStaticBezierLineBuffer = (function (_super) {\r\n    __extends(SimpleStaticBezierLineBuffer, _super);\r\n    function SimpleStaticBezierLineBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SimpleStaticBezierLineBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 1],\r\n                name: 'customColor',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [1],\r\n                name: 'normalDirection',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 0],\r\n                name: 'endPoints',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n            {\r\n                defaults: [0, 0],\r\n                name: 'controlPoint',\r\n                size: buffer_util_1.AttributeSize.TWO,\r\n            },\r\n            {\r\n                defaults: [0],\r\n                name: 'halfLinewidth',\r\n                size: buffer_util_1.AttributeSize.ONE,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param shapeBuffer\r\n     */\r\n    SimpleStaticBezierLineBuffer.prototype.update = function (shapeBuffer) {\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        // Commit static curved lines\r\n        var colorAttributeSize = 4;\r\n        var numVerticesPerSegment = 6;\r\n        var halfWidthSize = 1;\r\n        var length = 15;\r\n        var needsUpdate = false;\r\n        var p1;\r\n        var p2;\r\n        var color;\r\n        var alpha;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var _loop_1 = function (curvedLine) {\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            color = curvedLine.startColor.base.color;\r\n            halfWidthSize = curvedLine.lineWidth / 2.0;\r\n            length = curvedLine.resolution;\r\n            p1 = curvedLine.p1;\r\n            p2 = curvedLine.p2;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colors, cpos, normals, npos, endPoints, epos, controlPoints, copos, halfWidth, wpos) {\r\n                // Copy first vertex twice for intro degenerate tri\r\n                positions[ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[wpos] = halfWidthSize;\r\n                // Skip over degenerate tris color\r\n                cpos += colorAttributeSize;\r\n                normals[npos] = 1;\r\n                endPoints[epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                // TR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // BR\r\n                positions[++ppos] = (i + 1) / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // TL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = 1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // BL\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // Copy last vertex again for degenerate tri\r\n                positions[++ppos] = i / length;\r\n                positions[++ppos] = length;\r\n                positions[++ppos] = curvedLine.depth;\r\n                halfWidth[++wpos] = halfWidthSize;\r\n                // Skip over degenerate tris for color\r\n                cpos += colorAttributeSize;\r\n                normals[++npos] = -1;\r\n                endPoints[++epos] = p1.x;\r\n                endPoints[++epos] = p1.y;\r\n                endPoints[++epos] = p2.x;\r\n                endPoints[++epos] = p2.y;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\r\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\r\n            });\r\n            // If no updating is happening, just quit the loop\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        // Only if updates happened, should this change\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SimpleStaticBezierLineBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SimpleStaticBezierLineBuffer = SimpleStaticBezierLineBuffer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-bezier-line-buffer.ts\n// module id = 31\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\nvar buffer_util_1 = require(\"../../util/buffer-util\");\r\nvar base_buffer_1 = require(\"../base-buffer\");\r\nvar SimpleStaticLabelBuffer = (function (_super) {\r\n    __extends(SimpleStaticLabelBuffer, _super);\r\n    function SimpleStaticLabelBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SimpleStaticLabelBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'customColor',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 1],\r\n                name: 'texCoord',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0],\r\n                name: 'size',\r\n                size: buffer_util_1.AttributeSize.TWO,\r\n            },\r\n            {\r\n                defaults: [0, 0],\r\n                name: 'anchor',\r\n                size: buffer_util_1.AttributeSize.TWO,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param shapeBuffer\r\n     */\r\n    SimpleStaticLabelBuffer.prototype.update = function (shapeBuffer, atlasManager, startFade, endFade, labelMaxSize) {\r\n        // Make some constants and props for our buffer update loop\r\n        var numVerticesPerQuad = 6;\r\n        var label;\r\n        var texture;\r\n        var color;\r\n        var alpha;\r\n        var anchor;\r\n        var labelSize;\r\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\r\n            var colorRef = shapeBuffer[0].color;\r\n            var colorBase = colorRef.base;\r\n            var material = this.bufferItems.system.material;\r\n            var uniforms = material.uniforms;\r\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\r\n            uniforms.colorAtlas.value = atlas;\r\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\r\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\r\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\r\n            atlas.needsUpdate = true;\r\n            if (startFade || endFade || labelMaxSize) {\r\n                material = this.bufferItems.system.material;\r\n                uniforms = material.uniforms;\r\n                if (startFade)\r\n                    uniforms.startFade.value = startFade;\r\n                if (endFade)\r\n                    uniforms.endFade.value = endFade;\r\n                if (labelMaxSize)\r\n                    uniforms.maxLabelSize.value = labelMaxSize;\r\n            }\r\n        }\r\n        if (!shapeBuffer) {\r\n            return false;\r\n        }\r\n        var updated = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this.bufferItems, numVerticesPerQuad, shapeBuffer.length, function (i, positions, ppos, colors, cpos, texCoords, tpos, sizes, spos, anchors, apos) {\r\n            label = shapeBuffer[i];\r\n            texture = label.rasterizedLabel;\r\n            color = label.color.base;\r\n            alpha = label.color.base.opacity;\r\n            anchor = {\r\n                x: label.getLocation().x + label.getSize().width * Math.cos(label.getRotation()),\r\n                y: label.getLocation().y + label.getSize().width * Math.sin(label.getRotation()),\r\n            };\r\n            labelSize = label.getSize();\r\n            // Make sure the label is updated with it's latest metrics\r\n            label.update();\r\n            // Copy first vertex twice for intro degenerate tri\r\n            positions[ppos] = label.TR.x;\r\n            positions[++ppos] = label.TR.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[tpos] = texture.atlasTR.x;\r\n            texCoords[++tpos] = texture.atlasTR.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[cpos] = color.colorIndex;\r\n            sizes[spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // TR\r\n            positions[++ppos] = label.TR.x;\r\n            positions[++ppos] = label.TR.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasTR.x;\r\n            texCoords[++tpos] = texture.atlasTR.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // BR\r\n            positions[++ppos] = label.BR.x;\r\n            positions[++ppos] = label.BR.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasBR.x;\r\n            texCoords[++tpos] = texture.atlasBR.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // TL\r\n            positions[++ppos] = label.TL.x;\r\n            positions[++ppos] = label.TL.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasTL.x;\r\n            texCoords[++tpos] = texture.atlasTL.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // BL\r\n            positions[++ppos] = label.BL.x;\r\n            positions[++ppos] = label.BL.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasBL.x;\r\n            texCoords[++tpos] = texture.atlasBL.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n            // Copy last vertex again for degenerate tri\r\n            positions[++ppos] = label.BL.x;\r\n            positions[++ppos] = label.BL.y;\r\n            positions[++ppos] = label.depth;\r\n            texCoords[++tpos] = texture.atlasBL.x;\r\n            texCoords[++tpos] = texture.atlasBL.y;\r\n            texCoords[++tpos] = alpha;\r\n            colors[++cpos] = color.colorIndex;\r\n            sizes[++spos] = labelSize.width;\r\n            sizes[++spos] = labelSize.height;\r\n            anchors[++apos] = anchor.x;\r\n            anchors[++apos] = anchor.y;\r\n        });\r\n        this.bufferItems.geometry.setDrawRange(0, numVerticesPerQuad * shapeBuffer.length);\r\n        return updated;\r\n    };\r\n    return SimpleStaticLabelBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SimpleStaticLabelBuffer = SimpleStaticLabelBuffer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-label-buffer.ts\n// module id = 32\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\nvar buffer_util_1 = require(\"../../util/buffer-util\");\r\nvar base_buffer_1 = require(\"../base-buffer\");\r\nvar SimpleStaticLineBuffer = (function (_super) {\r\n    __extends(SimpleStaticLineBuffer, _super);\r\n    function SimpleStaticLineBuffer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     */\r\n    SimpleStaticLineBuffer.prototype.init = function (material, unitCount) {\r\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\r\n        this.bufferItems.attributes = [\r\n            {\r\n                defaults: [0, 0, 0],\r\n                name: 'position',\r\n                size: buffer_util_1.AttributeSize.THREE,\r\n            },\r\n            {\r\n                defaults: [0, 0, 0, 1],\r\n                name: 'customColor',\r\n                size: buffer_util_1.AttributeSize.FOUR,\r\n            },\r\n        ];\r\n        var verticesPerQuad = 6;\r\n        var numQuads = unitCount;\r\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\r\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\r\n        this.bufferItems.system.frustumCulled = false;\r\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\r\n    };\r\n    /**\r\n     * @override\r\n     * See interface definition\r\n     *\r\n     * @param shapeBuffer\r\n     */\r\n    SimpleStaticLineBuffer.prototype.update = function (shapeBuffer) {\r\n        var needsUpdate = false;\r\n        var numVerticesPerSegment = 6;\r\n        var colorAttributeSize = 4;\r\n        var stripPos = 0;\r\n        buffer_util_1.BufferUtil.beginUpdates();\r\n        var TR;\r\n        var BR;\r\n        var TL;\r\n        var BL;\r\n        var color;\r\n        var alpha;\r\n        var _loop_1 = function (curvedLine) {\r\n            var strip = curvedLine.getTriangleStrip();\r\n            color = curvedLine.startColor.base.color;\r\n            alpha = curvedLine.startColor.base.opacity;\r\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, strip.length / 4, function (i, positions, ppos, colors, cpos) {\r\n                stripPos = i * 4;\r\n                TR = strip[stripPos];\r\n                BR = strip[stripPos + 1];\r\n                TL = strip[stripPos + 2];\r\n                BL = strip[stripPos + 3];\r\n                // 1\r\n                positions[ppos] = TR.x;\r\n                positions[++ppos] = TR.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                cpos += colorAttributeSize;\r\n                // 2\r\n                positions[++ppos] = TR.x;\r\n                positions[++ppos] = TR.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 3\r\n                positions[++ppos] = BR.x;\r\n                positions[++ppos] = BR.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 4\r\n                positions[++ppos] = TL.x;\r\n                positions[++ppos] = TL.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 5\r\n                positions[++ppos] = BL.x;\r\n                positions[++ppos] = BL.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                colors[++cpos] = color.r;\r\n                colors[++cpos] = color.g;\r\n                colors[++cpos] = color.b;\r\n                colors[++cpos] = alpha;\r\n                // 6\r\n                positions[++ppos] = BL.x;\r\n                positions[++ppos] = BL.y;\r\n                positions[++ppos] = curvedLine.depth;\r\n                cpos += colorAttributeSize;\r\n            });\r\n            if (!needsUpdate) {\r\n                return \"break\";\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\r\n            var curvedLine = shapeBuffer_1[_i];\r\n            var state_1 = _loop_1(curvedLine);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\r\n        if (needsUpdate) {\r\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        else if (shapeBuffer.length === 0) {\r\n            this.bufferItems.geometry.setDrawRange(0, 0);\r\n        }\r\n        return needsUpdate;\r\n    };\r\n    return SimpleStaticLineBuffer;\r\n}(base_buffer_1.BaseBuffer));\r\nexports.SimpleStaticLineBuffer = SimpleStaticLineBuffer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-line-buffer.ts\n// module id = 33\n// module chunks = 0","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./reference/reference-color\"));\r\n__export(require(\"./shape/circle-shape\"));\r\n__export(require(\"./shape/curved-line-shape\"));\r\n__export(require(\"./shape/edge-shape\"));\r\n__export(require(\"./shape/image-shape\"));\r\n__export(require(\"./shape/label\"));\r\n__export(require(\"./shape/line-shape\"));\r\n__export(require(\"./shape/quad-shape\"));\r\n__export(require(\"./texture/atlas-color\"));\r\n__export(require(\"./texture/atlas-manager\"));\r\n__export(require(\"./texture/atlas-texture\"));\r\n__export(require(\"./texture/sprite\"));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/index.ts\n// module id = 34\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This defines a reference to a color that has been rendered to a texture\r\n * (See AtlasColor). This exposes the only properties that MAY be utilized\r\n * in a shader to modify the existing values without altering what is rendered\r\n * on the texture.\r\n */\r\nvar ReferenceColor = (function () {\r\n    /**\r\n     * Creates an instance of ReferenceColor.\r\n     *\r\n     * @param {AtlasColor} base The color to be based off of\r\n     */\r\n    function ReferenceColor(base) {\r\n        this.base = base;\r\n    }\r\n    return ReferenceColor;\r\n}());\r\nexports.ReferenceColor = ReferenceColor;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/reference/reference-color.ts\n// module id = 35\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar d3_color_1 = require(\"d3-color\");\r\nvar circle_1 = require(\"../../primitives/circle\");\r\n/**\r\n * Defines a circular shape that can be drawn\r\n */\r\nvar CircleShape = (function (_super) {\r\n    __extends(CircleShape, _super);\r\n    /**\r\n     * Sets the properties of the shape to be drawn\r\n     *\r\n     * @param x Center of the circle\r\n     * @param y Center of the circle\r\n     * @param r The radius of the circle\r\n     * @param color The color of the circle\r\n     * @param color The color within the inner radius of the circle\r\n     * @param innerR The inner radius of the circle\r\n     * @param d A data object to associate with this circle\r\n     */\r\n    function CircleShape(x, y, r, color, innerColor, innerR, d) {\r\n        var _this = _super.call(this, x, y, r, d) || this;\r\n        // Color\r\n        _this.r = 0;\r\n        _this.g = 0;\r\n        _this.b = 0;\r\n        _this.a = 0;\r\n        // Inner radius color\r\n        _this.r2 = 0;\r\n        _this.g2 = 0;\r\n        _this.b2 = 0;\r\n        _this.a2 = 0;\r\n        // Other properties\r\n        _this.alpha = 0;\r\n        _this.innerRadius = 0;\r\n        _this.ringWidth = 0;\r\n        _this.ringPad = 0;\r\n        _this.outline = false;\r\n        if (color) {\r\n            // FIXME: This is solving a bizarre potential race condition (or other voodoo) where the numbers are not being\r\n            // Applied correctly to this object when applying the d3 color object properties to this.\r\n            var r_1 = color.r, g = color.g, b = color.b, opacity = color.opacity;\r\n            _this.setOuterColor({ r: r_1, g: g, b: b, opacity: opacity });\r\n        }\r\n        if (innerR === undefined) {\r\n            innerR = 0;\r\n        }\r\n        _this.innerRadius = innerR;\r\n        if (innerColor) {\r\n            _this.setInnerColor(innerColor);\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Sets the color of the outer drawn radius\r\n     *\r\n     * @param color\r\n     */\r\n    CircleShape.prototype.setOuterColor = function (color) {\r\n        var r = color.r, g = color.g, b = color.b, opacity = color.opacity;\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = opacity;\r\n    };\r\n    /**\r\n     * Sets the color of the inner drawn radius\r\n     *\r\n     * @param color\r\n     */\r\n    CircleShape.prototype.setInnerColor = function (color) {\r\n        this.r2 = color.r;\r\n        this.g2 = color.g;\r\n        this.b2 = color.b;\r\n        this.a2 = color.opacity;\r\n    };\r\n    /**\r\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\r\n     * is identical to this one. The properties injected can be modifiers after the clone happens\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {CircleShape} A newly cloned instance of this circleshape\r\n     */\r\n    CircleShape.prototype.clone = function (newProperties) {\r\n        return Object.assign(new CircleShape(this._centerX, this._centerY, this._radius, d3_color_1.rgb(this.r, this.g, this.b, this.a), d3_color_1.rgb(this.r2, this.g2, this.b2, this.a2), this.innerRadius, this.d), this, newProperties);\r\n    };\r\n    /**\r\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\r\n     * is identical to this one. This will perform the clone but will change the data type\r\n     * associated with the circle in the cloned instance\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {CircleShape} A newly cloned instance of this circleshape\r\n     */\r\n    CircleShape.prototype.cloneWithData = function (newProperties) {\r\n        return Object.assign(new CircleShape(this._centerX, this._centerY, this._radius, d3_color_1.rgb(this.r, this.g, this.b, this.a), d3_color_1.rgb(this.r2, this.g2, this.b2, this.a2), this.innerRadius), this, newProperties);\r\n    };\r\n    return CircleShape;\r\n}(circle_1.Circle));\r\nexports.CircleShape = CircleShape;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/circle-shape.ts\n// module id = 36\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar curved_line_1 = require(\"../../primitives/curved-line\");\r\nvar line_1 = require(\"../../primitives/line\");\r\nvar point_1 = require(\"../../primitives/point\");\r\n/**\r\n * This defines a drawable curved line shape. It contains the information necessary\r\n * to efficiently render the line.\r\n *\r\n * @export\r\n * @class CurvedLineShape\r\n * @extends {CurvedLine<T>}\r\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\r\n *             with the shape easier.\r\n */\r\nvar CurvedLineShape = (function (_super) {\r\n    __extends(CurvedLineShape, _super);\r\n    /**\r\n     * Creates an instance of CurvedLineShape.\r\n     *\r\n     * @param {ICurvedLineShapeOptions} options The options for creating this line\r\n     */\r\n    function CurvedLineShape(options) {\r\n        var _this = \r\n        // We pass our properties to the curve line but we do not let it cache it's version of the line segments\r\n        // As we will be constructing our own segmentation requiring a new type of cache\r\n        _super.call(this, options) || this;\r\n        /** Depeth of draw location */\r\n        _this.depth = 0;\r\n        /** How thick the line should be */\r\n        _this.lineWidth = 1;\r\n        _this.encapsulatePoints(_this.getTriangleStrip());\r\n        _this.cachesQuadSegments = options.cacheSegments;\r\n        _this.depth = options.depth || 0;\r\n        _this.lineWidth = options.lineWidth || 1;\r\n        _this.startColor = options.startColor;\r\n        _this.endColor = options.endColor;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns a new instance of this object that mimicks the properties of this Object\r\n     *\r\n     * @returns {CurvedLineShape<T>} The cloned object\r\n     */\r\n    CurvedLineShape.prototype.clone = function () {\r\n        // Perform the clone\r\n        var clone = new CurvedLineShape({\r\n            cacheSegments: this.cachesSegments,\r\n            controlPoints: this.controlPoints,\r\n            end: this.p2,\r\n            endColor: this.endColor,\r\n            lineWidth: this.lineWidth,\r\n            resolution: this.resolution,\r\n            start: this.p1,\r\n            startColor: this.startColor,\r\n            type: this.type,\r\n        });\r\n        clone.d = this.d;\r\n        return clone;\r\n    };\r\n    /**\r\n     * @override\r\n     * See base definition\r\n     */\r\n    CurvedLineShape.prototype.distanceTo = function (point) {\r\n        return Math.max(0, _super.prototype.distanceTo.call(this, point) - (this.lineWidth / 2.0));\r\n    };\r\n    /**\r\n     * This produces a triangle strip that represents the quads that composes this line. If caching is present,\r\n     * subsequent calls to this method will be much faster unless the cache gets invalidated.\r\n     *\r\n     * @return {IPoint[]} The Triangle Strip of points to create the quads that make each segment of the curve\r\n     */\r\n    CurvedLineShape.prototype.getTriangleStrip = function () {\r\n        if (this.cachesSegments && this.cachedQuadSegments) {\r\n            return this.cachedQuadSegments;\r\n        }\r\n        // Make a container to hold our triangle strip info\r\n        var strip = [];\r\n        var normal = [];\r\n        // Start with calculating the line strip so we can use the line segments\r\n        // To produce the quads we need to render\r\n        var lineStrip = this.getLineStrip();\r\n        var lineWidthHalf = this.lineWidth / 2.0;\r\n        var line = new line_1.Line(point_1.Point.zero(), point_1.Point.zero());\r\n        // We make a container point for the scaling operation to reduce allocations\r\n        var scaledPoint = point_1.Point.zero();\r\n        // If the line strip is empty, then there is nothing to produce and makes\r\n        // Us unable to reduce the lineStrip, so return empty here\r\n        if (lineStrip.length < 2) {\r\n            return [];\r\n        }\r\n        // Calculate bisecting normal or each node\r\n        for (var i = 0; i < lineStrip.length - 1; i++) {\r\n            line.setPoints(lineStrip[i], lineStrip[i + 1]);\r\n            if (normal.length === 0) {\r\n                normal.push(line.perpendicular);\r\n            }\r\n            else {\r\n                // Sum of two normals of a point\r\n                var temp = {\r\n                    x: normal[i].x + line.perpendicular.x,\r\n                    y: normal[i].y + line.perpendicular.y,\r\n                };\r\n                // Normalize the sum of two normals\r\n                var sqrt = Math.sqrt(temp.x * temp.x + temp.y * temp.y);\r\n                temp.x = temp.x / sqrt;\r\n                temp.y = temp.y / sqrt;\r\n                normal[i] = temp;\r\n            }\r\n            normal.push(line.perpendicular);\r\n        }\r\n        // Use the new normals to generate quads\r\n        for (var i = 0; i < lineStrip.length - 1; i++) {\r\n            var previous = lineStrip[i];\r\n            var current = lineStrip[i + 1];\r\n            // TR\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], -lineWidthHalf, scaledPoint), current));\r\n            // BR\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], lineWidthHalf, scaledPoint), current));\r\n            // TL\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], -lineWidthHalf, scaledPoint), previous));\r\n            // BL\r\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], lineWidthHalf, scaledPoint), previous));\r\n        }\r\n        return strip;\r\n    };\r\n    /**\r\n     * @override\r\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\r\n     *\r\n     * @param {IPoint} p1\r\n     * @param {IPoint} p2\r\n     * @param {IPoint[]} controlPoints\r\n     */\r\n    CurvedLineShape.prototype.setPoints = function (p1, p2, controlPoints) {\r\n        _super.prototype.setPoints.call(this, p1, p2, controlPoints);\r\n        this.cachedQuadSegments = [];\r\n    };\r\n    return CurvedLineShape;\r\n}(curved_line_1.CurvedLine));\r\nexports.CurvedLineShape = CurvedLineShape;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/curved-line-shape.ts\n// module id = 37\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar d3_color_1 = require(\"d3-color\");\r\nvar line_1 = require(\"../../primitives/line\");\r\nvar line_shape_1 = require(\"./line-shape\");\r\n/**\r\n * This defines an edge that can be drawn.\r\n * This type of edge is a quad with distorted ends. The quad will represent a\r\n * line with each end having potentially different sizes thus giving a four sided\r\n * polygon rather than a parallelogram.\r\n *\r\n * The edge shape also doubles up as a simple line shape should it be desired to\r\n * render differently.\r\n */\r\nvar EdgeShape = (function (_super) {\r\n    __extends(EdgeShape, _super);\r\n    /**\r\n     * Constructor with basic parameters to declare an edge\r\n     *\r\n     * @param p1 The point the edge begins at\r\n     * @param p2 The point the edge terminates at\r\n     * @param d The data associated with the edge\r\n     * @param p1Col The color at the start point\r\n     * @param p2Col The color at the end point\r\n     * @param p1Width The width at the start point. Example: if you specify 4, then\r\n     *                the start part of the edge will fan out 2 on either side of the\r\n     *                start point\r\n     * @param p2Width The width at the end point. Example: if you specify 4, then\r\n     *                the end part of the edge will fan out 2 on either side of the\r\n     *                end point\r\n     */\r\n    function EdgeShape(p1, p2, d, p1Col, p2Col, p1Width, p2Width) {\r\n        var _this = \r\n        // Set up all of our line shape based metrics\r\n        _super.call(this, p1, p2, d, p1Col.r, p1Col.g, p1Col.b, p1Col.opacity, p2Col.r, p2Col.g, p2Col.b, p2Col.opacity, p1Width) || this;\r\n        /** Top left of the quad to generate this edge */\r\n        _this.tl = { x: 0, y: 0 };\r\n        /** Bottom left of the quad to generate this edge */\r\n        _this.bl = { x: 0, y: 0 };\r\n        /** Top right of the quad to generate this edge */\r\n        _this.tr = { x: 0, y: 0 };\r\n        /** Bottom Right of the quad to generate this edge */\r\n        _this.br = { x: 0, y: 0 };\r\n        /** The width of the edge at the termination point */\r\n        _this.endWidth = 1;\r\n        _this.endWidth = p2Width;\r\n        _this.setPoints(p1, p2);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Clones this instance of the edge shape and creates a new instance of an edge shape that\r\n     * is identical to this one. The properties injected can be modifiers after the clone happens\r\n     *\r\n     * @param newProperties New properties to override the properties on the new instance\r\n     *\r\n     * @return {EdgeShape} A newly cloned instance of this edgeshape\r\n     */\r\n    EdgeShape.prototype.clone = function (newProperties) {\r\n        return Object.assign(new EdgeShape(this.p1, this.p2, this.d, d3_color_1.rgb(this.r, this.g, this.b, this.a), d3_color_1.rgb(this.r2, this.g2, this.b2, this.a2), this.thickness, this.endWidth), this, newProperties);\r\n    };\r\n    /**\r\n     * Algorithm provided by\r\n     * https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\n     * Adapted to Javascript by Chris @ VoidRay co\r\n     *\r\n     * Remember the point must be in the same\r\n     * coordinate system that the edge is using\r\n     *\r\n     * @param {number} point The point to test\r\n     *\r\n     * @return {boolean} True if the point is inside the edge\r\n     */\r\n    EdgeShape.prototype.pointInside = function (point) {\r\n        var testx = point.x;\r\n        var testy = point.y;\r\n        // This is an algortihm to handle any number of points for a polygon. In this\r\n        // Case our polygon is simply the points that make this fat edge. Note:\r\n        // The points MUST be in CW order\r\n        var points = [this.tl, this.tr, this.br, this.bl];\r\n        var numberVertices = points.length;\r\n        var isClockwise = false;\r\n        for (var i = 0, j = numberVertices - 1; i < numberVertices; j = i++) {\r\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\r\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\r\n                    (points[j].y - points[i].y) + points[i].x)) {\r\n                isClockwise = !isClockwise;\r\n            }\r\n        }\r\n        return isClockwise;\r\n    };\r\n    /**\r\n     * @override\r\n     * This sets the two endpoints for this edge and recalculates the bounds\r\n     * of the edge accordingly.\r\n     *\r\n     * @param {IPoint} p1 The start point\r\n     * @param {IPoint} p2 The end point\r\n     */\r\n    EdgeShape.prototype.setPoints = function (p1, p2) {\r\n        _super.prototype.setPoints.call(this, p1, p2);\r\n        if (this.tl) {\r\n            // Get the distance from the points we will go based on specified widths\r\n            var p1Dx = this.thickness / 2;\r\n            var p2Dx = this.endWidth / 2;\r\n            // Calculate the deltas to get from point to quad edge\r\n            var p1DeltaX = this.perpendicular.x * p1Dx;\r\n            var p1DeltaY = this.perpendicular.y * p1Dx;\r\n            var p2DeltaX = this.perpendicular.x * p2Dx;\r\n            var p2DeltaY = this.perpendicular.y * p2Dx;\r\n            // Apply the metrics to our quad points\r\n            // Start side of the edge\r\n            this.tl.x = this.p1.x + p1DeltaX;\r\n            this.tl.y = this.p1.y + p1DeltaY;\r\n            this.bl.x = this.p1.x - p1DeltaX;\r\n            this.bl.y = this.p1.y - p1DeltaY;\r\n            // End side of the edge\r\n            this.tr.x = this.p2.x + p2DeltaX;\r\n            this.tr.y = this.p2.y + p2DeltaY;\r\n            this.br.x = this.p2.x - p2DeltaX;\r\n            this.br.y = this.p2.y - p2DeltaY;\r\n            // Create lines for the edges for computations and faster hit detections\r\n            this.topEdge = new line_1.Line(this.tl, this.tr);\r\n            this.bottomEdge = new line_1.Line(this.bl, this.br);\r\n            // Make sure our bounds reflects the entirety of the fat edge\r\n            this.encapsulatePoints([this.tl, this.tr, this.bl, this.br]);\r\n        }\r\n    };\r\n    return EdgeShape;\r\n}(line_shape_1.LineShape));\r\nexports.EdgeShape = EdgeShape;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/edge-shape.ts\n// module id = 38\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = require(\"../../primitives/bounds\");\r\n/**\r\n * Defines an image that can be rendered by the gpu. This is an axis oriented\r\n * image only (no rotations)\r\n */\r\nvar ImageShape = (function (_super) {\r\n    __extends(ImageShape, _super);\r\n    /**\r\n     * Generates a new ImageShape that can be rendered\r\n     *\r\n     * @param {AtlasTexture} image The AtlasTexture to use when rendering this image\r\n     * @param {number} size This is the size of the longest edge of the image while\r\n     *                      retaining aspect ratio.\r\n     */\r\n    function ImageShape(image, size) {\r\n        var _this = _super.call(this, 0, 0, size, size) || this;\r\n        /** This is the level of opacity the image will be rendered with */\r\n        _this.opacity = 1.0;\r\n        _this.texture = image;\r\n        _this.size = size;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ImageShape.prototype, \"size\", {\r\n        /**\r\n         * Returns the largest edge of the image\r\n         */\r\n        get: function () {\r\n            return Math.max(this.width, this.height);\r\n        },\r\n        /**\r\n         * This is the size the image will be rendered within World Space. The size\r\n         * correlates to the largest edge of the image\r\n         */\r\n        set: function (val) {\r\n            if (this.texture.aspectRatio > 1) {\r\n                this.width = val;\r\n                this.height = val / this.texture.aspectRatio;\r\n            }\r\n            else {\r\n                this.width = val * this.texture.aspectRatio;\r\n                this.height = val;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Centers this image on a provided location\r\n     *\r\n     * @param {number} x The x coordinate in world space\r\n     * @param {number} y The y coordinate in world space\r\n     */\r\n    ImageShape.prototype.centerOn = function (x, y) {\r\n        this.x = x - (this.width / 2.0);\r\n        this.y = y - (this.height / 2.0);\r\n    };\r\n    return ImageShape;\r\n}(bounds_1.Bounds));\r\nexports.ImageShape = ImageShape;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/image-shape.ts\n// module id = 39\n// module chunks = 0","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bounds_1 = require(\"../../primitives/bounds\");\r\nvar QuadShape = (function (_super) {\r\n    __extends(QuadShape, _super);\r\n    function QuadShape(bounds, color) {\r\n        var _this = _super.call(this, bounds.x, bounds.right, bounds.y, bounds.bottom) || this;\r\n        _this.r = 1.0;\r\n        _this.g = 0.0;\r\n        _this.b = 0.0;\r\n        _this.a = 1.0;\r\n        return _this;\r\n    }\r\n    return QuadShape;\r\n}(bounds_1.Bounds));\r\nexports.QuadShape = QuadShape;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/quad-shape.ts\n// module id = 40\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar three_1 = require(\"three\");\r\n/**\r\n * Defines a color that is located on an atlas\r\n */\r\nvar AtlasColor = (function () {\r\n    /**\r\n     * Constructor implementation\r\n     */\r\n    function AtlasColor(color, g, b, a) {\r\n        if (a === void 0) { a = 1.0; }\r\n        // Value between 1 - 0 for the opacity of the color\r\n        this.opacity = 1.0;\r\n        // The pixel width and height of the color rendered onto the atlas\r\n        // This will always be a 2x2 so the color can be sampled in the middle\r\n        // For a guaranteed pure color regardless of gl sampling states\r\n        this.pixelWidth = 2;\r\n        this.pixelHeight = 2;\r\n        if (color instanceof three_1.Color) {\r\n            this.color = color.clone();\r\n            this.opacity = g === undefined ? 1.0 : g;\r\n        }\r\n        else {\r\n            this.color = new three_1.Color(color, g, b);\r\n            this.opacity = a;\r\n        }\r\n    }\r\n    return AtlasColor;\r\n}());\r\nexports.AtlasColor = AtlasColor;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-color.ts\n// module id = 41\n// module chunks = 0","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./bounds\"));\r\n__export(require(\"./circle\"));\r\n__export(require(\"./curved-line\"));\r\n__export(require(\"./line\"));\r\n__export(require(\"./point\"));\r\n__export(require(\"./rotateable-quad\"));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/index.ts\n// module id = 42\n// module chunks = 0","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./buffer-util\"));\r\n__export(require(\"./custom-selection\"));\r\n__export(require(\"./get-font-metrics\"));\r\n__export(require(\"./pack-node\"));\r\n__export(require(\"./quad-tree\"));\r\n__export(require(\"./shape-buffer-cache\"));\r\n__export(require(\"./interpolation\"));\r\n__export(require(\"./mouse\"));\r\n__export(require(\"./time\"));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/index.ts\n// module id = 43\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Takes a map of the form <T, boolean> and returns an array of the keys,\r\n * excluding entries who's mapped value is false.\r\n *\r\n * @param map The map to convert to a list\r\n *\r\n * @return T[] A list of the keys, exluding false mappings\r\n */\r\nfunction boolMapToArray(map) {\r\n    return Array\r\n        .from(map)\r\n        .filter(function (item) { return item[1]; })\r\n        .map(function (item) { return item[0]; });\r\n}\r\nexports.boolMapToArray = boolMapToArray;\r\n/**\r\n * Defines a selection control for custom types and categories\r\n */\r\nvar CustomSelection = (function () {\r\n    function CustomSelection() {\r\n        /** This caches the list generation of a selection */\r\n        this.cachedSelection = new Map();\r\n        /** Map of the custom categories to the selection state */\r\n        this.selections = new Map();\r\n        /** Keeps flags indicating if a selection for a given category has changed or not */\r\n        this._didSelectionChange = new Map();\r\n    }\r\n    /**\r\n     * Clears out all custom selections for every category\r\n     */\r\n    CustomSelection.prototype.clearAllSelections = function () {\r\n        for (var _i = 0, _a = Array.from(this.selections.keys()); _i < _a.length; _i++) {\r\n            var key = _a[_i];\r\n            this.clearSelection(key);\r\n        }\r\n    };\r\n    /**\r\n     * Clears the selection for the category specified\r\n     *\r\n     * @param {string} category Name of the category of selection\r\n     */\r\n    CustomSelection.prototype.clearSelection = function (category) {\r\n        // We must have selected items to clear the selection\r\n        if (this.getSelection(category).length) {\r\n            this.selections.set(category, null);\r\n            this.cachedSelection.set(category, null);\r\n            this._didSelectionChange.set(category, true);\r\n        }\r\n    };\r\n    /**\r\n     * Makes an item no longer flaged as selected within the given category\r\n     *\r\n     * @param category The custom category of the selection\r\n     * @param item The item to remove from being selected\r\n     */\r\n    CustomSelection.prototype.deselect = function (category, item) {\r\n        var selectionMap = this.selections.get(category);\r\n        // See if the item is selected already, if it is, clear the selection and bust caches\r\n        if (selectionMap && selectionMap.get(item)) {\r\n            // Clear the cache for the selection list\r\n            this.cachedSelection.set(category, null);\r\n            // Set the selection\r\n            selectionMap.set(item, false);\r\n            // Flag the category of selections as changed\r\n            this._didSelectionChange.set(category, true);\r\n        }\r\n    };\r\n    /**\r\n     * Checks if a selection from a category has been modified\r\n     *\r\n     * @param {string} category The selection category to check\r\n     */\r\n    CustomSelection.prototype.didSelectionCategoryChange = function (category) {\r\n        return this._didSelectionChange.get(category);\r\n    };\r\n    /**\r\n     * Checks if ANY selection has changed\r\n     *\r\n     * @return {boolean} True if any selection has changed\r\n     */\r\n    CustomSelection.prototype.didSelectionChange = function () {\r\n        return boolMapToArray(this._didSelectionChange).length > 0;\r\n    };\r\n    /**\r\n     * This indicates that updates have taken place to account for selection\r\n     * changes.\r\n     */\r\n    CustomSelection.prototype.finalizeUpdate = function () {\r\n        for (var _i = 0, _a = Array.from(this._didSelectionChange.keys()); _i < _a.length; _i++) {\r\n            var key = _a[_i];\r\n            this._didSelectionChange.set(key, false);\r\n        }\r\n    };\r\n    /**\r\n     * This retrieves a list of the items that are selected\r\n     *\r\n     * @param category The selection category to check on\r\n     *\r\n     * @return {T} Returns a list of items that are currently selected\r\n     */\r\n    CustomSelection.prototype.getSelection = function (category) {\r\n        if (!this.cachedSelection.get(category)) {\r\n            var theSelection = this.selections.get(category);\r\n            if (theSelection) {\r\n                this.cachedSelection.set(category, boolMapToArray(theSelection));\r\n            }\r\n            else {\r\n                this.cachedSelection.set(category, []);\r\n            }\r\n        }\r\n        return this.cachedSelection.get(category);\r\n    };\r\n    /**\r\n     * Specifies an item to flag as selected for the given category\r\n     *\r\n     * @param category The custom category of the selection\r\n     * @param item The item to flag as selected\r\n     */\r\n    CustomSelection.prototype.select = function (category, item) {\r\n        var selectionMap = this.selections.get(category);\r\n        if (!selectionMap) {\r\n            selectionMap = new Map();\r\n            this.selections.set(category, selectionMap);\r\n        }\r\n        if (!selectionMap.get(item)) {\r\n            // Clear the cache for the selection list\r\n            this.cachedSelection.set(category, null);\r\n            // Set the selection\r\n            selectionMap.set(item, true);\r\n            // Flag the category of selections as changed\r\n            this._didSelectionChange.set(category, true);\r\n        }\r\n    };\r\n    /**\r\n     * Specifies an item to toggle it's selection status for the provided category\r\n     *\r\n     * @param category The custom category of the selection\r\n     * @param item The item to flag as selected\r\n     */\r\n    CustomSelection.prototype.toggleSelect = function (category, item) {\r\n        var selectionMap = this.selections.get(category);\r\n        if (!selectionMap) {\r\n            selectionMap = new Map();\r\n            this.selections.set(category, selectionMap);\r\n        }\r\n        // Clear the cache for the selection list\r\n        this.cachedSelection.set(category, null);\r\n        // Toggle the selection off if already selected\r\n        if (selectionMap.get(item)) {\r\n            this.deselect(category, item);\r\n        }\r\n        else {\r\n            this.select(category, item);\r\n        }\r\n        // Flag the category of selections as changed\r\n        this._didSelectionChange.set(category, true);\r\n    };\r\n    return CustomSelection;\r\n}());\r\nexports.CustomSelection = CustomSelection;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/custom-selection.ts\n// module id = 44\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getFontMetrics(props) {\r\n    var ctx = props.ctx;\r\n    var text = props.text;\r\n    var bboxHeight = props.bboxHeight;\r\n    var canvasHeight = props.ctx.canvas.height;\r\n    var baseline = props.baseline || 'alphabetic';\r\n    var flip = props.flip || false;\r\n    var drawBaseline = props.drawBaseline || false;\r\n    var fontFamily = 'Arial, san-serif';\r\n    var fontSize = 14;\r\n    if (props.fontFamily) {\r\n        fontFamily = props.fontFamily;\r\n    }\r\n    if (props.fontSize) {\r\n        fontSize = props.fontSize;\r\n    }\r\n    // Setting up the canvas\r\n    ctx.save(); // Create canvas to use as buffer\r\n    ctx.font = fontSize + \"px \" + fontFamily;\r\n    var textWidth = ctx.measureText(text).width;\r\n    // This keeps font in-screen, measureText().width doesn't\r\n    // Quite do it in some cases. For instance \"j\", or the letter \"f\"\r\n    // In the font \"Zapfino\".\r\n    var offsetx = fontSize * 2;\r\n    var offsety = fontSize * 2;\r\n    var cwidth = ctx.canvas.width = Math.round(textWidth + offsetx * 2);\r\n    var cheight = ctx.canvas.height = canvasHeight ? canvasHeight : Math.round(offsety * 2);\r\n    if (typeof (baseline) === 'string') {\r\n        offsety = 0; // Using <canvas> baseline\r\n        ctx.textBaseline = baseline;\r\n    }\r\n    // Ctx.font has to be called twice because resetting the size resets the state\r\n    if (flip) {\r\n        ctx.scale(1, -1);\r\n    }\r\n    ctx.font = fontSize + \"px \" + fontFamily;\r\n    ctx.fillText(text, offsetx, (typeof (bboxHeight) === 'number' ? bboxHeight : offsety));\r\n    // Drawing baseline\r\n    if (drawBaseline) {\r\n        ctx.fillRect(0, canvasHeight / 2, ctx.canvas.width, 1);\r\n    }\r\n    // Grabbing image data\r\n    var imageData = ctx.getImageData(0, 0, cwidth, cheight);\r\n    var data = imageData.data;\r\n    // Calculating top\r\n    var top = 0;\r\n    var pos = data.length;\r\n    var bottom = 0;\r\n    var realBottom = 0;\r\n    var left = 0;\r\n    var right = 0;\r\n    while (pos > 0) {\r\n        if (data[pos + 3]) {\r\n            pos -= pos % (cwidth * 4); // Back to beginning of the line top = (pos / 4) / cwidth; // calculate pixel position top -= offsety - fontSize; pos = data.length; // exit loop } pos += 4; } // calculating bottom var bottom = 0; var pos = data.length; while (pos > 0) {\r\n            if (data[pos + 3]) {\r\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\r\n                bottom = (pos / 4) / cwidth;\r\n                bottom -= offsety - fontSize;\r\n                pos = 0; // Exit loop\r\n            }\r\n            pos -= 4;\r\n        }\r\n        // Calculating left\r\n        left = 0;\r\n        var col = 0;\r\n        var row = 0; // Left bounds\r\n        while (row < cheight && col < cwidth) {\r\n            var px = data[(row * cwidth * 4) + (col * 4) + 3];\r\n            if (px) {\r\n                left = col - offsetx;\r\n                row = cheight;\r\n                col = cwidth;\r\n            }\r\n            row++;\r\n            if (row % cheight === 0) {\r\n                row = 0;\r\n                col++;\r\n            }\r\n        }\r\n        // Calculating right\r\n        right = 0;\r\n        col = cwidth;\r\n        row = 0; // Right bounds\r\n        while (row < cheight && col > 0) {\r\n            if (data[(row * cwidth * 4) + (col * 4) + 3]) {\r\n                right = col - offsetx;\r\n                row = cheight;\r\n                col = cwidth;\r\n            }\r\n            row++;\r\n            if (row % cheight === 0) {\r\n                row = 0;\r\n                col--;\r\n            }\r\n        }\r\n        // Calculating real-bottom\r\n        realBottom = 0;\r\n        pos = data.length;\r\n        while (pos > 0) {\r\n            if (data[pos + 3]) {\r\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\r\n                realBottom = (pos / 4) / cwidth;\r\n                pos = 0; // Exit loop\r\n            }\r\n            pos -= 4;\r\n        }\r\n        // Restoring state\r\n        ctx.restore();\r\n    }\r\n    // Returning raw-metrics\r\n    return {\r\n        bottom: realBottom,\r\n        height: (bottom - top),\r\n        left: (-left),\r\n        top: (fontSize - top),\r\n        width: (right - left),\r\n    };\r\n}\r\nexports.getFontMetrics = getFontMetrics;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/get-font-metrics.ts\n// module id = 45\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This defines an object that helps facilitate parts of or complete shape buffers that\r\n * need regenerating.\r\n */\r\nvar ShapeBufferCache = (function () {\r\n    function ShapeBufferCache() {\r\n        this.buffer = [];\r\n        this.bustCache = true;\r\n    }\r\n    /**\r\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\r\n     * it will not regenerate\r\n     */\r\n    ShapeBufferCache.prototype.generate = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this.bustCache) {\r\n            this.buildCache.apply(this, args);\r\n            this.bustCache = false;\r\n        }\r\n    };\r\n    /**\r\n     * Sub classes will implement this stub to perform what is necessary to produce\r\n     * a newly updated version of their cache.\r\n     */\r\n    ShapeBufferCache.prototype.buildCache = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        // Implemented by sub classes\r\n    };\r\n    /**\r\n     * Get the buffer the cache has generated\r\n     */\r\n    ShapeBufferCache.prototype.getBuffer = function () {\r\n        return this.buffer;\r\n    };\r\n    return ShapeBufferCache;\r\n}());\r\nexports.ShapeBufferCache = ShapeBufferCache;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/shape-buffer-cache.ts\n// module id = 46\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * This gets an integer time value that can fit within an attribute. Be aware,\r\n * this only supports up to 7 digits of the millisecond time.\r\n */\r\nfunction getAttributeCurrentTime() {\r\n    var time = Date.now() / 1E7;\r\n    return Math.floor((time - Math.floor(time)) * 1E7);\r\n}\r\nexports.getAttributeCurrentTime = getAttributeCurrentTime;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/time.ts\n// module id = 47\n// module chunks = 0"],"sourceRoot":""}