{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap d7c0f2534c177f961f29","webpack:///external \"three\"","webpack:///./src/webgl-surface/primitives/bounds.ts","webpack:///./src/webgl-surface/util/buffer-util.ts","webpack:///./node_modules/debug/src/browser.js","webpack:///./src/webgl-surface/buffers/base-buffer.ts","webpack:///external \"ramda\"","webpack:///./src/webgl-surface/primitives/point.ts","webpack:///./src/webgl-surface/primitives/line.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-texture.ts","webpack:///./src/webgl-surface/util/frame-info.ts","webpack:///./src/webgl-surface/util/webgl-stat.ts","webpack:///./src/webgl-surface/util/easing.ts","webpack:///./src/webgl-surface/util/interpolation.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-manager.ts","webpack:///./src/webgl-surface/util/pack-node.ts","webpack:///./src/webgl-surface/drawing/shape/label.ts","webpack:///./src/webgl-surface/primitives/rotateable-quad.ts","webpack:///./src/webgl-surface/drawing/texture/sprite.ts","webpack:///./src/webgl-surface/util/mouse.ts","webpack:///./src/webgl-surface/util/quad-tree.ts","webpack:///./src/webgl-surface/drawing/shape/curved-line-shape.ts","webpack:///./src/webgl-surface/primitives/curved-line.ts","webpack:///./src/webgl-surface/primitives/circle.ts","webpack:///./src/webgl-surface/drawing/shape/line-shape.ts","webpack:///./src/webgl-surface/util/multi-shape-buffer-cache.ts","webpack:///./src/webgl-surface/util/shape-buffer-cache.ts","webpack:///./src/index.ts","webpack:///./src/webgl-surface/webgl-surface.tsx","webpack:///external \"react\"","webpack:///external \"d3-color\"","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/debug/src/debug.js","webpack:///./node_modules/ms/index.js","webpack:///external \"bowser\"","webpack:///./src/webgl-surface/buffers/index.ts","webpack:///./src/webgl-surface/buffers/animated/shared-control-curved-line-buffer-ants.ts","webpack:///./src/webgl-surface/buffers/animated/shared-control-curved-line-colors-buffer.ts","webpack:///./src/webgl-surface/buffers/static/shared-control-curved-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-bezier-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-circle-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-label-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/simple-straight-line-buffer.ts","webpack:///./src/webgl-surface/buffers/static/uniform-instance-arc-buffer.ts","webpack:///./src/webgl-surface/drawing/index.ts","webpack:///./src/webgl-surface/drawing/reference/reference-color.ts","webpack:///./src/webgl-surface/drawing/animation/animated-curved-line-shape.ts","webpack:///./src/webgl-surface/drawing/shape/circle-shape.ts","webpack:///./src/webgl-surface/drawing/shape/edge-shape.ts","webpack:///./src/webgl-surface/drawing/shape/image-shape.ts","webpack:///./src/webgl-surface/drawing/shape/quad-shape.ts","webpack:///./src/webgl-surface/drawing/texture/atlas-color.ts","webpack:///./src/webgl-surface/primitives/index.ts","webpack:///./src/webgl-surface/util/index.ts","webpack:///./src/webgl-surface/util/animate.ts","webpack:///./src/webgl-surface/util/animated-shape-buffer-cache.ts","webpack:///./src/webgl-surface/util/custom-selection.ts","webpack:///./src/webgl-surface/util/get-font-metrics.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_5__","__WEBPACK_EXTERNAL_MODULE_28__","__WEBPACK_EXTERNAL_MODULE_29__","__WEBPACK_EXTERNAL_MODULE_33__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","Bounds","left","right","top","bottom","height","width","x","y","arguments","length","containsPoint","point","copyBounds","b","encapsulate","bounds","encapsulateBounds","sizeToFirst","minX","Number","MAX_VALUE","maxX","minY","maxY","forEach","encapsulatePoint","encapsulatePoints","points","undefined","fits","inner","hitBounds","pointInside","isBounds","isInside","maxBounds","MIN_VALUE","applyAttributeRegisters","attributeBuffers","incrementValues","attrRegister0","attrRegister1","attrRegister2","attrRegister3","attrRegister4","attrRegister5","attrRegister6","attrRegister7","attrRegister8","attrRegister9","attrRegister10","attrIndexIncr0","attrIndexIncr1","attrIndexIncr2","attrIndexIncr3","attrIndexIncr4","attrIndexIncr5","attrIndexIncr6","attrIndexIncr7","attrIndexIncr8","attrIndexIncr9","attrIndexIncr10","updateBuffer1","numBatches","updateAccessor","lastBatchRegister","attrIndex0","updateBuffer2","attrIndex1","updateBuffer3","attrIndex2","updateBuffer4","attrIndex3","updateBuffer5","attrIndex4","updateBuffer6","attrIndex5","updateBuffer7","attrIndex6","updateBuffer8","attrIndex7","updateBuffer9","attrIndex8","updateBuffer10","attrIndex9","updateBuffer11","attrIndex10","applyDefaultsHolders","defaults","defaultsHolder0","defaultsHolder1","defaultsHolder2","defaultsHolder3","fillSize1","buffer","start","fillSize2","fillSize3","fillSize4","isList","val","Array","isArray","three_1","webgl_stat_1","debugGenerator","debug","TriangleOrientation","AttributeSize","UniformAttributeSize","isStreamUpdatingRegister","fillMethodLookUp","_a","ONE","TWO","THREE","FOUR","updateBufferLookUp","1","2","3","4","5","6","7","8","9","10","11","BufferUtil","beginUpdates","dispose","buffers","bufferItems","attributes","currentData","geometry","system","endUpdates","totalBatches","examineBuffer","message","debugNamespace","debugBuffer","enabled","bufferAttributes","map","attr","array","triangles","drawMode","TrianglesDrawMode","currentVertex_1","attrSize_1","currentIndex_1","length_1","drawRange","count","tri","vertex_0","vertex_1","vertex_2","index","size","slice","push","TriangleStripDrawMode","currentVertex_2","attrSize_2","currentIndex_2","length_2","material","uniforms","flattenMultiBuffers","multiShapeBuffers","all","multiBuffer","getBuffers","concat","updateMultiBuffer","multiShapeBuffer","init","update","forceUpdates","shapeBuffers","didUpdate","reduce","flat","toFlatten","bufferLookup","Map","set","needsBuffer","shapes","delete","shift","shapeBuffer","vertexBuffer","vertexBuffers_1","from","values","setDrawRange","makeBuffer","numVertices","iMax","BufferGeometry","totalAttributeSize","attribute","attributeSize","name_1","injectBuffer","Float32Array","fillMethod","customFill","k","BufferAttribute","setDynamic","addAttribute","console","warn","makeUniformBuffer","maxBlock","uniformBufferBlockMax","WebGLStat","MAX_VERTEX_INSTANCE_DATA","sizeCheck","uniform","Math","max","block","Vector4","blocksPerInstance","maxInstances","floor","updateBuffer","newData","vertexBatch","force","testPerformed","updateMethod","updateRange","offset","itemSize","needsUpdate","updateUniformBuffer","instanceBatchSize","log","instanceData","type","uniformBuffer","uniformAttributes","currentInstance","currentInstanceStartBlock","updateArguments","_i","attributes_1","apply","makeBufferItems","process","useColors","window","document","documentElement","style","WebkitAppearance","firebug","exception","table","navigator","userAgent","toLowerCase","match","parseInt","RegExp","$1","formatArgs","args","namespace","humanize","diff","color","splice","lastC","replace","Function","save","namespaces","storage","removeItem","e","load","r","env","DEBUG","chrome","local","localStorage","colors","formatters","j","v","JSON","stringify","err","enable","buffer_util_1","BaseBuffer","unitCount","squareDistance","p1","p2","dx","dy","Point","add","out","getClosest","testPoint","distance","closestDistance","closestPoint","findClosest","getClosestIndex","getDirection","normalize","magnitude","sqrt","getDistance","squared","getMidpoint","direction","make","scale","zero","__extends","extendStatics","setPrototypeOf","__proto__","__","constructor","create","bounds_1","Line","_super","_this","setPoints","directionTo","vector","perpendicular","distanceTo","abs","lines","closestLine","line","slope","mag","AtlasTexture","path","label","aspectRatio","imagePath","rasterizedLabel","getAttributeCurrentTime","time","FrameInfo","lastFrameTime","Date","now","nextFrameTime","framesPlayed","getProgramInfo","gl","program","result","attributeCount","uniformCount","activeUniforms","getProgramParameter","ACTIVE_UNIFORMS","activeAttributes","ACTIVE_ATTRIBUTES","enums","35664","35665","35666","35667","35668","35669","35670","35671","35672","35673","35674","35675","35676","35678","35680","5120","5121","5122","5123","5124","5125","5126","blocks","getActiveUniform","typeName","getActiveAttrib","printCurrentProgramInfo","surface","info","getParameter","CURRENT_PROGRAM","MAX_VERTEX_UNIFORMS","MAX_FRAGMENT_UNIFORMS","MAX_ATTRIBUTES","WEBGL_SUPPORTED","canvas","createElement","WebGLRenderingContext","getContext","MAX_VERTEX_UNIFORM_VECTORS","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_VERTEX_ATTRIBS","linear","t","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","PI","easeOutSine","sin","easeInOutSine","easeInExpo","pow","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","a","asin","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","bezier2","c1","t2","mt","mt2","bezier3","c2","t3","mt3","circular","radiusEasing","direction1","point_1","theta1","atan2","direction2","theta2","dTheta","radius1","radius2","radius","easing_1","InterpolationMethod","pickInterpolation","BEZIER2","BEZIER3","CIRCULAR","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","done","then","__generator","body","verb","op","f","TypeError","_","ops","pop","trys","g","sent","throw","return","Symbol","iterator","d3_color_1","pack_node_1","label_1","atlas_texture_1","debugLabels","ZERO_IMAGE","atlasBL","atlasBR","atlasTL","atlasTR","Label","text","pixelHeight","pixelWidth","AtlasManager","atlasImages","atlasMap","atlasTexture","textureWidth","textureHeight","createAtlas","atlasName","images","images_1","image","texture","_b","PackNode","draw","drawColors","Texture","premultiplyAlpha","generateMipmaps","destroyAtlas","destroy","none_1","atlasReferenceID","isValidImage","isValid","setDefaultImage","assign","loadedImage","rect","dimensions","node","insertedNode","ux","uy","uw","uh","atlasDimensions","loadImage","first","second","insert","nodeImage","nodeDimensions","drawImage","error","colorWidth","colorHeight","maxPerRow","rowWidth","rowCount","colCount","renderHeight","renderSpace","startX","startY","nextX","nextY","beginX","beginY","col","row","colors_1","min","ceil","colorIndex","colorsPerRow","firstColor","nextColor","fillStyle","round","opacity","fillRect","Error","getAtlasTexture","Image","onload","onerror","src","labelSize","getSize","ctx","rasterizationOffset","fontSize","rgb","base","font","makeCSSFont","textAlign","textBaseline","toString","fillText","image_1","setSize","toDataURL","child","isLeaf","hasChild","newNode","fitFlag","imgWidth","imgHeight","dWidth","dHeight","remove","removed","ramda_1","rotateable_quad_1","sprite_1","measurement","Sprite","options","AnchorPosition","TopLeft","depth","fontWeight","maxWidth","id","zoomable","rasterizationPadding","setFontSize","_baseLabel","baseLabel","_rasterizedLabel","copyLabel","omit","setText","getText","position","lbl","baseSize","context","size_1","measureText","RotateableQuad","anchorCalculations","BottomLeft","quad","BottomRight","Custom","Middle","MiddleBottom","MiddleLeft","MiddleRight","MiddleTop","TopRight","location","rotation","anchor","setAnchor","setLocation","setRotation","calculateAnchor","custom","anchorType","getAnchor","getAnchorType","getLocation","getRotation","angle","anchorMat","Matrix4","makeTranslation","rotationMat","makeRotationZ","locationMat","transform","multiply","TL","clone","applyMatrix4","TR","BL","BR","w","h","contentScaleX","contentScaleY","scaleX","scaleY","getContentScale","getContentSize","getWidth","getHeight","normalizeFirefoxWheel","wheel","nativeEvent","deltaX","deltaY","sign","lowPassY","MAX_FIREFOX_WHEELDELTA","LOW_PASS_U0","LOW_PASS_U1","LOW_PASS_U2","LOW_PASS_U3","unshift","Vector2","normalizeChromeWheel","normalizeIE11Wheel","wheelDeltaX","IE_ADJUSTMENT","wheelDeltaY","wheelDelta","detail","OLD_IE_ADJUSTMENT","normalizeIE12Wheel","multiplyScalar","eventElementPosition","relative","mouseX","mouseY","eventX","eventY","target","event","pageX","pageY","clientX","clientY","scrollLeft","scrollTop","offsetParent","offsetLeft","offsetTop","normalizeWheel","browser","firefox","msie","version","msedge","filterQuery","queryValues","filtered","obj","find","Quadrants","mid","Node","children","childrenProps","nodes","props","doAdd","cover","addAll","allChildren","gatherChildren","split","isNaN","area","list","gatherProps","query","visit","queryBounds","queryPoint","cb","finished","Boolean","QuadTree","curved_line_1","line_1","CurvedLineShape","lineWidth","getTriangleStrip","cachesQuadSegments","cacheSegments","startColor","endColor","cachesSegments","controlPoints","end","resolution","cachedQuadSegments","strip","normal","lineStrip","getLineStrip","lineWidthHalf","scaledPoint","temp","previous","current","CurvedLine","bezierDistance","straightLine","closestIndex","circularDistance","straightDistance","makeBezier2Segments","cachedSegments","segments","dt","lineEnd","interpolation_1","makeBezier3Segments","makeCircularCWSegments","circleCenter","midPoint","minRadius","makeCircularCCWSegments","makeStraightSegments","CurveType","pickSegmentMethod","Bezier","CircularCW","CircularCCW","Straight","pickDistanceMethod","distanceMethod","segmentMethod","segmentMethods","numControlPoints","UID","Circle","_id","_radius","_centerX","_centerY","centerX","centerY","updateBounds","boundsInside","r2","dy2","dx2","notSquared","circles","closestCircle","circle","hitCircle","totalDistance","hitPoint","LineShape","thickness","newProperties","getIDProp","item","evenRoundRobinBufferAdd","smallest","found","some","tracker","noop","echoBuffer","shape_buffer_cache_1","multiBufferSelectionPrefix","multiBufferSelectionKeyUID","MultiShapeBufferCache","numBuffers","methods","selectionUID","addMethod","idMethod","initMethod","removeMethod","addShape","shape","store","allBuffers","idToItem","itemToBuffer","flagBuffersDirty","containsId","containsShape","isDirty","generate","selection","getStorage","processDirtyBuffers","getBuffer","getNumBuffers","getShapeById","getSelection","select","removeShape","indexOf","updateShape","ShapeBufferCache","bustCache","buildCache","__export","isAnimatedWithOptions","isAnimated","BaseApplyPropsMethods","React","atlas_manager_1","frame_info_1","mouse_1","quad_tree_1","debugCam","debugColors","BaseAnimatedMethods","BACKGROUND_COLOR","Color","setRGB","Vector3","WebGLSurface","atlasManager","atlasNames","labels","animatedMethodList","animatedMethodBreak","camera","OrthographicCamera","disableMouseInteraction","sizeCamera","currentZoom","destinationX","destinationY","destinationZoom","isPanning","lastMousePosition","propsMethodList","inertia","inertiaBuild","inertiaDecay","inertiaMax","quadTree","shiftIsDown","stop","currentX","currentY","targetZoom","previousZoomToFit","zoomTargetX","zoomTargetY","animating","labelsReady","labelsCurrentLoadedId","labelsLoadId","colorsReady","currentHoverItems","dragOver","animate","requestAnimationFrame","response","doDraw","method","break","updateCameraUniforms","forceDraw","emitViewport","applyProps","el","scene","renderEl","heightHalf","widthHalf","initCamera","Scene","initBuffers","renderer","WebGLRenderer","alpha","backgroundColor","antialias","preserveDrawingBuffer","setPixelRatio","devicePixelRatio","setClearColor","setFaceCulling","CullFaceNone","appendChild","domElement","makeDraggable","getElementById","viewSize","viewport","far","near","z","resizeContext","renderSize","zoom","updateProjectionMatrix","tl","screenToWorld","br","updateMatrixWorld","visible","onViewport","projection","handleMouseDown","onMouseDown","handleMouseOut","onMouseOut","handleMouseUp","mouse","world","hitInside","hitItems","hitItems_1","onMouseUp","handleMouseMove","onMouse","xDistance","yDistance","pan","willPan","maxInertia","hitItems_2","onMouseHover","onMouseLeave","applyRef","animatedMethods","baseAnimatedMethods","orderedBaseAnimatedMethods","animatedMethodsBase","CONTEXT","INERTIA","POSITION","positionCamera","ZOOM","destZoom","dZoom","screenZoomTarget","worldToScreen","zoomCamera","newScreenZoomTarget","zoomDX","zoomDY","applyColorBufferChanges","applyLabelBufferChanges","applyPropsMethods","basePropsMethods","orderedBasePropsMethods","applyPropsMethodsBase","INITIALIZE","oldColor","LABELS","textures","COLORS","BUFFERCHANGES","applyBufferChanges","CAMERA","appliedViewport","zoomToFitViewH","zoomToFitViewV","zoomToFit","onZoomRequest","componentDidMount","componentWillMount","screenSizeToWorld","bind","worldSizeToScreen","componentWillReceiveProps","componentWillUnmount","render","onRender","imageData","element","stage","onmousedown","onmousemove","scrollY","distanceX","distanceY","onmouseup","onmouseover","onselectstart","unproject","project","merge","shouldComponentUpdate","nextProps","onMouseMove","onDoubleClick","ref","Component","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","nextTick","title","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","selectColor","hash","charCodeAt","createDebug","self","curr","ms","prevTime","prev","coerce","format","formatter","names","skips","substr","disable","test","stack","parse","str","String","exec","parseFloat","fmtShort","fmtLong","plural","long","base_buffer_1","SharedControlCurvedLineBufferAnts","numQuads","Mesh","frustumCulled","controlPointSource","controlUniform","controlReference","colorRef","colorBase","atlas","colorAtlas","colorStart","colorEnd","antLength","antGap","antSpeed","controlPoint","controlRef","halfWidthSize","this_1","shapeBuffer_1","curvedLine","marchingAnts","gapLength","speed","strokeLength","controlLength","positions","ppos","scpos","ecpos","normals","npos","endPoints","epos","halfWidth","wpos","marching","mpos","controlPick","cpos","SharedControlCurvedLineColorsBuffer","colorStartStop","colorEndStop","startTime","duration","endColorStop","startColorStop","currentStart","currentEnd","colorPicks","ctpos","timing","tpos","isCluster","SharedControlCurvedLineBuffer","flatten","buffer_1","SimpleStaticBezierLineBuffer","copos","SimpleStaticCircleBuffer","Points","outerColor","rpos","SimpleStaticLabelBuffer","startFade","endFade","labelMaxSize","maxLabelSize","updated","texCoords","sizes","spos","anchors","apos","SimpleStaticLineBuffer","stripPos","SimpleStaticStraightLineBuffer","UniformInstanceArcBuffer","shared","bufferClass","pointClass","initVertexBuffer","geo","arr","vertex","segment","MAX_RESOLUTION","segmentIndex","bufferVertexCount","ReferenceColor","curved_line_shape_1","AnimatedCurvedLineShape","easing","_startColorChange","_endColorChange","startStop","endStop","_currentStartColor","_currentEndColor","_startColorStop","startBase","newBase","_endColorStop","endBase","easedTime","circle_1","CircleShape","innerColor","innerRadius","instance","line_shape_1","EdgeShape","startWidth","bl","tr","endWidth","testx","testy","numberVertices","isClockwise","p1Dx","p2Dx","p1DeltaX","p1DeltaY","p2DeltaX","p2DeltaY","topEdge","bottomEdge","ImageShape","centerOn","QuadShape","AtlasColor","PlayState","Animate","playState","PLAY","propToItem","cancel","container","prop","ease","multi_shape_buffer_cache_1","AnimatedShapeBufferCache","INIT","doAnimate","STOP","boolMapToArray","filter","CustomSelection","cachedSelection","selections","_didSelectionChange","clearAllSelections","keys","key","clearSelection","category","deselect","selectionMap","didSelectionCategoryChange","didSelectionChange","finalizeUpdate","theSelection","toggleSelect","getFontMetrics","bboxHeight","canvasHeight","baseline","flip","drawBaseline","fontFamily","textWidth","offsetx","offsety","cwidth","cheight","getImageData","data","pos","realBottom","restore"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"ramda\", \"react\", \"d3-color\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"voidgl\"] = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse\n\t\troot[\"voidgl\"] = factory(root[\"three\"], root[\"ramda\"], root[\"react\"], root[\"d3-color\"], root[\"bowser\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_33__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"ramda\", \"react\", \"d3-color\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"voidgl\"] = factory(require(\"three\"), require(\"ramda\"), require(\"react\"), require(\"d3-color\"), require(\"bowser\"));\n\telse\n\t\troot[\"voidgl\"] = factory(root[\"three\"], root[\"ramda\"], root[\"react\"], root[\"d3-color\"], root[\"bowser\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_33__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nvar Bounds = /** @class */ (function () {\n    /**\n     * Create a new instance\n     *\n     * @param left  The left side (x coordinate) of the instance\n     * @param right The right side of the instance\n     * @param top The top (y coordinate) of the instance\n     * @param bottom The bottom of the instance\n     */\n    function Bounds(left, right, top, bottom) {\n        this.height = 0;\n        this.width = 0;\n        this.x = 0;\n        this.y = 0;\n        if (arguments.length === 4) {\n            this.x = left;\n            this.width = right - left;\n            this.y = top;\n            this.height = top - bottom;\n        }\n    }\n    Object.defineProperty(Bounds.prototype, \"area\", {\n        /** The total rectangular surface area of this instance */\n        get: function () {\n            return this.width * this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"bottom\", {\n        /** The bottom coordinate for this instance (y + height) */\n        get: function () {\n            return this.y - this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"mid\", {\n        /** An x, y coordinate pair representing the center of this object */\n        get: function () {\n            return {\n                x: this.x + (this.width / 2),\n                y: this.y - (this.height / 2),\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"right\", {\n        get: function () {\n            return this.x + this.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Check to see if a given point lies within the bounds of this instance\n     *\n     * @param point The point to check\n     */\n    Bounds.prototype.containsPoint = function (point) {\n        if (point.x < this.x) {\n            return false;\n        }\n        if (point.y > this.y) {\n            return false;\n        }\n        if (point.x > this.right) {\n            return false;\n        }\n        if (point.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Copies the properties of the bounds specified\n     *\n     * @param b The bounds whose dimensions we wish to copy\n     */\n    Bounds.prototype.copyBounds = function (b) {\n        this.height = b.height;\n        this.width = b.width;\n        this.x = b.x;\n        this.y = b.y;\n    };\n    /**\n     * Ensure that this object contains the smaller bounds\n     *\n     * This method will not shrink this class, but only grow it as necessary to\n     * fit the destination object\n     *\n     * @param bounds The bounds to encapsulate\n     */\n    Bounds.prototype.encapsulate = function (bounds) {\n        if (bounds.x < this.x) {\n            this.width += this.x - bounds.x;\n            this.x = bounds.x;\n        }\n        if (bounds.y > this.y) {\n            this.height += bounds.y - this.y;\n            this.y = bounds.y;\n        }\n        if (bounds.right > this.right) {\n            this.width = bounds.right - this.x;\n        }\n        if (bounds.bottom < this.bottom) {\n            this.height = this.y - bounds.bottom;\n        }\n    };\n    /**\n     * Ensure that this object contains the provided list of bounds\n     *\n     * This will never shrink or modify the original area covered by this bounds\n     * but will instead stay the same or include the original area plus the specified\n     * list of bounds.\n     *\n     * @param {Bounds<any>[]} bounds The list of bounds objects to encapsulate\n     * @param {boolean} sizeToFirst If this is set, the procedure will start by making this bounds\n     *                              be a clone of the first bounds object in the list\n     */\n    Bounds.prototype.encapsulateBounds = function (bounds, sizeToFirst) {\n        if (sizeToFirst && bounds.length) {\n            this.copyBounds(bounds[0]);\n        }\n        if (bounds.length === 0) {\n            return;\n        }\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        bounds.forEach(function (p) {\n            if (p.x < minX) {\n                minX = p.x;\n            }\n            if (p.right > maxX) {\n                maxX = p.right;\n            }\n            if (p.bottom < minY) {\n                minY = p.bottom;\n            }\n            if (p.y > maxY) {\n                maxY = p.y;\n            }\n        });\n        // Make bounds that encompasses the bounds list, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Grow this class to contain the specified point\n     *\n     * This method will not shrink this instance. It will only grow it as\n     * necessary.\n     *\n     * @param point The point to encapsulate\n     */\n    Bounds.prototype.encapsulatePoint = function (point) {\n        if (point.x < this.x) {\n            this.width += this.x - point.x;\n            this.x = point.x;\n        }\n        if (point.y > this.y) {\n            this.height += point.y - this.y;\n            this.y = point.y;\n        }\n        if (point.x > this.right) {\n            this.width = point.x - this.x;\n        }\n        if (point.y < this.bottom) {\n            this.height = this.y - point.y;\n        }\n    };\n    /**\n     * Efficiently encapsulates a set of points by growing the current dimensions\n     * of the bounds until the points are enclosed. This will perform faster than\n     * running encapsulatePoint for a list of points.\n     *\n     * @param points An array of points that Can be of format {x, y} or [x, y]\n     *\n     * @memberOf Bounds\n     */\n    Bounds.prototype.encapsulatePoints = function (points) {\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        if (points[0] !== undefined && points[0].x) {\n            points.forEach(function (p) {\n                if (p.x < minX) {\n                    minX = p.x;\n                }\n                else if (p.x > maxX) {\n                    maxX = p.x;\n                }\n                if (p.y < minY) {\n                    minY = p.y;\n                }\n                else if (p.y > maxY) {\n                    maxY = p.y;\n                }\n            });\n        }\n        else {\n            points.forEach(function (p) {\n                if (p[0] < minX) {\n                    minX = p[0];\n                }\n                else if (p[0] > maxX) {\n                    maxX = p[0];\n                }\n                if (p[1] < minY) {\n                    minY = p[1];\n                }\n                else if (p[1] > maxY) {\n                    maxY = p[1];\n                }\n            });\n        }\n        // Make bounds that encompasses the points, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Checks to see if another bounds fits in itself.\n     *\n     * @param {Bounds} inner The bounds to test against\n     *\n     * @return {number} int 1 is an exact fit, 2 it fits with space, 0 it doesn't fit\n     */\n    Bounds.prototype.fits = function (inner) {\n        if (this.width === inner.width) {\n            if (this.height === inner.height) {\n                return 1;\n            }\n        }\n        if (this.width >= inner.width) {\n            if (this.height >= inner.height) {\n                return 2;\n            }\n        }\n        return 0;\n    };\n    /**\n     * Check to see if the provided bounds intersects with this instance\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if the other object intersects with this instance\n     */\n    Bounds.prototype.hitBounds = function (bounds) {\n        if (bounds.right < this.x) {\n            return false;\n        }\n        if (bounds.x > this.right) {\n            return false;\n        }\n        if (bounds.bottom > this.y) {\n            return false;\n        }\n        if (bounds.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Tests if a point is inside this bounds\n     *\n     * @param p The point to test\n     *\n     * @return boolean The point to test\n     */\n    Bounds.prototype.pointInside = function (p) {\n        if (p.x < this.x) {\n            return false;\n        }\n        if (p.y > this.y) {\n            return false;\n        }\n        if (p.x > this.right) {\n            return false;\n        }\n        if (p.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Test function to type check the provided value\n     *\n     * @return True if value is a bounds object\n     */\n    Bounds.isBounds = function (value) {\n        // Falsy values aren't bounds objects\n        if (!value) {\n            return false;\n        }\n        // Direct test for bounds objects\n        if (value instanceof this) {\n            return true;\n        }\n        // Duck-typing check\n        return value &&\n            'containsPoint' in value &&\n            'encapsulate' in value &&\n            'hitTest' in value;\n    };\n    /**\n     * Check if this instance is completely inside the provided bounds\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if this instance is inside the provided bounds\n     */\n    Bounds.prototype.isInside = function (bounds) {\n        return (bounds.x <= this.x &&\n            bounds.right >= this.right &&\n            bounds.y >= this.y &&\n            bounds.bottom <= this.bottom);\n    };\n    /**\n     * Generates a Bounds object covering max extents\n     *\n     * @return {Bounds} bounds covering as wide of a range as possible\n     */\n    Bounds.maxBounds = function () {\n        return new Bounds(Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE);\n    };\n    return Bounds;\n}());\nexports.Bounds = Bounds;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * This class and set of methods is provided to attempt to create as efficient as possible\n * methods for updating large vertex buffers with values. The first portion of the file is\n * a list of methods and registers. This is to prevent any instantiation needed for the methods\n * and registers to exist. Also, the methods have no useable parent scope to ensure nothing like\n * a 'this' is used. These methods utilize the registers and their own simple loops to pound\n * through large amounts of information while providing capabilities to edit vertices in batches.\n *\n * You will also notice there are many many similar methods with just a single extra parameter\n * here and there. This is to prevent ANY calculations on trying to determine a proper parameter set\n * while also making method calls directly without any .call or .apply.\n *\n * The number of update methods is how many differing attributes are supported. If you need more supported\n * attributes add an updateBufferN method and provide the required attributes. Insert the logic in the EXACT\n * pattern seen in the other methods. DO NOT attempt to add additional logic lest the performance be something\n * terrible.\n *\n * The BufferUtil class makes use of these methods and registers. It also provides some very handy methods\n * for working with your large buffers.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar webgl_stat_1 = __webpack_require__(10);\nvar debugGenerator = __webpack_require__(3);\nvar debug = __webpack_require__(3)('WebGLSurface:BufferUtil');\nvar TriangleOrientation;\n(function (TriangleOrientation) {\n    // The triangles points are clockwise\n    TriangleOrientation[TriangleOrientation[\"CW\"] = 0] = \"CW\";\n    // The triangles points are Counter clockwise\n    TriangleOrientation[TriangleOrientation[\"CCW\"] = 1] = \"CCW\";\n    // The triangles points are linear, thus degenerate\n    TriangleOrientation[TriangleOrientation[\"DEGENERATE\"] = 2] = \"DEGENERATE\";\n})(TriangleOrientation = exports.TriangleOrientation || (exports.TriangleOrientation = {}));\nvar AttributeSize;\n(function (AttributeSize) {\n    AttributeSize[AttributeSize[\"ONE\"] = 0] = \"ONE\";\n    AttributeSize[AttributeSize[\"TWO\"] = 1] = \"TWO\";\n    AttributeSize[AttributeSize[\"THREE\"] = 2] = \"THREE\";\n    AttributeSize[AttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(AttributeSize = exports.AttributeSize || (exports.AttributeSize = {}));\nvar UniformAttributeSize;\n(function (UniformAttributeSize) {\n    UniformAttributeSize[UniformAttributeSize[\"ONE\"] = 0] = \"ONE\";\n    UniformAttributeSize[UniformAttributeSize[\"TWO\"] = 1] = \"TWO\";\n    UniformAttributeSize[UniformAttributeSize[\"THREE\"] = 2] = \"THREE\";\n    UniformAttributeSize[UniformAttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(UniformAttributeSize = exports.UniformAttributeSize || (exports.UniformAttributeSize = {}));\n/**\n * These are for fast look ups of the default values provided\n * Doing this fashion avoids array look ups in the defaults values\n */\nvar defaultsHolder0 = 0;\nvar defaultsHolder1 = 0;\nvar defaultsHolder2 = 0;\nvar defaultsHolder3 = 0;\n/**\n * These are for fast look ups of attribute buffers that are going\n * through the update process. We do everything to mitigate array look ups\n * when and where we can\n */\nvar attrRegister0 = [];\nvar attrRegister1 = [];\nvar attrRegister2 = [];\nvar attrRegister3 = [];\nvar attrRegister4 = [];\nvar attrRegister5 = [];\nvar attrRegister6 = [];\nvar attrRegister7 = [];\nvar attrRegister8 = [];\nvar attrRegister9 = [];\nvar attrRegister10 = [];\nvar attrIndex0 = 0;\nvar attrIndex1 = 0;\nvar attrIndex2 = 0;\nvar attrIndex3 = 0;\nvar attrIndex4 = 0;\nvar attrIndex5 = 0;\nvar attrIndex6 = 0;\nvar attrIndex7 = 0;\nvar attrIndex8 = 0;\nvar attrIndex9 = 0;\nvar attrIndex10 = 0;\nvar attrIndexIncr0 = 0;\nvar attrIndexIncr1 = 0;\nvar attrIndexIncr2 = 0;\nvar attrIndexIncr3 = 0;\nvar attrIndexIncr4 = 0;\nvar attrIndexIncr5 = 0;\nvar attrIndexIncr6 = 0;\nvar attrIndexIncr7 = 0;\nvar attrIndexIncr8 = 0;\nvar attrIndexIncr9 = 0;\nvar attrIndexIncr10 = 0;\n/** This is used to define a starting batch location to aid in continuing batch updates */\nvar lastBatchRegister = 0;\nvar isStreamUpdatingRegister = false;\n/**\n * This takes our list of attribute buffers and applies them to the registers for rapid lookups\n *\n * @param {number[][]} attributeBuffers The buffers for each attribute to be updated\n * @param {number[]} incrementValues How much each batch increments it's lookup index\n */\nfunction applyAttributeRegisters(attributeBuffers, incrementValues) {\n    attrRegister0 = attributeBuffers[0];\n    attrRegister1 = attributeBuffers[1];\n    attrRegister2 = attributeBuffers[2];\n    attrRegister3 = attributeBuffers[3];\n    attrRegister4 = attributeBuffers[4];\n    attrRegister5 = attributeBuffers[5];\n    attrRegister6 = attributeBuffers[6];\n    attrRegister7 = attributeBuffers[7];\n    attrRegister8 = attributeBuffers[8];\n    attrRegister9 = attributeBuffers[9];\n    attrRegister10 = attributeBuffers[10];\n    attrIndexIncr0 = incrementValues[0];\n    attrIndexIncr1 = incrementValues[1];\n    attrIndexIncr2 = incrementValues[2];\n    attrIndexIncr3 = incrementValues[3];\n    attrIndexIncr4 = incrementValues[4];\n    attrIndexIncr5 = incrementValues[5];\n    attrIndexIncr6 = incrementValues[6];\n    attrIndexIncr7 = incrementValues[7];\n    attrIndexIncr8 = incrementValues[8];\n    attrIndexIncr9 = incrementValues[9];\n    attrIndexIncr10 = incrementValues[10];\n}\n/**\n * The following methods are targetted at executing the update accessor with varying number\n * of parameters while mitigating array look ups.\n *\n * @param {number} numBatches The number of batches to execute\n * @param {Function} updateAccessor The accessor function that will update the buffer values\n */\nfunction updateBuffer1(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0);\n    }\n}\nfunction updateBuffer2(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1);\n    }\n}\nfunction updateBuffer3(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2);\n    }\n}\nfunction updateBuffer4(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3);\n    }\n}\nfunction updateBuffer5(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4);\n    }\n}\nfunction updateBuffer6(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5);\n    }\n}\nfunction updateBuffer7(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6);\n    }\n}\nfunction updateBuffer8(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7);\n    }\n}\nfunction updateBuffer9(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8);\n    }\n}\nfunction updateBuffer10(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9);\n    }\n}\nfunction updateBuffer11(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        attrIndex10 = i * attrIndexIncr10;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9, attrRegister10, attrIndex10);\n    }\n}\n/**\n * This takes the defaults array provided and loads them into our default\n * lookup values\n *\n * @param {number[]} defaults The array with the default values in them for our buffer attribute\n */\nfunction applyDefaultsHolders(defaults) {\n    defaultsHolder0 = defaults[0] || 0;\n    defaultsHolder1 = defaults[1] || 0;\n    defaultsHolder2 = defaults[2] || 0;\n    defaultsHolder3 = defaults[3] || 0;\n}\n/**\n * The following methods are rapid ways of populating the buffer without\n * setting up a generic loop. This saves on performance by not creating a loop\n * nor allocating the variables necessary for the generic loop.\n *\n * @param {Float32Array} buffer The buffer to populate\n * @param {number} start The index the data should be populated into\n */\nfunction fillSize1(buffer, start) {\n    buffer[start] = defaultsHolder0;\n}\nfunction fillSize2(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n}\nfunction fillSize3(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n}\nfunction fillSize4(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n    buffer[++start] = defaultsHolder3;\n}\nfunction isList(val) {\n    if (Array.isArray(val))\n        return true;\n    return false;\n}\n/**\n * This is a quick lookup to find the correct filler method for the given attribute size\n */\nvar fillMethodLookUp = (_a = {},\n    _a[AttributeSize.ONE] = fillSize1,\n    _a[AttributeSize.TWO] = fillSize2,\n    _a[AttributeSize.THREE] = fillSize3,\n    _a[AttributeSize.FOUR] = fillSize4,\n    _a);\nvar updateBufferLookUp = {\n    1: updateBuffer1,\n    2: updateBuffer2,\n    3: updateBuffer3,\n    4: updateBuffer4,\n    5: updateBuffer5,\n    6: updateBuffer6,\n    7: updateBuffer7,\n    8: updateBuffer8,\n    9: updateBuffer9,\n    10: updateBuffer10,\n    11: updateBuffer11,\n};\n/**\n * This provides methods for handling common buffer tasks such as construction\n * and population.\n */\nvar BufferUtil = /** @class */ (function () {\n    function BufferUtil() {\n    }\n    /**\n     * This places our updateBuffer into a mode where the updates start at index 0 of the\n     * buffer. Subsequent calls will start where the previous call left off. This lets\n     * you stream in updates to the buffer rather than just update the entire buffer\n     * all at once.\n     */\n    BufferUtil.beginUpdates = function () {\n        isStreamUpdatingRegister = true;\n        lastBatchRegister = 0;\n    };\n    /**\n     * This takes the buffer items and cleans up their use within memory as best as possible.\n     *\n     * @param bufferItems\n     */\n    BufferUtil.dispose = function (buffers) {\n        if (buffers) {\n            buffers.forEach(function (bufferItems) {\n                bufferItems.attributes = null;\n                bufferItems.currentData = null;\n                bufferItems.geometry.dispose();\n                bufferItems.geometry = null;\n                bufferItems.system = null;\n            });\n        }\n    };\n    /**\n     * This stops updates streaming into the buffers and makes it where an update\n     * will always just start at the beginning of the buffer.\n     */\n    BufferUtil.endUpdates = function () {\n        var totalBatches = lastBatchRegister;\n        isStreamUpdatingRegister = false;\n        lastBatchRegister = 0;\n        return totalBatches;\n    };\n    /**\n     * It is often needed to examine a given buffer and see how the triangles are packed in.\n     * This is a common debugging need and will speed up debugging significantly.\n     *\n     * @param {IBufferItems<T, U>} bufferItems This is the buffer whose structure we want\n     *                                         to examine.\n     * @param {string} message This is the message for the debug statement. There are two\n     *                         predefined %o. The first is the vertex information the second\n     *                         is the uniform info. Leave null for a default message.\n     * @param {string} debugNamespace The namespace for the debugging info.\n     */\n    BufferUtil.examineBuffer = function (bufferItems, message, debugNamespace) {\n        // Get the appropriate debug namespace\n        var debugBuffer = debugGenerator(debugNamespace);\n        // Quick quit if the debugger is not enabled\n        if (!debugBuffer.enabled) {\n            return;\n        }\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // Get the attributes by name out of the three js buffer\n        var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n        // Get the raw number buffers\n        var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n        // This will store all of the examined triangles for easy viewing\n        var triangles = [];\n        if (bufferItems.system.drawMode === three_1.TrianglesDrawMode) {\n            var currentVertex_1 = 0;\n            var attrSize_1 = 0;\n            var currentIndex_1 = 0;\n            var length_1 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_1 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_2 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_1 = attr.size + 1;\n                        currentIndex_1 = currentVertex_1 * attrSize_1;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_1, currentIndex_1 + attrSize_1);\n                    });\n                    // Move to the next vertex\n                    currentVertex_1++;\n                };\n                // Each new triangle is a culmination of three vertices which are packed in\n                // The buffer with no vertex sharing\n                for (var i = 0; i < 3; ++i) {\n                    _loop_2(i);\n                }\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_1 < length_1) {\n                _loop_1();\n            }\n        }\n        else if (bufferItems.system.drawMode === three_1.TriangleStripDrawMode) {\n            var currentVertex_2 = 0;\n            var attrSize_2 = 0;\n            var currentIndex_2 = 0;\n            var length_2 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_3 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_4 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_2 = attr.size + 1;\n                        currentIndex_2 = currentVertex_2 * attrSize_2;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_2, currentIndex_2 + attrSize_2);\n                    });\n                    // Move to the next vertex\n                    currentVertex_2++;\n                };\n                // Each new triangle is three vertices, where the first two are shared with\n                // The previous triangle's last two vertices\n                for (var i = 0; i < 3; ++i) {\n                    _loop_4(i);\n                }\n                // Go back two vertices as the next tri will use them + the next vertex to\n                // Make the next triangle\n                currentVertex_2 -= 2;\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_2 < length_2) {\n                _loop_3();\n            }\n        }\n        // Log the debug info to the console using the debug utility\n        debugBuffer(message || 'vertices: %o uniforms: %o', {\n            drawRange: buffer.drawRange,\n            triangles: triangles,\n        }, bufferItems.system.material.uniforms);\n    };\n    /**\n     * Aids in taking in multiple multibuffers and flattening it to a single list\n     *\n     * @param multiShapeBuffers\n     */\n    BufferUtil.flattenMultiBuffers = function (multiShapeBuffers) {\n        var all = [];\n        multiShapeBuffers.forEach(function (multiBuffer) {\n            multiBuffer.getBuffers().forEach(function (buffer) { return all = all.concat(buffer); });\n        });\n        return all;\n    };\n    /**\n     * @static\n     * This helps aid in updating a complex multi buffer. It will establish when a new\n     * buffer needs to be created and initialized and it will automatically call a BaseBuffer's\n     * update when an update is detected as a need for the buffer.\n     *\n     * @param multiShapeBuffer\n     * @param buffers\n     * @param init\n     *\n     * @return {boolean} True if a buffer was updated\n     */\n    BufferUtil.updateMultiBuffer = function (multiShapeBuffer, buffers, init, update, forceUpdates) {\n        // If no buffers provided, then we do not need to update anything\n        if (!multiShapeBuffer) {\n            return false;\n        }\n        // This flag indicates whether an update occurred or not\n        var didUpdate = false;\n        // Get the shape buffers we need rendered into vertex buffers\n        var shapeBuffers;\n        // If this is a list of multibuffers, we flatten out all of the sub buffers\n        // This is a one level deep flatten as we do not want to accidentally handle shape clustering here\n        if (isList(multiShapeBuffer)) {\n            shapeBuffers = multiShapeBuffer.reduce(function (flat, toFlatten) { return flat.concat(toFlatten.getBuffers()); }, []);\n        }\n        else {\n            shapeBuffers = multiShapeBuffer.getBuffers();\n        }\n        // Make a lookup to identify the buffers that already exists for the given multi shape buffers\n        var bufferLookup = new Map();\n        buffers.forEach(function (buffer) { return bufferLookup.set(buffer.bufferItems.currentData, buffer); });\n        // This will store all of the shape buffers that needs to be rendered into a vertex buffer\n        var needsBuffer = [];\n        // If we're forcing updates then we should be ensuring all shapeBuffers needs a buffer\n        // And leave all of the bufferLookup so they will all be updated with the provided needed shape buffer updates\n        if (forceUpdates) {\n            needsBuffer = [].concat(shapeBuffers);\n        }\n        else {\n            shapeBuffers.forEach(function (shapes) {\n                if (bufferLookup.get(shapes)) {\n                    bufferLookup.delete(shapes);\n                }\n                else {\n                    needsBuffer.push(shapes);\n                }\n            });\n        }\n        // All buffers remaining in the buffer lookup are available for re-rendering the\n        // Shape buffers that still needs updates\n        // If the shape buffers needing updates is greater than the vertex buffers available\n        // Then we update with what we have and initialize any additional vertex buffers needed\n        if (needsBuffer.length >= bufferLookup.size) {\n            // Take any buffer that is not found with an existing shape buffer and update it\n            // With a buffer that needs an update\n            bufferLookup.forEach(function (value) {\n                didUpdate = update(value, needsBuffer.shift()) || didUpdate;\n            });\n            // Any remaining buffers that need updates will have to initialize a buffer\n            // To cram it in\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = init();\n                buffers.push(vertexBuffer);\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n        }\n        else {\n            var vertexBuffers_1 = Array.from(bufferLookup.values());\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = vertexBuffers_1.shift();\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n            vertexBuffers_1.forEach(function (buffer) {\n                buffer.bufferItems.geometry.setDrawRange(0, 0);\n            });\n        }\n        return didUpdate;\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with constructing a new buffer\n     * such as applying the name, generating the buffer, and populating default values to\n     * that buffer.\n     *\n     * @param {number} numVertices The number of vertices this buffer will have\n     * @param {IAttributeInfo[]} attributes A description of each attribute in the buffer\n     *\n     * @returns {BufferGeometry} The newly made buffer\n     */\n    BufferUtil.makeBuffer = function (numVertices, attributes) {\n        var iMax = attributes.length;\n        var geometry = new three_1.BufferGeometry();\n        var totalAttributeSize = 0;\n        for (var i = 0; i < iMax; ++i) {\n            var attribute = attributes[i];\n            var attributeSize = attribute.size + 1;\n            totalAttributeSize += attributeSize;\n            var name_1 = attribute.name;\n            var injectBuffer = attribute.injectBuffer;\n            var buffer = injectBuffer || new Float32Array(attributeSize * numVertices);\n            var fillMethod = fillMethodLookUp[attribute.size];\n            var customFill = attribute.customFill;\n            var defaults = attribute.defaults;\n            // If an explicit buffer was not provided, then we fill with the defaults\n            if (!injectBuffer) {\n                if (customFill) {\n                    // Let the custom fill method populate the buffer with whatever so be desired\n                    for (var k = 0; k < numVertices; ++k) {\n                        customFill(buffer, k, k * attributeSize, defaults);\n                    }\n                }\n                else {\n                    // We set up our default value registers before executing the fill method\n                    applyDefaultsHolders(defaults);\n                    // Fill our buffer with the indicated default values\n                    for (var k = 0; k < numVertices; ++k) {\n                        fillMethod(buffer, k * attributeSize);\n                    }\n                }\n            }\n            // Apply the buffer to our geometry buffer\n            var attr = new three_1.BufferAttribute(buffer, attributeSize);\n            attr.setDynamic(true);\n            geometry.addAttribute(name_1, attr);\n            debug('Made Buffer Attribute:', name_1, attributeSize);\n        }\n        if (totalAttributeSize > 16) {\n            console.warn('A Buffer has specified more attributes than available. The max is 16 and the buffer provided:', totalAttributeSize);\n        }\n        return geometry;\n    };\n    /**\n     * Generates the necessary metrics based on uniform attributes to generate a uniform buffer for\n     * rendering.\n     *\n     * @param uniforms\n     */\n    BufferUtil.makeUniformBuffer = function (uniforms) {\n        var maxBlock = 0;\n        var buffer = [];\n        var uniformBufferBlockMax = webgl_stat_1.WebGLStat.MAX_VERTEX_INSTANCE_DATA;\n        var sizeCheck = {};\n        uniforms.forEach(function (uniform) {\n            maxBlock = Math.max(uniform.block, maxBlock);\n            var check = sizeCheck[uniform.block] = (sizeCheck[uniform.block] || 0) + (uniform.size + 1);\n            if (check > 4) {\n                console.warn('There were too many uniform attribute usages of a single block:', uniform);\n            }\n        });\n        for (var i = 0; i < uniformBufferBlockMax; ++i) {\n            buffer.push(new three_1.Vector4(0, 0, 0, 0));\n        }\n        return {\n            blocksPerInstance: maxBlock,\n            buffer: buffer,\n            maxInstances: Math.floor(uniformBufferBlockMax / maxBlock),\n        };\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with updating a buffer. You specify how many vertices\n     * to update in a batch and you specify how many batches are present.\n     *\n     * Batches are used to represent your full shape object that is being loaded from the cpu:\n     *\n     * IE- you have a rectangle object you wish to update in your buffer. This takes around 6 vertices typically\n     * so you make your vertexBatch 6 and the numBatches the number of quads you need to update in the buffer.\n     *\n     * You then provide an accessor which aids in pointing to the buffer items that need updating. The accessor has\n     * variable arguments depending on the attributes you inject in.\n     *\n     * If you have attributes like:\n     * [\n     *  {name: position, size: AttributeSize.Three},\n     *  {name: color, size: AttributeSize.Four},\n     * ]\n     *\n     * Then your accessor will be delievered arguments in this form:\n     *\n     * function(batchIndex: number, positionBuffer: number[], positionIndex: number, colorBuffer: number[], colorIndex: number)\n     *\n     * NOTE: The params handed in ARE ORDERED BY the attributes injected in\n     *\n     * You then can update the buffers based on the index information handed alongside each buffer\n     *\n     * @param {T[]} newData The new data that is going to be injected into the buffer. This must be a NEW REFERENCE of data\n     *                      that does NOT match the reference in the bufferItems.currentData. So newData !== bufferItems.currentData\n     *                      in order for the update to occur.\n     * @param {BufferGeometry} bufferItems The buffer related items used to identify how to update the buffer\n     * @param {number} vertexBatch The number of vertices to include per update batch\n     * @param {number} numBatches The number of batches to execute\n     * @param {Function} updateAccessor The accessor for performing the data update to the buffer\n     * @param {boolean} force This bypasses the typical checks that determines if the buffer SHOULD update.\n     *\n     * @return {boolean} True if the buffer was updated with this call\n     */\n    BufferUtil.updateBuffer = function (newData, bufferItems, vertexBatch, numBatches, updateAccessor, force) {\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            // Flag the newly rendered data as our current data\n            bufferItems.currentData = newData;\n            // Get the attributes by name out of the three js buffer\n            var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n            // Get the raw number buffers\n            var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n            // Determine what kind of buffer pointer increments we will need\n            var incrementValues = attributes.map(function (attr) { return (attr.size + 1) * vertexBatch; });\n            // Apply all data needed to any registers we need\n            applyAttributeRegisters(attributeBuffers, incrementValues);\n            // Get the method that will perform the update based on number of attributes\n            var updateMethod = updateBufferLookUp[attributes.length];\n            // Execute the update method\n            updateMethod(numBatches + lastBatchRegister, updateAccessor);\n            // Flag each buffer attribute for needing an update\n            bufferAttributes.forEach(function (attr) {\n                if (attr.updateRange) {\n                    attr.updateRange.offset = 0;\n                    attr.updateRange.count = vertexBatch * (lastBatchRegister + numBatches) * attr.itemSize;\n                }\n                attr.needsUpdate = true;\n            });\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n        }\n        return false;\n    };\n    /**\n     * This is an alternative way to specify data for rendering. This updates information within the\n     * uniform blocks to specify instancing data (the alternative is just updating a vertex buffer\n     * with all of the data needed for every piece of geometry for every instance). This update method\n     * CAN save massive amounts of committed data for large geometry items (ie curves). It requires a\n     * different pipeline to make work (your shader must specify a uniform vec4 instanceData[], and\n     * your shape buffer to vertex buffer conversion must have a static vertex buffer).\n     *\n     * This is like a vertex buffer update except the updateAccessor will be of this format:\n     *\n     * updateAccessor(instanceIndex: number, uniformBlock0: Vector4, ..., uniformBlockN: Vector4);\n     *\n     * Where the uniform blocks provided will appear in the same order the IUniformAttributes were in\n     * when the uniform buffer was created.\n     *\n     */\n    BufferUtil.updateUniformBuffer = function (newData, bufferItems, instanceBatchSize, updateAccessor, force) {\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        console.log('ATTEMPTING UNIFORM BUFFER UPDATE', newData !== undefined, newData !== bufferItems.currentData);\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            var material = bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var instanceData = uniforms.instanceData;\n            bufferItems.currentData = newData;\n            console.log('ATTEMPTING UNIFORM BUFFER UPDATE', instanceData, instanceData.type, 'v4v', bufferItems.uniformBuffer);\n            // If the instance data uniform is available and it is the proper vec4 array type, then we\n            // Are able to update the uniform buffer\n            if (instanceData && instanceData.type === 'v4v' && bufferItems.uniformBuffer) {\n                var attributes = bufferItems.uniformAttributes;\n                var blocksPerInstance = bufferItems.uniformBuffer.blocksPerInstance;\n                var buffer = bufferItems.uniformBuffer.buffer;\n                var maxInstances = bufferItems.uniformBuffer.maxInstances;\n                var currentInstance = lastBatchRegister;\n                var currentInstanceStartBlock = lastBatchRegister;\n                // We loop and update as many instances as specified, only up to the\n                // Number of instances allowed for the uniform buffer\n                for (var i = 0; i < instanceBatchSize && currentInstance < maxInstances; ++i) {\n                    // Our current instance depends on our lastBatchRegister we utilize\n                    // When begin() is called\n                    currentInstance = lastBatchRegister + i;\n                    // We get the first block the instance will utilize\n                    currentInstanceStartBlock = blocksPerInstance * currentInstance;\n                    // This will contain all of our arguments the accessor will use\n                    var updateArguments = [currentInstance];\n                    // Loop through the attributes in the order they appear and gather the block they will\n                    // Update\n                    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n                        var attribute = attributes_1[_i];\n                        updateArguments.push(buffer[attribute.block + currentInstanceStartBlock]);\n                    }\n                    // Call the update accessor for the instance using the gathered arguments\n                    // TODO: This should be done with registers like vertex array buffer updates for Optimal\n                    // Performance. A method apply is very slow compared to the register way.\n                    updateAccessor.apply(null, updateArguments);\n                }\n                // Tell the uniform to update with the new dataset\n                instanceData.value = [].concat(buffer);\n            }\n            else {\n                console.warn('A uniform buffer update was specified on a material that lacks uniform buffer usage');\n                return false;\n            }\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n        }\n        return false;\n    };\n    /**\n     * This makes all of the typical items used in creating and managing a buffer of items rendered to the screen\n     *\n     * @returns {IBufferItems<T>} An empty object of the particular buffer items needed\n     */\n    BufferUtil.makeBufferItems = function () {\n        return {\n            attributes: [],\n            currentData: [],\n            geometry: null,\n            system: null,\n            uniformAttributes: [],\n            uniformBuffer: null,\n        };\n    };\n    return BufferUtil;\n}());\nexports.BufferUtil = BufferUtil;\nvar _a;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(31);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar buffer_util_1 = __webpack_require__(2);\n/**\n * This deinfes the minimal set of methods that should be implemented to create\n * a reusable buffer object that can be initialized and populated.\n */\nvar BaseBuffer = /** @class */ (function () {\n    function BaseBuffer() {\n    }\n    /**\n     * This disposes the resources associated with a buffer.\n     */\n    BaseBuffer.prototype.dispose = function () {\n        if (this.bufferItems) {\n            buffer_util_1.BufferUtil.dispose([this.bufferItems]);\n        }\n    };\n    /**\n     * This initializes the buffer and generates the buffer items object.\n     */\n    BaseBuffer.prototype.init = function (material, unitCount) {\n        // To be implemented by a subclass\n    };\n    /**\n     * This updates the buffer by providing the shape buffer needed to update\n     * the internal buffer items\n     *\n     * @param {T[]} shapeBuffer The shape buffer containing all of the shape data\n     *                          to be placed into the buffer.\n     *\n     * @return {boolean} Retrusn true if this pushed up any updates\n     */\n    BaseBuffer.prototype.update = function (shapeBuffer) {\n        // To be implemented by a subclass\n        return false;\n    };\n    return BaseBuffer;\n}());\nexports.BaseBuffer = BaseBuffer;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculates the distance between two points, but keeps the distance in dquared form\n * thus performing Math.sqrt() on the output of this distance would provide the true\n * distance between the points.\n *\n * It is often faster and all that is needed to compare squared distances vs real distances\n * thus eliminating multiple Math.sqrt operations\n *\n * NOTE: For vectors this is the same as (pseudo code):\n * let vector3 = vector2.subtract(vector1)\n * return vector3.dot(vector3)\n *\n * @param p1 The point to find the distance from the second point\n * @param p2 The point to find the distance from the first point\n *\n * @return {number} The distance * distance between the two points\n */\nfunction squareDistance(p1, p2) {\n    var dx = p1.x - p2.x;\n    var dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n}\n/**\n * Contains methods for managing or manipulating points\n *\n * @export\n * @class Point\n */\nvar Point = /** @class */ (function () {\n    function Point() {\n    }\n    /**\n     * Adds two points together\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @return {IPoint} The two points added together\n     */\n    Point.add = function (p1, p2, out) {\n        if (out) {\n            out.x = p1.x + p2.x;\n            out.y = p1.y + p2.y;\n            return out;\n        }\n        return {\n            x: p1.x + p2.x,\n            y: p1.y + p2.y,\n        };\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {IPoint} The closest point to the test point\n     */\n    Point.getClosest = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = null;\n        var distance;\n        var findClosest = function (point) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = point;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * This just returns the index of the found point and not the point itself\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {number} The index of the closest point to the test point\n     */\n    Point.getClosestIndex = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = 0;\n        var distance;\n        var findClosest = function (point, i) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = i;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This will calculate a direction vector between two points that points toward p2\n     *\n     * @param {IPoint} p1 The start of the direction\n     * @param {IPoint} p2 The direction to point the vector towards\n     * @param {boolean} normalize If true, this will make the vector have a magnitude of 1\n     *\n     * @returns {number}\n     */\n    Point.getDirection = function (p1, p2, normalize) {\n        if (normalize === void 0) { normalize = false; }\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        if (normalize) {\n            var magnitude = Math.sqrt(dx * dx + dy * dy);\n            dx /= magnitude;\n            dy /= magnitude;\n        }\n        return {\n            x: dx,\n            y: dy,\n        };\n    };\n    /**\n     * @static\n     * Gets the distance between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {boolean} squared If set to true, returns the distance * distance (performs faster)\n     *\n     * @returns {number} The real distance between two points\n     */\n    Point.getDistance = function (p1, p2, squared) {\n        if (squared === void 0) { squared = false; }\n        if (squared) {\n            return squareDistance(p1, p2);\n        }\n        return Math.sqrt(squareDistance(p1, p2));\n    };\n    /**\n     * @static\n     * Gets a point perfectly between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     *\n     * @returns {IPoint} The point between the two provided points\n     */\n    Point.getMidpoint = function (p1, p2) {\n        var direction = Point.getDirection(p1, p2);\n        return {\n            x: direction.x / 2 + p1.x,\n            y: direction.y / 2 + p1.y,\n        };\n    };\n    Point.make = function (x, y) {\n        return { x: x, y: y };\n    };\n    /**\n     * Scales a point by a given amount\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {number} s The amount to scale the point by\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @memberof Point\n     */\n    Point.scale = function (p1, s, out) {\n        if (out) {\n            out.x = p1.x * s;\n            out.y = p1.y * s;\n            return out;\n        }\n        return {\n            x: p1.x * s,\n            y: p1.y * s,\n        };\n    };\n    /**\n     * Makes a new point initialized to {0,0}\n     *\n     * @static\n     * @returns {IPoint} A new point object at {0,0}\n     */\n    Point.zero = function () {\n        return {\n            x: 0,\n            y: 0,\n        };\n    };\n    return Point;\n}());\nexports.Point = Point;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(1);\n/**\n * Represents a line with a given slope\n */\nvar Line = /** @class */ (function (_super) {\n    __extends(Line, _super);\n    /**\n     * Creates a new line that passes through the two specified points\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    function Line(p1, p2) {\n        var _this = _super.call(this, 0, 1, 1, 0) || this;\n        _this.setPoints(p1, p2);\n        return _this;\n    }\n    /**\n     * This calculates the distance to a point from the provided line\n     * BUT this ALSO retains the directionality of that distance. So one side of\n     * the line will be positive while the other negative\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.directionTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line, but we won't take the absolute to retain the direction\n        return this.perpendicular.x * vector.x + this.perpendicular.y * vector.y;\n    };\n    /**\n     * This calculates the distance to a point from the provided line\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.distanceTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line\n        return Math.abs(this.perpendicular.x * vector.x +\n            this.perpendicular.y * vector.y);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {Array} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    Line.getClosest = function (lines, p) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(p);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This sets the two endpoints for this line and recalculates the bounds\n     * of the line accordingly\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    Line.prototype.setPoints = function (p1, p2) {\n        this.x = p1.x - 1;\n        this.y = p1.y - 1;\n        this.width = 2;\n        this.height = 2;\n        this.encapsulatePoint(p2);\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        this.slope = dy / dx;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.magnitude = Math.sqrt(dx * dx + dy * dy);\n        this.perpendicular = {\n            x: this.p2.y - this.p1.y,\n            y: -(this.p2.x - this.p1.x),\n        };\n        // Normalize the perpendicular line\n        var mag = Math.sqrt(this.perpendicular.x * this.perpendicular.x +\n            this.perpendicular.y * this.perpendicular.y);\n        this.perpendicular.x /= mag;\n        this.perpendicular.y /= mag;\n    };\n    return Line;\n}(bounds_1.Bounds));\nexports.Line = Line;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines a texture that is located on an atlas\n */\nvar AtlasTexture = /** @class */ (function () {\n    /**\n     * Generates a new atlas texture that points to a specific image resource.\n     *\n     * @param path The path to the image resource to be loaded into the atlas.\n     */\n    function AtlasTexture(path, label) {\n        /** Stores the aspect ratio of the image for quick reference */\n        this.aspectRatio = 1.0;\n        this.imagePath = path;\n        this.label = label;\n        // Let the label keep track of it's rasterization\n        if (label) {\n            this.label.rasterizedLabel = this;\n        }\n    }\n    return AtlasTexture;\n}());\nexports.AtlasTexture = AtlasTexture;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FrameInfo = /** @class */ (function () {\n    function FrameInfo() {\n    }\n    /** Contains the time the previous frame started */\n    FrameInfo.lastFrameTime = Date.now();\n    /** Contains a theoretical approximation the next frame will start */\n    FrameInfo.nextFrameTime = Date.now();\n    /** Contains how many frames have been played for a given WebGLSurface context */\n    FrameInfo.framesPlayed = new Map();\n    return FrameInfo;\n}());\nexports.FrameInfo = FrameInfo;\n/**\n * This gets an integer time value that can fit within an attribute. Be aware,\n * this only supports up to 7 digits of the millisecond time.\n */\nfunction getAttributeCurrentTime() {\n    var time = FrameInfo.lastFrameTime / 1E7;\n    return Math.floor((time - Math.floor(time)) * 1E7);\n}\nexports.getAttributeCurrentTime = getAttributeCurrentTime;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProgramInfo(gl, program) {\n    var result = {\n        attributeCount: 0,\n        attributes: new Array(),\n        uniformCount: 0,\n        uniforms: new Array(),\n    }, activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    // Taken from the WebGl spec:\n    // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n    var enums = {\n        0x8B50: 'FLOAT_VEC2',\n        0x8B51: 'FLOAT_VEC3',\n        0x8B52: 'FLOAT_VEC4',\n        0x8B53: 'INT_VEC2',\n        0x8B54: 'INT_VEC3',\n        0x8B55: 'INT_VEC4',\n        0x8B56: 'BOOL',\n        0x8B57: 'BOOL_VEC2',\n        0x8B58: 'BOOL_VEC3',\n        0x8B59: 'BOOL_VEC4',\n        0x8B5A: 'FLOAT_MAT2',\n        0x8B5B: 'FLOAT_MAT3',\n        0x8B5C: 'FLOAT_MAT4',\n        0x8B5E: 'SAMPLER_2D',\n        0x8B60: 'SAMPLER_CUBE',\n        0x1400: 'BYTE',\n        0x1401: 'UNSIGNED_BYTE',\n        0x1402: 'SHORT',\n        0x1403: 'UNSIGNED_SHORT',\n        0x1404: 'INT',\n        0x1405: 'UNSIGNED_INT',\n        0x1406: 'FLOAT',\n    };\n    var blocks = {\n        0x8B50: 1,\n        0x8B51: 1,\n        0x8B52: 1,\n        0x8B53: 1,\n        0x8B54: 1,\n        0x8B55: 1,\n        0x8B56: 1,\n        0x8B57: 1,\n        0x8B58: 1,\n        0x8B59: 1,\n        0x8B5A: 1,\n        0x8B5B: 3,\n        0x8B5C: 4,\n        0x8B5E: 1,\n        0x8B60: 1,\n        0x1400: 1,\n        0x1401: 1,\n        0x1402: 1,\n        0x1403: 1,\n        0x1404: 1,\n        0x1405: 1,\n        0x1406: 1,\n    };\n    // Loop through active uniforms\n    for (var i = 0; i < activeUniforms; ++i) {\n        var uniform = gl.getActiveUniform(program, i);\n        uniform.typeName = enums[uniform.type];\n        result.uniforms.push(uniform);\n        result.uniformCount += uniform.size;\n        uniform.size = uniform.size * blocks[uniform.type];\n    }\n    // Loop through active attributes\n    for (var i = 0; i < activeAttributes; i++) {\n        var attribute = gl.getActiveAttrib(program, i);\n        attribute.typeName = enums[attribute.type];\n        result.attributes.push(attribute);\n        result.attributeCount += attribute.size;\n    }\n    return result;\n}\nvar WebGLStat = /** @class */ (function () {\n    function WebGLStat() {\n    }\n    WebGLStat.printCurrentProgramInfo = function (debug, surface) {\n        if (surface.gl) {\n            var info = getProgramInfo(surface.gl, surface.gl.getParameter(surface.gl.CURRENT_PROGRAM));\n            var table = window.table;\n            if (table) {\n                table(info.uniforms);\n            }\n        }\n        else {\n            debug('Attempted to printProgramInfo but the surface has not established its gl context yet');\n        }\n    };\n    WebGLStat.MAX_VERTEX_UNIFORMS = 0;\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = 0;\n    WebGLStat.MAX_ATTRIBUTES = 0;\n    WebGLStat.WEBGL_SUPPORTED = false;\n    // TODO: This remains static until we have a qay to inject variable parameters into the shader\n    //       Strings. 128 is the guaranteed saftey range for uniform sizes for WebGL. We could have\n    //       Significantly higher numbers on most devices if we have dynamic field replacement for\n    //       Shaders.\n    WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    return WebGLStat;\n}());\nexports.WebGLStat = WebGLStat;\nfunction initStats() {\n    // Let's perform some immediate operations to do some gl querying for useful information\n    function getAContext() {\n        try {\n            var canvas = document.createElement('canvas');\n            return window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    // Attempt to retrieve a context for webgl\n    var gl = getAContext();\n    // If the context exists, then we know gl is supported and we can fill in some metrics\n    if (gl) {\n        WebGLStat.WEBGL_SUPPORTED = true;\n        WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        WebGLStat.MAX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n        // TODO: See TODO at declaration\n        WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    }\n}\ninitStats();\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Does a linear easing of a value\n *\n * @param {number} t The time elapsed: 0 to d\n * @param {number} s The start value\n * @param {number} c The change in value\n * @param {number} d The duration of the change\n *\n * @returns A number linearly progressing from s to s+c depending on the value of\n *          t in relation to d\n */\nfunction linear(t, s, c, d) {\n    return c * t / d + s;\n}\nexports.linear = linear;\nfunction easeInQuad(t, b, c, d) {\n    return c * (t /= d) * t + b;\n}\nexports.easeInQuad = easeInQuad;\nfunction easeOutQuad(t, b, c, d) {\n    return -c * (t /= d) * (t - 2) + b;\n}\nexports.easeOutQuad = easeOutQuad;\nfunction easeInOutQuad(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t + b;\n    return -c / 2 * ((--t) * (t - 2) - 1) + b;\n}\nexports.easeInOutQuad = easeInOutQuad;\nfunction easeInCubic(t, b, c, d) {\n    return c * (t /= d) * t * t + b;\n}\nexports.easeInCubic = easeInCubic;\nfunction easeOutCubic(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t + 1) + b;\n}\nexports.easeOutCubic = easeOutCubic;\nfunction easeInOutCubic(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t + 2) + b;\n}\nexports.easeInOutCubic = easeInOutCubic;\nfunction easeInQuart(t, b, c, d) {\n    return c * (t /= d) * t * t * t + b;\n}\nexports.easeInQuart = easeInQuart;\nfunction easeOutQuart(t, b, c, d) {\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n}\nexports.easeOutQuart = easeOutQuart;\nfunction easeInOutQuart(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t + b;\n    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n}\nexports.easeInOutQuart = easeInOutQuart;\nfunction easeInQuint(t, b, c, d) {\n    return c * (t /= d) * t * t * t * t + b;\n}\nexports.easeInQuint = easeInQuint;\nfunction easeOutQuint(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n}\nexports.easeOutQuint = easeOutQuint;\nfunction easeInOutQuint(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n}\nexports.easeInOutQuint = easeInOutQuint;\nfunction easeInSine(t, b, c, d) {\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n}\nexports.easeInSine = easeInSine;\nfunction easeOutSine(t, b, c, d) {\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\n}\nexports.easeOutSine = easeOutSine;\nfunction easeInOutSine(t, b, c, d) {\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n}\nexports.easeInOutSine = easeInOutSine;\nfunction easeInExpo(t, b, c, d) {\n    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n}\nexports.easeInExpo = easeInExpo;\nfunction easeOutExpo(t, b, c, d) {\n    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n}\nexports.easeOutExpo = easeOutExpo;\nfunction easeInOutExpo(t, b, c, d) {\n    if (t === 0)\n        return b;\n    if (t === d)\n        return b + c;\n    if ((t /= d / 2) < 1)\n        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n}\nexports.easeInOutExpo = easeInOutExpo;\nfunction easeInCirc(t, b, c, d) {\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n}\nexports.easeInCirc = easeInCirc;\nfunction easeOutCirc(t, b, c, d) {\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n}\nexports.easeOutCirc = easeOutCirc;\nfunction easeInOutCirc(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n}\nexports.easeInOutCirc = easeInOutCirc;\nfunction easeInElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n}\nexports.easeInElastic = easeInElastic;\nfunction easeOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n}\nexports.easeOutElastic = easeOutElastic;\nfunction easeInOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d / 2) === 2)\n        return b + c;\n    if (!p)\n        p = d * (.3 * 1.5);\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    if (t < 1)\n        return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n}\nexports.easeInOutElastic = easeInOutElastic;\nfunction easeInBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\n}\nexports.easeInBack = easeInBack;\nfunction easeOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n}\nexports.easeOutBack = easeOutBack;\nfunction easeInOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    if ((t /= d / 2) < 1)\n        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n}\nexports.easeInOutBack = easeInOutBack;\nfunction easeInBounce(t, b, c, d) {\n    return c - easeOutBounce(d - t, 0, c, d) + b;\n}\nexports.easeInBounce = easeInBounce;\nfunction easeOutBounce(t, b, c, d) {\n    if ((t /= d) < (1 / 2.75)) {\n        return c * (7.5625 * t * t) + b;\n    }\n    else if (t < (2 / 2.75)) {\n        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n    }\n    else if (t < (2.5 / 2.75)) {\n        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n    }\n    else {\n        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n    }\n}\nexports.easeOutBounce = easeOutBounce;\nfunction easeInOutBounce(t, b, c, d) {\n    if (t < d / 2)\n        return easeInBounce(t * 2, 0, c, d) * .5 + b;\n    return easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n}\nexports.easeInOutBounce = easeInOutBounce;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_1 = __webpack_require__(6);\nvar easing_1 = __webpack_require__(11);\n/**\n * This enum is just a common way to define interpolation types\n */\nvar InterpolationMethod;\n(function (InterpolationMethod) {\n    InterpolationMethod[InterpolationMethod[\"BEZIER2\"] = 0] = \"BEZIER2\";\n    InterpolationMethod[InterpolationMethod[\"BEZIER3\"] = 1] = \"BEZIER3\";\n    InterpolationMethod[InterpolationMethod[\"CIRCULAR\"] = 2] = \"CIRCULAR\";\n})(InterpolationMethod = exports.InterpolationMethod || (exports.InterpolationMethod = {}));\n/**\n * This calculates a quadratic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier2(t, p1, p2, c1) {\n    var t2 = t * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    return {\n        x: p1.x * mt2 + c1.x * 2 * mt * t + p2.x * t2,\n        y: p1.y * mt2 + c1.y * 2 * mt * t + p2.y * t2,\n    };\n}\nexports.bezier2 = bezier2;\n/**\n * This calculates a cubic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The first control point of the curve\n * @param {IPoint} c2 The second control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier3(t, p1, p2, c1, c2) {\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    var mt3 = mt2 * mt;\n    return {\n        x: p1.x * mt3 + 3 * c1.x * mt2 * t + 3 * c2.x * mt * t2 + p2.x * t3,\n        y: p1.y * mt3 + 3 * c1.y * mt2 * t + 3 * c2.y * mt * t2 + p2.y * t3,\n    };\n}\nexports.bezier3 = bezier3;\n/**\n * This calculates a point along a path defined as a circular path which is a\n * path moving along the edge of a circle from one point to the next. This will\n * even allow for moving along a circle with a growing radius.\n *\n * @param {number} t The 0 - 1 time interval for the part of the path we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point, or more importantly, the center of the circle\n * @param {EasingMethod} radiusEasing Default easing for the radius growing is linear.\n *                                    Insert a custom easing method to change this.\n *\n * @returns {IPoint}\n */\nfunction circular(t, p1, p2, c1, radiusEasing) {\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(c1, p1);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(c1, p2);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Ensure our theta's are definitely between 0 to Math.PI * 2 after the atan\n    // Calculation\n    if (theta1 < 0)\n        theta1 += Math.PI * 2;\n    if (theta2 < 0)\n        theta2 += Math.PI * 2;\n    var dTheta = theta2 - theta1;\n    // We ALWAYS want our path to be the shortest around the circle\n    if (dTheta > Math.PI) {\n        dTheta = theta1 - theta2;\n    }\n    // We use this to calculate how far we are between the two points in radians\n    // Based on the time parameter provided for the interpolation\n    dTheta *= t;\n    // We must have the radial distance of both points to properly calculate\n    // An easing between the two radii\n    var radius1 = point_1.Point.getDistance(p1, c1);\n    var radius2 = point_1.Point.getDistance(p2, c1);\n    // We control how the radius eases out for the path, which is determined by\n    // The easing method, otherwise, it just linearly radiates out\n    var radius = (radiusEasing || easing_1.linear)(t, radius1, radius2 - radius1, 1.0);\n    return {\n        x: Math.cos(theta1 + dTheta) * radius + c1.x,\n        y: Math.sin(theta1 + dTheta) * radius + c1.y,\n    };\n}\nexports.circular = circular;\nexports.pickInterpolation = (_a = {},\n    _a[InterpolationMethod.BEZIER2] = bezier2,\n    _a[InterpolationMethod.BEZIER3] = bezier3,\n    _a[InterpolationMethod.CIRCULAR] = circular,\n    _a);\nvar _a;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar d3_color_1 = __webpack_require__(29);\nvar three_1 = __webpack_require__(0);\nvar bounds_1 = __webpack_require__(1);\nvar pack_node_1 = __webpack_require__(14);\nvar label_1 = __webpack_require__(15);\nvar atlas_texture_1 = __webpack_require__(8);\nvar debug = __webpack_require__(3)('webgl-surface:Atlas');\nvar debugLabels = __webpack_require__(3)('webgl-surface:Labels');\nvar ZERO_IMAGE = {\n    atlasBL: { x: 0, y: 0 },\n    atlasBR: { x: 0, y: 0 },\n    atlasTL: { x: 0, y: 0 },\n    atlasTR: { x: 0, y: 0 },\n    label: new label_1.Label({ text: ' ' }),\n    pixelHeight: 0,\n    pixelWidth: 0,\n};\n/**\n * Defines a manager of atlas', which includes generating the atlas and producing\n * textures defining those pieces of atlas.\n */\nvar AtlasManager = /** @class */ (function () {\n    /**\n     * Generates a new manager for atlas'. This will create and destroy atlas' and\n     * ensure they have the correct settings applied. A manager will also aid in\n     * packing images into the atlas indicated.\n     *\n     * @param {number} width The width of all atlas' generated\n     * @param {number} height The height of all atlas' generated\n     */\n    function AtlasManager(width, height) {\n        /** Gives a reference of all of the images loaded for the atlas */\n        this.atlasImages = {};\n        /** Stores the current mapping of the atlas */\n        this.atlasMap = {};\n        /** Stores all of the textures that are our atlases */\n        this.atlasTexture = {};\n        this.textureWidth = width;\n        this.textureHeight = height;\n    }\n    /**\n     * Atlas' must be created from scratch to update them. In order to properly\n     * update an existing one, you must destroy it then recreate it again.\n     * This is from not knowing how to update a texture via three js.\n     *\n     * @param atlasName The unique name of the atlas so it can be retrieved/referenced easily\n     * @param images The images with their image path set to be loaded into the atlas.\n     *               Images that keep an atlas ID of null indicates the image did not load\n     *               correctly\n     *\n     * @return {Texture} The Threejs texture that is created as our atlas. The images injected\n     *                   into the texture will be populated with the atlas'\n     */\n    AtlasManager.prototype.createAtlas = function (atlasName, images, colors) {\n        return __awaiter(this, void 0, void 0, function () {\n            var atlasMap, canvas, _i, images_1, image, image, texture, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        atlasMap = new pack_node_1.PackNode(0, 0, this.textureWidth, this.textureHeight);\n                        // Create the mapping element for the new atlas so we can track insertions / deletions\n                        this.atlasMap[atlasName] = atlasMap;\n                        // Make a listing of images that is within the atlas\n                        this.atlasImages[atlasName] = [];\n                        canvas = document.createElement('canvas').getContext('2d');\n                        // Size the canvas to the atlas size\n                        canvas.canvas.width = this.textureWidth;\n                        canvas.canvas.height = this.textureHeight;\n                        if (!images) return [3 /*break*/, 4];\n                        _i = 0, images_1 = images;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < images_1.length)) return [3 /*break*/, 4];\n                        image = images_1[_i];\n                        return [4 /*yield*/, this.draw(image, atlasName, canvas)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (!colors) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.drawColors(colors, atlasName, canvas)];\n                    case 5:\n                        image = _b.sent();\n                        // Add the dummy texture info as an image to our list of images\n                        if (image) {\n                            this.atlasImages[atlasName].push(image);\n                        }\n                        _b.label = 6;\n                    case 6:\n                        texture = new three_1.Texture(canvas.canvas);\n                        texture.premultiplyAlpha = true;\n                        texture.generateMipmaps = true;\n                        // Store the texture as the atlas.\n                        this.atlasTexture[atlasName] = texture;\n                        // Store the images as images within the atlas\n                        if (images) {\n                            (_a = this.atlasImages[atlasName]).push.apply(_a, images);\n                        }\n                        debug('Atlas Created-> texture: %o mapping: %o images: %o', texture, atlasMap, images);\n                        return [2 /*return*/, texture];\n                }\n            });\n        });\n    };\n    /**\n     * Disposes of the resources the atlas held and makes the atlas invalid for use\n     *\n     * @param atlasName\n     */\n    AtlasManager.prototype.destroyAtlas = function (atlasName) {\n        if (this.atlasTexture[atlasName]) {\n            this.atlasTexture[atlasName].dispose();\n            this.atlasTexture[atlasName] = null;\n        }\n        if (this.atlasMap[atlasName]) {\n            this.atlasMap[atlasName].destroy();\n            this.atlasMap[atlasName] = null;\n        }\n        if (this.atlasImages[atlasName]) {\n            var none_1 = { x: 0, y: 0 };\n            this.atlasImages[atlasName].forEach(function (image) {\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                image.pixelHeight = 0;\n                image.atlasBL = none_1;\n                image.atlasBR = none_1;\n                image.atlasTL = none_1;\n                image.atlasTR = none_1;\n            });\n            this.atlasImages[atlasName] = null;\n        }\n    };\n    AtlasManager.prototype.isValidImage = function (image) {\n        var isValid = false;\n        if (image && (image.imagePath || (image.label && image.label.text))) {\n            if (image.pixelWidth && image.pixelHeight) {\n                isValid = true;\n            }\n        }\n        return isValid;\n    };\n    AtlasManager.prototype.setDefaultImage = function (image, atlasName) {\n        image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n        return image;\n    };\n    /**\n     * This loads, packs, and draws the indicated image into the specified canvas\n     * using the metrics that exists for the specified atlas.\n     *\n     * @param image The image who should have it's image path loaded\n     * @param atlasName The name of the atlas to make the packing work\n     * @param canvas The canvas we will be drawing into to generate the complete image\n     *\n     * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\n     */\n    AtlasManager.prototype.draw = function (image, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var loadedImage, rect, dimensions, node, insertedNode, ux, uy, uw, uh, atlasDimensions;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Validate the index\n                        if (!this.atlasMap[atlasName]) {\n                            debug('Can not load image, invalid Atlas Name: %o for atlasMaps: %o', atlasName, this.atlasMap);\n                            return [2 /*return*/, false];\n                        }\n                        return [4 /*yield*/, this.loadImage(image)];\n                    case 1:\n                        loadedImage = _a.sent();\n                        // Make sure at this point the image knows it is not affiliated with an atlas\n                        // If something goes wrong with loading or insertting this image, then a null\n                        // Atlas value will indicate the image can not be used appropriately\n                        image.atlasReferenceID = null;\n                        // Only a non-null image means the image loaded correctly\n                        if (loadedImage && this.isValidImage(image)) {\n                            debug('Image loaded: %o', image.imagePath);\n                            rect = new bounds_1.Bounds(0, image.pixelWidth, image.pixelHeight, 0);\n                            dimensions = {\n                                first: image,\n                                second: rect,\n                            };\n                            // Auto add a buffer in\n                            dimensions.second.width += 1;\n                            dimensions.second.height += 1;\n                            node = this.atlasMap[atlasName];\n                            insertedNode = node.insert(dimensions);\n                            // If the result was NULL we did not successfully insert the image into any map\n                            if (insertedNode) {\n                                debug('Atlas location determined: %o', insertedNode);\n                                if (image.label) {\n                                    debugLabels('Atlas location determined. PackNode: %o Dimensions: %o', insertedNode, dimensions);\n                                }\n                                // Apply the image to the node\n                                insertedNode.nodeImage = image;\n                                ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                                uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                                uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                                uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                                debugLabels('uy is %o', uy);\n                                atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                                image.atlasReferenceID = atlasName;\n                                image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                                image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                                // Now draw the image to the indicated canvas\n                                canvas.drawImage(loadedImage, insertedNode.nodeDimensions.x, insertedNode.nodeDimensions.y);\n                                // We have finished inserting\n                                return [2 /*return*/, true];\n                            }\n                            else {\n                                // Log an error\n                                console.error(\"Could not fit image into atlas \" + image.imagePath);\n                                image = this.setDefaultImage(image, atlasName);\n                                return [2 /*return*/, false];\n                            }\n                        }\n                        else {\n                            // Log an error and load a default image\n                            console.error(\"Could not load image \" + image.imagePath);\n                            image = this.setDefaultImage(image, atlasName);\n                            return [2 /*return*/, false];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This renders a list of colors to the canvas. This using the same packing\n     * algorithm as any image so the rendering is placed correctly or determines\n     * if enough space is not available.\n     *\n     * @param {AtlasColor[]} colors The list of colors to be rendered to the atlas\n     * @param {string} atlasName The name of the atlas being rendered to\n     * @param {CanvasRenderingContext2D} canvas The canvas of the atlas being rendered to\n     *\n     * @returns {Promise<boolean>} Resolves to true if the operation was successful\n     */\n    AtlasManager.prototype.drawColors = function (colors, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var colorWidth, colorHeight, maxPerRow, rowWidth, rowCount, colCount, renderHeight, dimensions, node, insertedNode, image, ux, uy, uw, uh, atlasDimensions, renderSpace, startX, startY, nextX, nextY, beginX, beginY, col, row, _i, colors_1, color, _a, r, g, b;\n            return __generator(this, function (_b) {\n                debug('Finding space for colors on the atlas: %o', colors);\n                colorWidth = 2;\n                colorHeight = 2;\n                maxPerRow = 1024 / colorWidth;\n                rowWidth = Math.min(this.textureWidth, maxPerRow * colorWidth);\n                rowCount = Math.ceil((colors.length * colorWidth) / rowWidth);\n                colCount = Math.ceil(rowWidth / colorWidth);\n                renderHeight = rowCount * colorHeight;\n                dimensions = {\n                    // Since the algorithm requires something to fill this slot, just make a\n                    // Dummy object\n                    first: new atlas_texture_1.AtlasTexture(null, null),\n                    // Set the dimensions we calculated for the space our colors will take up\n                    // Within the atlas\n                    second: new bounds_1.Bounds(0, rowWidth, renderHeight, 0),\n                };\n                // Auto add a buffer in\n                dimensions.second.width += 1;\n                dimensions.second.height += 1;\n                node = this.atlasMap[atlasName];\n                insertedNode = node.insert(dimensions);\n                // If the result was NULL we did not successfully insert the image into any map\n                if (insertedNode) {\n                    debug('Atlas location determined for colors: %o', insertedNode);\n                    image = insertedNode.nodeImage = dimensions.first;\n                    ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                    uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                    uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                    uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                    atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                    image.atlasReferenceID = atlasName;\n                    image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                    image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                    renderSpace = insertedNode.nodeDimensions;\n                    startX = renderSpace.x;\n                    startY = renderSpace.y;\n                    nextX = colorWidth / this.textureWidth;\n                    nextY = -colorHeight / this.textureHeight;\n                    beginX = (startX / this.textureWidth) + (nextX / 2.0);\n                    beginY = 1.0 - (startY / this.textureHeight) + (nextY / 2.0);\n                    col = 0;\n                    row = 0;\n                    // Loop through each color, establish metrics, draw to the atlas\n                    for (_i = 0, colors_1 = colors; _i < colors_1.length; _i++) {\n                        color = colors_1[_i];\n                        // Staore the info needed to make the color referenceable again\n                        color.atlasReferenceID = atlasName;\n                        color.colorIndex = col + (row * colCount);\n                        color.colorsPerRow = colCount;\n                        // The location of the middle of the first color\n                        color.firstColor = {\n                            x: beginX,\n                            y: beginY,\n                        };\n                        color.nextColor = {\n                            x: nextX,\n                            y: nextY,\n                        };\n                        _a = color.color, r = _a.r, g = _a.g, b = _a.b;\n                        // Draw the color to the canvas\n                        canvas.fillStyle = \"rgba(\" + Math.round(r * 255.0) + \", \" + Math.round(g * 255.0) + \", \" + Math.round(b * 255.0) + \", \" + color.opacity + \")\";\n                        canvas.fillRect(col * colorWidth + startX, row * colorHeight + startY, colorWidth, colorHeight);\n                        col++;\n                        if (col === colCount) {\n                            col = 0;\n                            row++;\n                        }\n                    }\n                    // We have finished inserting\n                    return [2 /*return*/, image];\n                }\n                else {\n                    // Log an error\n                    throw new Error('Could not fit colors into atlas');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Retrieves the threejs texture for the atlas\n     *\n     * @param atlasName The identifier of the atlas\n     */\n    AtlasManager.prototype.getAtlasTexture = function (atlasName) {\n        return this.atlasTexture[atlasName];\n    };\n    /**\n     * This reads the input path and loads the image specified by the path\n     *\n     * @param {AtlasTexture} texture This is an atlas texture with the path set\n     *\n     * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\n     *                                     or null if there was an error\n     */\n    AtlasManager.prototype.loadImage = function (texture) {\n        if (texture.imagePath) {\n            return new Promise(function (resolve, reject) {\n                var image = new Image();\n                image.onload = function () {\n                    texture.pixelWidth = image.width;\n                    texture.pixelHeight = image.height;\n                    texture.aspectRatio = image.width / image.height;\n                    resolve(image);\n                };\n                image.onerror = function () {\n                    resolve(null);\n                };\n                image.src = texture.imagePath;\n            });\n        }\n        else if (texture.label) {\n            return new Promise(function (resolve, reject) {\n                var label = texture.label;\n                var labelSize = label.getSize();\n                var canvas = document.createElement('canvas');\n                var ctx = canvas.getContext('2d');\n                // Set the dimensions of the canvas/texture space we will be using to rasterize\n                // The label. Use the label's rasterization controls to aid in rendering the label\n                canvas.width = labelSize.width + texture.label.rasterizationOffset.x;\n                canvas.height = labelSize.height;\n                debug('label X %o', texture.label.rasterizationOffset.x);\n                if (ctx) {\n                    var fontSize = label.fontSize;\n                    var color = d3_color_1.rgb(label.color.base.color.r * 255, label.color.base.color.g * 255, label.color.base.color.b * 255, label.color.base.opacity);\n                    ctx.font = label.makeCSSFont(fontSize);\n                    ctx.textAlign = label.textAlign;\n                    ctx.textBaseline = label.textBaseline;\n                    ctx.fillStyle = color.toString();\n                    // Render the label to the canvas/texture space. This utilizes the label's\n                    // Rasterization metrics to aid in getting a clean render.\n                    ctx.fillText(label.text, texture.label.rasterizationOffset.x, texture.label.rasterizationOffset.y);\n                    var image_1 = new Image();\n                    image_1.onload = function () {\n                        // Here we use the canvas dimensions and NOT the image dimensions\n                        // As the image dimensions are unreliable here when setting the src\n                        // To a data url\n                        texture.pixelWidth = image_1.width;\n                        texture.pixelHeight = image_1.height;\n                        texture.aspectRatio = image_1.width / image_1.height;\n                        debugLabels('Applying size based on rasterization to the Label: w: %o h: %o', image_1.width, image_1.height);\n                        label.setSize({\n                            height: image_1.height,\n                            width: image_1.width,\n                        });\n                        resolve(image_1);\n                    };\n                    image_1.onerror = function () {\n                        resolve(null);\n                    };\n                    image_1.src = canvas.toDataURL('image/png');\n                }\n            });\n        }\n        return Promise.resolve(null);\n    };\n    return AtlasManager;\n}());\nexports.AtlasManager = AtlasManager;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(1);\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nvar PackNode = /** @class */ (function () {\n    function PackNode(x, y, width, height) {\n        this.child = [null, null];\n        this.isLeaf = true;\n        this.nodeImage = null;\n        this.nodeDimensions = new bounds_1.Bounds(x, x + width, y, y - height);\n    }\n    /**\n     * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n     */\n    PackNode.prototype.destroy = function () {\n        this.nodeImage = null;\n        if (this.child[0]) {\n            this.child[0].destroy();\n        }\n        if (this.child[1]) {\n            this.child[1].destroy();\n        }\n        this.child[0] = undefined;\n        this.child[1] = undefined;\n    };\n    /**\n     * Indicates if there is a child\n     */\n    PackNode.prototype.hasChild = function () {\n        if (this.child[0] && !this.child[0].nodeImage) {\n            return !this.child[0].isLeaf;\n        }\n        if (this.child[1] && !this.child[1].nodeImage) {\n            return !this.child[1].isLeaf;\n        }\n        return false;\n    };\n    /**\n     * Inserts images into our mapping, fitting them appropriately\n     */\n    PackNode.prototype.insert = function (image) {\n        if (!this.isLeaf) {\n            // Try inserting into first child\n            var newNode = this.child[0].insert(image);\n            if (newNode !== null) {\n                return newNode;\n            }\n            // No room in first so insert into second\n            return this.child[1].insert(image);\n        }\n        else {\n            // If there's already an image here, return\n            if (this.nodeImage) {\n                return null;\n            }\n            // Check the fit status of the image in this nodes rectangle space\n            var fitFlag = this.nodeDimensions.fits(image.second);\n            // If we're too small, return null indicating can not fit\n            if (fitFlag === 0) {\n                return null;\n            }\n            // If we're just right, accept\n            if (fitFlag === 1) {\n                return this;\n            }\n            // Otherwise, gotta split this node and create some leaves\n            this.isLeaf = false;\n            // Get the image width\n            var imgWidth = image.second.width;\n            var imgHeight = image.second.height;\n            // Decide which way to split\n            var dWidth = this.nodeDimensions.width - imgWidth;\n            var dHeight = this.nodeDimensions.height - image.second.height;\n            if (dWidth > dHeight) {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, imgWidth, this.nodeDimensions.height);\n                this.child[1] = new PackNode(this.nodeDimensions.x + imgWidth, this.nodeDimensions.y, dWidth, this.nodeDimensions.height);\n            }\n            else {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, this.nodeDimensions.width, imgHeight);\n                this.child[1] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y + imgHeight, this.nodeDimensions.width, dHeight);\n            }\n        }\n        // Insert into first child we created\n        return this.child[0].insert(image);\n    };\n    /**\n     * Removes the image from the mapping and tries to open up as much space as possible.\n     *\n     * @param {AtlasTexture} image The image to insert into the\n     */\n    PackNode.prototype.remove = function (image) {\n        if (!this.isLeaf) {\n            // Try removing from first child\n            var removed = this.child[0].remove(image);\n            if (removed) {\n                return true;\n            }\n            // Try remove from second\n            removed = this.child[1].remove(image);\n            if (!this.child[0].hasChild()) {\n                if (!this.child[1].hasChild()) {\n                    this.child[0] = null;\n                    this.child[1] = null;\n                }\n            }\n            return removed;\n        }\n        else {\n            if (this.nodeImage === image) {\n                this.nodeImage = null;\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    return PackNode;\n}());\nexports.PackNode = PackNode;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(5);\nvar rotateable_quad_1 = __webpack_require__(16);\nvar sprite_1 = __webpack_require__(17);\nvar measurement = new sprite_1.Sprite(200, 200, 1, 1);\nvar Label = /** @class */ (function (_super) {\n    __extends(Label, _super);\n    /**\n     * Creates an instance of Label.\n     *\n     * @param {Partial<Label<T>>} [options={}]\n     */\n    function Label(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { x: 0, y: 1 }, { width: 1, height: 1 }, 0, rotateable_quad_1.AnchorPosition.TopLeft) || this;\n        _this.depth = 40;\n        _this.direction = 'inherit';\n        _this.font = 'serif';\n        _this.fontSize = 10;\n        _this.fontWeight = 400;\n        _this.maxWidth = undefined;\n        _this.text = '';\n        _this.id = '';\n        _this.textAlign = 'start';\n        _this.textBaseline = 'alphabetic';\n        _this.zoomable = false;\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to offset the rasterization if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationOffset = { x: 20, y: 0 };\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to pad the rasterization space if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationPadding = { width: 0, height: 0 };\n        // Set props\n        Object.assign(_this, options);\n        // Make sure our dimensions are set\n        _this.setFontSize(options.fontSize || 12);\n        return _this;\n    }\n    Object.defineProperty(Label.prototype, \"baseLabel\", {\n        get: function () {\n            return this._baseLabel;\n        },\n        set: function (value) {\n            this._baseLabel = value;\n            this.text = value.text;\n            this.fontSize = value.fontSize;\n            this.font = value.font;\n            this.textAlign = value.textAlign;\n            this.textBaseline = value.textBaseline;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Label.prototype, \"rasterizedLabel\", {\n        /**\n         * This getter ensures the rasterized label retrieved is either this labels own rasterization\n         * or from a base.\n         */\n        get: function () {\n            if (this.baseLabel) {\n                return this.baseLabel.rasterizedLabel;\n            }\n            return this._rasterizedLabel;\n        },\n        set: function (value) {\n            this._rasterizedLabel = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Copies all of the properties of a label and makes this label use them\n     *\n     * @param {Label} label The labels whose properties we wish to copy\n     */\n    Label.prototype.copyLabel = function (label) {\n        // Assign the properties of the other label to this\n        // Specifically, ONLY label properties\n        Object.assign(this, ramda_1.omit(['x', 'y', 'width', 'height'], label));\n        // Use this to set the text to make sure all of the metrics are re-calculated\n        this.setText(label.text);\n    };\n    /**\n     * This gets the actual text this label is capable of rendering\n     */\n    Label.prototype.getText = function () {\n        if (this._baseLabel) {\n            return this._baseLabel.getText();\n        }\n        return this.text;\n    };\n    /**\n     * Takes all of the current settings and makes a CSS font string\n     */\n    Label.prototype.makeCSSFont = function (fontSize) {\n        return this.fontWeight + \" \" + (fontSize || this.fontSize) + \"px \" + this.font;\n    };\n    /**\n     * Change the position this text is rendered to\n     *\n     * @param x X world coordinate\n     * @param y Y world coordinate\n     */\n    Label.prototype.position = function (x, y) {\n        this.x = x;\n        this.y = y;\n    };\n    /**\n     * This sets the font size for the label based on the base text dimensions\n     *\n     * @param {number} fontSize\n     */\n    Label.prototype.setFontSize = function (fontSize) {\n        var lbl = this.getText();\n        var size = this.getSize();\n        var width = size.width;\n        var height = size.height;\n        if (this.baseLabel) {\n            var baseSize = this.baseLabel.getSize();\n            var scale = fontSize / this.baseLabel.fontSize;\n            height = baseSize.height * scale;\n            width = baseSize.width * scale;\n        }\n        else {\n            measurement.context.font = this.makeCSSFont();\n            var size_1 = measurement.context.measureText(lbl);\n            // Set our properties based on the calculated size\n            height = fontSize;\n            width = size_1.width;\n        }\n        this.fontSize = fontSize;\n        this.setSize({ width: width, height: height });\n    };\n    /**\n     * Change the text and the calculated bounding box for this label\n     */\n    Label.prototype.setText = function (lbl) {\n        this.text = lbl;\n        this.setFontSize(this.fontSize);\n    };\n    Label.prototype.update = function () {\n        this.setFontSize(this.fontSize);\n        _super.prototype.update.call(this);\n    };\n    return Label;\n}(rotateable_quad_1.RotateableQuad));\nexports.Label = Label;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar bounds_1 = __webpack_require__(1);\nvar AnchorPosition;\n(function (AnchorPosition) {\n    AnchorPosition[AnchorPosition[\"BottomLeft\"] = 0] = \"BottomLeft\";\n    AnchorPosition[AnchorPosition[\"BottomRight\"] = 1] = \"BottomRight\";\n    AnchorPosition[AnchorPosition[\"Custom\"] = 2] = \"Custom\";\n    AnchorPosition[AnchorPosition[\"Middle\"] = 3] = \"Middle\";\n    AnchorPosition[AnchorPosition[\"MiddleBottom\"] = 4] = \"MiddleBottom\";\n    AnchorPosition[AnchorPosition[\"MiddleLeft\"] = 5] = \"MiddleLeft\";\n    AnchorPosition[AnchorPosition[\"MiddleRight\"] = 6] = \"MiddleRight\";\n    AnchorPosition[AnchorPosition[\"MiddleTop\"] = 7] = \"MiddleTop\";\n    AnchorPosition[AnchorPosition[\"TopLeft\"] = 8] = \"TopLeft\";\n    AnchorPosition[AnchorPosition[\"TopRight\"] = 9] = \"TopRight\";\n})(AnchorPosition = exports.AnchorPosition || (exports.AnchorPosition = {}));\nvar anchorCalculations = (_a = {},\n    _a[AnchorPosition.BottomLeft] = function (quad) { return ({\n        x: 0,\n        y: 0,\n    }); },\n    _a[AnchorPosition.BottomRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: 0,\n    }); },\n    _a[AnchorPosition.Custom] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.Middle] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleBottom] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: 0,\n    }); },\n    _a[AnchorPosition.MiddleLeft] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleTop] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopLeft] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: quad.getSize().height,\n    }); },\n    _a);\nvar RotateableQuad = /** @class */ (function (_super) {\n    __extends(RotateableQuad, _super);\n    /**\n     * Generates a quad\n     *\n     * @param {IPoint} location The location of the quad (it's anchorpoint will be placed here)\n     * @param {number} width The width of the quad\n     * @param {number} height The height of the quad\n     * @param {AnchorPosition} anchor The anchor location of the quad.\n     *                                Location and rotation will be relative to this.\n     */\n    function RotateableQuad(location, size, rotation, anchor) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        // Apply our properties\n        _this.setSize(size);\n        _this.setAnchor(anchor);\n        _this.setLocation(location);\n        _this.setRotation(rotation);\n        // Update the transform and the corner vertices\n        _this.update();\n        return _this;\n    }\n    /**\n     * @private\n     * Recalculates this anchor position based on the anchor type\n     *\n     * @param {AnchorPosition} anchor\n     */\n    RotateableQuad.prototype.calculateAnchor = function (anchor) {\n        this.anchor = anchorCalculations[anchor](this);\n    };\n    /**\n     * Get the base size of the quad\n     *\n     * @returns {ISize} The base size of this quad\n     */\n    RotateableQuad.prototype.getSize = function () {\n        return this.size;\n    };\n    /**\n     * Sets the specified anchor position on the quad\n     *\n     * @param {AnchorPosition} anchor This specifies an auto calculated position for the anchor\n     * @param {IPoint} custom If specified, will set a custom anchor location rather\n     *                        than the calculated version.\n     */\n    RotateableQuad.prototype.setAnchor = function (anchor, custom) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        this.anchorType = anchor;\n        // Apply the custom position if present\n        if (custom) {\n            this.anchorType = AnchorPosition.Custom;\n            this.anchor = custom;\n            return;\n        }\n        this.calculateAnchor(anchor);\n    };\n    RotateableQuad.prototype.getAnchor = function () {\n        return this.anchor;\n    };\n    RotateableQuad.prototype.getAnchorType = function () {\n        return this.anchorType;\n    };\n    /**\n     * This sets the location of this quad to a given position where the anchor\n     * point will be located on top of the location provided.\n     *\n     * @param {IPoint} location The location to place the quad\n     */\n    RotateableQuad.prototype.setLocation = function (location) {\n        this.location = location;\n    };\n    RotateableQuad.prototype.getLocation = function () {\n        return this.location;\n    };\n    /**\n     * Sets the rotation of this quad, in radians, rotated around the anchor point.\n     *\n     * @param {number} rotation The rotation of the quad\n     */\n    RotateableQuad.prototype.setRotation = function (rotation) {\n        this.rotation = rotation;\n    };\n    /**\n     * get Rotation\n     */\n    RotateableQuad.prototype.getRotation = function () {\n        return this.rotation;\n    };\n    /**\n     * get direction as a point\n     */\n    RotateableQuad.prototype.getDirection = function () {\n        var angle = this.rotation;\n        return {\n            x: Math.cos(angle),\n            y: Math.sin(angle),\n        };\n    };\n    /**\n     * Applies the size to the base\n     *\n     * @param {ISize} size The size of the base quad\n     */\n    RotateableQuad.prototype.setSize = function (size) {\n        this.size = size;\n        this.base = [\n            new three_1.Vector4(0, size.height, 0, 1),\n            new three_1.Vector4(size.width, size.height, 0, 1),\n            new three_1.Vector4(0, 0, 0, 1),\n            new three_1.Vector4(size.width, 0, 0, 1),\n        ];\n        if (this.anchorType) {\n            this.calculateAnchor(this.anchorType);\n        }\n    };\n    /**\n     * This re-calculates the transform for this quad and applies the transform to\n     * the corners.\n     */\n    RotateableQuad.prototype.update = function () {\n        // Calculate the pieces of the transformation\n        var anchorMat = new three_1.Matrix4().makeTranslation(this.anchor.x, -this.anchor.y, 0);\n        var rotationMat = new three_1.Matrix4().makeRotationZ(this.rotation);\n        var locationMat = new three_1.Matrix4().makeTranslation(this.location.x, this.location.y, 0);\n        // Compose the transform based on the pieces and apply them\n        // In the proper compositing order\n        this.transform = new three_1.Matrix4()\n            .multiply(locationMat)\n            .multiply(rotationMat)\n            .multiply(anchorMat);\n        // Apply the transform to all of our base vertices\n        this.TL = this.base[0].clone().applyMatrix4(this.transform);\n        this.TR = this.base[1].clone().applyMatrix4(this.transform);\n        this.BL = this.base[2].clone().applyMatrix4(this.transform);\n        this.BR = this.base[3].clone().applyMatrix4(this.transform);\n        // Update the bounds of this object\n        this.x = this.TL.x;\n        this.y = this.TL.y;\n        this.width = 1;\n        this.height = 1;\n        this.encapsulatePoints([this.TR, this.BL, this.BR]);\n    };\n    return RotateableQuad;\n}(bounds_1.Bounds));\nexports.RotateableQuad = RotateableQuad;\nvar _a;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A canvas element wrapper that aids in tracking a canvas element along with\n * content scaling properties.\n *\n * @class Sprite\n */\nvar Sprite = /** @class */ (function () {\n    //\n    // Ctor at the top below props\n    //\n    /**\n     * Creates an instance of Sprite.\n     *\n     * @param w             The width of the context to create\n     * @param h             The height of the context to create\n     * @param contentScaleX The content scaling of the content\n     * @param contentScaleY The content scaling of the content\n     *\n     * @memberOf Sprite\n     */\n    function Sprite(w, h, contentScaleX, contentScaleY) {\n        this.scaleX = 1;\n        this.scaleY = 1;\n        var canvas = document.createElement('canvas');\n        if (canvas) {\n            this.scaleX = contentScaleX || this.scaleX;\n            this.scaleY = contentScaleY || this.scaleY;\n            canvas.width = w * this.scaleX;\n            canvas.height = h * this.scaleY;\n            this.context = canvas.getContext('2d');\n            this.canvas = canvas;\n        }\n    }\n    /**\n     * Retrieves the content scaling of this object\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentScale = function () {\n        return {\n            x: this.scaleX,\n            y: this.scaleY,\n        };\n    };\n    /**\n     * Retrieves the size of the content ignoring scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentSize = function () {\n        return {\n            height: this.canvas.height,\n            width: this.canvas.width,\n        };\n    };\n    /**\n     * Retrieves the dimensional width of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getWidth = function () {\n        return this.canvas.width / this.scaleX;\n    };\n    /**\n     * Retrieves the dimensional height of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getHeight = function () {\n        return this.canvas.height / this.scaleY;\n    };\n    return Sprite;\n}());\nexports.Sprite = Sprite;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar browser = __webpack_require__(33);\nvar three_1 = __webpack_require__(0);\nvar debug = __webpack_require__(3)('CommunicationsView:Mouse');\n/** Used to adjust the base whee delta for IE browsers */\nvar IE_ADJUSTMENT = 1 / 30;\n/** Used to adjust the rates for IE 11 */\nvar OLD_IE_ADJUSTMENT = -0.25;\n// This determines how large the delta can grow to in firefox\nvar MAX_FIREFOX_WHEELDELTA = 100;\n/**\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\n */\nvar lowPassY = [0, 0, 0, 0];\n// These coefficients represent the coefficients of a FIR filter.\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\n// Attained.\nvar LOW_PASS_U0 = 0.1;\nvar LOW_PASS_U1 = 0.2;\nvar LOW_PASS_U2 = 0.2;\nvar LOW_PASS_U3 = 0.5;\nfunction normalizeFirefoxWheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = 0;\n    var deltaY = 0;\n    // Reset the filter if the direction changes to prevent lag in directional change\n    if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\n        lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\n    }\n    deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\n    // Calculate the next value output from the FIR filter\n    deltaY = (wheel.deltaY * MAX_FIREFOX_WHEELDELTA) * LOW_PASS_U0 + lowPassY[0] * LOW_PASS_U1 + lowPassY[1] * LOW_PASS_U2 + lowPassY[2] * LOW_PASS_U3;\n    // Store the value of the filter in the FIR memory bank\n    lowPassY.unshift(deltaY);\n    // Keep our FIR memory clean and only the size of the number of coefficients\n    lowPassY.pop();\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeChromeWheel(e) {\n    var wheel = e.nativeEvent;\n    return new three_1.Vector2(wheel.deltaX, -wheel.deltaY);\n}\nfunction normalizeIE11Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    var deltaY = wheel.deltaY;\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\n        }\n    }\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeIE12Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX, deltaY = wheel.deltaY;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = wheel.wheelDelta || -wheel.detail;\n        }\n    }\n    var v = new three_1.Vector2(deltaX, -deltaY);\n    v.multiplyScalar(0.25);\n    return v;\n}\n// Determine this browsers version of wheel normalization and apply it\nvar normalizeWheel;\nexports.normalizeWheel = normalizeWheel;\nif (browser.firefox) {\n    debug('Using mouse wheel for firefox');\n    exports.normalizeWheel = normalizeWheel = normalizeFirefoxWheel;\n}\nelse if (browser.msie && +browser.version >= 11) {\n    debug('Using mouse wheel for IE 11');\n    exports.normalizeWheel = normalizeWheel = normalizeIE11Wheel;\n}\nelse if (browser.msedge) {\n    debug('Using mouse wheel for MS EDGE');\n    exports.normalizeWheel = normalizeWheel = normalizeIE12Wheel;\n}\nelse {\n    debug('Using mouse wheel for Chrome');\n    exports.normalizeWheel = normalizeWheel = normalizeChromeWheel;\n}\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(e, relative) {\n    var mouseX = 0, mouseY = 0, eventX = 0, eventY = 0, object = relative || e.nativeEvent.target;\n    // Get mouse position on document crossbrowser\n    if (!e) {\n        e = window.event;\n    }\n    if (e.pageX || e.pageY) {\n        mouseX = e.pageX;\n        mouseY = e.pageY;\n    }\n    else if (e.clientX || e.clientY) {\n        mouseX = e.clientX + document.body.scrollLeft\n            + document.documentElement.scrollLeft;\n        mouseY = e.clientY + document.body.scrollTop\n            + document.documentElement.scrollTop;\n    }\n    // Get parent element position in document\n    if (object.offsetParent) {\n        do {\n            eventX += object.offsetLeft;\n            eventY += object.offsetTop;\n            object = object.offsetParent;\n        } while (object);\n    }\n    // Mouse position minus elm position is mouseposition relative to element:\n    return { x: mouseX - eventX, y: mouseY - eventY };\n}\nexports.eventElementPosition = eventElementPosition;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(1);\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nvar maxPopulation = 5;\nvar maxDepth = 10;\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nfunction filterQuery(type, queryValues) {\n    var filtered = [];\n    queryValues.forEach(function (obj) {\n        if (type.find(function (t) { return obj instanceof t; })) {\n            filtered.push(obj);\n        }\n    });\n    return filtered;\n}\nexports.filterQuery = filterQuery;\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nvar Quadrants = /** @class */ (function () {\n    /**\n     * Creates an instance of Quadrants.\n     *\n     * @param bounds The bounds this will create quandrants for\n     * @param depth  The child depth of this element\n     *\n     * @memberOf Quadrants\n     */\n    function Quadrants(bounds, depth) {\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n        var mid = bounds.mid;\n        this.TL = new Node(bounds.x, mid.x, bounds.y, mid.y, depth);\n        this.TR = new Node(mid.x, bounds.right, bounds.y, mid.y, depth);\n        this.BL = new Node(bounds.x, mid.x, mid.y, bounds.bottom, depth);\n        this.BR = new Node(mid.x, bounds.right, mid.y, bounds.bottom, depth);\n    }\n    /**\n     * Ensures all memory is released for all nodes and all references are removed\n     * to potentially high memory consumption items\n     *\n     * @memberOf Quadrants\n     */\n    Quadrants.prototype.destroy = function () {\n        this.TL.destroy();\n        this.TR.destroy();\n        this.BL.destroy();\n        this.BR.destroy();\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n    };\n    return Quadrants;\n}());\nexports.Quadrants = Quadrants;\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nvar Node = /** @class */ (function () {\n    /**\n     * Creates an instance of Node.\n     *\n     * @param l     The bounding left wall of the space this node covers\n     * @param r     The bounding right wall of the space this node covers\n     * @param t     The bounding top wall of the space this node covers\n     * @param b     The bounding bottom wall of the space this node covers\n     * @param depth The depth within the quad tree this node resides\n     *\n     * @memberOf Node\n     */\n    function Node(left, right, top, bottom, depth) {\n        this.bounds = null;\n        this.children = [];\n        this.childrenProps = [];\n        this.depth = 0;\n        this.nodes = null;\n        // If params insertted\n        if (arguments.length >= 4) {\n            this.bounds = new bounds_1.Bounds(left, right, top, bottom);\n        }\n        else {\n            this.bounds = new bounds_1.Bounds(0, 1, 1, 0);\n        }\n        // Ensure the depth is set\n        this.depth = depth || 0;\n    }\n    /**\n     * Destroys this node and ensures all child nodes are destroyed as well.\n     *\n     * @memberOf Node\n     */\n    Node.prototype.destroy = function () {\n        this.children = null;\n        this.bounds = null;\n        if (this.nodes) {\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n    };\n    /**\n     * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n     * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n     * this quad tree spans (and this is the root node), the quad tree will expand to include\n     * the new child.\n     *\n     * @param child The Bounds type object to inject\n     * @param props Properties that can be retrieved with the child object if applicable\n     *\n     * @returns True if the insertion was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.add = function (child, props) {\n        // This is the entry function for adding children, so we must first expand our top node\n        // To cover the area that the child is located.\n        // If we're in bounds, then let's just add the child\n        if (child.isInside(this.bounds)) {\n            return this.doAdd(child);\n        }\n        else {\n            this.cover(child);\n            return this.add(child, props);\n        }\n    };\n    /**\n     * Adds a list of new children to this quad tree. It performs the same operations as\n     * addChild for each child in the list, however, it more efficiently recalculates the\n     * bounds necessary to cover the area the children cover.\n     *\n     * @param children      List of Bounds objects to inject\n     * @param childrenProps List of props to associate with each element\n     *\n     * @memberOf Node\n     */\n    Node.prototype.addAll = function (children, childrenProps) {\n        var _this = this;\n        // Ensure the properties are at least defined\n        childrenProps = childrenProps || [];\n        // Make sure we cover the entire area of all the children.\n        // We can speed this up a lot if we first calculate the total bounds the new children covers\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = -Number.MAX_VALUE;\n        var maxY = -Number.MAX_VALUE;\n        // Get the dimensions of the new bounds\n        children.forEach(function (child) {\n            if (child.x < minX) {\n                minX = child.x;\n            }\n            if (child.right > maxX) {\n                maxX = child.right;\n            }\n            if (child.bottom < minY) {\n                minY = child.bottom;\n            }\n            if (child.y > maxY) {\n                maxY = child.y;\n            }\n        });\n        // Make sure our bounds includes the specified bounds\n        this.cover(new bounds_1.Bounds(minX, maxX, maxY, minY));\n        // Add all of the children into the tree\n        children.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n     * This will cause all children to be re-injected into the tree.\n     *\n     * @param bounds The bounds to include in the tree's coverage\n     *\n     * @memberOf Node\n     */\n    Node.prototype.cover = function (bounds) {\n        var _this = this;\n        // If we are already covering the area: abort\n        if (bounds.isInside(this.bounds)) {\n            return;\n        }\n        // Make our bounds cover the new area\n        this.bounds.encapsulate(bounds);\n        this.bounds.x -= 1;\n        this.bounds.y += 1;\n        this.bounds.width += 2;\n        this.bounds.height += 4;\n        // Get all of the children underneath this node\n        var allChildren = this.gatherChildren([]);\n        // Destroy the split nodes\n        if (this.nodes) {\n            // Completely...destroy...\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n        // Reinsert all children with the new dimensions in place\n        allChildren.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * When adding children, this performs the actual action of injecting the child into the tree\n     * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n     *\n     * @param child The Bounds item to inject into the tree\n     * @param props The props to remain associated with the child\n     *\n     * @returns True if the injection was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.doAdd = function (child) {\n        // If nodes are present, then we have already exceeded the population of this node\n        if (this.nodes) {\n            if (child.isInside(this.nodes.TL.bounds)) {\n                return this.nodes.TL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.TR.bounds)) {\n                return this.nodes.TR.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BL.bounds)) {\n                return this.nodes.BL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BR.bounds)) {\n                return this.nodes.BR.doAdd(child);\n            }\n            // Otherwise, this is a child overlapping this border\n            this.children.push(child);\n            return true;\n        }\n        else if (child.isInside(this.bounds)) {\n            this.children.push(child);\n            // If we exceeded our population for this quadrant, it is time to split up\n            if (this.children.length > maxPopulation && this.depth < maxDepth) {\n                this.split();\n            }\n            return true;\n        }\n        // This is when there is something wrong with the insertted child. The bounds\n        // For the quad should have grown without issue, but in this case the bounds\n        // Could not grow to accomodate the child.\n        if (isNaN(child.width + child.height + child.x + child.y)) {\n            console.error('Child did not fit into bounds because a dimension is NaN', child);\n        }\n        else if (child.area === 0) {\n            console.error('Child did not fit into bounds because the area is zero', child);\n        }\n        // Don't insert the child and continue\n        return true;\n    };\n    /**\n     * Collects all children of all the current and sub nodes into a single list.\n     *\n     * @param list The list we must aggregate children into\n     *\n     * @return The list specified as the list parameter\n     */\n    Node.prototype.gatherChildren = function (list) {\n        list = list.concat(this.children);\n        if (this.nodes) {\n            this.nodes.TL.gatherChildren(list);\n            this.nodes.TR.gatherChildren(list);\n            this.nodes.BL.gatherChildren(list);\n            this.nodes.BR.gatherChildren(list);\n        }\n        return list;\n    };\n    /**\n     * Collects all props associated with the children. This array of props will\n     * mirror the list retrieved with gatherChildren.\n     *\n     * @param list\n     *\n     * @returns The list specified as the list paramter\n     *\n     * @memberOf Node\n     */\n    Node.prototype.gatherProps = function (list) {\n        var _this = this;\n        this.children.forEach(function (c, index) {\n            list.push(_this.childrenProps[index]);\n        });\n        if (this.nodes) {\n            this.nodes.TL.gatherProps(list);\n            this.nodes.TR.gatherProps(list);\n            this.nodes.BL.gatherProps(list);\n            this.nodes.BR.gatherProps(list);\n        }\n        return list;\n    };\n    /**\n     * Entry query for determining query type based on input object\n     *\n     * @param bounds Can be a Bounds or a Point object\n     * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n     *               information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return An array of children that intersects with the query\n     */\n    Node.prototype.query = function (bounds, visit) {\n        // Query a rectangle\n        if (bounds instanceof bounds_1.Bounds) {\n            if (bounds.hitBounds(this.bounds)) {\n                return this.queryBounds(bounds, [], visit);\n            }\n            // Return an empty array when nothing is collided with\n            return [];\n        }\n        // Query a point\n        if (this.bounds.containsPoint(bounds)) {\n            return this.queryPoint(bounds, [], visit);\n        }\n        // Return an empty array when nothing is collided with\n        return [];\n    };\n    /**\n     * Queries children for intersection with a bounds object\n     *\n     * @param b     The Bounds to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return     Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryBounds = function (b, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.hitBounds(b)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (b.hitBounds(this.nodes.TL.bounds)) {\n                this.nodes.TL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.TR.bounds)) {\n                this.nodes.TR.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BL.bounds)) {\n                this.nodes.BL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BR.bounds)) {\n                this.nodes.BR.queryBounds(b, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Queries children for intersection with a point\n     *\n     * @param p     The Point to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return      Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryPoint = function (p, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.containsPoint(p)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (this.nodes.TL.bounds.containsPoint(p)) {\n                this.nodes.TL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.TR.bounds.containsPoint(p)) {\n                this.nodes.TR.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BL.bounds.containsPoint(p)) {\n                this.nodes.BL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BR.bounds.containsPoint(p)) {\n                this.nodes.BR.queryPoint(p, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Creates four sub quadrants for this node.\n     */\n    Node.prototype.split = function () {\n        // Gather all items to be handed down\n        var allChildren = this.gatherChildren([]);\n        // Gather all props for the children to be handed down as well\n        this.nodes = new Quadrants(this.bounds, this.depth + 1);\n        this.children = [];\n        this.childrenProps = [];\n        while (allChildren.length > 0) {\n            this.doAdd(allChildren.pop());\n        }\n    };\n    /**\n     * Traverses the quad tree returning every quadrant encountered\n     *\n     * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n     */\n    Node.prototype.visit = function (cb) {\n        var finished = Boolean(cb(this));\n        if (this.nodes && !finished) {\n            this.nodes.TL.visit(cb);\n            this.nodes.TR.visit(cb);\n            this.nodes.BL.visit(cb);\n            this.nodes.BR.visit(cb);\n        }\n    };\n    return Node;\n}());\nexports.Node = Node;\nvar QuadTree = /** @class */ (function (_super) {\n    __extends(QuadTree, _super);\n    function QuadTree() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QuadTree;\n}(Node));\nexports.QuadTree = QuadTree;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar curved_line_1 = __webpack_require__(21);\nvar line_1 = __webpack_require__(7);\nvar point_1 = __webpack_require__(6);\n/**\n * This defines a drawable curved line shape. It contains the information necessary\n * to efficiently render the line.\n *\n * @export\n * @class CurvedLineShape\n * @extends {CurvedLine<T>}\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\n *             with the shape easier.\n */\nvar CurvedLineShape = /** @class */ (function (_super) {\n    __extends(CurvedLineShape, _super);\n    /**\n     * Creates an instance of CurvedLineShape.\n     *\n     * @param {ICurvedLineShapeOptions} options The options for creating this line\n     */\n    function CurvedLineShape(options) {\n        var _this = \n        // We pass our properties to the curve line but we do not let it cache it's version of the line segments\n        // As we will be constructing our own segmentation requiring a new type of cache\n        _super.call(this, options) || this;\n        /** Depeth of draw location */\n        _this.depth = 0;\n        /** How thick the line should be */\n        _this.lineWidth = 1;\n        _this.encapsulatePoints(_this.getTriangleStrip());\n        _this.cachesQuadSegments = options.cacheSegments;\n        _this.depth = options.depth || 0;\n        _this.lineWidth = options.lineWidth || 1;\n        _this.startColor = options.startColor;\n        _this.endColor = options.endColor;\n        return _this;\n    }\n    /**\n     * Returns a new instance of this object that mimicks the properties of this Object\n     *\n     * @returns {CurvedLineShape<T>} The cloned object\n     */\n    CurvedLineShape.prototype.clone = function () {\n        // Perform the clone\n        var clone = new CurvedLineShape({\n            cacheSegments: this.cachesSegments,\n            controlPoints: this.controlPoints,\n            end: this.end,\n            endColor: this.endColor,\n            lineWidth: this.lineWidth,\n            resolution: this.resolution,\n            start: this.start,\n            startColor: this.startColor,\n            type: this.type,\n        });\n        clone.d = this.d;\n        return clone;\n    };\n    /**\n     * @override\n     * See base definition\n     */\n    CurvedLineShape.prototype.distanceTo = function (point) {\n        return Math.max(0, _super.prototype.distanceTo.call(this, point) - (this.lineWidth / 2.0));\n    };\n    /**\n     * This produces a triangle strip that represents the quads that composes this line. If caching is present,\n     * subsequent calls to this method will be much faster unless the cache gets invalidated.\n     *\n     * @return {IPoint[]} The Triangle Strip of points to create the quads that make each segment of the curve\n     */\n    CurvedLineShape.prototype.getTriangleStrip = function () {\n        if (this.cachesSegments && this.cachedQuadSegments) {\n            return this.cachedQuadSegments;\n        }\n        // Make a container to hold our triangle strip info\n        var strip = [];\n        var normal = [];\n        // Start with calculating the line strip so we can use the line segments\n        // To produce the quads we need to render\n        var lineStrip = this.getLineStrip();\n        var lineWidthHalf = this.lineWidth / 2.0;\n        var line = new line_1.Line(point_1.Point.zero(), point_1.Point.zero());\n        // We make a container point for the scaling operation to reduce allocations\n        var scaledPoint = point_1.Point.zero();\n        // If the line strip is empty, then there is nothing to produce and makes\n        // Us unable to reduce the lineStrip, so return empty here\n        if (lineStrip.length < 2) {\n            return [];\n        }\n        // Calculate bisecting normal or each node\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            line.setPoints(lineStrip[i], lineStrip[i + 1]);\n            if (normal.length === 0) {\n                normal.push(line.perpendicular);\n            }\n            else {\n                // Sum of two normals of a point\n                var temp = {\n                    x: normal[i].x + line.perpendicular.x,\n                    y: normal[i].y + line.perpendicular.y,\n                };\n                // Normalize the sum of two normals\n                var sqrt = Math.sqrt(temp.x * temp.x + temp.y * temp.y);\n                temp.x = temp.x / sqrt;\n                temp.y = temp.y / sqrt;\n                normal[i] = temp;\n            }\n            normal.push(line.perpendicular);\n        }\n        // Use the new normals to generate quads\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            var previous = lineStrip[i];\n            var current = lineStrip[i + 1];\n            // TR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], -lineWidthHalf, scaledPoint), current));\n            // BR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], lineWidthHalf, scaledPoint), current));\n            // TL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], -lineWidthHalf, scaledPoint), previous));\n            // BL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], lineWidthHalf, scaledPoint), previous));\n        }\n        return strip;\n    };\n    /**\n     * @override\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     */\n    CurvedLineShape.prototype.setPoints = function (start, end, controlPoints) {\n        _super.prototype.setPoints.call(this, start, end, controlPoints);\n        this.cachedQuadSegments = [];\n    };\n    return CurvedLineShape;\n}(curved_line_1.CurvedLine));\nexports.CurvedLineShape = CurvedLineShape;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interpolation_1 = __webpack_require__(12);\nvar bounds_1 = __webpack_require__(1);\nvar line_1 = __webpack_require__(7);\nvar point_1 = __webpack_require__(6);\nvar debug = __webpack_require__(3)('bezier');\n/**\n * This enum covers the type of curved lines that can be made. Making a specific curve\n *\n * @export\n * @enum {number}\n */\nvar CurveType;\n(function (CurveType) {\n    /** This will make the curve be generated from interpolating between the end points and provided control points */\n    CurveType[CurveType[\"Bezier\"] = 0] = \"Bezier\";\n    /**\n     * This will draw a curve as though there is a circular arc passing over the two end points. The radius of the\n     * circular arc is determined by how far the control point is from the straight line that can be made from the two\n     * end points.\n     */\n    CurveType[CurveType[\"CircularCCW\"] = 1] = \"CircularCCW\";\n    CurveType[CurveType[\"CircularCW\"] = 2] = \"CircularCW\";\n    /**\n     * This ignores the control points altogether and just created a straight line with a single segment that consists\n     * of the specified endpoints\n     */\n    CurveType[CurveType[\"Straight\"] = 3] = \"Straight\";\n})(CurveType = exports.CurveType || (exports.CurveType = {}));\n// -------[ Distance Calculating Methods ]----------------------------\n/**\n * Calculates the distance to the bezier curve by testing all of the bezier curve's segment lines\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction bezierDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a circle\n * TODO: Using the segment approach for now. Can be sped up by using circle math\n * instead\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction circularDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a straight line\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction straightDistance(line, testPoint) {\n    return new line_1.Line(line.start, line.end).distanceTo(testPoint);\n}\n// -------[ Segment Generating Methods ]----------------------------\n/**\n * Uses quadratic bezier principles to create the segments for a quadratic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier2Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier2(dt * i, start, lineEnd, c1));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Uses cubic bezier principles to create the segments for a cubic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier3Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    var c2 = line.controlPoints[1];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier3(dt * i, start, lineEnd, c1, c2));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that follows along a circular path on the line.\n * The distance the control point is from the straight line that flows through the two\n * end points of the line determines the radius of the curvature of the line\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeCircularCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    debug('CW');\n    // Generate a line so we can have a perpendicular calculation\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        // We get the midpoint of the line as we want to align the center of the circle with this point\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        // The shortest the radius can be is the distance from the line to the mid point\n        // Anything shorter will just result in a hemisphere being rendered\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        // Get the perpendicular direction to the line so we can calculate the center of our circle\n        // From the mid point\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        // Calculate the location of the center of the circle\n        circleCenter = {\n            x: perpendicular.x * distance + midPoint.x,\n            y: perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    debug(' center of circle is %o  %o', circleCenter.x, circleCenter.y);\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Calculate how much to increment theta in our parametric circular equation\n    if (theta1 < theta2)\n        theta1 += Math.PI * 2;\n    var dTheta = (theta1 - theta2) / line.resolution;\n    debug('theta1 is %o, theta2 is %o', theta1, theta2);\n    // Compute the segments based on the information we have gathered by applying it to a circular\n    // Parametric equation\n    var segments = [];\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 - (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 - (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    // Cache the segments if specified by the curved line\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    debug('Generated Circular Segments: %o dTheta: %o radius: %o', segments, dTheta, radius);\n    return segments;\n}\nfunction makeCircularCCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        circleCenter = {\n            x: -perpendicular.x * distance + midPoint.x,\n            y: -perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    if (theta2 < theta1)\n        theta2 += Math.PI * 2;\n    var dTheta = (theta2 - theta1) / line.resolution;\n    var segments = [];\n    // CCW, from end to start\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 + (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 + (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    if (line.cachedSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that is straight, thus only 1 segments is needed\n * and will be generated.\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeStraightSegments(line) {\n    return [line.start, line.end];\n}\n/** A quick lookup for a proper segment creating method for a curved line  */\nvar pickSegmentMethod = (_a = {},\n    _a[CurveType.Bezier] = [\n        null,\n        makeBezier2Segments,\n        makeBezier3Segments,\n    ],\n    _a[CurveType.CircularCW] = [\n        null,\n        makeCircularCWSegments,\n        makeCircularCWSegments,\n    ],\n    _a[CurveType.CircularCCW] = [\n        null,\n        makeCircularCCWSegments,\n        makeCircularCCWSegments,\n    ],\n    _a[CurveType.Straight] = [\n        makeStraightSegments,\n    ],\n    _a);\n/** A quick lookup for a proper distance calculating method for a curved line  */\nvar pickDistanceMethod = (_b = {},\n    _b[CurveType.Bezier] = bezierDistance,\n    _b[CurveType.CircularCW] = circularDistance,\n    _b[CurveType.CircularCCW] = circularDistance,\n    _b[CurveType.Straight] = straightDistance,\n    _b);\n/**\n * Defines an object which illustrates a curved line. Curved lines can be formed in many\n * ways but most often from two end points and some provided control points.\n *\n * @export\n * @class CurvedLine\n * @extends {Bounds<T>}\n * @template T An associated data type with this object. Use <never> if no data type is ever associated\n */\nvar CurvedLine = /** @class */ (function (_super) {\n    __extends(CurvedLine, _super);\n    /**\n     * Generates a primitive that describes a curved line, which is defined by the lines end points, type, and control points\n     *\n     * @param {ICurvedLineOptions} options The configuration options of this curved line\n     */\n    function CurvedLine(options) {\n        var _this = this;\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        _this = _super.call(this, minX, maxX, maxY, minY) || this;\n        // Apply the relevant properties to the curve\n        _this.cachesSegments = options.cacheSegments || false;\n        _this.type = options.type;\n        _this.resolution = options.resolution || 20;\n        // Set the metrics for this curved line\n        _this.setPoints(options.start, options.end, options.controlPoints);\n        // Set the method that will be used for calculating distance from a point\n        _this.distanceMethod = pickDistanceMethod[options.type];\n        return _this;\n    }\n    Object.defineProperty(CurvedLine.prototype, \"values\", {\n        get: function () {\n            return {\n                controlPoints: this.controlPoints,\n                end: this.end,\n                start: this.start,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Calculates the nearest distance from the provided point to this curved line\n     *\n     * @param {IPoint} point The point to test the distance from\n     *\n     * @returns {number} The calculated nearest distance from this curve to the point\n     */\n    CurvedLine.prototype.distanceTo = function (point) {\n        return this.distanceMethod(this, point);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {CurvedLine<any>[]} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    CurvedLine.getClosest = function (lines, point) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(point);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This returns the line strip that represents the curve. A line strip is specifically a group of points\n     * that forms line segments by taking the current point as one end and the previous point as the second end\n     * thus, you would start at index 1 and loop to the end to generate all of the lines composing this single\n     * line.\n     *\n     * @return {IPoint[]} All of the points in the line strip\n     */\n    CurvedLine.prototype.getLineStrip = function () {\n        return this.segmentMethod(this);\n    };\n    /**\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     * @param {boolean} preventRebounding If set, this will prevent the bounds from being recalculated\n     */\n    CurvedLine.prototype.setPoints = function (start, end, controlPoints) {\n        // Apply the points\n        this.start = start;\n        this.end = end;\n        if (controlPoints.length === 0)\n            debug('start: %o, end:%o', start, end);\n        // Get the available segment methods for the given type\n        var segmentMethods = pickSegmentMethod[this.type];\n        // If we adjust the control points we need to re-evaluate the type of segment creation method we use\n        if (controlPoints) {\n            this.controlPoints = controlPoints;\n            // Get the number of control points we want to base the curve off of\n            var numControlPoints = controlPoints.length;\n            // If we have more control points than the methods available, then we use the greatest method available to best\n            // Handle as many control points as possible\n            if (numControlPoints > segmentMethods.length) {\n                numControlPoints = segmentMethods.length - 1;\n            }\n            // Set the method that will be used for generating segments\n            this.segmentMethod = segmentMethods[numControlPoints];\n            // Make sure the input wasn't bad\n            if (!this.segmentMethod) {\n                throw new Error('An Invalid number of control points was provided to a curved line. You must have at LEAST 1 control point. Or 0 for a straight line');\n            }\n            if (this.type === CurveType.Bezier) {\n                this.encapsulatePoints(controlPoints);\n            }\n            else if (this.type === CurveType.CircularCCW || this.type === CurveType.CircularCW) {\n                this.encapsulatePoints(this.getLineStrip());\n            }\n        }\n        this.encapsulatePoint(start);\n        this.encapsulatePoint(end);\n        // Invalidate caches if they exist\n        this.cachedSegments = null;\n    };\n    return CurvedLine;\n}(bounds_1.Bounds));\nexports.CurvedLine = CurvedLine;\nvar _a, _b;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(1);\nvar UID = 0;\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * Generate a new Circle object\n     *\n     * @param x The center of the circle\n     * @param y The center of the circle\n     * @param r The radius of the circle\n     * @param d A data object to associate with the circle\n     */\n    function Circle(options) {\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        /** a UID of the circle */\n        _this._id = ++UID;\n        /** Radius of the circle */\n        _this._radius = 0;\n        /** X coord of the center of the circle */\n        _this._centerX = 0;\n        /** Y coord of the center of the circle */\n        _this._centerY = 0;\n        _this._centerX = options.centerX;\n        _this._centerY = options.centerY;\n        _this._radius = options.radius;\n        _this.updateBounds();\n        return _this;\n    }\n    Object.defineProperty(Circle.prototype, \"values\", {\n        get: function () {\n            return {\n                radius: this._radius,\n                x: this._centerX,\n                y: this._centerY,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"radius\", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (val) {\n            this._radius = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (val) {\n            this._centerX = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (val) {\n            this._centerY = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Tests if the specified bounds is inside this circle\n     *\n     * @param b The bounds to test against\n     */\n    Circle.prototype.boundsInside = function (b) {\n        var r2 = this._radius * this._radius;\n        var dx = b.x - this._centerX;\n        var dy = b.y - this._centerY;\n        var dy2 = dy * dy;\n        var dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.right - this._centerX;\n        dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dy = b.bottom - this._centerY;\n        dy2 = dy * dy;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.x - this._centerX;\n        dx2 = dx * dx;\n        return (dx2 + dy2) < r2;\n    };\n    /**\n     * Calculates the distance to a provided point\n     *\n     * @param {IPoint} p The point to calculate the distance of the middle of the\n     *                   circle to\n     * @param {boolean} notSquared Flag true to prevent the Math.sqrt operation, leaving\n     *                             the result as distance^2\n     *\n     * @return {number} The distance from mid circle to the point\n     */\n    Circle.prototype.distanceTo = function (p, notSquared) {\n        var dx = this._centerX - p.x;\n        var dy = this._centerY - p.y;\n        if (notSquared) {\n            return dx * dx + dy * dy;\n        }\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    /**\n     * Retrieves the closest circle to a provided point\n     *\n     * @param {Array} circles The circles to see who is the nearest\n     * @param {IPoint} p The point to compare the circles against for nearness\n     *\n     * @return {Circle} The nearest circle\n     */\n    Circle.getClosest = function (circles, p) {\n        var closestCircle;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        circles.forEach(function (circle) {\n            distance = circle.distanceTo(p, true);\n            if (distance < closestDistance) {\n                closestCircle = circle;\n                closestDistance = distance;\n            }\n        });\n        return closestCircle;\n    };\n    /**\n     * Tests if this circle is colliding with the specified circle\n     *\n     * @param c The circle to test against\n     *\n     * @return {boolean} True if colliding\n     */\n    Circle.prototype.hitCircle = function (c) {\n        var totalDistance = c._radius + this._radius;\n        totalDistance *= totalDistance;\n        return this.distanceTo({ x: c._centerX, y: c._centerY }, true) < totalDistance;\n    };\n    /**\n     * @override\n     * This makes it so the test of a point tests based on a Circle shape\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.hitPoint = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * If there are multiple metrics to update for the circle, this is the most\n     * efficient way to do that as it will update it's bounds only once.\n     *\n     * @param x\n     * @param y\n     * @param r\n     */\n    Circle.prototype.position = function (x, y, r) {\n        this._centerX = x;\n        this._centerY = y;\n        this._radius = r;\n        this.updateBounds();\n    };\n    /**\n     * @override\n     * Tests if a point is inside the circle\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.pointInside = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * When the circle gains different circle metrics, it's Bounds must adjust\n     * accordingly, which is what this method recalculates.\n     */\n    Circle.prototype.updateBounds = function () {\n        var radius = this._radius;\n        this.x = this._centerX - radius;\n        this.y = this._centerY - radius;\n        this.height = radius * 2;\n        this.width = radius * 2;\n    };\n    /**\n     * Pretty print the metrics of this circle\n     */\n    Circle.prototype.toString = function () {\n        return \"[Circle {x: \" + this._centerX + \", y: \" + this._centerY + \", r: \" + this._radius + \"}]\";\n    };\n    return Circle;\n}(bounds_1.Bounds));\nexports.Circle = Circle;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = __webpack_require__(7);\n/**\n * Defines a line that can be drawn\n */\nvar LineShape = /** @class */ (function (_super) {\n    __extends(LineShape, _super);\n    /**\n     * Generate a new line that can be drawn\n     */\n    function LineShape(options) {\n        var _this = _super.call(this, options.p1, options.p2) || this;\n        _this.depth = options.depth || 0.0;\n        _this.endColor = options.endColor;\n        _this.startColor = options.startColor;\n        _this.thickness = options.thickness || 1.0;\n        return _this;\n    }\n    /**\n     * Clones this instance of the line shape and creates a new instance of a line shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this line shape\n     */\n    LineShape.prototype.clone = function (newProperties) {\n        return Object.assign(new LineShape(this), newProperties);\n    };\n    return LineShape;\n}(line_1.Line));\nexports.LineShape = LineShape;\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar shape_buffer_cache_1 = __webpack_require__(25);\n/** This is a part of the identifier that is used to retrieve a multibuffer's storage */\nvar multiBufferSelectionPrefix = '__mb__';\n/** This is to ensure each multibuffer gets it's own unique selection identifier */\nvar multiBufferSelectionKeyUID = 0;\nfunction getIDProp(item) {\n    return item.id;\n}\nfunction evenRoundRobinBufferAdd(item, buffers) {\n    var smallest = buffers[0].buffer.length;\n    var found = buffers[0];\n    // Look for the next buffer that has the smallest length\n    // To fill it up\n    buffers.some(function (tracker) {\n        if (tracker.buffer.length < smallest) {\n            found = tracker;\n            return true;\n        }\n        return false;\n    });\n    found.buffer.push(item);\n    return [found];\n}\nfunction noop() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // NO-OP\n}\nfunction echoBuffer(item, buffer, buffers) {\n    return [buffer];\n}\n/**\n * This class helps facilitate breaking up a potentially large shape buffer into multiple buffers.\n */\nvar MultiShapeBufferCache = /** @class */ (function (_super) {\n    __extends(MultiShapeBufferCache, _super);\n    /**\n     * Makes a new multi shape buffer for minimizing changes\n     *\n     * @param numBuffers The number of buffers this multibuffer will manage\n     */\n    function MultiShapeBufferCache(numBuffers, methods) {\n        var _this = _super.call(this) || this;\n        /** The number of buffers this multi buffer manages */\n        _this.numBuffers = 0;\n        /** UID for storing the data for this buffer in the selection */\n        _this.selectionUID = multiBufferSelectionPrefix + (++multiBufferSelectionKeyUID);\n        /**\n         * The method used to add to the buffers. This is changeable so one can implement geometric or\n         * logical adds for invalidation. This returns a list of buffers that will be invalidated from\n         * the operation. The first buffer returned in the invalidation is the strongly associated buffer\n         * to the item injected. This first buffer is the most likely buffer the item is injected into.\n         */\n        _this.addMethod = evenRoundRobinBufferAdd;\n        /**\n         * Gives an implentor opportunity to define the way an is is specified for a given item. It\n         * defaults to searching for an 'id' property on the item.\n         */\n        _this.idMethod = getIDProp;\n        /**\n         * The method that is called right after the initial buffers get constructed. This is changeable\n         * so monitors can.\n         */\n        _this.initMethod = noop;\n        /**\n         * The method that is called right before a shape is removed from a buffer.\n         * This let's the\n         */\n        _this.removeMethod = echoBuffer;\n        /**\n         * The method that is called when an item is updated. This gives a monitor a chance to invalidate\n         * a number of buffers.\n         */\n        _this.updateMethod = echoBuffer;\n        // Store the number of buffers that are created when the buffers are initialized\n        _this.numBuffers = numBuffers;\n        // Set the hook methods if any are specified\n        if (methods) {\n            _this.addMethod = methods.add || _this.addMethod;\n            _this.idMethod = methods.id || _this.idMethod;\n            _this.initMethod = methods.init || _this.initMethod;\n            _this.removeMethod = methods.remove || _this.removeMethod;\n            _this.updateMethod = methods.update || _this.updateMethod;\n        }\n        return _this;\n    }\n    /**\n     * Adds a shape to a buffer and invalidates it\n     *\n     * @param shape The shape to add to a buffer\n     */\n    MultiShapeBufferCache.prototype.addShape = function (shape) {\n        // Perform the custom add opearation\n        var buffers = this.addMethod(shape, this.store.allBuffers);\n        // Stores the shape for lookup via id\n        this.store.idToItem.set(this.idMethod(shape), shape);\n        // Stores the shape for lookup to buffer. We count the\n        // First dirty buffer as the buffer the item is the closest to\n        // Association.\n        this.store.itemToBuffer.set(shape, buffers[0]);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * Sees if there is a shape associated with this id\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.containsId = function (id) {\n        return Boolean(this.store.idToItem.get(id));\n    };\n    /**\n     * Sees if this shape has been added to this buffer or not\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.containsShape = function (shape) {\n        // Check if this multibuffer has the shape or no\n        return Boolean(this.store.itemToBuffer.get(shape));\n    };\n    /**\n     * This flags a list of buffers as dirty\n     *\n     * @param buffers\n     */\n    MultiShapeBufferCache.prototype.flagBuffersDirty = function (buffers) {\n        // Flag provided buffers as dirty\n        if (buffers) {\n            // This flags the indicated buffers as dirty\n            buffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n        else {\n            this.store.allBuffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n    };\n    /**\n     * @override\n     * This is called with triggers all of the updates necessary.\n     * We add in our buffer update and invalidation to this process here.\n     *\n     * @param args\n     */\n    MultiShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        // Run the generation which will trigger cache building and modding\n        _super.prototype.generate.apply(this, arguments);\n        // We now invalidate any buffers that have been flagged\n        this.processDirtyBuffers();\n    };\n    /**\n     * @override\n     * This retrieves the multibuffer for this shape buffer\n     */\n    MultiShapeBufferCache.prototype.getBuffer = function () {\n        console.warn('A multishape buffer should have getBuffers called instead');\n        return [];\n    };\n    /**\n     * Get all of the buffers.\n     * WARNING: do NOT modify the output values in any way.\n     *\n     * @return {T[][]} All of the buffers\n     */\n    MultiShapeBufferCache.prototype.getBuffers = function () {\n        if (this.store) {\n            return this.store.allBuffers.map(function (tracker) { return tracker.buffer; });\n        }\n        return [];\n    };\n    /**\n     * Returns the number of buffers this MultiShapeBuffer is managing.\n     */\n    MultiShapeBufferCache.prototype.getNumBuffers = function () {\n        return this.store.allBuffers.length;\n    };\n    /**\n     * Retrieves a shape by the given id. Is undefined if the id is not recognized.\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.getShapeById = function (id) {\n        return this.store.idToItem.get(id);\n    };\n    /**\n     * This makes all buffers a part of a new array pointer thus making sure\n     * they will be committed to the gpu.\n     */\n    MultiShapeBufferCache.prototype.processDirtyBuffers = function () {\n        this.store.allBuffers.forEach(function (tracker) {\n            if (tracker.isDirty) {\n                tracker.isDirty = false;\n                tracker.buffer = [].concat(tracker.buffer);\n            }\n        });\n    };\n    /**\n     * This retrieves the storage inside the selection. If it doesn't exist,\n     * then the storage is created.\n     *\n     * @param selection\n     */\n    MultiShapeBufferCache.prototype.getStorage = function (selection) {\n        // Get the storage from the selection\n        var storage = (selection.getSelection(this.selectionUID) || [])[0];\n        // If the storage is not stored in the selection, then we create a storage and update the selection with that storage\n        if (!storage) {\n            storage = {\n                allBuffers: [],\n                idToItem: new Map(),\n                itemToBuffer: new Map(),\n            };\n            // Generate the buffers indicated\n            for (var i = 0; i < this.numBuffers; ++i) {\n                storage.allBuffers.push({\n                    buffer: [],\n                    isDirty: false,\n                });\n            }\n            // Initialize anything that may be monitoring the buffers\n            this.initMethod(storage.allBuffers);\n            // Add the storage to the selection\n            selection.select(this.selectionUID, storage);\n        }\n        // Make sure our internal pointer to the storage is set correctly\n        return (this.store = storage);\n    };\n    /**\n     * Removes a shape from the buffer it is a part of.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.removeShape = function (shape) {\n        // This is the buffer associated with the shape\n        var buffer = this.store.itemToBuffer.get(shape);\n        // Get the buffers invalidated by the remove\n        var buffers = this.removeMethod(shape, buffer, this.store.allBuffers);\n        // Clear the shape out from the buffer\n        buffer.buffer.splice(buffer.buffer.indexOf(shape), 1);\n        // Delete the item from the id lookup\n        this.store.idToItem.delete(this.idMethod(shape));\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * This is called to indicate an update to an item has occurred.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.updateShape = function (shape) {\n        // Flag each element that needs updating\n        var buffers = this.updateMethod(shape, this.store.itemToBuffer.get(shape), this.store.allBuffers);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    return MultiShapeBufferCache;\n}(shape_buffer_cache_1.ShapeBufferCache));\nexports.MultiShapeBufferCache = MultiShapeBufferCache;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar ShapeBufferCache = /** @class */ (function () {\n    function ShapeBufferCache() {\n        this.buffer = [];\n        this.bustCache = true;\n    }\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    ShapeBufferCache.prototype.generate = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this.bustCache) {\n            this.buildCache.apply(this, args);\n            this.bustCache = false;\n        }\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    ShapeBufferCache.prototype.buildCache = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Get the buffer the cache has generated\n     */\n    ShapeBufferCache.prototype.getBuffer = function () {\n        return this.buffer;\n    };\n    return ShapeBufferCache;\n}());\nexports.ShapeBufferCache = ShapeBufferCache;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(27));\n__export(__webpack_require__(34));\n__export(__webpack_require__(44));\n__export(__webpack_require__(52));\n__export(__webpack_require__(53));\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(5);\nvar React = __webpack_require__(28);\nvar three_1 = __webpack_require__(0);\nvar atlas_manager_1 = __webpack_require__(13);\nvar atlas_texture_1 = __webpack_require__(8);\nvar bounds_1 = __webpack_require__(1);\nvar frame_info_1 = __webpack_require__(9);\nvar mouse_1 = __webpack_require__(18);\nvar quad_tree_1 = __webpack_require__(19);\nvar webgl_stat_1 = __webpack_require__(10);\nvar debug = __webpack_require__(3)('webgl-surface:GPU');\nvar debugCam = __webpack_require__(3)('webgl-surface:Camera');\nvar debugLabels = __webpack_require__(3)('webgl-surface:Labels');\nvar debugColors = __webpack_require__(3)('webgl-surface:Colors');\n/**\n * This enum names the base methods that are passed into the applyPropsMethods\n * method. This allows subclasses to easily pick the property setting methods they need\n * from the base\n */\nvar BaseApplyPropsMethods;\n(function (BaseApplyPropsMethods) {\n    /** Initializes any context that needs to be set up before the props are set */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"INITIALIZE\"] = 0] = \"INITIALIZE\";\n    /** Moment when any buffer changes should be applied */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"BUFFERCHANGES\"] = 1] = \"BUFFERCHANGES\";\n    /** Initializes camera properties to facilitate smoothe start up */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"CAMERA\"] = 2] = \"CAMERA\";\n    /** Generates the labels as images within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"LABELS\"] = 3] = \"LABELS\";\n    /** Generates the colors within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"COLORS\"] = 4] = \"COLORS\";\n})(BaseApplyPropsMethods = exports.BaseApplyPropsMethods || (exports.BaseApplyPropsMethods = {}));\n/**\n * This enum names the base methods that are passed into the animatedMethods\n * method. This allows subsclasses to easily pick the animated methods they need\n * from the base\n */\nvar BaseAnimatedMethods;\n(function (BaseAnimatedMethods) {\n    /** Sets up the base context needed to execute most methods */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"CONTEXT\"] = 0] = \"CONTEXT\";\n    /** Sets up the inertia method for inertial panning */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"INERTIA\"] = 1] = \"INERTIA\";\n    /** Animates the postion of the camera to a destination */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"POSITION\"] = 2] = \"POSITION\";\n    /** Zooms the camera based on a point of focus */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"ZOOM\"] = 3] = \"ZOOM\";\n})(BaseAnimatedMethods = exports.BaseAnimatedMethods || (exports.BaseAnimatedMethods = {}));\nfunction isAnimatedWithOptions(value) {\n    if (value.options) {\n        return true;\n    }\n    return false;\n}\nfunction isAnimated(value) {\n    if (!value.options) {\n        return true;\n    }\n    return false;\n}\n/** This is the smallest increment the zoom can make. Anything less and nothing will happen */\nvar MIN_ZOOM_INCREMENT = 0.001;\nvar BYTE_MAX = 0xFF;\nvar BACKGROUND_COLOR = new three_1.Color().setRGB(38 / BYTE_MAX, 50 / BYTE_MAX, 78 / BYTE_MAX);\n// --[ CONSTANTS ]-------------------------------------------\n// Make a container vector for performing operations within\nvar vector = new three_1.Vector3();\n// --[ SHADERS ]-------------------------------------------\n/**\n * Equivalent of Math.sign, but faster, and works in all browsers\n *\n * @param {number} value The number to determine the sign\n *\n * @return {number} Returns zero if a sign can not be determined, -1 for a negative, 1 for a positive\n */\nfunction sign(value) {\n    if (!value) {\n        return 0;\n    }\n    if (value > 0) {\n        return 1;\n    }\n    if (value < 0) {\n        return -1;\n    }\n    return 0;\n}\n/**\n * The base component for the communications view\n */\nvar WebGLSurface = /** @class */ (function (_super) {\n    __extends(WebGLSurface, _super);\n    function WebGLSurface() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** This is the atlas manager for managing images and labels rendered as textures */\n        _this.atlasManager = new atlas_manager_1.AtlasManager(2048, 2048);\n        /** Tracks the names of the atlas' generated */\n        _this.atlasNames = {\n            colors: 'colors',\n            labels: 'labels',\n        };\n        /**\n         * List of methods that execute within the animation loop. Makes adding and removing these methods\n         * simpler to manage, as well as gives a clear and optimized way of overriding existing methods\n         * or reordering their execution\n         */\n        _this.animatedMethodList = [];\n        /**\n         * If this is set to true during an animated method's lifecycle, then all subsequent animated methods\n         * will not be executed for the current frame. Upon reaching the end of the frame, the break will reset\n         * and the animated methods will attempt executing again\n         */\n        _this.animatedMethodBreak = false;\n        /**\n         * The camera that 'looks' at our world and gives us the ability to convert\n         * screen coordinates to world coordinates, and vice versa\n         */\n        _this.camera = new three_1.OrthographicCamera(0, 0, 0, 0, 0, 0);\n        /**\n         * While this number is positive it will be decremented every frame.\n         * While positive, mouse interactions will not occur. This utilizes frame ticks\n         * as SOME values and numbers settle per frame, not necessarily within timelapses.\n         * More often than not, there will only be a need for 1-2 frames of mouse disable to\n         * allow the camera to be positioned in a correct location before screen to world projections\n         * start taking place.\n         */\n        _this.disableMouseInteraction = 0;\n        /** Used to aid in mouse interactions */\n        _this.distance = 0;\n        _this.sizeCamera = null;\n        /** Keep track of the current zoom so it can be set in requestAnimationFrame */\n        _this.currentZoom = 1;\n        /** Horizontal destination the camera will pan to */\n        _this.destinationX = 0;\n        /** Vertical position the camera will pan to */\n        _this.destinationY = 0;\n        /** The destination zoom level the camera used during panning */\n        _this.destinationZoom = 1;\n        /** Is the camera currently in a panning state */\n        _this.isPanning = false;\n        /** Last known screen position of the mouse */\n        _this.lastMousePosition = { x: 0, y: 0 };\n        /** List of methods to execute when applying props */\n        _this.propsMethodList = [];\n        /** Inertial values for drag panning */\n        _this.inertia = null;\n        _this.inertiaBuild = 1.5;\n        _this.inertiaDecay = .9;\n        _this.inertiaMax = 100;\n        /**\n         * All data is put into this quad tree so we can query spatial regions for\n         * items\n         */\n        _this.quadTree = null;\n        /**\n         * True if the shift key is currently being held\n         *\n         * Panning is affected by whether or not the shift key is being held down, but\n         * I don't know how yet.\n         */\n        _this.shiftIsDown = false;\n        _this.stop = false;\n        /** The current rendered position and zoom */\n        _this.currentX = 0;\n        _this.currentY = 0;\n        _this.targetZoom = 1;\n        /** The (world) position the focus will zoom in and out of */\n        _this.previousZoomToFit = 0;\n        _this.zoomTargetX = 0;\n        _this.zoomTargetY = 0;\n        /** When this is set, the draw loop continues to run. Used by the draw loop to complete animations */\n        _this.animating = false;\n        _this.labels = [];\n        _this.labelsReady = false;\n        /**\n         * This is the latest labels loading identifier, used to determine if the labels\n         * last loaded matches the labels currently needing to be rendered.\n         */\n        _this.labelsCurrentLoadedId = 0;\n        _this.labelsLoadId = 0;\n        /** When this is set to true, the atlas with the colors is now ready to be referenced */\n        _this.colors = [];\n        _this.colorsReady = false;\n        /** Holds the items currently hovered over */\n        _this.currentHoverItems = [];\n        /** Mouse in stage or not */\n        _this.dragOver = true;\n        /** Flag for detecting whether or not webgl is supported at all */\n        /**\n         * This is the update loop that operates at the requestAnimationFrame speed.\n         * This updates the cameras current position and causes changes over time for\n         * any property that has a start and a destination.\n         */\n        _this.animate = function () {\n            if (_this.stop) {\n                return;\n            }\n            frame_info_1.FrameInfo.lastFrameTime = Date.now();\n            frame_info_1.FrameInfo.framesPlayed.set(_this, (frame_info_1.FrameInfo.framesPlayed.get(_this) || 0) + 1);\n            requestAnimationFrame(function () { return _this.animate(); });\n            var response;\n            var doDraw = false;\n            var didBreak = _this.animatedMethodList.some(function (method) {\n                if (isAnimatedWithOptions(method)) {\n                    if (method.options.labelsReady && method.options.colorsReady) {\n                        if (_this.labelsReady && _this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.labelsReady) {\n                        if (_this.labelsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.colorsReady) {\n                        if (_this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                }\n                else if (isAnimated(method)) {\n                    response = method();\n                }\n                // Update our draw status based on response\n                if (!doDraw) {\n                    doDraw = response.doDraw;\n                }\n                // Stop the system if needed\n                if (response.stop) {\n                    _this.stop = true;\n                }\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            // We prevent any animation loop execution if we did break\n            if (didBreak) {\n                return;\n            }\n            // Make sure all camera related uniforms are up to date\n            _this.updateCameraUniforms();\n            // Handle the deactivation period of mouse interactions by decrementing it\n            // If it's positive\n            if (_this.disableMouseInteraction > 0) {\n                _this.disableMouseInteraction--;\n            }\n            if (doDraw || _this.forceDraw) {\n                _this.forceDraw = false;\n                _this.emitViewport();\n                _this.draw();\n            }\n        };\n        /**\n         * Applies new props injected into this component.\n         *\n         * Applying new props does not entail that a re-render will happen so we\n         * handle application of props as a separate concept. Here we:\n         *\n         * set up zoom targetting and apply quested zoom levels\n         *\n         * Create our quad tree and associate properties to objects if a new dataset\n         * is provided\n         *\n         * Analyze our dataset for interesting and useful metrics such as max and mins\n         * to aid in visualization normalization\n         *\n         * @param {T} props The new properties for this component\n         */\n        _this.applyProps = function (props) {\n            debug('Applying props');\n            var response;\n            _this.propsMethodList.some(function (method) {\n                response = method(props);\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            debugCam('current cam', _this.currentX, _this.currentY, _this.destinationX, _this.destinationY);\n            debugCam('Zoom Target: [%o, %o]', _this.zoomTargetX, _this.zoomTargetY);\n            debugCam('Last Mouse: [%o, %o]', _this.lastMousePosition.x, _this.lastMousePosition.y);\n        };\n        /**\n         * This initializes the surface and calls for sub class classes to initialize\n         * their buffers\n         *\n         * @param {HTMLElement} el The DOM element this component is contained in\n         * @param {number} w The width of the rendering\n         * @param {number} h The height of the rendering\n         */\n        _this.init = function (el, w, h) {\n            if (!el || _this.scene) {\n                return;\n            }\n            _this.renderEl = el;\n            if (w === 0 || h === 0) {\n                return;\n            }\n            debug('Initializing GPU objects el: %o width: %o height: %o', el, w, h);\n            // Set up a ctx for our render space\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2.0,\n                width: w,\n                widthHalf: w / 2.0,\n            };\n            // Set up the camera now that the ctx is set up\n            _this.initCamera();\n            // Create a scene so we can add our buffer objects to it\n            // We also add the scene to the window to make threejs tools available\n            window.scene = _this.scene = new three_1.Scene();\n            // Fire our hook for starting up our specific buffer implementation\n            _this.initBuffers();\n            // FINALIZE SET UP\n            // Generate the renderer along with it's properties\n            _this.renderer = new three_1.WebGLRenderer({\n                alpha: _this.props.backgroundColor && (_this.props.backgroundColor.opacity < 1.0),\n                antialias: true,\n                preserveDrawingBuffer: true,\n            });\n            // This sets the pixel ratio to handle differing pixel densities in screens\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            // Applies the background color and establishes whether or not the context supports\n            // Alpha or not\n            if (_this.props.backgroundColor) {\n                _this.renderer.setClearColor(new three_1.Color(_this.props.backgroundColor.r, _this.props.backgroundColor.g, _this.props.backgroundColor.b), _this.props.backgroundColor.opacity);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            // We render shapes. We care not for culling.\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            // Set up DOM interaction with the renderer\n            var container = el;\n            container.appendChild(_this.renderer.domElement);\n            // Get the gl context for queries and advanced operations\n            _this.gl = _this.renderer.domElement.getContext('webgl');\n            _this.makeDraggable(document.getElementById('div'), _this);\n        };\n        /**\n         * Initializes the camera and any contexts associated with it\n         */\n        _this.initCamera = function () {\n            debug('Initializing Camera');\n            // INITIALIZE THE CAMERA\n            var h = _this.ctx.height;\n            var viewSize = h;\n            var w = _this.ctx.width;\n            var aspectRatio = w / h;\n            var viewport = {\n                aspectRatio: aspectRatio,\n                bottom: -viewSize / 2,\n                far: 10000000,\n                left: (-aspectRatio * viewSize) / 2,\n                near: -100,\n                right: (aspectRatio * viewSize) / 2,\n                top: viewSize / 2,\n                viewSize: viewSize,\n            };\n            _this.camera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.sizeCamera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.camera.position.z = 300;\n            _this.sizeCamera.position.set(0, 0, 300);\n        };\n        /**\n         * This is executed when our rendering surface (the canvas) changes in size in any\n         * way. It will make sure our renderer matches the context to prevent scaling\n         * and other deformations.\n         */\n        _this.resizeContext = function () {\n            var w = _this.props.width;\n            var h = _this.props.height;\n            // See if a renderer even exists yet\n            if (!_this.renderer) {\n                return false;\n            }\n            var renderSize = _this.renderer.getSize();\n            // Check if the resize is needed\n            if (renderSize.width === w && renderSize.height === h) {\n                return false;\n            }\n            debug('RENDERER RESIZE');\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2,\n                width: w,\n                widthHalf: w / 2,\n            };\n            var zoom = _this.camera.zoom;\n            var position = _this.camera.position.clone();\n            _this.initCamera();\n            _this.camera.zoom = zoom;\n            _this.camera.position.set(position.x, position.y, position.z);\n            _this.camera.updateProjectionMatrix();\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            if (_this.props.backgroundColor) {\n                var color = _this.props.backgroundColor;\n                _this.renderer.setClearColor(new three_1.Color(color.r, color.g, color.b), color.opacity < 1.0 ? color.opacity : undefined);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            return true;\n        };\n        /**\n         * This method handles emitting the viewport and the current visible elements\n         * to the subclass that needs detailed information regarding the viewport.\n         */\n        _this.emitViewport = function () {\n            var tl = _this.screenToWorld(0, 0);\n            var br = _this.screenToWorld(_this.ctx.width, _this.ctx.height);\n            _this.camera.updateMatrixWorld(true);\n            var visible = _this.quadTree.query(new bounds_1.Bounds(tl.x, br.x, tl.y, br.y));\n            _this.onViewport(visible, _this.projection, _this.ctx);\n        };\n        /**\n         * Handles mouse interactions when the mouse is pressed on the canvas. This\n         * engages panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseDown = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = true;\n            _this.distance = 0;\n            _this.onMouseDown();\n        };\n        /**\n         * Handles mouse interactions when the mouse is release or left the canvas. This\n         * stops panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseOut = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            _this.distance = 0;\n            _this.onMouseOut();\n        };\n        /**\n         * Handles mouse interactions when the mouse is released on the canvas. This\n         * stops panning and engages click events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseUp = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            // Handle mouse interaction\n            if (_this.distance < 5) {\n                var hitInside = [];\n                // Circle Interaction\n                var hitItems = _this.quadTree.query(world);\n                for (var _i = 0, hitItems_1 = hitItems; _i < hitItems_1.length; _i++) {\n                    var item = hitItems_1[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                    }\n                }\n                // Tell the listener that the user clicked on some items\n                if (hitInside.length) {\n                    _this.onMouseUp(e, hitInside, mouse, world, _this.projection);\n                }\n                else {\n                    _this.onMouseUp(e, null, mouse, world, _this.projection);\n                }\n            }\n        };\n        /**\n         * Handles mouse interactions when the mouse is moving on the canvas. This\n         * causes panning and hover events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseMove = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            var onMouse = _this.props.onMouse;\n            var zoom = _this.props.zoom;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            _this.distance++;\n            debug('mouse X %o Y %o', mouse.x, mouse.y);\n            // Handle panning\n            if (_this.isPanning) {\n                debug('down and moving ~~');\n                var xDistance = (mouse.x - _this.lastMousePosition.x) / _this.targetZoom;\n                var yDistance = -(mouse.y - _this.lastMousePosition.y) / _this.targetZoom;\n                // Execute the hook to allow subclasses\n                var pan = _this.willPan(xDistance, yDistance);\n                xDistance = pan.x;\n                yDistance = pan.y;\n                _this.destinationX -= xDistance;\n                _this.destinationY -= yDistance;\n                _this.inertia = _this.inertia || { x: 0, y: 0 };\n                if (sign(xDistance) !== sign(_this.inertia.x)) {\n                    _this.inertia.x = 0;\n                }\n                if (sign(yDistance) !== sign(_this.inertia.y)) {\n                    _this.inertia.y = 0;\n                }\n                _this.inertia.x = xDistance * _this.inertiaBuild;\n                _this.inertia.y = yDistance * _this.inertiaBuild;\n                var maxInertia = _this.inertiaMax / zoom;\n                var mag = Math.sqrt(_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y);\n                // Make sure the magnitude of the inertia is less than our max allowed\n                if (mag > maxInertia) {\n                    // Since it's greater, let's confine the inertia's magnitude to the max magnitude\n                    // By normalizing the intertia vector and multilying it by the max\n                    _this.inertia.x = (_this.inertia.x / mag) * maxInertia;\n                    _this.inertia.y = (_this.inertia.y / mag) * maxInertia;\n                }\n            }\n            if (_this.quadTree && !_this.isPanning) {\n                // Empty the last hovered items to populate a new list\n                var currentHoverItems = [];\n                // Handle mouse interaction with items\n                // Interaction with circles\n                var hitItems = _this.quadTree.query(world);\n                var hitInside = [];\n                for (var _i = 0, hitItems_2 = hitItems; _i < hitItems_2.length; _i++) {\n                    var item = hitItems_2[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                        currentHoverItems.push(item);\n                    }\n                }\n                // Inform of all items hit or hovered\n                _this.onMouseHover(hitInside, mouse, world, _this.projection);\n                // Diff the currently hovered items with the old ones to see what is\n                // No longer hit\n                var left = [];\n                for (var _a = 0, _b = _this.currentHoverItems; _a < _b.length; _a++) {\n                    var item = _b[_a];\n                    if (currentHoverItems.indexOf(item) < 0) {\n                        left.push(item);\n                    }\n                }\n                // Inform of all items no longer hovered\n                _this.onMouseLeave(left, mouse, world, _this.projection);\n                _this.currentHoverItems = currentHoverItems;\n            }\n            if (onMouse) {\n                _this.onMouse(mouse, world, _this.isPanning);\n            }\n            _this.lastMousePosition = mouse;\n        };\n        /**\n         * We make the ref application be a declared function so react does not find the need to execute the\n         * application numerous times for a detected changed method\n         *\n         * @param {HTMLElement} n This is the canvas element from the dom\n         */\n        _this.applyRef = function (n) {\n            _this.init(n, _this.props.width, _this.props.height);\n            _this.applyProps(_this.props);\n        };\n        return _this;\n    }\n    /**\n     * This is a hook so subclasses can contribute animated methods to the animation loop and organize the base methods\n     * as desired.\n     *\n     * @param {AnimatedMethodLookup} baseAnimatedMethods The base animated methods referenceable by name\n     * @param {AnimatedMethod[]} orderedBaseAnimatedMethods The base animated methods in their default order for ease of use\n     *\n     * @return {AnimatedMethods[]} The list of animated methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.animatedMethods = function (baseAnimatedMethods, orderedBaseAnimatedMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBaseAnimatedMethods;\n    };\n    /**\n     * This generates the base animated methods lookup.\n     * We do not make these methods a part of the class as this is the base class\n     * We want the start up methods to be inconsequential to sub classes, thus allowing\n     * us to override, sort, or replace the initial methods and have the method get garbage\n     * collected and no longer a part of the object. It is recommended to make the sub classes\n     * actually point to class methods for better clarity\n     *\n     * @return {ANimatedMethodLookup} The base animated methods in a lookup\n     */\n    WebGLSurface.prototype.animatedMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            // Context changes and early checks\n            _a[BaseAnimatedMethods.CONTEXT] = function () {\n                var response = {\n                    break: false,\n                    doDraw: false,\n                };\n                if (_this.resizeContext()) {\n                    response.doDraw = true;\n                }\n                // Quadtree MUST be present to do proper computations\n                if (!_this.quadTree) {\n                    response.break = true;\n                }\n                return response;\n            },\n            // Apply inertia\n            _a[BaseAnimatedMethods.INERTIA] = function () {\n                if (!_this.isPanning) {\n                    if (_this.inertia) {\n                        // Disabled inertia for now\n                        // This.destinationX -= this.inertia.x\n                        // This.destinationY -= this.inertia.y\n                        _this.inertia.x *= _this.inertiaDecay;\n                        _this.inertia.y *= _this.inertiaDecay;\n                        if (_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y < 1) {\n                            _this.inertia = null;\n                        }\n                    }\n                }\n                // A non response\n                return {\n                    doDraw: false,\n                };\n            },\n            // Apply position\n            _a[BaseAnimatedMethods.POSITION] = function () {\n                // If values are transitioned rather than immediately applied, this is\n                // The value you would want the minimum change to be before cutting off\n                // The transition\n                // Const minAdjust = 1 / this.props.zoom\n                // If there is change in X apply the new position to the old\n                // This is where animated values were originally placed and can be placed\n                // Again if a transition is desired\n                var response = {\n                    doDraw: (_this.currentX !== _this.destinationX) || (_this.currentY !== _this.destinationY),\n                };\n                _this.currentX = _this.destinationX;\n                _this.currentY = _this.destinationY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            // Apply zooming\n            _a[BaseAnimatedMethods.ZOOM] = function () {\n                var response = {\n                    doDraw: false,\n                };\n                // Apply Zoom\n                // Const zoomToFitH = this.ctx.width / Math.max(this.quadTree.bounds.width, this.props.viewport.width);\n                // Const zoomToFitV = this.ctx.height / Math.max(this.quadTree.bounds.height, this.props.viewport.height);\n                // Const zoomToFit = Math.min(zoomToFitH, zoomToFitV);\n                var zoomToFit = 1;\n                var destZoom = _this.destinationZoom * zoomToFit;\n                var dZoom = Math.abs(destZoom - _this.targetZoom);\n                var minDZoom = MIN_ZOOM_INCREMENT;\n                var zoomRate = 3;\n                if (dZoom > minDZoom) {\n                    _this.targetZoom = _this.targetZoom + ((destZoom - _this.targetZoom) / zoomRate);\n                    response.doDraw = true;\n                }\n                else if (dZoom !== 0) {\n                    _this.targetZoom = destZoom;\n                    response.doDraw = true;\n                }\n                // Get the zoom target metrics before zooming\n                var zoomTargetX = _this.zoomTargetX;\n                var zoomTargetY = _this.zoomTargetY;\n                var screenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Update the camera zoom level\n                _this.zoomCamera(_this.targetZoom);\n                // After we have zoomed we see how much our target location moved on screen\n                var newScreenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Now we move our screen by the moved delta to keep it exactly where it was before hand\n                var zoomDX = -(newScreenZoomTarget.x - screenZoomTarget.x) / _this.targetZoom;\n                var zoomDY = (newScreenZoomTarget.y - screenZoomTarget.y) / _this.targetZoom;\n                _this.currentX -= zoomDX;\n                _this.currentY -= zoomDY;\n                _this.destinationX -= zoomDX;\n                _this.destinationY -= zoomDY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for subclasses to be able to apply buffer changes that rely\n     * on colors rendered into the atlas after the system has prepped the colors for render.\n     */\n    WebGLSurface.prototype.applyColorBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * This is a hook for subclasses to be able to apply label buffer changes after the system has\n     * prepped the labels for render.\n     */\n    WebGLSurface.prototype.applyLabelBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * @override\n     * This is a hook so subclasses can contribute property application methods to the applyProps process and organize the base methods\n     * as desired.\n     *\n     * @param {ApplyPropsMethodLookup<T>} basePropsMethods The base props methods referenceable by name\n     * @param {ApplyPropsMethod<T>[]} orderedBasePropsMethods The base animated methods in their default order for ease of use\n     *\n     * @return {ApplyPropsMethod<T>[]} The list of property application methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.applyPropsMethods = function (basePropsMethods, orderedBasePropsMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBasePropsMethods;\n    };\n    /**\n     * This is a hook so subclasses can contribute methods to the applying props procedure and organize the base methods\n     * as desired.\n     *\n     * @return {ApplyPropsMethodLookup<T>} The base apply props method that are indexed for ease of reference\n     */\n    WebGLSurface.prototype.applyPropsMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            _a[BaseApplyPropsMethods.INITIALIZE] = function (props) {\n                var backgroundColor = props.backgroundColor, height = props.height, width = props.width;\n                _this.init(_this.renderEl, width, height);\n                if (!_this.renderEl || width === 0 || height === 0) {\n                    return {\n                        break: true,\n                    };\n                }\n                // Get the target for zooming\n                if (_this.camera) {\n                    var world = _this.screenToWorld(_this.lastMousePosition.x, _this.lastMousePosition.y);\n                    _this.zoomTargetX = world.x;\n                    _this.zoomTargetY = world.y;\n                }\n                if (_this.renderer && backgroundColor) {\n                    var oldColor = _this.props.backgroundColor || {\n                        b: BACKGROUND_COLOR.b,\n                        g: BACKGROUND_COLOR.g,\n                        opacity: 1.0,\n                        r: BACKGROUND_COLOR.r,\n                    };\n                    var same = oldColor.r === backgroundColor.r &&\n                        oldColor.g === backgroundColor.g &&\n                        oldColor.b === backgroundColor.b &&\n                        oldColor.opacity === backgroundColor.opacity;\n                    if (!same) {\n                        _this.renderer.setClearColor(new three_1.Color(backgroundColor.r, backgroundColor.g, backgroundColor.b), \n                        // Only if a transparent background is specified should we\n                        // Allow the parameter. We avoid the parameter to ensure\n                        // Transparent mode it not activated unless absolutely necessary\n                        backgroundColor.opacity < 1 ? backgroundColor.opacity : undefined);\n                    }\n                }\n                debug('props', props);\n                return {};\n            },\n            _a[BaseApplyPropsMethods.LABELS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.labels && props.labels !== _this.labels) {\n                    debugLabels('Labels are being comitted to an Atlas %o', props.labels);\n                    // Flag the labels as incapable of rendering\n                    _this.labelsReady = false;\n                    _this.labelsLoadId++;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.labels = props.labels;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.labels)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.labels);\n                    }\n                    var textures = props.labels.map(function (label) { return new atlas_texture_1.AtlasTexture(null, label); });\n                    debugLabels('Creating the atlas for labels based on these textures %o', textures);\n                    _this.atlasManager.createAtlas(_this.atlasNames.labels, textures)\n                        .then(function () {\n                        debugLabels('Labels rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.labels));\n                        _this.forceDraw = true;\n                        _this.labelsCurrentLoadedId++;\n                        // If we are done loading AND we match up with the current load id, then labels\n                        // For the latest labels update are indeed ready for display\n                        if (_this.labelsCurrentLoadedId === _this.labelsLoadId) {\n                            _this.labelsReady = true;\n                        }\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.COLORS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.colors && props.colors !== _this.colors) {\n                    debugColors('Colors are being comitted to an Atlas %o', props.colors);\n                    // Flag the labels as incapable of rendering\n                    _this.colorsReady = false;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.colors = props.colors;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.colors)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.colors);\n                    }\n                    debugColors('Creating the atlas for colors based on these colors %o', _this.colors);\n                    _this.atlasManager.createAtlas(_this.atlasNames.colors, null, _this.colors)\n                        .then(function () {\n                        debugColors('Colors rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.colors));\n                        _this.forceDraw = true;\n                        _this.colorsReady = true;\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.BUFFERCHANGES] = function (props) {\n                // Call the hook to allow sub componentry to have a place to update it's buffers\n                _this.applyBufferChanges(props);\n                // We call the label buffering when the labels are ready to render.\n                // Labels now utilize the color atlas as well, thus requiring colors\n                // To be loaded\n                if (_this.labelsReady && _this.colorsReady) {\n                    debugLabels('labels changed %o', props);\n                    _this.applyLabelBufferChanges(props);\n                }\n                // For resources that only need the color atlas to be ready\n                if (_this.colorsReady) {\n                    _this.applyColorBufferChanges(props);\n                }\n                return {};\n            },\n            _a[BaseApplyPropsMethods.CAMERA] = function (props) {\n                _this.destinationZoom = props.zoom;\n                // On initialization this should start with some base camera metrics\n                if (props.viewport && props.viewport !== _this.appliedViewport && _this.quadTree) {\n                    debugCam('Applying viewport to camera: %o World Space Bounds: %o Screen context: %o', props.viewport, _this.quadTree.bounds, { width: props.width, height: props.height });\n                    // Position the camera over the mid of the specified viewport\n                    var mid = props.viewport.mid;\n                    _this.currentX = _this.destinationX = mid.x;\n                    _this.currentY = _this.destinationY = mid.y;\n                    // Calculate the zoom level when the input zoom is at 1\n                    var zoomAtOne = 1;\n                    // Calculate the zoom needed for the viewport\n                    var zoomToFitViewH = props.width / props.viewport.width;\n                    var zoomToFitViewV = props.height / props.viewport.height;\n                    var zoomToFit = Math.min(zoomToFitViewH, zoomToFitViewV);\n                    // This adjusts the destination zxoom by a tiny amount so the view will redraw\n                    var microAdjustment = 1.001;\n                    // Make our destination zoom a zoom that will fit the dimensions of the viewport\n                    // Relative to the zoom at one level\n                    _this.destinationZoom = zoomToFit / zoomAtOne;\n                    _this.targetZoom = (_this.destinationZoom * zoomAtOne) * microAdjustment;\n                    // Make sure any zooming that happens occurs over the middle of the initial viewport\n                    _this.zoomTargetX = mid.x;\n                    _this.zoomTargetY = mid.y;\n                    // Make sure mouse position doesn't mess with the zooming focus either\n                    _this.lastMousePosition.x = props.width / 2.0;\n                    _this.lastMousePosition.y = props.height / 2.0;\n                    // Apply the values immediately to the camera\n                    _this.positionCamera(_this.currentX, _this.currentY);\n                    _this.zoomCamera(_this.targetZoom);\n                    _this.updateCameraUniforms();\n                    // We request the calculated zoom level so adjustments on the input can be made\n                    if (props.onZoomRequest) {\n                        props.onZoomRequest(_this.destinationZoom);\n                        debugCam('Requesting zoom level', _this.destinationZoom);\n                    }\n                    // Let's disable mouse interactions for a little bit until the camera has settled into place\n                    var framesToDisable = 10;\n                    _this.disableMouseInteraction = framesToDisable;\n                    _this.appliedViewport = props.viewport;\n                    debugCam('init cam', _this.currentX, _this.currentY);\n                }\n                // Ensure we have our quad tree available even if it is empty\n                if (!_this.quadTree) {\n                    _this.quadTree = new quad_tree_1.QuadTree(0, 1, 1, 0);\n                }\n                return {};\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for sub components to have a location to update their buffers\n     *\n     * @param {T} props This is the next set of props that are going to be applied to this component\n     */\n    WebGLSurface.prototype.applyBufferChanges = function (props) {\n        // NOTE: This will be implemented by base classes\n    };\n    /**\n     * @override\n     * Start the update loop and register any interesting listeners\n     */\n    WebGLSurface.prototype.componentDidMount = function () {\n        this.animate();\n    };\n    /**\n     * @override\n     * This will set up any unchanging context as well as establish the set of methods\n     * that are to be used within constructed method loops.\n     */\n    WebGLSurface.prototype.componentWillMount = function () {\n        /** Create our context bound projection methods for handing to processes that may need them */\n        this.projection = {\n            screenSizeToWorld: this.screenSizeToWorld.bind(this),\n            screenToWorld: this.screenToWorld.bind(this),\n            worldSizeToScreen: this.worldSizeToScreen.bind(this),\n            worldToScreen: this.worldToScreen.bind(this),\n        };\n        /** Generate our applying props methods to execute within our applyProps process */\n        var basePropsMethods = this.applyPropsMethodsBase();\n        this.propsMethodList = this.applyPropsMethods(basePropsMethods, [\n            basePropsMethods[BaseApplyPropsMethods.INITIALIZE],\n            basePropsMethods[BaseApplyPropsMethods.LABELS],\n            basePropsMethods[BaseApplyPropsMethods.COLORS],\n            basePropsMethods[BaseApplyPropsMethods.BUFFERCHANGES],\n            basePropsMethods[BaseApplyPropsMethods.CAMERA],\n        ]);\n        /** Generate our animated methods to execute within our animation loop */\n        var baseAnimatedMethods = this.animatedMethodsBase();\n        this.animatedMethodList = this.animatedMethods(baseAnimatedMethods, [\n            baseAnimatedMethods[BaseAnimatedMethods.CONTEXT],\n            baseAnimatedMethods[BaseAnimatedMethods.INERTIA],\n            baseAnimatedMethods[BaseAnimatedMethods.POSITION],\n            baseAnimatedMethods[BaseAnimatedMethods.ZOOM],\n        ]);\n    };\n    /**\n     * @override\n     * Simply applies the new injected props\n     *\n     * @param {T} props The new properties to be applied to this component\n     */\n    WebGLSurface.prototype.componentWillReceiveProps = function (props) {\n        this.applyProps(props);\n    };\n    /**\n     * @override\n     * Release listeners and stop update loop\n     */\n    WebGLSurface.prototype.componentWillUnmount = function () {\n        this.stop = true;\n        if (this.quadTree) {\n            this.quadTree.destroy();\n        }\n        this.quadTree = null;\n        this.camera = null;\n        this.sizeCamera = null;\n        this.ctx = null;\n        this.renderEl = null;\n        this.renderer = null;\n        this.scene = null;\n        this.atlasManager.destroyAtlas(this.atlasNames.colors);\n        this.atlasManager.destroyAtlas(this.atlasNames.labels);\n        frame_info_1.FrameInfo.framesPlayed.delete(this);\n    };\n    /**\n     * This is the draw method executed from the animation loop. Everytime, this is\n     * called, the webgl surface will be redrawn.\n     */\n    WebGLSurface.prototype.draw = function () {\n        // Draw the 3D scene\n        this.renderer.render(this.scene, this.camera);\n        if (this.props.onRender && (this.colorsReady || this.colors.length === 0)\n            && (this.labelsReady || this.labels.length === 0)) {\n            var imageData = this.renderer.domElement.toDataURL();\n            this.props.onRender(imageData);\n        }\n    };\n    /**\n     * This is a hook allowing sub classes to have a place to initialize their buffers\n     * and materials etc.\n     */\n    WebGLSurface.prototype.initBuffers = function () {\n        // NOTE: This is to be implemented by subclasses\n    };\n    /**\n     * Hook for subclasses to when the mouse moves. Provides some information\n     * about mouse location and interaction.\n     *\n     * @param {IPoint} mouse Position of the mouse relative to the canvas\n     * @param {IPoint} world Position of the mouse relative to the world space\n     * @param {boolean} isPanning The panning state of the mouse\n     */\n    WebGLSurface.prototype.onMouse = function (mouse, world, isPanning) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse down events\n     */\n    WebGLSurface.prototype.onMouseDown = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse out events\n     */\n    WebGLSurface.prototype.onMouseOut = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse up events and the items that were interacted with in the process\n     *\n     * @param {React.MouseEvent} e The react synthetic event associated with the action\n     * @param {Bounds[]} hitInside The items the mouse interacted with\n     * @param {IPoint} mouse The location of the mouse on the screen\n     * @param {IPoint} world The location of the mouse projected into the world\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseUp = function (e, hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse hovering over an item included in the quadtree\n     *\n     * @param {Bounds[]} hitInside The items hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseHover = function (hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse leaving an item included in the quadtree\n     *\n     * @param {Bounds[]} left The items no longer hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseLeave = function (left, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to changes in the viewport and currently visible items\n     *\n     * @param {Bounds[]} visible\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     * @param {IScreenContext} ctx\n     */\n    WebGLSurface.prototype.onViewport = function (visible, projection, ctx) {\n        // NOTE: For subclasses\n    };\n    WebGLSurface.prototype.makeDraggable = function (element, stage) {\n        element.onmousedown = function (event) {\n            debug('DRAG~');\n            stage.dragOver = false;\n            document.onmousemove = function (event) {\n                debug('Move');\n                var mouseX = event.clientX;\n                var mouseY = event.clientY + window.scrollY;\n                var distanceX = (mouseX - stage.lastMousePosition.x) / stage.targetZoom;\n                var distanceY = (mouseY - stage.lastMousePosition.y) / stage.targetZoom;\n                stage.destinationX -= distanceX;\n                stage.destinationY += distanceY;\n                stage.lastMousePosition.x = mouseX;\n                stage.lastMousePosition.y = mouseY;\n            };\n            document.onmouseup = function () {\n                debug('Up');\n                document.onmousemove = null;\n                stage.isPanning = false;\n                stage.dragOver = true;\n            };\n            document.onmouseover = function () {\n                debug('Over');\n                if (stage.dragOver === false)\n                    stage.isPanning = true;\n            };\n            element.onmouseup = function () {\n                stage.dragOver = true;\n            };\n            // Text will not be selected when it is being dragged\n            element.onselectstart = function () { return false; };\n        };\n    };\n    /**\n     * Places the camera at a given location in world space\n     *\n     * @param {number} x The x-coordinate for the camera in world space\n     * @param {number} y The x-coordinate for the camera in world space\n     */\n    WebGLSurface.prototype.positionCamera = function (x, y) {\n        if (this.camera) {\n            this.camera.position.set(x, y, this.camera.position.z);\n        }\n    };\n    /**\n     * Projects a screen coordinate to a world coordinate\n     *\n     * @param {number} x The x coord within the screen to project into the world\n     * @param {number} y The y coord within the screen to project into the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenToWorld = function (x, y, obj) {\n        // Get the coordinates in normalized screen space\n        vector.set((x / this.ctx.width) * 2 - 1, -(y / this.ctx.height) * 2 + 1, 0.0);\n        // Unproject the normalized space to the world. It will project\n        // The vector to a REALLY far away z coordinate, but it does not matter\n        // Since we are utilizing an orthographic camera (no perspective distortion)\n        vector.unproject(this.camera);\n        obj = obj || { x: 0, y: 0 };\n        obj.x = vector.x;\n        obj.y = vector.y;\n        return obj;\n    };\n    /**\n     * Projects a size on the screen to the size represented in the world\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenSizeToWorld = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        obj.height = h / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        return obj;\n    };\n    /**\n     * Projects a world coordinate to the screen\n     *\n     * @param {number} x The x coord in the world to project to the screen\n     * @param {number} y The y coord in the world to project to the screen\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {IPoint} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldToScreen = function (x, y, obj) {\n        // This projects to NORMALIZED screen space (-1, 1) range for x and y\n        vector.set(x, y, 0);\n        vector.project(this.camera);\n        // Use the window dimensions to denormalize the vector\n        obj = ramda_1.merge(obj || {}, {\n            x: (vector.x * this.ctx.widthHalf) + this.ctx.widthHalf,\n            y: -(vector.y * this.ctx.heightHalf) + this.ctx.heightHalf,\n        });\n        return obj;\n    };\n    /**\n     * Projects a size within the world to how it would appear on the screen\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldSizeToScreen = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w * this.sizeCamera.zoom;\n        obj.height = h * this.sizeCamera.zoom;\n        return obj;\n    };\n    /**\n     * Sets the zoom level the camera will view the world with\n     *\n     * @param {number} zoom The zoom level. Must be > 0\n     */\n    WebGLSurface.prototype.zoomCamera = function (zoom) {\n        this.camera.zoom = zoom;\n        this.sizeCamera.zoom = zoom;\n        this.camera.updateProjectionMatrix();\n        this.sizeCamera.updateProjectionMatrix();\n    };\n    /**\n     * This is a hook allowing a sub class to update uniforms when the camera is changed in\n     * any way\n     */\n    WebGLSurface.prototype.updateCameraUniforms = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * @override\n     * Only re-render if the dimensions of the component have changed. All other\n     * internal render updates are handled internally\n     *\n     * @param {T} nextProps The next properties injected\n     */\n    WebGLSurface.prototype.shouldComponentUpdate = function (nextProps) {\n        return this.props.width !== nextProps.width || this.props.height !== nextProps.height;\n    };\n    /**\n     * Hook to allow subclasses some control over panning distances\n     *\n     * @param {number} distanceX The distance to pan in the x direction\n     * @param {number} distanceY The distance to pan in the y direction\n     *\n     * @return {Vector3} The vector indicating the direction to pan\n     */\n    WebGLSurface.prototype.willPan = function (distanceX, distanceY) {\n        return new three_1.Vector3(distanceX, distanceY, 0.0);\n    };\n    // -----[ Render ]---------------------------------------------\n    //\n    // In a React app, it's nice to put the render function at the bottom of the\n    // File\n    /**\n     * This should only attempt rendering when the canvas DOM element needs to be resized.\n     * You will note shouldComponentUpdate helps facilitate this.\n     */\n    WebGLSurface.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, width = _a.width, height = _a.height;\n        if (!webgl_stat_1.WebGLStat.WEBGL_SUPPORTED) {\n            return React.createElement(\"div\", null, this.props.children || 'Web GL not supported');\n        }\n        return (React.createElement(\"div\", { id: \"div\", onMouseDown: this.handleMouseDown, onMouseOut: this.handleMouseOut, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseOut, onMouseMove: this.handleMouseMove, onDoubleClick: function (e) {\n                if (_this.props.onDoubleClick) {\n                    _this.props.onDoubleClick(e);\n                }\n            }, style: { position: 'relative', width: width, height: height } },\n            React.createElement(\"div\", { ref: this.applyRef })));\n    };\n    return WebGLSurface;\n}(React.Component));\nexports.WebGLSurface = WebGLSurface;\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_28__;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(32);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_33__;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(35));\n__export(__webpack_require__(36));\n__export(__webpack_require__(4));\n__export(__webpack_require__(37));\n__export(__webpack_require__(38));\n__export(__webpack_require__(39));\n__export(__webpack_require__(40));\n__export(__webpack_require__(41));\n__export(__webpack_require__(42));\n__export(__webpack_require__(43));\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBufferAnts = /** @class */ (function (_super) {\n    __extends(SharedControlCurvedLineBufferAnts, _super);\n    function SharedControlCurvedLineBufferAnts() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBufferAnts.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'marching',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBufferAnts.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (shapeBuffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\n            var colorRef = shapeBuffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var marchingAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var antLength;\n        var antGap;\n        var antSpeed;\n        var controlPoint;\n        var controlRef;\n        // We can not accurately send very large numbers via float point into the attributes\n        // So we trim down our time sent to the attribute down to a number that is less than\n        // 16,777,217 which means we can only reliably grab the last 7 digits of the date's time\n        var antStartTime = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            // We will not render the curved line with this buffer if the marching ants are not provided\n            if (!curvedLine.marchingAnts) {\n                console.error('Attempted to render a curved line shape with a marching ant buffer but provided no marching ant metrics. This curved line shape will be skipped', curvedLine);\n                return \"continue\";\n            }\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            antGap = curvedLine.marchingAnts.gapLength;\n            antSpeed = curvedLine.marchingAnts.speed;\n            antLength = curvedLine.marchingAnts.strokeLength + curvedLine.marchingAnts.gapLength;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, marching, mpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                marching[mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBufferAnts;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBufferAnts = SharedControlCurvedLineBufferAnts;\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineColorsBuffer = /** @class */ (function (_super) {\n    __extends(SharedControlCurvedLineColorsBuffer, _super);\n    function SharedControlCurvedLineColorsBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'colorPicks',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'timing',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (shapeBuffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var uniforms;\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\n            var colorRef = shapeBuffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var timingAttributeSize = 2;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorStartStop;\n        var colorEnd;\n        var colorEndStop;\n        var alpha;\n        var startTime;\n        var duration;\n        var controlRef;\n        var controlPoint;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorEnd = curvedLine.endColor.base.colorIndex;\n            colorEndStop = curvedLine.endColorStop.base.colorIndex;\n            colorStart = curvedLine.startColor.base.colorIndex;\n            colorStartStop = curvedLine.startColorStop.base.colorIndex;\n            duration = curvedLine.duration;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.currentStart;\n            p2 = curvedLine.currentEnd;\n            startTime = curvedLine.startTime;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colorPicks, cpos, controlPick, ctpos, timing, tpos, normals, npos, endPoints, epos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                controlPick[ctpos] = controlRef;\n                cpos += colorAttributeSize;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[wpos] = halfWidthSize;\n                normals[npos] = 1;\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                tpos += timingAttributeSize;\n                // TR\n                colorPicks[cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[tpos] = startTime;\n                timing[++tpos] = duration;\n                // BR\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // TL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // BL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++ctpos] = controlRef;\n            }, \n            // We force updates for this buffer since it has animated properties\n            // Such as currentStartStop and currentEndStop which calculates\n            // Animations on the CPU side.\n            true);\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineColorsBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineColorsBuffer = SharedControlCurvedLineColorsBuffer;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(5);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBuffer = /** @class */ (function (_super) {\n    __extends(SharedControlCurvedLineBuffer, _super);\n    function SharedControlCurvedLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var controlPoint;\n        var controlRef;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, buffer_1 = buffer; _i < buffer_1.length; _i++) {\n            var curvedLine = buffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBuffer = SharedControlCurvedLineBuffer;\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This ONLY supports a single color\n */\nvar SimpleStaticBezierLineBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticBezierLineBuffer, _super);\n    function SimpleStaticBezierLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticBezierLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0, 0],\n                name: 'controlPoint',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticBezierLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var color;\n        var alpha;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            color = curvedLine.startColor.base.color;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colors, cpos, normals, npos, endPoints, epos, controlPoints, copos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                cpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticBezierLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticBezierLineBuffer = SimpleStaticBezierLineBuffer;\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\nvar SimpleStaticCircleBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticCircleBuffer, _super);\n    function SimpleStaticCircleBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticCircleBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'radius',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 1;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Points(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticCircleBuffer.prototype.update = function (shapeBuffer, atlasManager, camera) {\n        if (!shapeBuffer || shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        if (atlasManager) {\n            var colorRef = shapeBuffer[0].outerColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n            if (camera) {\n                uniforms.zoom.value = camera.zoom;\n            }\n        }\n        var needsUpdate = false;\n        var circle;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this.bufferItems, 1, shapeBuffer.length, function (i, positions, ppos, radius, rpos, color, cpos) {\n            circle = shapeBuffer[i];\n            // These are point sprites, so just update a single vertex\n            positions[ppos] = circle._centerX;\n            positions[++ppos] = circle._centerY;\n            positions[++ppos] = circle.depth;\n            radius[rpos] = circle._radius;\n            color[cpos] = circle.outerColor.base.colorIndex;\n        });\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, shapeBuffer.length);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticCircleBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticCircleBuffer = SimpleStaticCircleBuffer;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(5);\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticLabelBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticLabelBuffer, _super);\n    function SimpleStaticLabelBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLabelBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 1],\n                name: 'texCoord',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'size',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0, 0],\n                name: 'anchor',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLabelBuffer.prototype.update = function (shapeBuffer, atlasManager, startFade, endFade, labelMaxSize) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // Make some constants and props for our buffer update loop\n        var numVerticesPerQuad = 6;\n        var label;\n        var texture;\n        var color;\n        var alpha;\n        var anchor;\n        var labelSize;\n        if (atlasManager) {\n            var colorRef = buffer[0].color;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            if (uniforms.colorAtlas.value !== atlas) {\n                uniforms.colorAtlas.value = atlas;\n                uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n                uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n                uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n                atlas.needsUpdate = true;\n            }\n            if (startFade || endFade || labelMaxSize) {\n                material = this.bufferItems.system.material;\n                uniforms = material.uniforms;\n                uniforms.startFade.value = startFade || 0;\n                uniforms.endFade.value = endFade || 0;\n                uniforms.maxLabelSize.value = labelMaxSize || 0;\n            }\n        }\n        var updated = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerQuad, buffer.length, function (i, positions, ppos, colors, cpos, texCoords, tpos, sizes, spos, anchors, apos) {\n            label = buffer[i];\n            texture = label.rasterizedLabel;\n            color = label.color.base;\n            alpha = label.color.base.opacity;\n            anchor = {\n                x: label.getLocation().x + label.getSize().width * Math.cos(label.getRotation()),\n                y: label.getLocation().y + label.getSize().width * Math.sin(label.getRotation()),\n            };\n            labelSize = label.getSize();\n            // Make sure the label is updated with it's latest metrics\n            label.update();\n            // Copy first vertex twice for intro degenerate tri\n            positions[ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[cpos] = color.colorIndex;\n            sizes[spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TR\n            positions[++ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BR\n            positions[++ppos] = label.BR.x;\n            positions[++ppos] = label.BR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBR.x;\n            texCoords[++tpos] = texture.atlasBR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TL\n            positions[++ppos] = label.TL.x;\n            positions[++ppos] = label.TL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTL.x;\n            texCoords[++tpos] = texture.atlasTL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BL\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // Copy last vertex again for degenerate tri\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n        });\n        this.bufferItems.geometry.setDrawRange(0, numVerticesPerQuad * buffer.length);\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return updated;\n    };\n    return SimpleStaticLabelBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLabelBuffer = SimpleStaticLabelBuffer;\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\nvar SimpleStaticLineBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticLineBuffer, _super);\n    function SimpleStaticLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var colorAttributeSize = 4;\n        var stripPos = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var TR;\n        var BR;\n        var TL;\n        var BL;\n        var color;\n        var alpha;\n        var _loop_1 = function (curvedLine) {\n            var strip = curvedLine.getTriangleStrip();\n            color = curvedLine.startColor.base.color;\n            alpha = curvedLine.startColor.base.opacity;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, strip.length / 4, function (i, positions, ppos, colors, cpos) {\n                stripPos = i * 4;\n                TR = strip[stripPos];\n                BR = strip[stripPos + 1];\n                TL = strip[stripPos + 2];\n                BL = strip[stripPos + 3];\n                // 1\n                positions[ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n                // 2\n                positions[++ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 3\n                positions[++ppos] = BR.x;\n                positions[++ppos] = BR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 4\n                positions[++ppos] = TL.x;\n                positions[++ppos] = TL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 5\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 6\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n            });\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLineBuffer = SimpleStaticLineBuffer;\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = __webpack_require__(5);\nvar three_1 = __webpack_require__(0);\nvar point_1 = __webpack_require__(6);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticStraightLineBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticStraightLineBuffer, _super);\n    function SimpleStaticStraightLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticStraightLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticStraightLineBuffer.prototype.update = function (shapeBuffer, atlasManager) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var TR = point_1.Point.zero();\n        var BR = point_1.Point.zero();\n        var TL = point_1.Point.zero();\n        var BL = point_1.Point.zero();\n        var startColor = 0;\n        var endColor = 0;\n        var line;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerSegment, buffer.length, function (i, positions, ppos, color, cpos) {\n            line = buffer[i];\n            startColor = line.startColor.base.colorIndex;\n            endColor = line.endColor.base.colorIndex;\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TR);\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BR);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TL);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BL);\n            // 1\n            positions[ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            cpos += 1.0;\n            // 2\n            positions[++ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            color[cpos] = endColor;\n            // 3\n            positions[++ppos] = BR.x;\n            positions[++ppos] = BR.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = endColor;\n            // 4\n            positions[++ppos] = TL.x;\n            positions[++ppos] = TL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 5\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 6\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n        });\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n            // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n            // Come into existance) we must explicitly ensure the current data is set to the actual\n            // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n            if (isCluster(shapeBuffer)) {\n                this.bufferItems.currentData = shapeBuffer;\n            }\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticStraightLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticStraightLineBuffer = SimpleStaticStraightLineBuffer;\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar buffer_util_1 = __webpack_require__(2);\nvar base_buffer_1 = __webpack_require__(4);\nvar MAX_RESOLUTION = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = MAX_RESOLUTION * VERTICES_PER_SEGMENT;\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceArcBuffer = /** @class */ (function (_super) {\n    __extends(UniformInstanceArcBuffer, _super);\n    function UniformInstanceArcBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {UniformInstanceArcBuffer} shared This should be another instance that has already\n     *                                          been initialized. Providing this will greatly improve\n     *                                          performance by causing sharing of relevant resources across\n     *                                          buffers.\n     */\n    UniformInstanceArcBuffer.prototype.init = function (material, unitCount, shared, bufferClass, pointClass) {\n        if (unitCount !== 0) {\n            console.warn('Unit count is used for vertex buffers that are not using uniform instancing', 'The unit count for these types of buffers are automatically calculated', 'To disable this warning please place a ZERO for the unit count parameter');\n        }\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'halfLineWidth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 2,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n        ];\n        // Generate the uniform buffer to express the type of data to be placed in our instanceData\n        // Uniform\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        // Initialize the vertex buffer, whether that be sharing resources or generating it's own\n        this.initVertexBuffer(shared);\n        var geo = new bufferClass();\n        var arr = new Float32Array(64);\n        geo.addAttribute('whowhatsit', new three_1.BufferAttribute(arr, 1));\n        geo.setDrawRange(0, 1);\n        console.log(three_1.BufferGeometry === bufferClass);\n        // Generate the mesh based on the shared or generated buffer\n        this.bufferItems.system = new three_1.Points(geo, material);\n        // This.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE);\n        this.bufferItems.system.frustumCulled = false;\n        // This.bufferItems.system.drawMode = TriangleStripDrawMode;\n    };\n    UniformInstanceArcBuffer.prototype.initVertexBuffer = function (shared) {\n        this.bufferItems.attributes = [\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    var segment = Math.floor((vertex % VERTICES_PER_CURVE) / VERTICES_PER_SEGMENT) % MAX_RESOLUTION;\n                    var segmentIndex = vertex % VERTICES_PER_SEGMENT;\n                    buffer[start] = segmentIndex >= 3 ? segment : segment + 1;\n                },\n                defaults: [0],\n                name: 'vertexIndex',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    buffer[start] = MAX_RESOLUTION;\n                },\n                defaults: [0],\n                name: 'totalVertices',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    var segmentIndex = vertex % VERTICES_PER_SEGMENT;\n                    buffer[start] = segmentIndex <= 1 ? 1 : (segmentIndex >= 4 ? -1 : (segmentIndex === 2 ? -1 : 1));\n                },\n                defaults: [0],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    buffer[start] = Math.floor(vertex / VERTICES_PER_CURVE);\n                },\n                defaults: [0],\n                name: 'instance',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        // If a buffer with geometry was provided, we share that geometry to significantly\n        // Reduce memory footprint and improve performance\n        if (shared && shared.bufferItems && shared.bufferItems.geometry) {\n            this.bufferItems.geometry = shared.bufferItems.geometry;\n        }\n        else {\n            if (shared && !(shared.bufferItems || shared.bufferItems.geometry)) {\n                console.warn('A UniformInstanceArcBuffer trying to share resources was provided a shared object that did not have the proper elements to share. Shared but lacking:', shared);\n            }\n            var bufferVertexCount = VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances;\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(bufferVertexCount, this.bufferItems.attributes);\n        }\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceArcBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        // If (!shapeBuffer) {\n        //   This.bufferItems.geometry.setDrawRange(0, 0);\n        //   Return false;\n        // }\n        // // This is a special case where we need to update our current item dataset to prevent\n        // // Re-updates for the same empty shape buffer\n        // If (shapeBuffer.length === 0) {\n        //   This.bufferItems.currentData = shapeBuffer;\n        //   This.bufferItems.geometry.setDrawRange(0, 0);\n        //   Return true;\n        // }\n        // Let buffer: CurvedLineShape<any>[];\n        // If (isCluster(shapeBuffer)) {\n        //   Buffer = flatten<CurvedLineShape<any>>(shapeBuffer);\n        // }\n        // Else {\n        //   Buffer = shapeBuffer;\n        // }\n        // // This let's us know if we're maxing out the instances this buffer can handle\n        // If (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n        //   Console.warn(\n        //     'Too many shapes provided for a uniform instancing buffer.',\n        //     'Max supported:',\n        //     This.bufferItems.uniformBuffer.maxInstances,\n        //     'Shapes provided:',\n        //     Buffer.length,\n        //     'This shape buffer should be split across more uniform instancing buffers to render correctly.',\n        //     'Consider using the MultiShapeBufferCache. If this is already in use:',\n        //     'Consider raising the number of buffers it splits across',\n        //   );\n        // }\n        // // As this is a single material, we have to assume that the color atlas\n        // // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // // Information for one color will be valid for all colors\n        // If (atlasManager) {\n        //   Const colorRef: ReferenceColor = buffer[0].startColor;\n        //   Const colorBase = colorRef.base;\n        //   // Update all uniforms for this material to utilize the atlas metrics for\n        //   // Picking colors\n        //   Const material: ShaderMaterial = this.bufferItems.system.material as ShaderMaterial;\n        //   Const uniforms: { [k: string]: IUniform } = material.uniforms;\n        //   Const atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n        //   Uniforms.colorAtlas.value = atlas;\n        //   Uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n        //   Uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n        //   Uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n        //   Atlas.needsUpdate = true;\n        // }\n        // Let needsUpdate = false;\n        // // Commit the information to the uniform instancing group\n        // NeedsUpdate = BufferUtil.updateUniformBuffer(\n        //   Buffer, this.bufferItems,\n        //   Math.min(buffer.length, this.bufferItems.uniformBuffer.maxInstances),\n        //   (\n        //     Instance: number,\n        //     StartColor: Vector4,\n        //     EndColor: Vector4,\n        //     HalfLine: Vector4,\n        //     Resolution: Vector4,\n        //     EndPoints: Vector4,\n        //     Depth: Vector4,\n        //     ControlPoint: Vector4,\n        //   ) => {\n        //     Const curve = buffer[instance];\n        //     StartColor.x = curve.startColor.base.colorIndex;\n        //     EndColor.y = curve.endColor.base.colorIndex;\n        //     HalfLine.z = curve.lineWidth / 2.0;\n        //     Resolution.w = curve.resolution;\n        //     EndPoints.x = curve.start.x;\n        //     EndPoints.y = curve.start.y;\n        //     EndPoints.z = curve.end.x;\n        //     EndPoints.w = curve.end.y;\n        //     Depth.x = curve.depth;\n        //     ControlPoint.y = curve.controlPoints[1].x;\n        //     ControlPoint.z = curve.controlPoints[1].y;\n        //   },\n        // ) || needsUpdate;\n        // Console.log('CURVE SHAPE BUFFER', buffer);\n        // Console.log('UNIFORM BUFFER', this.bufferItems.uniformBuffer.buffer);\n        // // Only if updates happened, should this change\n        // If (needsUpdate) {\n        //   Console.log('UPDATED DRAW RANGE', buffer.length * VERTICES_PER_CURVE);\n        //   This.bufferItems.geometry.setDrawRange(0, buffer.length * VERTICES_PER_CURVE);\n        // }\n        // Return needsUpdate;\n        return true;\n    };\n    return UniformInstanceArcBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceArcBuffer = UniformInstanceArcBuffer;\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(45));\n__export(__webpack_require__(46));\n__export(__webpack_require__(47));\n__export(__webpack_require__(20));\n__export(__webpack_require__(48));\n__export(__webpack_require__(49));\n__export(__webpack_require__(15));\n__export(__webpack_require__(23));\n__export(__webpack_require__(50));\n__export(__webpack_require__(51));\n__export(__webpack_require__(13));\n__export(__webpack_require__(8));\n__export(__webpack_require__(17));\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines a reference to a color that has been rendered to a texture\n * (See AtlasColor). This exposes the only properties that MAY be utilized\n * in a shader to modify the existing values without altering what is rendered\n * on the texture.\n */\nvar ReferenceColor = /** @class */ (function () {\n    /**\n     * Creates an instance of ReferenceColor.\n     *\n     * @param {AtlasColor} base The color to be based off of\n     */\n    function ReferenceColor(base) {\n        this.base = base;\n    }\n    return ReferenceColor;\n}());\nexports.ReferenceColor = ReferenceColor;\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\nvar easing_1 = __webpack_require__(11);\nvar frame_info_1 = __webpack_require__(9);\nvar interpolation_1 = __webpack_require__(12);\nvar curved_line_shape_1 = __webpack_require__(20);\n/**\n * This represents curved lines and what it would take to animate various properties.\n * While this provides helpers to aid in animating the properties, it is up to\n * buffers, shaders and materials to render those changes appropriately.\n */\nvar AnimatedCurvedLineShape = /** @class */ (function (_super) {\n    __extends(AnimatedCurvedLineShape, _super);\n    function AnimatedCurvedLineShape(options) {\n        var _this = _super.call(this, options) || this;\n        /**\n         * This defines the suggested easing for the animation for any of\n         * the values.\n         */\n        _this.easing = easing_1.linear;\n        _this._startColorChange = new three_1.Color(0, 0, 0);\n        _this._endColorChange = new three_1.Color(0, 0, 0);\n        /** The starting end point's destination */\n        _this.startStop = { x: 0, y: 0 };\n        _this.endStop = { x: 0, y: 0 };\n        /**\n         * This calculates the current start color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentStartColor = new three_1.Color(0, 0, 0);\n        /**\n         * This calculates the current end color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentEndColor = new three_1.Color(0, 0, 0);\n        if (options) {\n            _this.startStop = options.startStop || { x: 0, y: 0 };\n            _this.endStop = options.endStop || { x: 0, y: 0 };\n            if (options.startColorStop) {\n                _this.startColorStop = options.startColorStop;\n            }\n            if (options.endColorStop) {\n                _this.endColorStop = options.endColorStop;\n            }\n        }\n        return _this;\n    }\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"startColorStop\", {\n        get: function () {\n            return this._startColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._startColorStop = value;\n            this._startColorChange.r = newBase.r - startBase.r;\n            this._startColorChange.g = newBase.g - startBase.g;\n            this._startColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"endColorStop\", {\n        get: function () {\n            return this._endColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._endColorStop = value;\n            this._endColorChange.r = newBase.r - startBase.r;\n            this._endColorChange.g = newBase.g - startBase.g;\n            this._endColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStartColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var startBase = this.startColor.base.color;\n            this._currentStartColor.r = this.easing(time, startBase.r, this._startColorChange.r, this.duration);\n            this._currentStartColor.g = this.easing(time, startBase.g, this._startColorChange.g, this.duration);\n            this._currentStartColor.b = this.easing(time, startBase.b, this._startColorChange.b, this.duration);\n            return this._currentStartColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEndColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var endBase = this.endColor.base.color;\n            this._currentEndColor.r = this.easing(time, endBase.r, this._endColorChange.r, this.duration);\n            this._currentEndColor.g = this.easing(time, endBase.g, this._endColorChange.g, this.duration);\n            this._currentEndColor.b = this.easing(time, endBase.b, this._endColorChange.b, this.duration);\n            return this._currentEndColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStart\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            var newStart = interpolation_1.circular(easedTime, this.start, this.startStop, this.controlPoints[1]);\n            return newStart;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEnd\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            // Apply the circular interpolation to the points\n            return interpolation_1.circular(easedTime, this.end, this.endStop, this.controlPoints[1]);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AnimatedCurvedLineShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.AnimatedCurvedLineShape = AnimatedCurvedLineShape;\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar circle_1 = __webpack_require__(22);\n/**\n * Defines a circular shape that can be drawn\n */\nvar CircleShape = /** @class */ (function (_super) {\n    __extends(CircleShape, _super);\n    /**\n     * Sets the properties of the shape to be drawn\n     *\n     * @param {ICircleShapeOptions} options The options for the shape\n     */\n    function CircleShape(options) {\n        var _this = _super.call(this, options) || this;\n        _this.depth = options.depth || 0;\n        _this.innerColor = options.innerColor;\n        _this.innerRadius = options.innerRadius;\n        _this.outerColor = options.outerColor;\n        return _this;\n    }\n    /**\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this circleshape\n     */\n    CircleShape.prototype.clone = function (newProperties) {\n        var instance = new CircleShape(this);\n        instance.d = this.d;\n        return instance;\n    };\n    return CircleShape;\n}(circle_1.Circle));\nexports.CircleShape = CircleShape;\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = __webpack_require__(7);\nvar line_shape_1 = __webpack_require__(23);\n/**\n * This defines an edge that can be drawn.\n * This type of edge is a quad with distorted ends. The quad will represent a\n * line with each end having potentially different sizes thus giving a four sided\n * polygon rather than a parallelogram.\n *\n * The edge shape also doubles up as a simple line shape should it be desired to\n * render differently.\n */\nvar EdgeShape = /** @class */ (function (_super) {\n    __extends(EdgeShape, _super);\n    /**\n     * Constructor with basic parameters to declare an edge\n     *\n     * @param p1 The point the edge begins at\n     * @param p2 The point the edge terminates at\n     * @param d The data associated with the edge\n     * @param p1Col The color at the start point\n     * @param p2Col The color at the end point\n     * @param p1Width The width at the start point. Example: if you specify 4, then\n     *                the start part of the edge will fan out 2 on either side of the\n     *                start point\n     * @param p2Width The width at the end point. Example: if you specify 4, then\n     *                the end part of the edge will fan out 2 on either side of the\n     *                end point\n     */\n    function EdgeShape(options) {\n        var _this = \n        // Set up all of our line shape based metrics\n        _super.call(this, Object.assign(options, {\n            thickness: options.startWidth,\n        })) || this;\n        /** Top left of the quad to generate this edge */\n        _this.tl = { x: 0, y: 0 };\n        /** Bottom left of the quad to generate this edge */\n        _this.bl = { x: 0, y: 0 };\n        /** Top right of the quad to generate this edge */\n        _this.tr = { x: 0, y: 0 };\n        /** Bottom Right of the quad to generate this edge */\n        _this.br = { x: 0, y: 0 };\n        /** The width of the edge at the termination point */\n        _this.endWidth = 1;\n        _this.endWidth = options.endWidth || 1.0;\n        _this.setPoints(options.p1, options.p2);\n        return _this;\n    }\n    /**\n     * Clones this instance of the edge shape and creates a new instance of an edge shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {EdgeShape} A newly cloned instance of this edgeshape\n     */\n    EdgeShape.prototype.clone = function (newProperties) {\n        return Object.assign(new EdgeShape(Object.assign(this, {\n            startWidth: this.thickness,\n        })), newProperties);\n    };\n    /**\n     * Algorithm provided by\n     * https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n     * Adapted to Javascript by Chris @ VoidRay co\n     *\n     * Remember the point must be in the same\n     * coordinate system that the edge is using\n     *\n     * @param {number} point The point to test\n     *\n     * @return {boolean} True if the point is inside the edge\n     */\n    EdgeShape.prototype.pointInside = function (point) {\n        var testx = point.x;\n        var testy = point.y;\n        // This is an algortihm to handle any number of points for a polygon. In this\n        // Case our polygon is simply the points that make this fat edge. Note:\n        // The points MUST be in CW order\n        var points = [this.tl, this.tr, this.br, this.bl];\n        var numberVertices = points.length;\n        var isClockwise = false;\n        for (var i = 0, j = numberVertices - 1; i < numberVertices; j = i++) {\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\n                    (points[j].y - points[i].y) + points[i].x)) {\n                isClockwise = !isClockwise;\n            }\n        }\n        return isClockwise;\n    };\n    /**\n     * @override\n     * This sets the two endpoints for this edge and recalculates the bounds\n     * of the edge accordingly.\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    EdgeShape.prototype.setPoints = function (p1, p2) {\n        _super.prototype.setPoints.call(this, p1, p2);\n        if (this.tl) {\n            // Get the distance from the points we will go based on specified widths\n            var p1Dx = this.thickness / 2;\n            var p2Dx = this.endWidth / 2;\n            // Calculate the deltas to get from point to quad edge\n            var p1DeltaX = this.perpendicular.x * p1Dx;\n            var p1DeltaY = this.perpendicular.y * p1Dx;\n            var p2DeltaX = this.perpendicular.x * p2Dx;\n            var p2DeltaY = this.perpendicular.y * p2Dx;\n            // Apply the metrics to our quad points\n            // Start side of the edge\n            this.tl.x = this.p1.x + p1DeltaX;\n            this.tl.y = this.p1.y + p1DeltaY;\n            this.bl.x = this.p1.x - p1DeltaX;\n            this.bl.y = this.p1.y - p1DeltaY;\n            // End side of the edge\n            this.tr.x = this.p2.x + p2DeltaX;\n            this.tr.y = this.p2.y + p2DeltaY;\n            this.br.x = this.p2.x - p2DeltaX;\n            this.br.y = this.p2.y - p2DeltaY;\n            // Create lines for the edges for computations and faster hit detections\n            this.topEdge = new line_1.Line(this.tl, this.tr);\n            this.bottomEdge = new line_1.Line(this.bl, this.br);\n            // Make sure our bounds reflects the entirety of the fat edge\n            this.encapsulatePoints([this.tl, this.tr, this.bl, this.br]);\n        }\n    };\n    return EdgeShape;\n}(line_shape_1.LineShape));\nexports.EdgeShape = EdgeShape;\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(1);\n/**\n * Defines an image that can be rendered by the gpu. This is an axis oriented\n * image only (no rotations)\n */\nvar ImageShape = /** @class */ (function (_super) {\n    __extends(ImageShape, _super);\n    /**\n     * Generates a new ImageShape that can be rendered\n     *\n     * @param {AtlasTexture} image The AtlasTexture to use when rendering this image\n     * @param {number} size This is the size of the longest edge of the image while\n     *                      retaining aspect ratio.\n     */\n    function ImageShape(image, size) {\n        var _this = _super.call(this, 0, 0, size, size) || this;\n        /** This is the level of opacity the image will be rendered with */\n        _this.opacity = 1.0;\n        _this.texture = image;\n        _this.size = size;\n        return _this;\n    }\n    Object.defineProperty(ImageShape.prototype, \"size\", {\n        /**\n         * Returns the largest edge of the image\n         */\n        get: function () {\n            return Math.max(this.width, this.height);\n        },\n        /**\n         * This is the size the image will be rendered within World Space. The size\n         * correlates to the largest edge of the image\n         */\n        set: function (val) {\n            if (this.texture.aspectRatio > 1) {\n                this.width = val;\n                this.height = val / this.texture.aspectRatio;\n            }\n            else {\n                this.width = val * this.texture.aspectRatio;\n                this.height = val;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Centers this image on a provided location\n     *\n     * @param {number} x The x coordinate in world space\n     * @param {number} y The y coordinate in world space\n     */\n    ImageShape.prototype.centerOn = function (x, y) {\n        this.x = x - (this.width / 2.0);\n        this.y = y - (this.height / 2.0);\n    };\n    return ImageShape;\n}(bounds_1.Bounds));\nexports.ImageShape = ImageShape;\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = __webpack_require__(1);\nvar QuadShape = /** @class */ (function (_super) {\n    __extends(QuadShape, _super);\n    function QuadShape(bounds, color) {\n        var _this = _super.call(this, bounds.x, bounds.right, bounds.y, bounds.bottom) || this;\n        _this.r = 1.0;\n        _this.g = 0.0;\n        _this.b = 0.0;\n        _this.a = 1.0;\n        return _this;\n    }\n    return QuadShape;\n}(bounds_1.Bounds));\nexports.QuadShape = QuadShape;\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(0);\n/**\n * Defines a color that is located on an atlas\n */\nvar AtlasColor = /** @class */ (function () {\n    /**\n     * Constructor implementation\n     */\n    function AtlasColor(color, g, b, a) {\n        if (a === void 0) { a = 1.0; }\n        // Value between 1 - 0 for the opacity of the color\n        this.opacity = 1.0;\n        // The pixel width and height of the color rendered onto the atlas\n        // This will always be a 2x2 so the color can be sampled in the middle\n        // For a guaranteed pure color regardless of gl sampling states\n        this.pixelWidth = 2;\n        this.pixelHeight = 2;\n        if (color instanceof three_1.Color) {\n            this.color = color.clone();\n            this.opacity = g === undefined ? 1.0 : g;\n        }\n        else {\n            this.color = new three_1.Color(color, g, b);\n            this.opacity = a;\n        }\n    }\n    return AtlasColor;\n}());\nexports.AtlasColor = AtlasColor;\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(1));\n__export(__webpack_require__(22));\n__export(__webpack_require__(21));\n__export(__webpack_require__(7));\n__export(__webpack_require__(6));\n__export(__webpack_require__(16));\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(54));\n__export(__webpack_require__(55));\n__export(__webpack_require__(2));\n__export(__webpack_require__(56));\n__export(__webpack_require__(11));\n__export(__webpack_require__(9));\n__export(__webpack_require__(57));\n__export(__webpack_require__(12));\n__export(__webpack_require__(18));\n__export(__webpack_require__(24));\n__export(__webpack_require__(14));\n__export(__webpack_require__(19));\n__export(__webpack_require__(25));\n__export(__webpack_require__(10));\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"PLAY\"] = 0] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 1] = \"STOP\";\n})(PlayState || (PlayState = {}));\nvar Animate = /** @class */ (function () {\n    function Animate() {\n    }\n    Animate.animate = function () {\n        if (Animate.playState === PlayState.PLAY) {\n            requestAnimationFrame(Animate.animate);\n        }\n        this.animating.forEach(function (propToItem) {\n            propToItem.forEach(function (animate) {\n                // TODO\n            });\n        });\n    };\n    Animate.cancel = function (container, prop) {\n        // TODO\n    };\n    Animate.value = function (container, prop, start, end, duration, ease) {\n        // TODO\n    };\n    Animate.point = function (container) {\n        // TODO\n    };\n    Animate.start = function () {\n        // TODO\n    };\n    Animate.stop = function () {\n        // TODO\n    };\n    Animate.playState = PlayState.PLAY;\n    Animate.animating = new Map();\n    return Animate;\n}());\nexports.Animate = Animate;\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar multi_shape_buffer_cache_1 = __webpack_require__(24);\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"INIT\"] = 0] = \"INIT\";\n    PlayState[PlayState[\"PLAY\"] = 1] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 2] = \"STOP\";\n})(PlayState = exports.PlayState || (exports.PlayState = {}));\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar AnimatedShapeBufferCache = /** @class */ (function (_super) {\n    __extends(AnimatedShapeBufferCache, _super);\n    function AnimatedShapeBufferCache() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.playState = PlayState.INIT;\n        _this.buffer = [];\n        _this.bustCache = true;\n        /**\n         * This is the internal control for managing execution of the animate method\n         */\n        _this.doAnimate = function () {\n            if (_this.playState === PlayState.PLAY) {\n                requestAnimationFrame(_this.doAnimate);\n            }\n            _this.animate();\n        };\n        return _this;\n    }\n    /**\n     * This is the method that will execute with the frame rate. Subclasses can\n     * override this to implement animated changes\n     */\n    AnimatedShapeBufferCache.prototype.animate = function () {\n        // Implemented by subclasses\n    };\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    AnimatedShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        if (this.bustCache) {\n            this.buildCache.apply(this, arguments);\n            this.bustCache = false;\n            if (this.playState === PlayState.INIT) {\n                this.start();\n                requestAnimationFrame(this.doAnimate);\n            }\n        }\n        // We always invalidate and commit all of our buffers for animations\n        this.flagBuffersDirty();\n        // Make sure our buffers are updated so they will commit to vertex buffers\n        this.processDirtyBuffers();\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    AnimatedShapeBufferCache.prototype.buildCache = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Begins executing the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.start = function () {\n        this.playState = PlayState.PLAY;\n    };\n    /**\n     * Ceases the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.stop = function () {\n        this.playState = PlayState.STOP;\n    };\n    return AnimatedShapeBufferCache;\n}(multi_shape_buffer_cache_1.MultiShapeBufferCache));\nexports.AnimatedShapeBufferCache = AnimatedShapeBufferCache;\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Takes a map of the form <T, boolean> and returns an array of the keys,\n * excluding entries who's mapped value is false.\n *\n * @param map The map to convert to a list\n *\n * @return T[] A list of the keys, exluding false mappings\n */\nfunction boolMapToArray(map) {\n    return Array\n        .from(map)\n        .filter(function (item) { return item[1]; })\n        .map(function (item) { return item[0]; });\n}\nexports.boolMapToArray = boolMapToArray;\n/**\n * Defines a selection control for custom types and categories\n */\nvar CustomSelection = /** @class */ (function () {\n    function CustomSelection() {\n        /** This caches the list generation of a selection */\n        this.cachedSelection = new Map();\n        /** Map of the custom categories to the selection state */\n        this.selections = new Map();\n        /** Keeps flags indicating if a selection for a given category has changed or not */\n        this._didSelectionChange = new Map();\n    }\n    /**\n     * Clears out all custom selections for every category\n     */\n    CustomSelection.prototype.clearAllSelections = function () {\n        for (var _i = 0, _a = Array.from(this.selections.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this.clearSelection(key);\n        }\n    };\n    /**\n     * Clears the selection for the category specified\n     *\n     * @param {string} category Name of the category of selection\n     */\n    CustomSelection.prototype.clearSelection = function (category) {\n        // We must have selected items to clear the selection\n        if (this.getSelection(category).length) {\n            this.selections.set(category, null);\n            this.cachedSelection.set(category, null);\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Makes an item no longer flaged as selected within the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to remove from being selected\n     */\n    CustomSelection.prototype.deselect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        // See if the item is selected already, if it is, clear the selection and bust caches\n        if (selectionMap && selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, false);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Checks if a selection from a category has been modified\n     *\n     * @param {string} category The selection category to check\n     */\n    CustomSelection.prototype.didSelectionCategoryChange = function (category) {\n        return this._didSelectionChange.get(category);\n    };\n    /**\n     * Checks if ANY selection has changed\n     *\n     * @return {boolean} True if any selection has changed\n     */\n    CustomSelection.prototype.didSelectionChange = function () {\n        return boolMapToArray(this._didSelectionChange).length > 0;\n    };\n    /**\n     * This indicates that updates have taken place to account for selection\n     * changes.\n     */\n    CustomSelection.prototype.finalizeUpdate = function () {\n        for (var _i = 0, _a = Array.from(this._didSelectionChange.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this._didSelectionChange.set(key, false);\n        }\n    };\n    /**\n     * This retrieves a list of the items that are selected\n     *\n     * @param category The selection category to check on\n     *\n     * @return {T} Returns a list of items that are currently selected\n     */\n    CustomSelection.prototype.getSelection = function (category) {\n        if (!this.cachedSelection.get(category)) {\n            var theSelection = this.selections.get(category);\n            if (theSelection) {\n                this.cachedSelection.set(category, boolMapToArray(theSelection));\n            }\n            else {\n                this.cachedSelection.set(category, []);\n            }\n        }\n        return this.cachedSelection.get(category);\n    };\n    /**\n     * Specifies an item to flag as selected for the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.select = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        if (!selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, true);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Specifies an item to toggle it's selection status for the provided category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.toggleSelect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        // Clear the cache for the selection list\n        this.cachedSelection.set(category, null);\n        // Toggle the selection off if already selected\n        if (selectionMap.get(item)) {\n            this.deselect(category, item);\n        }\n        else {\n            this.select(category, item);\n        }\n        // Flag the category of selections as changed\n        this._didSelectionChange.set(category, true);\n    };\n    return CustomSelection;\n}());\nexports.CustomSelection = CustomSelection;\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getFontMetrics(props) {\n    var ctx = props.ctx;\n    var text = props.text;\n    var bboxHeight = props.bboxHeight;\n    var canvasHeight = props.ctx.canvas.height;\n    var baseline = props.baseline || 'alphabetic';\n    var flip = props.flip || false;\n    var drawBaseline = props.drawBaseline || false;\n    var fontFamily = 'Arial, san-serif';\n    var fontSize = 14;\n    if (props.fontFamily) {\n        fontFamily = props.fontFamily;\n    }\n    if (props.fontSize) {\n        fontSize = props.fontSize;\n    }\n    // Setting up the canvas\n    ctx.save(); // Create canvas to use as buffer\n    ctx.font = fontSize + \"px \" + fontFamily;\n    var textWidth = ctx.measureText(text).width;\n    // This keeps font in-screen, measureText().width doesn't\n    // Quite do it in some cases. For instance \"j\", or the letter \"f\"\n    // In the font \"Zapfino\".\n    var offsetx = fontSize * 2;\n    var offsety = fontSize * 2;\n    var cwidth = ctx.canvas.width = Math.round(textWidth + offsetx * 2);\n    var cheight = ctx.canvas.height = canvasHeight ? canvasHeight : Math.round(offsety * 2);\n    if (typeof (baseline) === 'string') {\n        offsety = 0; // Using <canvas> baseline\n        ctx.textBaseline = baseline;\n    }\n    // Ctx.font has to be called twice because resetting the size resets the state\n    if (flip) {\n        ctx.scale(1, -1);\n    }\n    ctx.font = fontSize + \"px \" + fontFamily;\n    ctx.fillText(text, offsetx, (typeof (bboxHeight) === 'number' ? bboxHeight : offsety));\n    // Drawing baseline\n    if (drawBaseline) {\n        ctx.fillRect(0, canvasHeight / 2, ctx.canvas.width, 1);\n    }\n    // Grabbing image data\n    var imageData = ctx.getImageData(0, 0, cwidth, cheight);\n    var data = imageData.data;\n    // Calculating top\n    var top = 0;\n    var pos = data.length;\n    var bottom = 0;\n    var realBottom = 0;\n    var left = 0;\n    var right = 0;\n    while (pos > 0) {\n        if (data[pos + 3]) {\n            pos -= pos % (cwidth * 4); // Back to beginning of the line top = (pos / 4) / cwidth; // calculate pixel position top -= offsety - fontSize; pos = data.length; // exit loop } pos += 4; } // calculating bottom var bottom = 0; var pos = data.length; while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                bottom = (pos / 4) / cwidth;\n                bottom -= offsety - fontSize;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Calculating left\n        left = 0;\n        var col = 0;\n        var row = 0; // Left bounds\n        while (row < cheight && col < cwidth) {\n            var px = data[(row * cwidth * 4) + (col * 4) + 3];\n            if (px) {\n                left = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col++;\n            }\n        }\n        // Calculating right\n        right = 0;\n        col = cwidth;\n        row = 0; // Right bounds\n        while (row < cheight && col > 0) {\n            if (data[(row * cwidth * 4) + (col * 4) + 3]) {\n                right = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col--;\n            }\n        }\n        // Calculating real-bottom\n        realBottom = 0;\n        pos = data.length;\n        while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                realBottom = (pos / 4) / cwidth;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Restoring state\n        ctx.restore();\n    }\n    // Returning raw-metrics\n    return {\n        bottom: realBottom,\n        height: (bottom - top),\n        left: (-left),\n        top: (fontSize - top),\n        width: (right - left),\n    };\n}\nexports.getFontMetrics = getFontMetrics;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 26);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d7c0f2534c177f961f29","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"three\"\n// module id = 0\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nvar Bounds = /** @class */ (function () {\n    /**\n     * Create a new instance\n     *\n     * @param left  The left side (x coordinate) of the instance\n     * @param right The right side of the instance\n     * @param top The top (y coordinate) of the instance\n     * @param bottom The bottom of the instance\n     */\n    function Bounds(left, right, top, bottom) {\n        this.height = 0;\n        this.width = 0;\n        this.x = 0;\n        this.y = 0;\n        if (arguments.length === 4) {\n            this.x = left;\n            this.width = right - left;\n            this.y = top;\n            this.height = top - bottom;\n        }\n    }\n    Object.defineProperty(Bounds.prototype, \"area\", {\n        /** The total rectangular surface area of this instance */\n        get: function () {\n            return this.width * this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"bottom\", {\n        /** The bottom coordinate for this instance (y + height) */\n        get: function () {\n            return this.y - this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"mid\", {\n        /** An x, y coordinate pair representing the center of this object */\n        get: function () {\n            return {\n                x: this.x + (this.width / 2),\n                y: this.y - (this.height / 2),\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Bounds.prototype, \"right\", {\n        get: function () {\n            return this.x + this.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Check to see if a given point lies within the bounds of this instance\n     *\n     * @param point The point to check\n     */\n    Bounds.prototype.containsPoint = function (point) {\n        if (point.x < this.x) {\n            return false;\n        }\n        if (point.y > this.y) {\n            return false;\n        }\n        if (point.x > this.right) {\n            return false;\n        }\n        if (point.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Copies the properties of the bounds specified\n     *\n     * @param b The bounds whose dimensions we wish to copy\n     */\n    Bounds.prototype.copyBounds = function (b) {\n        this.height = b.height;\n        this.width = b.width;\n        this.x = b.x;\n        this.y = b.y;\n    };\n    /**\n     * Ensure that this object contains the smaller bounds\n     *\n     * This method will not shrink this class, but only grow it as necessary to\n     * fit the destination object\n     *\n     * @param bounds The bounds to encapsulate\n     */\n    Bounds.prototype.encapsulate = function (bounds) {\n        if (bounds.x < this.x) {\n            this.width += this.x - bounds.x;\n            this.x = bounds.x;\n        }\n        if (bounds.y > this.y) {\n            this.height += bounds.y - this.y;\n            this.y = bounds.y;\n        }\n        if (bounds.right > this.right) {\n            this.width = bounds.right - this.x;\n        }\n        if (bounds.bottom < this.bottom) {\n            this.height = this.y - bounds.bottom;\n        }\n    };\n    /**\n     * Ensure that this object contains the provided list of bounds\n     *\n     * This will never shrink or modify the original area covered by this bounds\n     * but will instead stay the same or include the original area plus the specified\n     * list of bounds.\n     *\n     * @param {Bounds<any>[]} bounds The list of bounds objects to encapsulate\n     * @param {boolean} sizeToFirst If this is set, the procedure will start by making this bounds\n     *                              be a clone of the first bounds object in the list\n     */\n    Bounds.prototype.encapsulateBounds = function (bounds, sizeToFirst) {\n        if (sizeToFirst && bounds.length) {\n            this.copyBounds(bounds[0]);\n        }\n        if (bounds.length === 0) {\n            return;\n        }\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        bounds.forEach(function (p) {\n            if (p.x < minX) {\n                minX = p.x;\n            }\n            if (p.right > maxX) {\n                maxX = p.right;\n            }\n            if (p.bottom < minY) {\n                minY = p.bottom;\n            }\n            if (p.y > maxY) {\n                maxY = p.y;\n            }\n        });\n        // Make bounds that encompasses the bounds list, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Grow this class to contain the specified point\n     *\n     * This method will not shrink this instance. It will only grow it as\n     * necessary.\n     *\n     * @param point The point to encapsulate\n     */\n    Bounds.prototype.encapsulatePoint = function (point) {\n        if (point.x < this.x) {\n            this.width += this.x - point.x;\n            this.x = point.x;\n        }\n        if (point.y > this.y) {\n            this.height += point.y - this.y;\n            this.y = point.y;\n        }\n        if (point.x > this.right) {\n            this.width = point.x - this.x;\n        }\n        if (point.y < this.bottom) {\n            this.height = this.y - point.y;\n        }\n    };\n    /**\n     * Efficiently encapsulates a set of points by growing the current dimensions\n     * of the bounds until the points are enclosed. This will perform faster than\n     * running encapsulatePoint for a list of points.\n     *\n     * @param points An array of points that Can be of format {x, y} or [x, y]\n     *\n     * @memberOf Bounds\n     */\n    Bounds.prototype.encapsulatePoints = function (points) {\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        if (points[0] !== undefined && points[0].x) {\n            points.forEach(function (p) {\n                if (p.x < minX) {\n                    minX = p.x;\n                }\n                else if (p.x > maxX) {\n                    maxX = p.x;\n                }\n                if (p.y < minY) {\n                    minY = p.y;\n                }\n                else if (p.y > maxY) {\n                    maxY = p.y;\n                }\n            });\n        }\n        else {\n            points.forEach(function (p) {\n                if (p[0] < minX) {\n                    minX = p[0];\n                }\n                else if (p[0] > maxX) {\n                    maxX = p[0];\n                }\n                if (p[1] < minY) {\n                    minY = p[1];\n                }\n                else if (p[1] > maxY) {\n                    maxY = p[1];\n                }\n            });\n        }\n        // Make bounds that encompasses the points, then we encapsulate\n        // Those bounds\n        this.encapsulate(new Bounds(minX, maxX, maxY, minY));\n    };\n    /**\n     * Checks to see if another bounds fits in itself.\n     *\n     * @param {Bounds} inner The bounds to test against\n     *\n     * @return {number} int 1 is an exact fit, 2 it fits with space, 0 it doesn't fit\n     */\n    Bounds.prototype.fits = function (inner) {\n        if (this.width === inner.width) {\n            if (this.height === inner.height) {\n                return 1;\n            }\n        }\n        if (this.width >= inner.width) {\n            if (this.height >= inner.height) {\n                return 2;\n            }\n        }\n        return 0;\n    };\n    /**\n     * Check to see if the provided bounds intersects with this instance\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if the other object intersects with this instance\n     */\n    Bounds.prototype.hitBounds = function (bounds) {\n        if (bounds.right < this.x) {\n            return false;\n        }\n        if (bounds.x > this.right) {\n            return false;\n        }\n        if (bounds.bottom > this.y) {\n            return false;\n        }\n        if (bounds.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Tests if a point is inside this bounds\n     *\n     * @param p The point to test\n     *\n     * @return boolean The point to test\n     */\n    Bounds.prototype.pointInside = function (p) {\n        if (p.x < this.x) {\n            return false;\n        }\n        if (p.y > this.y) {\n            return false;\n        }\n        if (p.x > this.right) {\n            return false;\n        }\n        if (p.y < this.bottom) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Test function to type check the provided value\n     *\n     * @return True if value is a bounds object\n     */\n    Bounds.isBounds = function (value) {\n        // Falsy values aren't bounds objects\n        if (!value) {\n            return false;\n        }\n        // Direct test for bounds objects\n        if (value instanceof this) {\n            return true;\n        }\n        // Duck-typing check\n        return value &&\n            'containsPoint' in value &&\n            'encapsulate' in value &&\n            'hitTest' in value;\n    };\n    /**\n     * Check if this instance is completely inside the provided bounds\n     *\n     * @param bounds The bounds to test against this instance\n     *\n     * @return True if this instance is inside the provided bounds\n     */\n    Bounds.prototype.isInside = function (bounds) {\n        return (bounds.x <= this.x &&\n            bounds.right >= this.right &&\n            bounds.y >= this.y &&\n            bounds.bottom <= this.bottom);\n    };\n    /**\n     * Generates a Bounds object covering max extents\n     *\n     * @return {Bounds} bounds covering as wide of a range as possible\n     */\n    Bounds.maxBounds = function () {\n        return new Bounds(Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE);\n    };\n    return Bounds;\n}());\nexports.Bounds = Bounds;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/bounds.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\n/**\n * This class and set of methods is provided to attempt to create as efficient as possible\n * methods for updating large vertex buffers with values. The first portion of the file is\n * a list of methods and registers. This is to prevent any instantiation needed for the methods\n * and registers to exist. Also, the methods have no useable parent scope to ensure nothing like\n * a 'this' is used. These methods utilize the registers and their own simple loops to pound\n * through large amounts of information while providing capabilities to edit vertices in batches.\n *\n * You will also notice there are many many similar methods with just a single extra parameter\n * here and there. This is to prevent ANY calculations on trying to determine a proper parameter set\n * while also making method calls directly without any .call or .apply.\n *\n * The number of update methods is how many differing attributes are supported. If you need more supported\n * attributes add an updateBufferN method and provide the required attributes. Insert the logic in the EXACT\n * pattern seen in the other methods. DO NOT attempt to add additional logic lest the performance be something\n * terrible.\n *\n * The BufferUtil class makes use of these methods and registers. It also provides some very handy methods\n * for working with your large buffers.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar webgl_stat_1 = require(\"./webgl-stat\");\nvar debugGenerator = require('debug');\nvar debug = require('debug')('WebGLSurface:BufferUtil');\nvar TriangleOrientation;\n(function (TriangleOrientation) {\n    // The triangles points are clockwise\n    TriangleOrientation[TriangleOrientation[\"CW\"] = 0] = \"CW\";\n    // The triangles points are Counter clockwise\n    TriangleOrientation[TriangleOrientation[\"CCW\"] = 1] = \"CCW\";\n    // The triangles points are linear, thus degenerate\n    TriangleOrientation[TriangleOrientation[\"DEGENERATE\"] = 2] = \"DEGENERATE\";\n})(TriangleOrientation = exports.TriangleOrientation || (exports.TriangleOrientation = {}));\nvar AttributeSize;\n(function (AttributeSize) {\n    AttributeSize[AttributeSize[\"ONE\"] = 0] = \"ONE\";\n    AttributeSize[AttributeSize[\"TWO\"] = 1] = \"TWO\";\n    AttributeSize[AttributeSize[\"THREE\"] = 2] = \"THREE\";\n    AttributeSize[AttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(AttributeSize = exports.AttributeSize || (exports.AttributeSize = {}));\nvar UniformAttributeSize;\n(function (UniformAttributeSize) {\n    UniformAttributeSize[UniformAttributeSize[\"ONE\"] = 0] = \"ONE\";\n    UniformAttributeSize[UniformAttributeSize[\"TWO\"] = 1] = \"TWO\";\n    UniformAttributeSize[UniformAttributeSize[\"THREE\"] = 2] = \"THREE\";\n    UniformAttributeSize[UniformAttributeSize[\"FOUR\"] = 3] = \"FOUR\";\n})(UniformAttributeSize = exports.UniformAttributeSize || (exports.UniformAttributeSize = {}));\n/**\n * These are for fast look ups of the default values provided\n * Doing this fashion avoids array look ups in the defaults values\n */\nvar defaultsHolder0 = 0;\nvar defaultsHolder1 = 0;\nvar defaultsHolder2 = 0;\nvar defaultsHolder3 = 0;\n/**\n * These are for fast look ups of attribute buffers that are going\n * through the update process. We do everything to mitigate array look ups\n * when and where we can\n */\nvar attrRegister0 = [];\nvar attrRegister1 = [];\nvar attrRegister2 = [];\nvar attrRegister3 = [];\nvar attrRegister4 = [];\nvar attrRegister5 = [];\nvar attrRegister6 = [];\nvar attrRegister7 = [];\nvar attrRegister8 = [];\nvar attrRegister9 = [];\nvar attrRegister10 = [];\nvar attrIndex0 = 0;\nvar attrIndex1 = 0;\nvar attrIndex2 = 0;\nvar attrIndex3 = 0;\nvar attrIndex4 = 0;\nvar attrIndex5 = 0;\nvar attrIndex6 = 0;\nvar attrIndex7 = 0;\nvar attrIndex8 = 0;\nvar attrIndex9 = 0;\nvar attrIndex10 = 0;\nvar attrIndexIncr0 = 0;\nvar attrIndexIncr1 = 0;\nvar attrIndexIncr2 = 0;\nvar attrIndexIncr3 = 0;\nvar attrIndexIncr4 = 0;\nvar attrIndexIncr5 = 0;\nvar attrIndexIncr6 = 0;\nvar attrIndexIncr7 = 0;\nvar attrIndexIncr8 = 0;\nvar attrIndexIncr9 = 0;\nvar attrIndexIncr10 = 0;\n/** This is used to define a starting batch location to aid in continuing batch updates */\nvar lastBatchRegister = 0;\nvar isStreamUpdatingRegister = false;\n/**\n * This takes our list of attribute buffers and applies them to the registers for rapid lookups\n *\n * @param {number[][]} attributeBuffers The buffers for each attribute to be updated\n * @param {number[]} incrementValues How much each batch increments it's lookup index\n */\nfunction applyAttributeRegisters(attributeBuffers, incrementValues) {\n    attrRegister0 = attributeBuffers[0];\n    attrRegister1 = attributeBuffers[1];\n    attrRegister2 = attributeBuffers[2];\n    attrRegister3 = attributeBuffers[3];\n    attrRegister4 = attributeBuffers[4];\n    attrRegister5 = attributeBuffers[5];\n    attrRegister6 = attributeBuffers[6];\n    attrRegister7 = attributeBuffers[7];\n    attrRegister8 = attributeBuffers[8];\n    attrRegister9 = attributeBuffers[9];\n    attrRegister10 = attributeBuffers[10];\n    attrIndexIncr0 = incrementValues[0];\n    attrIndexIncr1 = incrementValues[1];\n    attrIndexIncr2 = incrementValues[2];\n    attrIndexIncr3 = incrementValues[3];\n    attrIndexIncr4 = incrementValues[4];\n    attrIndexIncr5 = incrementValues[5];\n    attrIndexIncr6 = incrementValues[6];\n    attrIndexIncr7 = incrementValues[7];\n    attrIndexIncr8 = incrementValues[8];\n    attrIndexIncr9 = incrementValues[9];\n    attrIndexIncr10 = incrementValues[10];\n}\n/**\n * The following methods are targetted at executing the update accessor with varying number\n * of parameters while mitigating array look ups.\n *\n * @param {number} numBatches The number of batches to execute\n * @param {Function} updateAccessor The accessor function that will update the buffer values\n */\nfunction updateBuffer1(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0);\n    }\n}\nfunction updateBuffer2(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1);\n    }\n}\nfunction updateBuffer3(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2);\n    }\n}\nfunction updateBuffer4(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3);\n    }\n}\nfunction updateBuffer5(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4);\n    }\n}\nfunction updateBuffer6(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5);\n    }\n}\nfunction updateBuffer7(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6);\n    }\n}\nfunction updateBuffer8(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7);\n    }\n}\nfunction updateBuffer9(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8);\n    }\n}\nfunction updateBuffer10(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9);\n    }\n}\nfunction updateBuffer11(numBatches, updateAccessor) {\n    for (var i = lastBatchRegister; i < numBatches; ++i) {\n        attrIndex0 = i * attrIndexIncr0;\n        attrIndex1 = i * attrIndexIncr1;\n        attrIndex2 = i * attrIndexIncr2;\n        attrIndex3 = i * attrIndexIncr3;\n        attrIndex4 = i * attrIndexIncr4;\n        attrIndex5 = i * attrIndexIncr5;\n        attrIndex6 = i * attrIndexIncr6;\n        attrIndex7 = i * attrIndexIncr7;\n        attrIndex8 = i * attrIndexIncr8;\n        attrIndex9 = i * attrIndexIncr9;\n        attrIndex10 = i * attrIndexIncr10;\n        updateAccessor(i - lastBatchRegister, attrRegister0, attrIndex0, attrRegister1, attrIndex1, attrRegister2, attrIndex2, attrRegister3, attrIndex3, attrRegister4, attrIndex4, attrRegister5, attrIndex5, attrRegister6, attrIndex6, attrRegister7, attrIndex7, attrRegister8, attrIndex8, attrRegister9, attrIndex9, attrRegister10, attrIndex10);\n    }\n}\n/**\n * This takes the defaults array provided and loads them into our default\n * lookup values\n *\n * @param {number[]} defaults The array with the default values in them for our buffer attribute\n */\nfunction applyDefaultsHolders(defaults) {\n    defaultsHolder0 = defaults[0] || 0;\n    defaultsHolder1 = defaults[1] || 0;\n    defaultsHolder2 = defaults[2] || 0;\n    defaultsHolder3 = defaults[3] || 0;\n}\n/**\n * The following methods are rapid ways of populating the buffer without\n * setting up a generic loop. This saves on performance by not creating a loop\n * nor allocating the variables necessary for the generic loop.\n *\n * @param {Float32Array} buffer The buffer to populate\n * @param {number} start The index the data should be populated into\n */\nfunction fillSize1(buffer, start) {\n    buffer[start] = defaultsHolder0;\n}\nfunction fillSize2(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n}\nfunction fillSize3(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n}\nfunction fillSize4(buffer, start) {\n    buffer[start] = defaultsHolder0;\n    buffer[++start] = defaultsHolder1;\n    buffer[++start] = defaultsHolder2;\n    buffer[++start] = defaultsHolder3;\n}\nfunction isList(val) {\n    if (Array.isArray(val))\n        return true;\n    return false;\n}\n/**\n * This is a quick lookup to find the correct filler method for the given attribute size\n */\nvar fillMethodLookUp = (_a = {},\n    _a[AttributeSize.ONE] = fillSize1,\n    _a[AttributeSize.TWO] = fillSize2,\n    _a[AttributeSize.THREE] = fillSize3,\n    _a[AttributeSize.FOUR] = fillSize4,\n    _a);\nvar updateBufferLookUp = {\n    1: updateBuffer1,\n    2: updateBuffer2,\n    3: updateBuffer3,\n    4: updateBuffer4,\n    5: updateBuffer5,\n    6: updateBuffer6,\n    7: updateBuffer7,\n    8: updateBuffer8,\n    9: updateBuffer9,\n    10: updateBuffer10,\n    11: updateBuffer11,\n};\n/**\n * This provides methods for handling common buffer tasks such as construction\n * and population.\n */\nvar BufferUtil = /** @class */ (function () {\n    function BufferUtil() {\n    }\n    /**\n     * This places our updateBuffer into a mode where the updates start at index 0 of the\n     * buffer. Subsequent calls will start where the previous call left off. This lets\n     * you stream in updates to the buffer rather than just update the entire buffer\n     * all at once.\n     */\n    BufferUtil.beginUpdates = function () {\n        isStreamUpdatingRegister = true;\n        lastBatchRegister = 0;\n    };\n    /**\n     * This takes the buffer items and cleans up their use within memory as best as possible.\n     *\n     * @param bufferItems\n     */\n    BufferUtil.dispose = function (buffers) {\n        if (buffers) {\n            buffers.forEach(function (bufferItems) {\n                bufferItems.attributes = null;\n                bufferItems.currentData = null;\n                bufferItems.geometry.dispose();\n                bufferItems.geometry = null;\n                bufferItems.system = null;\n            });\n        }\n    };\n    /**\n     * This stops updates streaming into the buffers and makes it where an update\n     * will always just start at the beginning of the buffer.\n     */\n    BufferUtil.endUpdates = function () {\n        var totalBatches = lastBatchRegister;\n        isStreamUpdatingRegister = false;\n        lastBatchRegister = 0;\n        return totalBatches;\n    };\n    /**\n     * It is often needed to examine a given buffer and see how the triangles are packed in.\n     * This is a common debugging need and will speed up debugging significantly.\n     *\n     * @param {IBufferItems<T, U>} bufferItems This is the buffer whose structure we want\n     *                                         to examine.\n     * @param {string} message This is the message for the debug statement. There are two\n     *                         predefined %o. The first is the vertex information the second\n     *                         is the uniform info. Leave null for a default message.\n     * @param {string} debugNamespace The namespace for the debugging info.\n     */\n    BufferUtil.examineBuffer = function (bufferItems, message, debugNamespace) {\n        // Get the appropriate debug namespace\n        var debugBuffer = debugGenerator(debugNamespace);\n        // Quick quit if the debugger is not enabled\n        if (!debugBuffer.enabled) {\n            return;\n        }\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // Get the attributes by name out of the three js buffer\n        var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n        // Get the raw number buffers\n        var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n        // This will store all of the examined triangles for easy viewing\n        var triangles = [];\n        if (bufferItems.system.drawMode === three_1.TrianglesDrawMode) {\n            var currentVertex_1 = 0;\n            var attrSize_1 = 0;\n            var currentIndex_1 = 0;\n            var length_1 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_1 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_2 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_1 = attr.size + 1;\n                        currentIndex_1 = currentVertex_1 * attrSize_1;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_1, currentIndex_1 + attrSize_1);\n                    });\n                    // Move to the next vertex\n                    currentVertex_1++;\n                };\n                // Each new triangle is a culmination of three vertices which are packed in\n                // The buffer with no vertex sharing\n                for (var i = 0; i < 3; ++i) {\n                    _loop_2(i);\n                }\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_1 < length_1) {\n                _loop_1();\n            }\n        }\n        else if (bufferItems.system.drawMode === three_1.TriangleStripDrawMode) {\n            var currentVertex_2 = 0;\n            var attrSize_2 = 0;\n            var currentIndex_2 = 0;\n            var length_2 = buffer.drawRange.start + buffer.drawRange.count;\n            var _loop_3 = function () {\n                var tri = {\n                    vertex_0: {},\n                    vertex_1: {},\n                    vertex_2: {},\n                };\n                var _loop_4 = function (i) {\n                    attributes.forEach(function (attr, index) {\n                        attrSize_2 = attr.size + 1;\n                        currentIndex_2 = currentVertex_2 * attrSize_2;\n                        tri[\"vertex_\" + i][attr.name] = attributeBuffers[index].slice(currentIndex_2, currentIndex_2 + attrSize_2);\n                    });\n                    // Move to the next vertex\n                    currentVertex_2++;\n                };\n                // Each new triangle is three vertices, where the first two are shared with\n                // The previous triangle's last two vertices\n                for (var i = 0; i < 3; ++i) {\n                    _loop_4(i);\n                }\n                // Go back two vertices as the next tri will use them + the next vertex to\n                // Make the next triangle\n                currentVertex_2 -= 2;\n                // Store the calculated tri\n                triangles.push(tri);\n            };\n            while (currentVertex_2 < length_2) {\n                _loop_3();\n            }\n        }\n        // Log the debug info to the console using the debug utility\n        debugBuffer(message || 'vertices: %o uniforms: %o', {\n            drawRange: buffer.drawRange,\n            triangles: triangles,\n        }, bufferItems.system.material.uniforms);\n    };\n    /**\n     * Aids in taking in multiple multibuffers and flattening it to a single list\n     *\n     * @param multiShapeBuffers\n     */\n    BufferUtil.flattenMultiBuffers = function (multiShapeBuffers) {\n        var all = [];\n        multiShapeBuffers.forEach(function (multiBuffer) {\n            multiBuffer.getBuffers().forEach(function (buffer) { return all = all.concat(buffer); });\n        });\n        return all;\n    };\n    /**\n     * @static\n     * This helps aid in updating a complex multi buffer. It will establish when a new\n     * buffer needs to be created and initialized and it will automatically call a BaseBuffer's\n     * update when an update is detected as a need for the buffer.\n     *\n     * @param multiShapeBuffer\n     * @param buffers\n     * @param init\n     *\n     * @return {boolean} True if a buffer was updated\n     */\n    BufferUtil.updateMultiBuffer = function (multiShapeBuffer, buffers, init, update, forceUpdates) {\n        // If no buffers provided, then we do not need to update anything\n        if (!multiShapeBuffer) {\n            return false;\n        }\n        // This flag indicates whether an update occurred or not\n        var didUpdate = false;\n        // Get the shape buffers we need rendered into vertex buffers\n        var shapeBuffers;\n        // If this is a list of multibuffers, we flatten out all of the sub buffers\n        // This is a one level deep flatten as we do not want to accidentally handle shape clustering here\n        if (isList(multiShapeBuffer)) {\n            shapeBuffers = multiShapeBuffer.reduce(function (flat, toFlatten) { return flat.concat(toFlatten.getBuffers()); }, []);\n        }\n        else {\n            shapeBuffers = multiShapeBuffer.getBuffers();\n        }\n        // Make a lookup to identify the buffers that already exists for the given multi shape buffers\n        var bufferLookup = new Map();\n        buffers.forEach(function (buffer) { return bufferLookup.set(buffer.bufferItems.currentData, buffer); });\n        // This will store all of the shape buffers that needs to be rendered into a vertex buffer\n        var needsBuffer = [];\n        // If we're forcing updates then we should be ensuring all shapeBuffers needs a buffer\n        // And leave all of the bufferLookup so they will all be updated with the provided needed shape buffer updates\n        if (forceUpdates) {\n            needsBuffer = [].concat(shapeBuffers);\n        }\n        else {\n            shapeBuffers.forEach(function (shapes) {\n                if (bufferLookup.get(shapes)) {\n                    bufferLookup.delete(shapes);\n                }\n                else {\n                    needsBuffer.push(shapes);\n                }\n            });\n        }\n        // All buffers remaining in the buffer lookup are available for re-rendering the\n        // Shape buffers that still needs updates\n        // If the shape buffers needing updates is greater than the vertex buffers available\n        // Then we update with what we have and initialize any additional vertex buffers needed\n        if (needsBuffer.length >= bufferLookup.size) {\n            // Take any buffer that is not found with an existing shape buffer and update it\n            // With a buffer that needs an update\n            bufferLookup.forEach(function (value) {\n                didUpdate = update(value, needsBuffer.shift()) || didUpdate;\n            });\n            // Any remaining buffers that need updates will have to initialize a buffer\n            // To cram it in\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = init();\n                buffers.push(vertexBuffer);\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n        }\n        else {\n            var vertexBuffers_1 = Array.from(bufferLookup.values());\n            needsBuffer.forEach(function (shapeBuffer) {\n                var vertexBuffer = vertexBuffers_1.shift();\n                didUpdate = update(vertexBuffer, shapeBuffer) || didUpdate;\n            });\n            vertexBuffers_1.forEach(function (buffer) {\n                buffer.bufferItems.geometry.setDrawRange(0, 0);\n            });\n        }\n        return didUpdate;\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with constructing a new buffer\n     * such as applying the name, generating the buffer, and populating default values to\n     * that buffer.\n     *\n     * @param {number} numVertices The number of vertices this buffer will have\n     * @param {IAttributeInfo[]} attributes A description of each attribute in the buffer\n     *\n     * @returns {BufferGeometry} The newly made buffer\n     */\n    BufferUtil.makeBuffer = function (numVertices, attributes) {\n        var iMax = attributes.length;\n        var geometry = new three_1.BufferGeometry();\n        var totalAttributeSize = 0;\n        for (var i = 0; i < iMax; ++i) {\n            var attribute = attributes[i];\n            var attributeSize = attribute.size + 1;\n            totalAttributeSize += attributeSize;\n            var name_1 = attribute.name;\n            var injectBuffer = attribute.injectBuffer;\n            var buffer = injectBuffer || new Float32Array(attributeSize * numVertices);\n            var fillMethod = fillMethodLookUp[attribute.size];\n            var customFill = attribute.customFill;\n            var defaults = attribute.defaults;\n            // If an explicit buffer was not provided, then we fill with the defaults\n            if (!injectBuffer) {\n                if (customFill) {\n                    // Let the custom fill method populate the buffer with whatever so be desired\n                    for (var k = 0; k < numVertices; ++k) {\n                        customFill(buffer, k, k * attributeSize, defaults);\n                    }\n                }\n                else {\n                    // We set up our default value registers before executing the fill method\n                    applyDefaultsHolders(defaults);\n                    // Fill our buffer with the indicated default values\n                    for (var k = 0; k < numVertices; ++k) {\n                        fillMethod(buffer, k * attributeSize);\n                    }\n                }\n            }\n            // Apply the buffer to our geometry buffer\n            var attr = new three_1.BufferAttribute(buffer, attributeSize);\n            attr.setDynamic(true);\n            geometry.addAttribute(name_1, attr);\n            debug('Made Buffer Attribute:', name_1, attributeSize);\n        }\n        if (totalAttributeSize > 16) {\n            console.warn('A Buffer has specified more attributes than available. The max is 16 and the buffer provided:', totalAttributeSize);\n        }\n        return geometry;\n    };\n    /**\n     * Generates the necessary metrics based on uniform attributes to generate a uniform buffer for\n     * rendering.\n     *\n     * @param uniforms\n     */\n    BufferUtil.makeUniformBuffer = function (uniforms) {\n        var maxBlock = 0;\n        var buffer = [];\n        var uniformBufferBlockMax = webgl_stat_1.WebGLStat.MAX_VERTEX_INSTANCE_DATA;\n        var sizeCheck = {};\n        uniforms.forEach(function (uniform) {\n            maxBlock = Math.max(uniform.block, maxBlock);\n            var check = sizeCheck[uniform.block] = (sizeCheck[uniform.block] || 0) + (uniform.size + 1);\n            if (check > 4) {\n                console.warn('There were too many uniform attribute usages of a single block:', uniform);\n            }\n        });\n        for (var i = 0; i < uniformBufferBlockMax; ++i) {\n            buffer.push(new three_1.Vector4(0, 0, 0, 0));\n        }\n        return {\n            blocksPerInstance: maxBlock,\n            buffer: buffer,\n            maxInstances: Math.floor(uniformBufferBlockMax / maxBlock),\n        };\n    };\n    /**\n     * @static\n     * This handles many of the common tasks associated with updating a buffer. You specify how many vertices\n     * to update in a batch and you specify how many batches are present.\n     *\n     * Batches are used to represent your full shape object that is being loaded from the cpu:\n     *\n     * IE- you have a rectangle object you wish to update in your buffer. This takes around 6 vertices typically\n     * so you make your vertexBatch 6 and the numBatches the number of quads you need to update in the buffer.\n     *\n     * You then provide an accessor which aids in pointing to the buffer items that need updating. The accessor has\n     * variable arguments depending on the attributes you inject in.\n     *\n     * If you have attributes like:\n     * [\n     *  {name: position, size: AttributeSize.Three},\n     *  {name: color, size: AttributeSize.Four},\n     * ]\n     *\n     * Then your accessor will be delievered arguments in this form:\n     *\n     * function(batchIndex: number, positionBuffer: number[], positionIndex: number, colorBuffer: number[], colorIndex: number)\n     *\n     * NOTE: The params handed in ARE ORDERED BY the attributes injected in\n     *\n     * You then can update the buffers based on the index information handed alongside each buffer\n     *\n     * @param {T[]} newData The new data that is going to be injected into the buffer. This must be a NEW REFERENCE of data\n     *                      that does NOT match the reference in the bufferItems.currentData. So newData !== bufferItems.currentData\n     *                      in order for the update to occur.\n     * @param {BufferGeometry} bufferItems The buffer related items used to identify how to update the buffer\n     * @param {number} vertexBatch The number of vertices to include per update batch\n     * @param {number} numBatches The number of batches to execute\n     * @param {Function} updateAccessor The accessor for performing the data update to the buffer\n     * @param {boolean} force This bypasses the typical checks that determines if the buffer SHOULD update.\n     *\n     * @return {boolean} True if the buffer was updated with this call\n     */\n    BufferUtil.updateBuffer = function (newData, bufferItems, vertexBatch, numBatches, updateAccessor, force) {\n        var attributes = bufferItems.attributes;\n        var buffer = bufferItems.geometry;\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            // Flag the newly rendered data as our current data\n            bufferItems.currentData = newData;\n            // Get the attributes by name out of the three js buffer\n            var bufferAttributes = attributes.map(function (attr) { return buffer.attributes[attr.name]; });\n            // Get the raw number buffers\n            var attributeBuffers = bufferAttributes.map(function (attr) { return attr.array; });\n            // Determine what kind of buffer pointer increments we will need\n            var incrementValues = attributes.map(function (attr) { return (attr.size + 1) * vertexBatch; });\n            // Apply all data needed to any registers we need\n            applyAttributeRegisters(attributeBuffers, incrementValues);\n            // Get the method that will perform the update based on number of attributes\n            var updateMethod = updateBufferLookUp[attributes.length];\n            // Execute the update method\n            updateMethod(numBatches + lastBatchRegister, updateAccessor);\n            // Flag each buffer attribute for needing an update\n            bufferAttributes.forEach(function (attr) {\n                if (attr.updateRange) {\n                    attr.updateRange.offset = 0;\n                    attr.updateRange.count = vertexBatch * (lastBatchRegister + numBatches) * attr.itemSize;\n                }\n                attr.needsUpdate = true;\n            });\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += numBatches;\n        }\n        return false;\n    };\n    /**\n     * This is an alternative way to specify data for rendering. This updates information within the\n     * uniform blocks to specify instancing data (the alternative is just updating a vertex buffer\n     * with all of the data needed for every piece of geometry for every instance). This update method\n     * CAN save massive amounts of committed data for large geometry items (ie curves). It requires a\n     * different pipeline to make work (your shader must specify a uniform vec4 instanceData[], and\n     * your shape buffer to vertex buffer conversion must have a static vertex buffer).\n     *\n     * This is like a vertex buffer update except the updateAccessor will be of this format:\n     *\n     * updateAccessor(instanceIndex: number, uniformBlock0: Vector4, ..., uniformBlockN: Vector4);\n     *\n     * Where the uniform blocks provided will appear in the same order the IUniformAttributes were in\n     * when the uniform buffer was created.\n     *\n     */\n    BufferUtil.updateUniformBuffer = function (newData, bufferItems, instanceBatchSize, updateAccessor, force) {\n        // If we passed the data check on the first pass, then all future streamed updates\n        // Should pass as well\n        var testPerformed = lastBatchRegister !== 0 && isStreamUpdatingRegister;\n        console.log('ATTEMPTING UNIFORM BUFFER UPDATE', newData !== undefined, newData !== bufferItems.currentData);\n        // We check if there is a reference change in the data indicating a buffer push needs to happen\n        if ((newData !== undefined && newData !== bufferItems.currentData) || testPerformed || force) {\n            // If we aren't streaming updates, then we always start at the beginning\n            if (!isStreamUpdatingRegister) {\n                // Reset out last batch register as this is an entriely new update\n                lastBatchRegister = 0;\n            }\n            var material = bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var instanceData = uniforms.instanceData;\n            bufferItems.currentData = newData;\n            console.log('ATTEMPTING UNIFORM BUFFER UPDATE', instanceData, instanceData.type, 'v4v', bufferItems.uniformBuffer);\n            // If the instance data uniform is available and it is the proper vec4 array type, then we\n            // Are able to update the uniform buffer\n            if (instanceData && instanceData.type === 'v4v' && bufferItems.uniformBuffer) {\n                var attributes = bufferItems.uniformAttributes;\n                var blocksPerInstance = bufferItems.uniformBuffer.blocksPerInstance;\n                var buffer = bufferItems.uniformBuffer.buffer;\n                var maxInstances = bufferItems.uniformBuffer.maxInstances;\n                var currentInstance = lastBatchRegister;\n                var currentInstanceStartBlock = lastBatchRegister;\n                // We loop and update as many instances as specified, only up to the\n                // Number of instances allowed for the uniform buffer\n                for (var i = 0; i < instanceBatchSize && currentInstance < maxInstances; ++i) {\n                    // Our current instance depends on our lastBatchRegister we utilize\n                    // When begin() is called\n                    currentInstance = lastBatchRegister + i;\n                    // We get the first block the instance will utilize\n                    currentInstanceStartBlock = blocksPerInstance * currentInstance;\n                    // This will contain all of our arguments the accessor will use\n                    var updateArguments = [currentInstance];\n                    // Loop through the attributes in the order they appear and gather the block they will\n                    // Update\n                    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n                        var attribute = attributes_1[_i];\n                        updateArguments.push(buffer[attribute.block + currentInstanceStartBlock]);\n                    }\n                    // Call the update accessor for the instance using the gathered arguments\n                    // TODO: This should be done with registers like vertex array buffer updates for Optimal\n                    // Performance. A method apply is very slow compared to the register way.\n                    updateAccessor.apply(null, updateArguments);\n                }\n                // Tell the uniform to update with the new dataset\n                instanceData.value = [].concat(buffer);\n            }\n            else {\n                console.warn('A uniform buffer update was specified on a material that lacks uniform buffer usage');\n                return false;\n            }\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n            return true;\n        }\n        else {\n            // Move our register forward in case we are in a stream update\n            lastBatchRegister += instanceBatchSize;\n        }\n        return false;\n    };\n    /**\n     * This makes all of the typical items used in creating and managing a buffer of items rendered to the screen\n     *\n     * @returns {IBufferItems<T>} An empty object of the particular buffer items needed\n     */\n    BufferUtil.makeBufferItems = function () {\n        return {\n            attributes: [],\n            currentData: [],\n            geometry: null,\n            system: null,\n            uniformAttributes: [],\n            uniformBuffer: null,\n        };\n    };\n    return BufferUtil;\n}());\nexports.BufferUtil = BufferUtil;\nvar _a;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/buffer-util.ts\n// module id = 2\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/browser.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar buffer_util_1 = require(\"../util/buffer-util\");\n/**\n * This deinfes the minimal set of methods that should be implemented to create\n * a reusable buffer object that can be initialized and populated.\n */\nvar BaseBuffer = /** @class */ (function () {\n    function BaseBuffer() {\n    }\n    /**\n     * This disposes the resources associated with a buffer.\n     */\n    BaseBuffer.prototype.dispose = function () {\n        if (this.bufferItems) {\n            buffer_util_1.BufferUtil.dispose([this.bufferItems]);\n        }\n    };\n    /**\n     * This initializes the buffer and generates the buffer items object.\n     */\n    BaseBuffer.prototype.init = function (material, unitCount) {\n        // To be implemented by a subclass\n    };\n    /**\n     * This updates the buffer by providing the shape buffer needed to update\n     * the internal buffer items\n     *\n     * @param {T[]} shapeBuffer The shape buffer containing all of the shape data\n     *                          to be placed into the buffer.\n     *\n     * @return {boolean} Retrusn true if this pushed up any updates\n     */\n    BaseBuffer.prototype.update = function (shapeBuffer) {\n        // To be implemented by a subclass\n        return false;\n    };\n    return BaseBuffer;\n}());\nexports.BaseBuffer = BaseBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/base-buffer.ts\n// module id = 4\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ramda\"\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculates the distance between two points, but keeps the distance in dquared form\n * thus performing Math.sqrt() on the output of this distance would provide the true\n * distance between the points.\n *\n * It is often faster and all that is needed to compare squared distances vs real distances\n * thus eliminating multiple Math.sqrt operations\n *\n * NOTE: For vectors this is the same as (pseudo code):\n * let vector3 = vector2.subtract(vector1)\n * return vector3.dot(vector3)\n *\n * @param p1 The point to find the distance from the second point\n * @param p2 The point to find the distance from the first point\n *\n * @return {number} The distance * distance between the two points\n */\nfunction squareDistance(p1, p2) {\n    var dx = p1.x - p2.x;\n    var dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n}\n/**\n * Contains methods for managing or manipulating points\n *\n * @export\n * @class Point\n */\nvar Point = /** @class */ (function () {\n    function Point() {\n    }\n    /**\n     * Adds two points together\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @return {IPoint} The two points added together\n     */\n    Point.add = function (p1, p2, out) {\n        if (out) {\n            out.x = p1.x + p2.x;\n            out.y = p1.y + p2.y;\n            return out;\n        }\n        return {\n            x: p1.x + p2.x,\n            y: p1.y + p2.y,\n        };\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {IPoint} The closest point to the test point\n     */\n    Point.getClosest = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = null;\n        var distance;\n        var findClosest = function (point) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = point;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This analyzes a test point against a list of points and determines which of the points is\n     * the closest to the test point. If there are equi-distant points in the list, this will return\n     * the first found in the list.\n     *\n     * This just returns the index of the found point and not the point itself\n     *\n     * @param {IPoint} testPoint The point to compare against other points\n     * @param {IPoint[]} points The list of points to be compared against\n     *\n     * @return {number} The index of the closest point to the test point\n     */\n    Point.getClosestIndex = function (testPoint, points) {\n        var closestDistance = Number.MAX_VALUE;\n        var closestPoint = 0;\n        var distance;\n        var findClosest = function (point, i) {\n            distance = squareDistance(point, testPoint);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestPoint = i;\n            }\n        };\n        points.forEach(findClosest);\n        return closestPoint;\n    };\n    /**\n     * @static\n     * This will calculate a direction vector between two points that points toward p2\n     *\n     * @param {IPoint} p1 The start of the direction\n     * @param {IPoint} p2 The direction to point the vector towards\n     * @param {boolean} normalize If true, this will make the vector have a magnitude of 1\n     *\n     * @returns {number}\n     */\n    Point.getDirection = function (p1, p2, normalize) {\n        if (normalize === void 0) { normalize = false; }\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        if (normalize) {\n            var magnitude = Math.sqrt(dx * dx + dy * dy);\n            dx /= magnitude;\n            dy /= magnitude;\n        }\n        return {\n            x: dx,\n            y: dy,\n        };\n    };\n    /**\n     * @static\n     * Gets the distance between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     * @param {boolean} squared If set to true, returns the distance * distance (performs faster)\n     *\n     * @returns {number} The real distance between two points\n     */\n    Point.getDistance = function (p1, p2, squared) {\n        if (squared === void 0) { squared = false; }\n        if (squared) {\n            return squareDistance(p1, p2);\n        }\n        return Math.sqrt(squareDistance(p1, p2));\n    };\n    /**\n     * @static\n     * Gets a point perfectly between two points\n     *\n     * @param {IPoint} p1\n     * @param {IPoint} p2\n     *\n     * @returns {IPoint} The point between the two provided points\n     */\n    Point.getMidpoint = function (p1, p2) {\n        var direction = Point.getDirection(p1, p2);\n        return {\n            x: direction.x / 2 + p1.x,\n            y: direction.y / 2 + p1.y,\n        };\n    };\n    Point.make = function (x, y) {\n        return { x: x, y: y };\n    };\n    /**\n     * Scales a point by a given amount\n     *\n     * @static\n     * @param {IPoint} p1\n     * @param {number} s The amount to scale the point by\n     * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n     *\n     * @memberof Point\n     */\n    Point.scale = function (p1, s, out) {\n        if (out) {\n            out.x = p1.x * s;\n            out.y = p1.y * s;\n            return out;\n        }\n        return {\n            x: p1.x * s,\n            y: p1.y * s,\n        };\n    };\n    /**\n     * Makes a new point initialized to {0,0}\n     *\n     * @static\n     * @returns {IPoint} A new point object at {0,0}\n     */\n    Point.zero = function () {\n        return {\n            x: 0,\n            y: 0,\n        };\n    };\n    return Point;\n}());\nexports.Point = Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/point.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"./bounds\");\n/**\n * Represents a line with a given slope\n */\nvar Line = /** @class */ (function (_super) {\n    __extends(Line, _super);\n    /**\n     * Creates a new line that passes through the two specified points\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    function Line(p1, p2) {\n        var _this = _super.call(this, 0, 1, 1, 0) || this;\n        _this.setPoints(p1, p2);\n        return _this;\n    }\n    /**\n     * This calculates the distance to a point from the provided line\n     * BUT this ALSO retains the directionality of that distance. So one side of\n     * the line will be positive while the other negative\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.directionTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line, but we won't take the absolute to retain the direction\n        return this.perpendicular.x * vector.x + this.perpendicular.y * vector.y;\n    };\n    /**\n     * This calculates the distance to a point from the provided line\n     *\n     * @param {IPoint} p The Point to see how far from the line we are\n     *\n     * @return {number} The calculated distance to the provided point\n     */\n    Line.prototype.distanceTo = function (p) {\n        // Make a vector from a line point to the indicated point\n        var vector = {\n            x: this.p1.x - p.x,\n            y: this.p1.y - p.y,\n        };\n        // The distance is d = |v . r| where v is a unit perpendicular vector to the\n        // Line\n        return Math.abs(this.perpendicular.x * vector.x +\n            this.perpendicular.y * vector.y);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {Array} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    Line.getClosest = function (lines, p) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(p);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This sets the two endpoints for this line and recalculates the bounds\n     * of the line accordingly\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    Line.prototype.setPoints = function (p1, p2) {\n        this.x = p1.x - 1;\n        this.y = p1.y - 1;\n        this.width = 2;\n        this.height = 2;\n        this.encapsulatePoint(p2);\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        this.slope = dy / dx;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.magnitude = Math.sqrt(dx * dx + dy * dy);\n        this.perpendicular = {\n            x: this.p2.y - this.p1.y,\n            y: -(this.p2.x - this.p1.x),\n        };\n        // Normalize the perpendicular line\n        var mag = Math.sqrt(this.perpendicular.x * this.perpendicular.x +\n            this.perpendicular.y * this.perpendicular.y);\n        this.perpendicular.x /= mag;\n        this.perpendicular.y /= mag;\n    };\n    return Line;\n}(bounds_1.Bounds));\nexports.Line = Line;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/line.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines a texture that is located on an atlas\n */\nvar AtlasTexture = /** @class */ (function () {\n    /**\n     * Generates a new atlas texture that points to a specific image resource.\n     *\n     * @param path The path to the image resource to be loaded into the atlas.\n     */\n    function AtlasTexture(path, label) {\n        /** Stores the aspect ratio of the image for quick reference */\n        this.aspectRatio = 1.0;\n        this.imagePath = path;\n        this.label = label;\n        // Let the label keep track of it's rasterization\n        if (label) {\n            this.label.rasterizedLabel = this;\n        }\n    }\n    return AtlasTexture;\n}());\nexports.AtlasTexture = AtlasTexture;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-texture.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FrameInfo = /** @class */ (function () {\n    function FrameInfo() {\n    }\n    /** Contains the time the previous frame started */\n    FrameInfo.lastFrameTime = Date.now();\n    /** Contains a theoretical approximation the next frame will start */\n    FrameInfo.nextFrameTime = Date.now();\n    /** Contains how many frames have been played for a given WebGLSurface context */\n    FrameInfo.framesPlayed = new Map();\n    return FrameInfo;\n}());\nexports.FrameInfo = FrameInfo;\n/**\n * This gets an integer time value that can fit within an attribute. Be aware,\n * this only supports up to 7 digits of the millisecond time.\n */\nfunction getAttributeCurrentTime() {\n    var time = FrameInfo.lastFrameTime / 1E7;\n    return Math.floor((time - Math.floor(time)) * 1E7);\n}\nexports.getAttributeCurrentTime = getAttributeCurrentTime;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/frame-info.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProgramInfo(gl, program) {\n    var result = {\n        attributeCount: 0,\n        attributes: new Array(),\n        uniformCount: 0,\n        uniforms: new Array(),\n    }, activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    // Taken from the WebGl spec:\n    // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n    var enums = {\n        0x8B50: 'FLOAT_VEC2',\n        0x8B51: 'FLOAT_VEC3',\n        0x8B52: 'FLOAT_VEC4',\n        0x8B53: 'INT_VEC2',\n        0x8B54: 'INT_VEC3',\n        0x8B55: 'INT_VEC4',\n        0x8B56: 'BOOL',\n        0x8B57: 'BOOL_VEC2',\n        0x8B58: 'BOOL_VEC3',\n        0x8B59: 'BOOL_VEC4',\n        0x8B5A: 'FLOAT_MAT2',\n        0x8B5B: 'FLOAT_MAT3',\n        0x8B5C: 'FLOAT_MAT4',\n        0x8B5E: 'SAMPLER_2D',\n        0x8B60: 'SAMPLER_CUBE',\n        0x1400: 'BYTE',\n        0x1401: 'UNSIGNED_BYTE',\n        0x1402: 'SHORT',\n        0x1403: 'UNSIGNED_SHORT',\n        0x1404: 'INT',\n        0x1405: 'UNSIGNED_INT',\n        0x1406: 'FLOAT',\n    };\n    var blocks = {\n        0x8B50: 1,\n        0x8B51: 1,\n        0x8B52: 1,\n        0x8B53: 1,\n        0x8B54: 1,\n        0x8B55: 1,\n        0x8B56: 1,\n        0x8B57: 1,\n        0x8B58: 1,\n        0x8B59: 1,\n        0x8B5A: 1,\n        0x8B5B: 3,\n        0x8B5C: 4,\n        0x8B5E: 1,\n        0x8B60: 1,\n        0x1400: 1,\n        0x1401: 1,\n        0x1402: 1,\n        0x1403: 1,\n        0x1404: 1,\n        0x1405: 1,\n        0x1406: 1,\n    };\n    // Loop through active uniforms\n    for (var i = 0; i < activeUniforms; ++i) {\n        var uniform = gl.getActiveUniform(program, i);\n        uniform.typeName = enums[uniform.type];\n        result.uniforms.push(uniform);\n        result.uniformCount += uniform.size;\n        uniform.size = uniform.size * blocks[uniform.type];\n    }\n    // Loop through active attributes\n    for (var i = 0; i < activeAttributes; i++) {\n        var attribute = gl.getActiveAttrib(program, i);\n        attribute.typeName = enums[attribute.type];\n        result.attributes.push(attribute);\n        result.attributeCount += attribute.size;\n    }\n    return result;\n}\nvar WebGLStat = /** @class */ (function () {\n    function WebGLStat() {\n    }\n    WebGLStat.printCurrentProgramInfo = function (debug, surface) {\n        if (surface.gl) {\n            var info = getProgramInfo(surface.gl, surface.gl.getParameter(surface.gl.CURRENT_PROGRAM));\n            var table = window.table;\n            if (table) {\n                table(info.uniforms);\n            }\n        }\n        else {\n            debug('Attempted to printProgramInfo but the surface has not established its gl context yet');\n        }\n    };\n    WebGLStat.MAX_VERTEX_UNIFORMS = 0;\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = 0;\n    WebGLStat.MAX_ATTRIBUTES = 0;\n    WebGLStat.WEBGL_SUPPORTED = false;\n    // TODO: This remains static until we have a qay to inject variable parameters into the shader\n    //       Strings. 128 is the guaranteed saftey range for uniform sizes for WebGL. We could have\n    //       Significantly higher numbers on most devices if we have dynamic field replacement for\n    //       Shaders.\n    WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    return WebGLStat;\n}());\nexports.WebGLStat = WebGLStat;\nfunction initStats() {\n    // Let's perform some immediate operations to do some gl querying for useful information\n    function getAContext() {\n        try {\n            var canvas = document.createElement('canvas');\n            return window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    // Attempt to retrieve a context for webgl\n    var gl = getAContext();\n    // If the context exists, then we know gl is supported and we can fill in some metrics\n    if (gl) {\n        WebGLStat.WEBGL_SUPPORTED = true;\n        WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        WebGLStat.MAX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n        // TODO: See TODO at declaration\n        WebGLStat.MAX_VERTEX_INSTANCE_DATA = 128 - 32;\n    }\n}\ninitStats();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/webgl-stat.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Does a linear easing of a value\n *\n * @param {number} t The time elapsed: 0 to d\n * @param {number} s The start value\n * @param {number} c The change in value\n * @param {number} d The duration of the change\n *\n * @returns A number linearly progressing from s to s+c depending on the value of\n *          t in relation to d\n */\nfunction linear(t, s, c, d) {\n    return c * t / d + s;\n}\nexports.linear = linear;\nfunction easeInQuad(t, b, c, d) {\n    return c * (t /= d) * t + b;\n}\nexports.easeInQuad = easeInQuad;\nfunction easeOutQuad(t, b, c, d) {\n    return -c * (t /= d) * (t - 2) + b;\n}\nexports.easeOutQuad = easeOutQuad;\nfunction easeInOutQuad(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t + b;\n    return -c / 2 * ((--t) * (t - 2) - 1) + b;\n}\nexports.easeInOutQuad = easeInOutQuad;\nfunction easeInCubic(t, b, c, d) {\n    return c * (t /= d) * t * t + b;\n}\nexports.easeInCubic = easeInCubic;\nfunction easeOutCubic(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t + 1) + b;\n}\nexports.easeOutCubic = easeOutCubic;\nfunction easeInOutCubic(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t + 2) + b;\n}\nexports.easeInOutCubic = easeInOutCubic;\nfunction easeInQuart(t, b, c, d) {\n    return c * (t /= d) * t * t * t + b;\n}\nexports.easeInQuart = easeInQuart;\nfunction easeOutQuart(t, b, c, d) {\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n}\nexports.easeOutQuart = easeOutQuart;\nfunction easeInOutQuart(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t + b;\n    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n}\nexports.easeInOutQuart = easeInOutQuart;\nfunction easeInQuint(t, b, c, d) {\n    return c * (t /= d) * t * t * t * t + b;\n}\nexports.easeInQuint = easeInQuint;\nfunction easeOutQuint(t, b, c, d) {\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n}\nexports.easeOutQuint = easeOutQuint;\nfunction easeInOutQuint(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return c / 2 * t * t * t * t * t + b;\n    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n}\nexports.easeInOutQuint = easeInOutQuint;\nfunction easeInSine(t, b, c, d) {\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n}\nexports.easeInSine = easeInSine;\nfunction easeOutSine(t, b, c, d) {\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\n}\nexports.easeOutSine = easeOutSine;\nfunction easeInOutSine(t, b, c, d) {\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n}\nexports.easeInOutSine = easeInOutSine;\nfunction easeInExpo(t, b, c, d) {\n    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n}\nexports.easeInExpo = easeInExpo;\nfunction easeOutExpo(t, b, c, d) {\n    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n}\nexports.easeOutExpo = easeOutExpo;\nfunction easeInOutExpo(t, b, c, d) {\n    if (t === 0)\n        return b;\n    if (t === d)\n        return b + c;\n    if ((t /= d / 2) < 1)\n        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n}\nexports.easeInOutExpo = easeInOutExpo;\nfunction easeInCirc(t, b, c, d) {\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n}\nexports.easeInCirc = easeInCirc;\nfunction easeOutCirc(t, b, c, d) {\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n}\nexports.easeOutCirc = easeOutCirc;\nfunction easeInOutCirc(t, b, c, d) {\n    if ((t /= d / 2) < 1)\n        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n}\nexports.easeInOutCirc = easeInOutCirc;\nfunction easeInElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n}\nexports.easeInElastic = easeInElastic;\nfunction easeOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d) === 1)\n        return b + c;\n    if (!p)\n        p = d * .3;\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n}\nexports.easeOutElastic = easeOutElastic;\nfunction easeInOutElastic(t, b, c, d) {\n    var s = 1.70158;\n    var p = 0;\n    var a = c;\n    if (t === 0)\n        return b;\n    if ((t /= d / 2) === 2)\n        return b + c;\n    if (!p)\n        p = d * (.3 * 1.5);\n    if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n    }\n    else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    if (t < 1)\n        return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n}\nexports.easeInOutElastic = easeInOutElastic;\nfunction easeInBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\n}\nexports.easeInBack = easeInBack;\nfunction easeOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n}\nexports.easeOutBack = easeOutBack;\nfunction easeInOutBack(t, b, c, d, s) {\n    if (s === undefined)\n        s = 1.70158;\n    if ((t /= d / 2) < 1)\n        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n}\nexports.easeInOutBack = easeInOutBack;\nfunction easeInBounce(t, b, c, d) {\n    return c - easeOutBounce(d - t, 0, c, d) + b;\n}\nexports.easeInBounce = easeInBounce;\nfunction easeOutBounce(t, b, c, d) {\n    if ((t /= d) < (1 / 2.75)) {\n        return c * (7.5625 * t * t) + b;\n    }\n    else if (t < (2 / 2.75)) {\n        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n    }\n    else if (t < (2.5 / 2.75)) {\n        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n    }\n    else {\n        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n    }\n}\nexports.easeOutBounce = easeOutBounce;\nfunction easeInOutBounce(t, b, c, d) {\n    if (t < d / 2)\n        return easeInBounce(t * 2, 0, c, d) * .5 + b;\n    return easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n}\nexports.easeInOutBounce = easeInOutBounce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/easing.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_1 = require(\"../primitives/point\");\nvar easing_1 = require(\"./easing\");\n/**\n * This enum is just a common way to define interpolation types\n */\nvar InterpolationMethod;\n(function (InterpolationMethod) {\n    InterpolationMethod[InterpolationMethod[\"BEZIER2\"] = 0] = \"BEZIER2\";\n    InterpolationMethod[InterpolationMethod[\"BEZIER3\"] = 1] = \"BEZIER3\";\n    InterpolationMethod[InterpolationMethod[\"CIRCULAR\"] = 2] = \"CIRCULAR\";\n})(InterpolationMethod = exports.InterpolationMethod || (exports.InterpolationMethod = {}));\n/**\n * This calculates a quadratic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier2(t, p1, p2, c1) {\n    var t2 = t * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    return {\n        x: p1.x * mt2 + c1.x * 2 * mt * t + p2.x * t2,\n        y: p1.y * mt2 + c1.y * 2 * mt * t + p2.y * t2,\n    };\n}\nexports.bezier2 = bezier2;\n/**\n * This calculates a cubic bezier curve.\n *\n * We use specific bezier curve implementations for low degree curves as it is\n * much much faster to calculate.\n *\n * @param {number} t The 0 - 1 time interval for the part of the curve we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The first control point of the curve\n * @param {IPoint} c2 The second control point of the curve\n *\n * @returns {IPoint} The calculated point on the curve for the provided time interval\n */\nfunction bezier3(t, p1, p2, c1, c2) {\n    var t2 = t * t;\n    var t3 = t2 * t;\n    var mt = 1 - t;\n    var mt2 = mt * mt;\n    var mt3 = mt2 * mt;\n    return {\n        x: p1.x * mt3 + 3 * c1.x * mt2 * t + 3 * c2.x * mt * t2 + p2.x * t3,\n        y: p1.y * mt3 + 3 * c1.y * mt2 * t + 3 * c2.y * mt * t2 + p2.y * t3,\n    };\n}\nexports.bezier3 = bezier3;\n/**\n * This calculates a point along a path defined as a circular path which is a\n * path moving along the edge of a circle from one point to the next. This will\n * even allow for moving along a circle with a growing radius.\n *\n * @param {number} t The 0 - 1 time interval for the part of the path we desire\n * @param {IPoint} p1 The First end point of the curve\n * @param {IPoint} p2 The second end point of the curve\n * @param {IPoint} c1 The control point, or more importantly, the center of the circle\n * @param {EasingMethod} radiusEasing Default easing for the radius growing is linear.\n *                                    Insert a custom easing method to change this.\n *\n * @returns {IPoint}\n */\nfunction circular(t, p1, p2, c1, radiusEasing) {\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(c1, p1);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(c1, p2);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Ensure our theta's are definitely between 0 to Math.PI * 2 after the atan\n    // Calculation\n    if (theta1 < 0)\n        theta1 += Math.PI * 2;\n    if (theta2 < 0)\n        theta2 += Math.PI * 2;\n    var dTheta = theta2 - theta1;\n    // We ALWAYS want our path to be the shortest around the circle\n    if (dTheta > Math.PI) {\n        dTheta = theta1 - theta2;\n    }\n    // We use this to calculate how far we are between the two points in radians\n    // Based on the time parameter provided for the interpolation\n    dTheta *= t;\n    // We must have the radial distance of both points to properly calculate\n    // An easing between the two radii\n    var radius1 = point_1.Point.getDistance(p1, c1);\n    var radius2 = point_1.Point.getDistance(p2, c1);\n    // We control how the radius eases out for the path, which is determined by\n    // The easing method, otherwise, it just linearly radiates out\n    var radius = (radiusEasing || easing_1.linear)(t, radius1, radius2 - radius1, 1.0);\n    return {\n        x: Math.cos(theta1 + dTheta) * radius + c1.x,\n        y: Math.sin(theta1 + dTheta) * radius + c1.y,\n    };\n}\nexports.circular = circular;\nexports.pickInterpolation = (_a = {},\n    _a[InterpolationMethod.BEZIER2] = bezier2,\n    _a[InterpolationMethod.BEZIER3] = bezier3,\n    _a[InterpolationMethod.CIRCULAR] = circular,\n    _a);\nvar _a;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/interpolation.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar d3_color_1 = require(\"d3-color\");\nvar three_1 = require(\"three\");\nvar bounds_1 = require(\"../../primitives/bounds\");\nvar pack_node_1 = require(\"../../util/pack-node\");\nvar label_1 = require(\"../shape/label\");\nvar atlas_texture_1 = require(\"./atlas-texture\");\nvar debug = require('debug')('webgl-surface:Atlas');\nvar debugLabels = require('debug')('webgl-surface:Labels');\nvar ZERO_IMAGE = {\n    atlasBL: { x: 0, y: 0 },\n    atlasBR: { x: 0, y: 0 },\n    atlasTL: { x: 0, y: 0 },\n    atlasTR: { x: 0, y: 0 },\n    label: new label_1.Label({ text: ' ' }),\n    pixelHeight: 0,\n    pixelWidth: 0,\n};\n/**\n * Defines a manager of atlas', which includes generating the atlas and producing\n * textures defining those pieces of atlas.\n */\nvar AtlasManager = /** @class */ (function () {\n    /**\n     * Generates a new manager for atlas'. This will create and destroy atlas' and\n     * ensure they have the correct settings applied. A manager will also aid in\n     * packing images into the atlas indicated.\n     *\n     * @param {number} width The width of all atlas' generated\n     * @param {number} height The height of all atlas' generated\n     */\n    function AtlasManager(width, height) {\n        /** Gives a reference of all of the images loaded for the atlas */\n        this.atlasImages = {};\n        /** Stores the current mapping of the atlas */\n        this.atlasMap = {};\n        /** Stores all of the textures that are our atlases */\n        this.atlasTexture = {};\n        this.textureWidth = width;\n        this.textureHeight = height;\n    }\n    /**\n     * Atlas' must be created from scratch to update them. In order to properly\n     * update an existing one, you must destroy it then recreate it again.\n     * This is from not knowing how to update a texture via three js.\n     *\n     * @param atlasName The unique name of the atlas so it can be retrieved/referenced easily\n     * @param images The images with their image path set to be loaded into the atlas.\n     *               Images that keep an atlas ID of null indicates the image did not load\n     *               correctly\n     *\n     * @return {Texture} The Threejs texture that is created as our atlas. The images injected\n     *                   into the texture will be populated with the atlas'\n     */\n    AtlasManager.prototype.createAtlas = function (atlasName, images, colors) {\n        return __awaiter(this, void 0, void 0, function () {\n            var atlasMap, canvas, _i, images_1, image, image, texture, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        atlasMap = new pack_node_1.PackNode(0, 0, this.textureWidth, this.textureHeight);\n                        // Create the mapping element for the new atlas so we can track insertions / deletions\n                        this.atlasMap[atlasName] = atlasMap;\n                        // Make a listing of images that is within the atlas\n                        this.atlasImages[atlasName] = [];\n                        canvas = document.createElement('canvas').getContext('2d');\n                        // Size the canvas to the atlas size\n                        canvas.canvas.width = this.textureWidth;\n                        canvas.canvas.height = this.textureHeight;\n                        if (!images) return [3 /*break*/, 4];\n                        _i = 0, images_1 = images;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < images_1.length)) return [3 /*break*/, 4];\n                        image = images_1[_i];\n                        return [4 /*yield*/, this.draw(image, atlasName, canvas)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (!colors) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.drawColors(colors, atlasName, canvas)];\n                    case 5:\n                        image = _b.sent();\n                        // Add the dummy texture info as an image to our list of images\n                        if (image) {\n                            this.atlasImages[atlasName].push(image);\n                        }\n                        _b.label = 6;\n                    case 6:\n                        texture = new three_1.Texture(canvas.canvas);\n                        texture.premultiplyAlpha = true;\n                        texture.generateMipmaps = true;\n                        // Store the texture as the atlas.\n                        this.atlasTexture[atlasName] = texture;\n                        // Store the images as images within the atlas\n                        if (images) {\n                            (_a = this.atlasImages[atlasName]).push.apply(_a, images);\n                        }\n                        debug('Atlas Created-> texture: %o mapping: %o images: %o', texture, atlasMap, images);\n                        return [2 /*return*/, texture];\n                }\n            });\n        });\n    };\n    /**\n     * Disposes of the resources the atlas held and makes the atlas invalid for use\n     *\n     * @param atlasName\n     */\n    AtlasManager.prototype.destroyAtlas = function (atlasName) {\n        if (this.atlasTexture[atlasName]) {\n            this.atlasTexture[atlasName].dispose();\n            this.atlasTexture[atlasName] = null;\n        }\n        if (this.atlasMap[atlasName]) {\n            this.atlasMap[atlasName].destroy();\n            this.atlasMap[atlasName] = null;\n        }\n        if (this.atlasImages[atlasName]) {\n            var none_1 = { x: 0, y: 0 };\n            this.atlasImages[atlasName].forEach(function (image) {\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                image.pixelHeight = 0;\n                image.atlasBL = none_1;\n                image.atlasBR = none_1;\n                image.atlasTL = none_1;\n                image.atlasTR = none_1;\n            });\n            this.atlasImages[atlasName] = null;\n        }\n    };\n    AtlasManager.prototype.isValidImage = function (image) {\n        var isValid = false;\n        if (image && (image.imagePath || (image.label && image.label.text))) {\n            if (image.pixelWidth && image.pixelHeight) {\n                isValid = true;\n            }\n        }\n        return isValid;\n    };\n    AtlasManager.prototype.setDefaultImage = function (image, atlasName) {\n        image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n        return image;\n    };\n    /**\n     * This loads, packs, and draws the indicated image into the specified canvas\n     * using the metrics that exists for the specified atlas.\n     *\n     * @param image The image who should have it's image path loaded\n     * @param atlasName The name of the atlas to make the packing work\n     * @param canvas The canvas we will be drawing into to generate the complete image\n     *\n     * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\n     */\n    AtlasManager.prototype.draw = function (image, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var loadedImage, rect, dimensions, node, insertedNode, ux, uy, uw, uh, atlasDimensions;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Validate the index\n                        if (!this.atlasMap[atlasName]) {\n                            debug('Can not load image, invalid Atlas Name: %o for atlasMaps: %o', atlasName, this.atlasMap);\n                            return [2 /*return*/, false];\n                        }\n                        return [4 /*yield*/, this.loadImage(image)];\n                    case 1:\n                        loadedImage = _a.sent();\n                        // Make sure at this point the image knows it is not affiliated with an atlas\n                        // If something goes wrong with loading or insertting this image, then a null\n                        // Atlas value will indicate the image can not be used appropriately\n                        image.atlasReferenceID = null;\n                        // Only a non-null image means the image loaded correctly\n                        if (loadedImage && this.isValidImage(image)) {\n                            debug('Image loaded: %o', image.imagePath);\n                            rect = new bounds_1.Bounds(0, image.pixelWidth, image.pixelHeight, 0);\n                            dimensions = {\n                                first: image,\n                                second: rect,\n                            };\n                            // Auto add a buffer in\n                            dimensions.second.width += 1;\n                            dimensions.second.height += 1;\n                            node = this.atlasMap[atlasName];\n                            insertedNode = node.insert(dimensions);\n                            // If the result was NULL we did not successfully insert the image into any map\n                            if (insertedNode) {\n                                debug('Atlas location determined: %o', insertedNode);\n                                if (image.label) {\n                                    debugLabels('Atlas location determined. PackNode: %o Dimensions: %o', insertedNode, dimensions);\n                                }\n                                // Apply the image to the node\n                                insertedNode.nodeImage = image;\n                                ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                                uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                                uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                                uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                                debugLabels('uy is %o', uy);\n                                atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                                image.atlasReferenceID = atlasName;\n                                image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                                image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                                image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                                // Now draw the image to the indicated canvas\n                                canvas.drawImage(loadedImage, insertedNode.nodeDimensions.x, insertedNode.nodeDimensions.y);\n                                // We have finished inserting\n                                return [2 /*return*/, true];\n                            }\n                            else {\n                                // Log an error\n                                console.error(\"Could not fit image into atlas \" + image.imagePath);\n                                image = this.setDefaultImage(image, atlasName);\n                                return [2 /*return*/, false];\n                            }\n                        }\n                        else {\n                            // Log an error and load a default image\n                            console.error(\"Could not load image \" + image.imagePath);\n                            image = this.setDefaultImage(image, atlasName);\n                            return [2 /*return*/, false];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This renders a list of colors to the canvas. This using the same packing\n     * algorithm as any image so the rendering is placed correctly or determines\n     * if enough space is not available.\n     *\n     * @param {AtlasColor[]} colors The list of colors to be rendered to the atlas\n     * @param {string} atlasName The name of the atlas being rendered to\n     * @param {CanvasRenderingContext2D} canvas The canvas of the atlas being rendered to\n     *\n     * @returns {Promise<boolean>} Resolves to true if the operation was successful\n     */\n    AtlasManager.prototype.drawColors = function (colors, atlasName, canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var colorWidth, colorHeight, maxPerRow, rowWidth, rowCount, colCount, renderHeight, dimensions, node, insertedNode, image, ux, uy, uw, uh, atlasDimensions, renderSpace, startX, startY, nextX, nextY, beginX, beginY, col, row, _i, colors_1, color, _a, r, g, b;\n            return __generator(this, function (_b) {\n                debug('Finding space for colors on the atlas: %o', colors);\n                colorWidth = 2;\n                colorHeight = 2;\n                maxPerRow = 1024 / colorWidth;\n                rowWidth = Math.min(this.textureWidth, maxPerRow * colorWidth);\n                rowCount = Math.ceil((colors.length * colorWidth) / rowWidth);\n                colCount = Math.ceil(rowWidth / colorWidth);\n                renderHeight = rowCount * colorHeight;\n                dimensions = {\n                    // Since the algorithm requires something to fill this slot, just make a\n                    // Dummy object\n                    first: new atlas_texture_1.AtlasTexture(null, null),\n                    // Set the dimensions we calculated for the space our colors will take up\n                    // Within the atlas\n                    second: new bounds_1.Bounds(0, rowWidth, renderHeight, 0),\n                };\n                // Auto add a buffer in\n                dimensions.second.width += 1;\n                dimensions.second.height += 1;\n                node = this.atlasMap[atlasName];\n                insertedNode = node.insert(dimensions);\n                // If the result was NULL we did not successfully insert the image into any map\n                if (insertedNode) {\n                    debug('Atlas location determined for colors: %o', insertedNode);\n                    image = insertedNode.nodeImage = dimensions.first;\n                    ux = insertedNode.nodeDimensions.x / this.textureWidth;\n                    uy = insertedNode.nodeDimensions.y / this.textureHeight;\n                    uw = insertedNode.nodeDimensions.width / this.textureWidth;\n                    uh = insertedNode.nodeDimensions.height / this.textureHeight;\n                    atlasDimensions = new bounds_1.Bounds(ux, ux + uw, 1.0 - uy, 1.0 - (uy + uh));\n                    image.atlasReferenceID = atlasName;\n                    image.atlasBL = { x: atlasDimensions.x, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasBR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y - atlasDimensions.height };\n                    image.atlasTL = { x: atlasDimensions.x, y: atlasDimensions.y };\n                    image.atlasTR = { x: atlasDimensions.x + atlasDimensions.width, y: atlasDimensions.y };\n                    renderSpace = insertedNode.nodeDimensions;\n                    startX = renderSpace.x;\n                    startY = renderSpace.y;\n                    nextX = colorWidth / this.textureWidth;\n                    nextY = -colorHeight / this.textureHeight;\n                    beginX = (startX / this.textureWidth) + (nextX / 2.0);\n                    beginY = 1.0 - (startY / this.textureHeight) + (nextY / 2.0);\n                    col = 0;\n                    row = 0;\n                    // Loop through each color, establish metrics, draw to the atlas\n                    for (_i = 0, colors_1 = colors; _i < colors_1.length; _i++) {\n                        color = colors_1[_i];\n                        // Staore the info needed to make the color referenceable again\n                        color.atlasReferenceID = atlasName;\n                        color.colorIndex = col + (row * colCount);\n                        color.colorsPerRow = colCount;\n                        // The location of the middle of the first color\n                        color.firstColor = {\n                            x: beginX,\n                            y: beginY,\n                        };\n                        color.nextColor = {\n                            x: nextX,\n                            y: nextY,\n                        };\n                        _a = color.color, r = _a.r, g = _a.g, b = _a.b;\n                        // Draw the color to the canvas\n                        canvas.fillStyle = \"rgba(\" + Math.round(r * 255.0) + \", \" + Math.round(g * 255.0) + \", \" + Math.round(b * 255.0) + \", \" + color.opacity + \")\";\n                        canvas.fillRect(col * colorWidth + startX, row * colorHeight + startY, colorWidth, colorHeight);\n                        col++;\n                        if (col === colCount) {\n                            col = 0;\n                            row++;\n                        }\n                    }\n                    // We have finished inserting\n                    return [2 /*return*/, image];\n                }\n                else {\n                    // Log an error\n                    throw new Error('Could not fit colors into atlas');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Retrieves the threejs texture for the atlas\n     *\n     * @param atlasName The identifier of the atlas\n     */\n    AtlasManager.prototype.getAtlasTexture = function (atlasName) {\n        return this.atlasTexture[atlasName];\n    };\n    /**\n     * This reads the input path and loads the image specified by the path\n     *\n     * @param {AtlasTexture} texture This is an atlas texture with the path set\n     *\n     * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\n     *                                     or null if there was an error\n     */\n    AtlasManager.prototype.loadImage = function (texture) {\n        if (texture.imagePath) {\n            return new Promise(function (resolve, reject) {\n                var image = new Image();\n                image.onload = function () {\n                    texture.pixelWidth = image.width;\n                    texture.pixelHeight = image.height;\n                    texture.aspectRatio = image.width / image.height;\n                    resolve(image);\n                };\n                image.onerror = function () {\n                    resolve(null);\n                };\n                image.src = texture.imagePath;\n            });\n        }\n        else if (texture.label) {\n            return new Promise(function (resolve, reject) {\n                var label = texture.label;\n                var labelSize = label.getSize();\n                var canvas = document.createElement('canvas');\n                var ctx = canvas.getContext('2d');\n                // Set the dimensions of the canvas/texture space we will be using to rasterize\n                // The label. Use the label's rasterization controls to aid in rendering the label\n                canvas.width = labelSize.width + texture.label.rasterizationOffset.x;\n                canvas.height = labelSize.height;\n                debug('label X %o', texture.label.rasterizationOffset.x);\n                if (ctx) {\n                    var fontSize = label.fontSize;\n                    var color = d3_color_1.rgb(label.color.base.color.r * 255, label.color.base.color.g * 255, label.color.base.color.b * 255, label.color.base.opacity);\n                    ctx.font = label.makeCSSFont(fontSize);\n                    ctx.textAlign = label.textAlign;\n                    ctx.textBaseline = label.textBaseline;\n                    ctx.fillStyle = color.toString();\n                    // Render the label to the canvas/texture space. This utilizes the label's\n                    // Rasterization metrics to aid in getting a clean render.\n                    ctx.fillText(label.text, texture.label.rasterizationOffset.x, texture.label.rasterizationOffset.y);\n                    var image_1 = new Image();\n                    image_1.onload = function () {\n                        // Here we use the canvas dimensions and NOT the image dimensions\n                        // As the image dimensions are unreliable here when setting the src\n                        // To a data url\n                        texture.pixelWidth = image_1.width;\n                        texture.pixelHeight = image_1.height;\n                        texture.aspectRatio = image_1.width / image_1.height;\n                        debugLabels('Applying size based on rasterization to the Label: w: %o h: %o', image_1.width, image_1.height);\n                        label.setSize({\n                            height: image_1.height,\n                            width: image_1.width,\n                        });\n                        resolve(image_1);\n                    };\n                    image_1.onerror = function () {\n                        resolve(null);\n                    };\n                    image_1.src = canvas.toDataURL('image/png');\n                }\n            });\n        }\n        return Promise.resolve(null);\n    };\n    return AtlasManager;\n}());\nexports.AtlasManager = AtlasManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-manager.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../primitives/bounds\");\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nvar PackNode = /** @class */ (function () {\n    function PackNode(x, y, width, height) {\n        this.child = [null, null];\n        this.isLeaf = true;\n        this.nodeImage = null;\n        this.nodeDimensions = new bounds_1.Bounds(x, x + width, y, y - height);\n    }\n    /**\n     * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n     */\n    PackNode.prototype.destroy = function () {\n        this.nodeImage = null;\n        if (this.child[0]) {\n            this.child[0].destroy();\n        }\n        if (this.child[1]) {\n            this.child[1].destroy();\n        }\n        this.child[0] = undefined;\n        this.child[1] = undefined;\n    };\n    /**\n     * Indicates if there is a child\n     */\n    PackNode.prototype.hasChild = function () {\n        if (this.child[0] && !this.child[0].nodeImage) {\n            return !this.child[0].isLeaf;\n        }\n        if (this.child[1] && !this.child[1].nodeImage) {\n            return !this.child[1].isLeaf;\n        }\n        return false;\n    };\n    /**\n     * Inserts images into our mapping, fitting them appropriately\n     */\n    PackNode.prototype.insert = function (image) {\n        if (!this.isLeaf) {\n            // Try inserting into first child\n            var newNode = this.child[0].insert(image);\n            if (newNode !== null) {\n                return newNode;\n            }\n            // No room in first so insert into second\n            return this.child[1].insert(image);\n        }\n        else {\n            // If there's already an image here, return\n            if (this.nodeImage) {\n                return null;\n            }\n            // Check the fit status of the image in this nodes rectangle space\n            var fitFlag = this.nodeDimensions.fits(image.second);\n            // If we're too small, return null indicating can not fit\n            if (fitFlag === 0) {\n                return null;\n            }\n            // If we're just right, accept\n            if (fitFlag === 1) {\n                return this;\n            }\n            // Otherwise, gotta split this node and create some leaves\n            this.isLeaf = false;\n            // Get the image width\n            var imgWidth = image.second.width;\n            var imgHeight = image.second.height;\n            // Decide which way to split\n            var dWidth = this.nodeDimensions.width - imgWidth;\n            var dHeight = this.nodeDimensions.height - image.second.height;\n            if (dWidth > dHeight) {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, imgWidth, this.nodeDimensions.height);\n                this.child[1] = new PackNode(this.nodeDimensions.x + imgWidth, this.nodeDimensions.y, dWidth, this.nodeDimensions.height);\n            }\n            else {\n                this.child[0] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y, this.nodeDimensions.width, imgHeight);\n                this.child[1] = new PackNode(this.nodeDimensions.x, this.nodeDimensions.y + imgHeight, this.nodeDimensions.width, dHeight);\n            }\n        }\n        // Insert into first child we created\n        return this.child[0].insert(image);\n    };\n    /**\n     * Removes the image from the mapping and tries to open up as much space as possible.\n     *\n     * @param {AtlasTexture} image The image to insert into the\n     */\n    PackNode.prototype.remove = function (image) {\n        if (!this.isLeaf) {\n            // Try removing from first child\n            var removed = this.child[0].remove(image);\n            if (removed) {\n                return true;\n            }\n            // Try remove from second\n            removed = this.child[1].remove(image);\n            if (!this.child[0].hasChild()) {\n                if (!this.child[1].hasChild()) {\n                    this.child[0] = null;\n                    this.child[1] = null;\n                }\n            }\n            return removed;\n        }\n        else {\n            if (this.nodeImage === image) {\n                this.nodeImage = null;\n                image.atlasReferenceID = null;\n                image.pixelWidth = 0;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    return PackNode;\n}());\nexports.PackNode = PackNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/pack-node.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar rotateable_quad_1 = require(\"../../primitives/rotateable-quad\");\nvar sprite_1 = require(\"../texture/sprite\");\nvar measurement = new sprite_1.Sprite(200, 200, 1, 1);\nvar Label = /** @class */ (function (_super) {\n    __extends(Label, _super);\n    /**\n     * Creates an instance of Label.\n     *\n     * @param {Partial<Label<T>>} [options={}]\n     */\n    function Label(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { x: 0, y: 1 }, { width: 1, height: 1 }, 0, rotateable_quad_1.AnchorPosition.TopLeft) || this;\n        _this.depth = 40;\n        _this.direction = 'inherit';\n        _this.font = 'serif';\n        _this.fontSize = 10;\n        _this.fontWeight = 400;\n        _this.maxWidth = undefined;\n        _this.text = '';\n        _this.id = '';\n        _this.textAlign = 'start';\n        _this.textBaseline = 'alphabetic';\n        _this.zoomable = false;\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to offset the rasterization if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationOffset = { x: 20, y: 0 };\n        /**\n         * This contains an adjustment to aid in the rasterization process. Getting\n         * reliable dimensions for fonts and text can be incredibly challenging,\n         * thus, this allows you to pad the rasterization space if you get pieces of\n         * the label cut off.\n         */\n        _this.rasterizationPadding = { width: 0, height: 0 };\n        // Set props\n        Object.assign(_this, options);\n        // Make sure our dimensions are set\n        _this.setFontSize(options.fontSize || 12);\n        return _this;\n    }\n    Object.defineProperty(Label.prototype, \"baseLabel\", {\n        get: function () {\n            return this._baseLabel;\n        },\n        set: function (value) {\n            this._baseLabel = value;\n            this.text = value.text;\n            this.fontSize = value.fontSize;\n            this.font = value.font;\n            this.textAlign = value.textAlign;\n            this.textBaseline = value.textBaseline;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Label.prototype, \"rasterizedLabel\", {\n        /**\n         * This getter ensures the rasterized label retrieved is either this labels own rasterization\n         * or from a base.\n         */\n        get: function () {\n            if (this.baseLabel) {\n                return this.baseLabel.rasterizedLabel;\n            }\n            return this._rasterizedLabel;\n        },\n        set: function (value) {\n            this._rasterizedLabel = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Copies all of the properties of a label and makes this label use them\n     *\n     * @param {Label} label The labels whose properties we wish to copy\n     */\n    Label.prototype.copyLabel = function (label) {\n        // Assign the properties of the other label to this\n        // Specifically, ONLY label properties\n        Object.assign(this, ramda_1.omit(['x', 'y', 'width', 'height'], label));\n        // Use this to set the text to make sure all of the metrics are re-calculated\n        this.setText(label.text);\n    };\n    /**\n     * This gets the actual text this label is capable of rendering\n     */\n    Label.prototype.getText = function () {\n        if (this._baseLabel) {\n            return this._baseLabel.getText();\n        }\n        return this.text;\n    };\n    /**\n     * Takes all of the current settings and makes a CSS font string\n     */\n    Label.prototype.makeCSSFont = function (fontSize) {\n        return this.fontWeight + \" \" + (fontSize || this.fontSize) + \"px \" + this.font;\n    };\n    /**\n     * Change the position this text is rendered to\n     *\n     * @param x X world coordinate\n     * @param y Y world coordinate\n     */\n    Label.prototype.position = function (x, y) {\n        this.x = x;\n        this.y = y;\n    };\n    /**\n     * This sets the font size for the label based on the base text dimensions\n     *\n     * @param {number} fontSize\n     */\n    Label.prototype.setFontSize = function (fontSize) {\n        var lbl = this.getText();\n        var size = this.getSize();\n        var width = size.width;\n        var height = size.height;\n        if (this.baseLabel) {\n            var baseSize = this.baseLabel.getSize();\n            var scale = fontSize / this.baseLabel.fontSize;\n            height = baseSize.height * scale;\n            width = baseSize.width * scale;\n        }\n        else {\n            measurement.context.font = this.makeCSSFont();\n            var size_1 = measurement.context.measureText(lbl);\n            // Set our properties based on the calculated size\n            height = fontSize;\n            width = size_1.width;\n        }\n        this.fontSize = fontSize;\n        this.setSize({ width: width, height: height });\n    };\n    /**\n     * Change the text and the calculated bounding box for this label\n     */\n    Label.prototype.setText = function (lbl) {\n        this.text = lbl;\n        this.setFontSize(this.fontSize);\n    };\n    Label.prototype.update = function () {\n        this.setFontSize(this.fontSize);\n        _super.prototype.update.call(this);\n    };\n    return Label;\n}(rotateable_quad_1.RotateableQuad));\nexports.Label = Label;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/label.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar bounds_1 = require(\"./bounds\");\nvar AnchorPosition;\n(function (AnchorPosition) {\n    AnchorPosition[AnchorPosition[\"BottomLeft\"] = 0] = \"BottomLeft\";\n    AnchorPosition[AnchorPosition[\"BottomRight\"] = 1] = \"BottomRight\";\n    AnchorPosition[AnchorPosition[\"Custom\"] = 2] = \"Custom\";\n    AnchorPosition[AnchorPosition[\"Middle\"] = 3] = \"Middle\";\n    AnchorPosition[AnchorPosition[\"MiddleBottom\"] = 4] = \"MiddleBottom\";\n    AnchorPosition[AnchorPosition[\"MiddleLeft\"] = 5] = \"MiddleLeft\";\n    AnchorPosition[AnchorPosition[\"MiddleRight\"] = 6] = \"MiddleRight\";\n    AnchorPosition[AnchorPosition[\"MiddleTop\"] = 7] = \"MiddleTop\";\n    AnchorPosition[AnchorPosition[\"TopLeft\"] = 8] = \"TopLeft\";\n    AnchorPosition[AnchorPosition[\"TopRight\"] = 9] = \"TopRight\";\n})(AnchorPosition = exports.AnchorPosition || (exports.AnchorPosition = {}));\nvar anchorCalculations = (_a = {},\n    _a[AnchorPosition.BottomLeft] = function (quad) { return ({\n        x: 0,\n        y: 0,\n    }); },\n    _a[AnchorPosition.BottomRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: 0,\n    }); },\n    _a[AnchorPosition.Custom] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.Middle] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleBottom] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: 0,\n    }); },\n    _a[AnchorPosition.MiddleLeft] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: quad.getSize().height / 2,\n    }); },\n    _a[AnchorPosition.MiddleTop] = function (quad) { return ({\n        x: quad.getSize().width / 2,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopLeft] = function (quad) { return ({\n        x: 0,\n        y: quad.getSize().height,\n    }); },\n    _a[AnchorPosition.TopRight] = function (quad) { return ({\n        x: quad.getSize().width,\n        y: quad.getSize().height,\n    }); },\n    _a);\nvar RotateableQuad = /** @class */ (function (_super) {\n    __extends(RotateableQuad, _super);\n    /**\n     * Generates a quad\n     *\n     * @param {IPoint} location The location of the quad (it's anchorpoint will be placed here)\n     * @param {number} width The width of the quad\n     * @param {number} height The height of the quad\n     * @param {AnchorPosition} anchor The anchor location of the quad.\n     *                                Location and rotation will be relative to this.\n     */\n    function RotateableQuad(location, size, rotation, anchor) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        // Apply our properties\n        _this.setSize(size);\n        _this.setAnchor(anchor);\n        _this.setLocation(location);\n        _this.setRotation(rotation);\n        // Update the transform and the corner vertices\n        _this.update();\n        return _this;\n    }\n    /**\n     * @private\n     * Recalculates this anchor position based on the anchor type\n     *\n     * @param {AnchorPosition} anchor\n     */\n    RotateableQuad.prototype.calculateAnchor = function (anchor) {\n        this.anchor = anchorCalculations[anchor](this);\n    };\n    /**\n     * Get the base size of the quad\n     *\n     * @returns {ISize} The base size of this quad\n     */\n    RotateableQuad.prototype.getSize = function () {\n        return this.size;\n    };\n    /**\n     * Sets the specified anchor position on the quad\n     *\n     * @param {AnchorPosition} anchor This specifies an auto calculated position for the anchor\n     * @param {IPoint} custom If specified, will set a custom anchor location rather\n     *                        than the calculated version.\n     */\n    RotateableQuad.prototype.setAnchor = function (anchor, custom) {\n        if (anchor === void 0) { anchor = AnchorPosition.Middle; }\n        this.anchorType = anchor;\n        // Apply the custom position if present\n        if (custom) {\n            this.anchorType = AnchorPosition.Custom;\n            this.anchor = custom;\n            return;\n        }\n        this.calculateAnchor(anchor);\n    };\n    RotateableQuad.prototype.getAnchor = function () {\n        return this.anchor;\n    };\n    RotateableQuad.prototype.getAnchorType = function () {\n        return this.anchorType;\n    };\n    /**\n     * This sets the location of this quad to a given position where the anchor\n     * point will be located on top of the location provided.\n     *\n     * @param {IPoint} location The location to place the quad\n     */\n    RotateableQuad.prototype.setLocation = function (location) {\n        this.location = location;\n    };\n    RotateableQuad.prototype.getLocation = function () {\n        return this.location;\n    };\n    /**\n     * Sets the rotation of this quad, in radians, rotated around the anchor point.\n     *\n     * @param {number} rotation The rotation of the quad\n     */\n    RotateableQuad.prototype.setRotation = function (rotation) {\n        this.rotation = rotation;\n    };\n    /**\n     * get Rotation\n     */\n    RotateableQuad.prototype.getRotation = function () {\n        return this.rotation;\n    };\n    /**\n     * get direction as a point\n     */\n    RotateableQuad.prototype.getDirection = function () {\n        var angle = this.rotation;\n        return {\n            x: Math.cos(angle),\n            y: Math.sin(angle),\n        };\n    };\n    /**\n     * Applies the size to the base\n     *\n     * @param {ISize} size The size of the base quad\n     */\n    RotateableQuad.prototype.setSize = function (size) {\n        this.size = size;\n        this.base = [\n            new three_1.Vector4(0, size.height, 0, 1),\n            new three_1.Vector4(size.width, size.height, 0, 1),\n            new three_1.Vector4(0, 0, 0, 1),\n            new three_1.Vector4(size.width, 0, 0, 1),\n        ];\n        if (this.anchorType) {\n            this.calculateAnchor(this.anchorType);\n        }\n    };\n    /**\n     * This re-calculates the transform for this quad and applies the transform to\n     * the corners.\n     */\n    RotateableQuad.prototype.update = function () {\n        // Calculate the pieces of the transformation\n        var anchorMat = new three_1.Matrix4().makeTranslation(this.anchor.x, -this.anchor.y, 0);\n        var rotationMat = new three_1.Matrix4().makeRotationZ(this.rotation);\n        var locationMat = new three_1.Matrix4().makeTranslation(this.location.x, this.location.y, 0);\n        // Compose the transform based on the pieces and apply them\n        // In the proper compositing order\n        this.transform = new three_1.Matrix4()\n            .multiply(locationMat)\n            .multiply(rotationMat)\n            .multiply(anchorMat);\n        // Apply the transform to all of our base vertices\n        this.TL = this.base[0].clone().applyMatrix4(this.transform);\n        this.TR = this.base[1].clone().applyMatrix4(this.transform);\n        this.BL = this.base[2].clone().applyMatrix4(this.transform);\n        this.BR = this.base[3].clone().applyMatrix4(this.transform);\n        // Update the bounds of this object\n        this.x = this.TL.x;\n        this.y = this.TL.y;\n        this.width = 1;\n        this.height = 1;\n        this.encapsulatePoints([this.TR, this.BL, this.BR]);\n    };\n    return RotateableQuad;\n}(bounds_1.Bounds));\nexports.RotateableQuad = RotateableQuad;\nvar _a;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/rotateable-quad.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A canvas element wrapper that aids in tracking a canvas element along with\n * content scaling properties.\n *\n * @class Sprite\n */\nvar Sprite = /** @class */ (function () {\n    //\n    // Ctor at the top below props\n    //\n    /**\n     * Creates an instance of Sprite.\n     *\n     * @param w             The width of the context to create\n     * @param h             The height of the context to create\n     * @param contentScaleX The content scaling of the content\n     * @param contentScaleY The content scaling of the content\n     *\n     * @memberOf Sprite\n     */\n    function Sprite(w, h, contentScaleX, contentScaleY) {\n        this.scaleX = 1;\n        this.scaleY = 1;\n        var canvas = document.createElement('canvas');\n        if (canvas) {\n            this.scaleX = contentScaleX || this.scaleX;\n            this.scaleY = contentScaleY || this.scaleY;\n            canvas.width = w * this.scaleX;\n            canvas.height = h * this.scaleY;\n            this.context = canvas.getContext('2d');\n            this.canvas = canvas;\n        }\n    }\n    /**\n     * Retrieves the content scaling of this object\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentScale = function () {\n        return {\n            x: this.scaleX,\n            y: this.scaleY,\n        };\n    };\n    /**\n     * Retrieves the size of the content ignoring scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getContentSize = function () {\n        return {\n            height: this.canvas.height,\n            width: this.canvas.width,\n        };\n    };\n    /**\n     * Retrieves the dimensional width of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getWidth = function () {\n        return this.canvas.width / this.scaleX;\n    };\n    /**\n     * Retrieves the dimensional height of the content applying scaling\n     *\n     * @readonly\n     *\n     * @memberOf Sprite\n     */\n    Sprite.prototype.getHeight = function () {\n        return this.canvas.height / this.scaleY;\n    };\n    return Sprite;\n}());\nexports.Sprite = Sprite;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/sprite.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar browser = require(\"bowser\");\nvar three_1 = require(\"three\");\nvar debug = require('debug')('CommunicationsView:Mouse');\n/** Used to adjust the base whee delta for IE browsers */\nvar IE_ADJUSTMENT = 1 / 30;\n/** Used to adjust the rates for IE 11 */\nvar OLD_IE_ADJUSTMENT = -0.25;\n// This determines how large the delta can grow to in firefox\nvar MAX_FIREFOX_WHEELDELTA = 100;\n/**\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\n */\nvar lowPassY = [0, 0, 0, 0];\n// These coefficients represent the coefficients of a FIR filter.\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\n// Attained.\nvar LOW_PASS_U0 = 0.1;\nvar LOW_PASS_U1 = 0.2;\nvar LOW_PASS_U2 = 0.2;\nvar LOW_PASS_U3 = 0.5;\nfunction normalizeFirefoxWheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = 0;\n    var deltaY = 0;\n    // Reset the filter if the direction changes to prevent lag in directional change\n    if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\n        lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\n    }\n    deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\n    // Calculate the next value output from the FIR filter\n    deltaY = (wheel.deltaY * MAX_FIREFOX_WHEELDELTA) * LOW_PASS_U0 + lowPassY[0] * LOW_PASS_U1 + lowPassY[1] * LOW_PASS_U2 + lowPassY[2] * LOW_PASS_U3;\n    // Store the value of the filter in the FIR memory bank\n    lowPassY.unshift(deltaY);\n    // Keep our FIR memory clean and only the size of the number of coefficients\n    lowPassY.pop();\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeChromeWheel(e) {\n    var wheel = e.nativeEvent;\n    return new three_1.Vector2(wheel.deltaX, -wheel.deltaY);\n}\nfunction normalizeIE11Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    var deltaY = wheel.deltaY;\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\n        }\n    }\n    return new three_1.Vector2(-deltaX, -deltaY);\n}\nfunction normalizeIE12Wheel(e) {\n    var wheel = e.nativeEvent;\n    var deltaX = wheel.deltaX, deltaY = wheel.deltaY;\n    if (deltaX === undefined) {\n        deltaX = wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n    }\n    if (deltaY === undefined) {\n        if (wheel.wheelDeltaY !== undefined) {\n            deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n        }\n        else {\n            deltaY = wheel.wheelDelta || -wheel.detail;\n        }\n    }\n    var v = new three_1.Vector2(deltaX, -deltaY);\n    v.multiplyScalar(0.25);\n    return v;\n}\n// Determine this browsers version of wheel normalization and apply it\nvar normalizeWheel;\nexports.normalizeWheel = normalizeWheel;\nif (browser.firefox) {\n    debug('Using mouse wheel for firefox');\n    exports.normalizeWheel = normalizeWheel = normalizeFirefoxWheel;\n}\nelse if (browser.msie && +browser.version >= 11) {\n    debug('Using mouse wheel for IE 11');\n    exports.normalizeWheel = normalizeWheel = normalizeIE11Wheel;\n}\nelse if (browser.msedge) {\n    debug('Using mouse wheel for MS EDGE');\n    exports.normalizeWheel = normalizeWheel = normalizeIE12Wheel;\n}\nelse {\n    debug('Using mouse wheel for Chrome');\n    exports.normalizeWheel = normalizeWheel = normalizeChromeWheel;\n}\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(e, relative) {\n    var mouseX = 0, mouseY = 0, eventX = 0, eventY = 0, object = relative || e.nativeEvent.target;\n    // Get mouse position on document crossbrowser\n    if (!e) {\n        e = window.event;\n    }\n    if (e.pageX || e.pageY) {\n        mouseX = e.pageX;\n        mouseY = e.pageY;\n    }\n    else if (e.clientX || e.clientY) {\n        mouseX = e.clientX + document.body.scrollLeft\n            + document.documentElement.scrollLeft;\n        mouseY = e.clientY + document.body.scrollTop\n            + document.documentElement.scrollTop;\n    }\n    // Get parent element position in document\n    if (object.offsetParent) {\n        do {\n            eventX += object.offsetLeft;\n            eventY += object.offsetTop;\n            object = object.offsetParent;\n        } while (object);\n    }\n    // Mouse position minus elm position is mouseposition relative to element:\n    return { x: mouseX - eventX, y: mouseY - eventY };\n}\nexports.eventElementPosition = eventElementPosition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/mouse.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../primitives/bounds\");\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nvar maxPopulation = 5;\nvar maxDepth = 10;\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nfunction filterQuery(type, queryValues) {\n    var filtered = [];\n    queryValues.forEach(function (obj) {\n        if (type.find(function (t) { return obj instanceof t; })) {\n            filtered.push(obj);\n        }\n    });\n    return filtered;\n}\nexports.filterQuery = filterQuery;\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nvar Quadrants = /** @class */ (function () {\n    /**\n     * Creates an instance of Quadrants.\n     *\n     * @param bounds The bounds this will create quandrants for\n     * @param depth  The child depth of this element\n     *\n     * @memberOf Quadrants\n     */\n    function Quadrants(bounds, depth) {\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n        var mid = bounds.mid;\n        this.TL = new Node(bounds.x, mid.x, bounds.y, mid.y, depth);\n        this.TR = new Node(mid.x, bounds.right, bounds.y, mid.y, depth);\n        this.BL = new Node(bounds.x, mid.x, mid.y, bounds.bottom, depth);\n        this.BR = new Node(mid.x, bounds.right, mid.y, bounds.bottom, depth);\n    }\n    /**\n     * Ensures all memory is released for all nodes and all references are removed\n     * to potentially high memory consumption items\n     *\n     * @memberOf Quadrants\n     */\n    Quadrants.prototype.destroy = function () {\n        this.TL.destroy();\n        this.TR.destroy();\n        this.BL.destroy();\n        this.BR.destroy();\n        this.TL = null;\n        this.TR = null;\n        this.BL = null;\n        this.BR = null;\n    };\n    return Quadrants;\n}());\nexports.Quadrants = Quadrants;\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nvar Node = /** @class */ (function () {\n    /**\n     * Creates an instance of Node.\n     *\n     * @param l     The bounding left wall of the space this node covers\n     * @param r     The bounding right wall of the space this node covers\n     * @param t     The bounding top wall of the space this node covers\n     * @param b     The bounding bottom wall of the space this node covers\n     * @param depth The depth within the quad tree this node resides\n     *\n     * @memberOf Node\n     */\n    function Node(left, right, top, bottom, depth) {\n        this.bounds = null;\n        this.children = [];\n        this.childrenProps = [];\n        this.depth = 0;\n        this.nodes = null;\n        // If params insertted\n        if (arguments.length >= 4) {\n            this.bounds = new bounds_1.Bounds(left, right, top, bottom);\n        }\n        else {\n            this.bounds = new bounds_1.Bounds(0, 1, 1, 0);\n        }\n        // Ensure the depth is set\n        this.depth = depth || 0;\n    }\n    /**\n     * Destroys this node and ensures all child nodes are destroyed as well.\n     *\n     * @memberOf Node\n     */\n    Node.prototype.destroy = function () {\n        this.children = null;\n        this.bounds = null;\n        if (this.nodes) {\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n    };\n    /**\n     * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n     * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n     * this quad tree spans (and this is the root node), the quad tree will expand to include\n     * the new child.\n     *\n     * @param child The Bounds type object to inject\n     * @param props Properties that can be retrieved with the child object if applicable\n     *\n     * @returns True if the insertion was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.add = function (child, props) {\n        // This is the entry function for adding children, so we must first expand our top node\n        // To cover the area that the child is located.\n        // If we're in bounds, then let's just add the child\n        if (child.isInside(this.bounds)) {\n            return this.doAdd(child);\n        }\n        else {\n            this.cover(child);\n            return this.add(child, props);\n        }\n    };\n    /**\n     * Adds a list of new children to this quad tree. It performs the same operations as\n     * addChild for each child in the list, however, it more efficiently recalculates the\n     * bounds necessary to cover the area the children cover.\n     *\n     * @param children      List of Bounds objects to inject\n     * @param childrenProps List of props to associate with each element\n     *\n     * @memberOf Node\n     */\n    Node.prototype.addAll = function (children, childrenProps) {\n        var _this = this;\n        // Ensure the properties are at least defined\n        childrenProps = childrenProps || [];\n        // Make sure we cover the entire area of all the children.\n        // We can speed this up a lot if we first calculate the total bounds the new children covers\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = -Number.MAX_VALUE;\n        var maxY = -Number.MAX_VALUE;\n        // Get the dimensions of the new bounds\n        children.forEach(function (child) {\n            if (child.x < minX) {\n                minX = child.x;\n            }\n            if (child.right > maxX) {\n                maxX = child.right;\n            }\n            if (child.bottom < minY) {\n                minY = child.bottom;\n            }\n            if (child.y > maxY) {\n                maxY = child.y;\n            }\n        });\n        // Make sure our bounds includes the specified bounds\n        this.cover(new bounds_1.Bounds(minX, maxX, maxY, minY));\n        // Add all of the children into the tree\n        children.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n     * This will cause all children to be re-injected into the tree.\n     *\n     * @param bounds The bounds to include in the tree's coverage\n     *\n     * @memberOf Node\n     */\n    Node.prototype.cover = function (bounds) {\n        var _this = this;\n        // If we are already covering the area: abort\n        if (bounds.isInside(this.bounds)) {\n            return;\n        }\n        // Make our bounds cover the new area\n        this.bounds.encapsulate(bounds);\n        this.bounds.x -= 1;\n        this.bounds.y += 1;\n        this.bounds.width += 2;\n        this.bounds.height += 4;\n        // Get all of the children underneath this node\n        var allChildren = this.gatherChildren([]);\n        // Destroy the split nodes\n        if (this.nodes) {\n            // Completely...destroy...\n            this.nodes.destroy();\n            this.nodes = null;\n        }\n        // Reinsert all children with the new dimensions in place\n        allChildren.forEach(function (child, index) { return _this.doAdd(child); });\n    };\n    /**\n     * When adding children, this performs the actual action of injecting the child into the tree\n     * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n     *\n     * @param child The Bounds item to inject into the tree\n     * @param props The props to remain associated with the child\n     *\n     * @returns True if the injection was successful\n     *\n     * @memberOf Node\n     */\n    Node.prototype.doAdd = function (child) {\n        // If nodes are present, then we have already exceeded the population of this node\n        if (this.nodes) {\n            if (child.isInside(this.nodes.TL.bounds)) {\n                return this.nodes.TL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.TR.bounds)) {\n                return this.nodes.TR.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BL.bounds)) {\n                return this.nodes.BL.doAdd(child);\n            }\n            if (child.isInside(this.nodes.BR.bounds)) {\n                return this.nodes.BR.doAdd(child);\n            }\n            // Otherwise, this is a child overlapping this border\n            this.children.push(child);\n            return true;\n        }\n        else if (child.isInside(this.bounds)) {\n            this.children.push(child);\n            // If we exceeded our population for this quadrant, it is time to split up\n            if (this.children.length > maxPopulation && this.depth < maxDepth) {\n                this.split();\n            }\n            return true;\n        }\n        // This is when there is something wrong with the insertted child. The bounds\n        // For the quad should have grown without issue, but in this case the bounds\n        // Could not grow to accomodate the child.\n        if (isNaN(child.width + child.height + child.x + child.y)) {\n            console.error('Child did not fit into bounds because a dimension is NaN', child);\n        }\n        else if (child.area === 0) {\n            console.error('Child did not fit into bounds because the area is zero', child);\n        }\n        // Don't insert the child and continue\n        return true;\n    };\n    /**\n     * Collects all children of all the current and sub nodes into a single list.\n     *\n     * @param list The list we must aggregate children into\n     *\n     * @return The list specified as the list parameter\n     */\n    Node.prototype.gatherChildren = function (list) {\n        list = list.concat(this.children);\n        if (this.nodes) {\n            this.nodes.TL.gatherChildren(list);\n            this.nodes.TR.gatherChildren(list);\n            this.nodes.BL.gatherChildren(list);\n            this.nodes.BR.gatherChildren(list);\n        }\n        return list;\n    };\n    /**\n     * Collects all props associated with the children. This array of props will\n     * mirror the list retrieved with gatherChildren.\n     *\n     * @param list\n     *\n     * @returns The list specified as the list paramter\n     *\n     * @memberOf Node\n     */\n    Node.prototype.gatherProps = function (list) {\n        var _this = this;\n        this.children.forEach(function (c, index) {\n            list.push(_this.childrenProps[index]);\n        });\n        if (this.nodes) {\n            this.nodes.TL.gatherProps(list);\n            this.nodes.TR.gatherProps(list);\n            this.nodes.BL.gatherProps(list);\n            this.nodes.BR.gatherProps(list);\n        }\n        return list;\n    };\n    /**\n     * Entry query for determining query type based on input object\n     *\n     * @param bounds Can be a Bounds or a Point object\n     * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n     *               information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return An array of children that intersects with the query\n     */\n    Node.prototype.query = function (bounds, visit) {\n        // Query a rectangle\n        if (bounds instanceof bounds_1.Bounds) {\n            if (bounds.hitBounds(this.bounds)) {\n                return this.queryBounds(bounds, [], visit);\n            }\n            // Return an empty array when nothing is collided with\n            return [];\n        }\n        // Query a point\n        if (this.bounds.containsPoint(bounds)) {\n            return this.queryPoint(bounds, [], visit);\n        }\n        // Return an empty array when nothing is collided with\n        return [];\n    };\n    /**\n     * Queries children for intersection with a bounds object\n     *\n     * @param b     The Bounds to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return     Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryBounds = function (b, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.hitBounds(b)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (b.hitBounds(this.nodes.TL.bounds)) {\n                this.nodes.TL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.TR.bounds)) {\n                this.nodes.TR.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BL.bounds)) {\n                this.nodes.BL.queryBounds(b, list, visit);\n            }\n            if (b.hitBounds(this.nodes.BR.bounds)) {\n                this.nodes.BR.queryBounds(b, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Queries children for intersection with a point\n     *\n     * @param p     The Point to test children against\n     * @param list  The list of children to aggregate into the query\n     * @param visit A callback function that will receive the Node as it is analyzed. This gives\n     *              information on a spatial scale, how a query reaches it's target intersections.\n     *\n     * @return      Returns the exact same list that was input as the list param\n     */\n    Node.prototype.queryPoint = function (p, list, visit) {\n        this.children.forEach(function (c, index) {\n            if (c.containsPoint(p)) {\n                list.push(c);\n            }\n        });\n        if (visit) {\n            visit(this);\n        }\n        if (this.nodes) {\n            if (this.nodes.TL.bounds.containsPoint(p)) {\n                this.nodes.TL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.TR.bounds.containsPoint(p)) {\n                this.nodes.TR.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BL.bounds.containsPoint(p)) {\n                this.nodes.BL.queryPoint(p, list, visit);\n            }\n            if (this.nodes.BR.bounds.containsPoint(p)) {\n                this.nodes.BR.queryPoint(p, list, visit);\n            }\n        }\n        return list;\n    };\n    /**\n     * Creates four sub quadrants for this node.\n     */\n    Node.prototype.split = function () {\n        // Gather all items to be handed down\n        var allChildren = this.gatherChildren([]);\n        // Gather all props for the children to be handed down as well\n        this.nodes = new Quadrants(this.bounds, this.depth + 1);\n        this.children = [];\n        this.childrenProps = [];\n        while (allChildren.length > 0) {\n            this.doAdd(allChildren.pop());\n        }\n    };\n    /**\n     * Traverses the quad tree returning every quadrant encountered\n     *\n     * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n     */\n    Node.prototype.visit = function (cb) {\n        var finished = Boolean(cb(this));\n        if (this.nodes && !finished) {\n            this.nodes.TL.visit(cb);\n            this.nodes.TR.visit(cb);\n            this.nodes.BL.visit(cb);\n            this.nodes.BR.visit(cb);\n        }\n    };\n    return Node;\n}());\nexports.Node = Node;\nvar QuadTree = /** @class */ (function (_super) {\n    __extends(QuadTree, _super);\n    function QuadTree() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QuadTree;\n}(Node));\nexports.QuadTree = QuadTree;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/quad-tree.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar curved_line_1 = require(\"../../primitives/curved-line\");\nvar line_1 = require(\"../../primitives/line\");\nvar point_1 = require(\"../../primitives/point\");\n/**\n * This defines a drawable curved line shape. It contains the information necessary\n * to efficiently render the line.\n *\n * @export\n * @class CurvedLineShape\n * @extends {CurvedLine<T>}\n * @template T An associated data type that can be linked to this shape to make data retrieval from interacting\n *             with the shape easier.\n */\nvar CurvedLineShape = /** @class */ (function (_super) {\n    __extends(CurvedLineShape, _super);\n    /**\n     * Creates an instance of CurvedLineShape.\n     *\n     * @param {ICurvedLineShapeOptions} options The options for creating this line\n     */\n    function CurvedLineShape(options) {\n        var _this = \n        // We pass our properties to the curve line but we do not let it cache it's version of the line segments\n        // As we will be constructing our own segmentation requiring a new type of cache\n        _super.call(this, options) || this;\n        /** Depeth of draw location */\n        _this.depth = 0;\n        /** How thick the line should be */\n        _this.lineWidth = 1;\n        _this.encapsulatePoints(_this.getTriangleStrip());\n        _this.cachesQuadSegments = options.cacheSegments;\n        _this.depth = options.depth || 0;\n        _this.lineWidth = options.lineWidth || 1;\n        _this.startColor = options.startColor;\n        _this.endColor = options.endColor;\n        return _this;\n    }\n    /**\n     * Returns a new instance of this object that mimicks the properties of this Object\n     *\n     * @returns {CurvedLineShape<T>} The cloned object\n     */\n    CurvedLineShape.prototype.clone = function () {\n        // Perform the clone\n        var clone = new CurvedLineShape({\n            cacheSegments: this.cachesSegments,\n            controlPoints: this.controlPoints,\n            end: this.end,\n            endColor: this.endColor,\n            lineWidth: this.lineWidth,\n            resolution: this.resolution,\n            start: this.start,\n            startColor: this.startColor,\n            type: this.type,\n        });\n        clone.d = this.d;\n        return clone;\n    };\n    /**\n     * @override\n     * See base definition\n     */\n    CurvedLineShape.prototype.distanceTo = function (point) {\n        return Math.max(0, _super.prototype.distanceTo.call(this, point) - (this.lineWidth / 2.0));\n    };\n    /**\n     * This produces a triangle strip that represents the quads that composes this line. If caching is present,\n     * subsequent calls to this method will be much faster unless the cache gets invalidated.\n     *\n     * @return {IPoint[]} The Triangle Strip of points to create the quads that make each segment of the curve\n     */\n    CurvedLineShape.prototype.getTriangleStrip = function () {\n        if (this.cachesSegments && this.cachedQuadSegments) {\n            return this.cachedQuadSegments;\n        }\n        // Make a container to hold our triangle strip info\n        var strip = [];\n        var normal = [];\n        // Start with calculating the line strip so we can use the line segments\n        // To produce the quads we need to render\n        var lineStrip = this.getLineStrip();\n        var lineWidthHalf = this.lineWidth / 2.0;\n        var line = new line_1.Line(point_1.Point.zero(), point_1.Point.zero());\n        // We make a container point for the scaling operation to reduce allocations\n        var scaledPoint = point_1.Point.zero();\n        // If the line strip is empty, then there is nothing to produce and makes\n        // Us unable to reduce the lineStrip, so return empty here\n        if (lineStrip.length < 2) {\n            return [];\n        }\n        // Calculate bisecting normal or each node\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            line.setPoints(lineStrip[i], lineStrip[i + 1]);\n            if (normal.length === 0) {\n                normal.push(line.perpendicular);\n            }\n            else {\n                // Sum of two normals of a point\n                var temp = {\n                    x: normal[i].x + line.perpendicular.x,\n                    y: normal[i].y + line.perpendicular.y,\n                };\n                // Normalize the sum of two normals\n                var sqrt = Math.sqrt(temp.x * temp.x + temp.y * temp.y);\n                temp.x = temp.x / sqrt;\n                temp.y = temp.y / sqrt;\n                normal[i] = temp;\n            }\n            normal.push(line.perpendicular);\n        }\n        // Use the new normals to generate quads\n        for (var i = 0; i < lineStrip.length - 1; i++) {\n            var previous = lineStrip[i];\n            var current = lineStrip[i + 1];\n            // TR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], -lineWidthHalf, scaledPoint), current));\n            // BR\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i + 1], lineWidthHalf, scaledPoint), current));\n            // TL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], -lineWidthHalf, scaledPoint), previous));\n            // BL\n            strip.push(point_1.Point.add(point_1.Point.scale(normal[i], lineWidthHalf, scaledPoint), previous));\n        }\n        return strip;\n    };\n    /**\n     * @override\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     */\n    CurvedLineShape.prototype.setPoints = function (start, end, controlPoints) {\n        _super.prototype.setPoints.call(this, start, end, controlPoints);\n        this.cachedQuadSegments = [];\n    };\n    return CurvedLineShape;\n}(curved_line_1.CurvedLine));\nexports.CurvedLineShape = CurvedLineShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/curved-line-shape.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interpolation_1 = require(\"../util/interpolation\");\nvar bounds_1 = require(\"./bounds\");\nvar line_1 = require(\"./line\");\nvar point_1 = require(\"./point\");\nvar debug = require('debug')('bezier');\n/**\n * This enum covers the type of curved lines that can be made. Making a specific curve\n *\n * @export\n * @enum {number}\n */\nvar CurveType;\n(function (CurveType) {\n    /** This will make the curve be generated from interpolating between the end points and provided control points */\n    CurveType[CurveType[\"Bezier\"] = 0] = \"Bezier\";\n    /**\n     * This will draw a curve as though there is a circular arc passing over the two end points. The radius of the\n     * circular arc is determined by how far the control point is from the straight line that can be made from the two\n     * end points.\n     */\n    CurveType[CurveType[\"CircularCCW\"] = 1] = \"CircularCCW\";\n    CurveType[CurveType[\"CircularCW\"] = 2] = \"CircularCW\";\n    /**\n     * This ignores the control points altogether and just created a straight line with a single segment that consists\n     * of the specified endpoints\n     */\n    CurveType[CurveType[\"Straight\"] = 3] = \"Straight\";\n})(CurveType = exports.CurveType || (exports.CurveType = {}));\n// -------[ Distance Calculating Methods ]----------------------------\n/**\n * Calculates the distance to the bezier curve by testing all of the bezier curve's segment lines\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction bezierDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a circle\n * TODO: Using the segment approach for now. Can be sped up by using circle math\n * instead\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction circularDistance(line, testPoint) {\n    // Get all of the points associated with the curve\n    var lineStrip = line.getLineStrip();\n    // Find the closest points to the mouse\n    var closestIndex = point_1.Point.getClosestIndex(testPoint, lineStrip);\n    // Calculate the lines that eminate from this point and do a distance calculation from that line\n    // Find the closest distance and use it\n    var closestDistance = Number.MAX_VALUE;\n    var straightLine;\n    if (closestIndex > 0) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex - 1]);\n        closestDistance = straightLine.distanceTo(testPoint);\n    }\n    if (closestIndex < lineStrip.length - 1) {\n        straightLine = new line_1.Line(lineStrip[closestIndex], lineStrip[closestIndex + 1]);\n        closestDistance = Math.min(closestDistance, straightLine.distanceTo(testPoint));\n    }\n    return closestDistance;\n}\n/**\n * Calculates the nearness of the line by using the properties of a straight line\n *\n * @param {CurvedLine<any>} line The curved bezier line type\n * @param {IPoint} testPoint The Point to test distance to\n *\n * @returns {number} The nearest distance from the curve to the test point\n */\nfunction straightDistance(line, testPoint) {\n    return new line_1.Line(line.start, line.end).distanceTo(testPoint);\n}\n// -------[ Segment Generating Methods ]----------------------------\n/**\n * Uses quadratic bezier principles to create the segments for a quadratic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier2Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier2(dt * i, start, lineEnd, c1));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Uses cubic bezier principles to create the segments for a cubic bezier curve\n *\n * @param {CurvedLine} line The curved line object that contains the info to produce the segments\n *\n * @returns {IPoint[]} A line strip of all the calculated points along the line\n */\nfunction makeBezier3Segments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var segments = [];\n    var dt = 1 / line.resolution;\n    var start = line.start;\n    var lineEnd = line.end;\n    var c1 = line.controlPoints[0];\n    var c2 = line.controlPoints[1];\n    for (var i = 0, end = line.resolution; i <= end; ++i) {\n        segments.push(interpolation_1.bezier3(dt * i, start, lineEnd, c1, c2));\n    }\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that follows along a circular path on the line.\n * The distance the control point is from the straight line that flows through the two\n * end points of the line determines the radius of the curvature of the line\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeCircularCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    debug('CW');\n    // Generate a line so we can have a perpendicular calculation\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        // We get the midpoint of the line as we want to align the center of the circle with this point\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        // The shortest the radius can be is the distance from the line to the mid point\n        // Anything shorter will just result in a hemisphere being rendered\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        // Get the perpendicular direction to the line so we can calculate the center of our circle\n        // From the mid point\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        // Calculate the location of the center of the circle\n        circleCenter = {\n            x: perpendicular.x * distance + midPoint.x,\n            y: perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    debug(' center of circle is %o  %o', circleCenter.x, circleCenter.y);\n    // Get the direction vector from the circle center to the first end point\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    // Get the angle of the first vector\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    // Get the direction vector from the circle center to the second end point\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    // Get the angle of the second vector\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    // Calculate how much to increment theta in our parametric circular equation\n    if (theta1 < theta2)\n        theta1 += Math.PI * 2;\n    var dTheta = (theta1 - theta2) / line.resolution;\n    debug('theta1 is %o, theta2 is %o', theta1, theta2);\n    // Compute the segments based on the information we have gathered by applying it to a circular\n    // Parametric equation\n    var segments = [];\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 - (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 - (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    // Cache the segments if specified by the curved line\n    if (line.cachesSegments) {\n        line.cachedSegments = segments;\n    }\n    debug('Generated Circular Segments: %o dTheta: %o radius: %o', segments, dTheta, radius);\n    return segments;\n}\nfunction makeCircularCCWSegments(line) {\n    if (line.cachesSegments && line.cachedSegments) {\n        return line.cachedSegments;\n    }\n    var straightLine = new line_1.Line(line.start, line.end);\n    var radius = point_1.Point.getDistance(line.start, line.controlPoints[0]);\n    var circleCenter = line.controlPoints[1];\n    if (!circleCenter) {\n        var midPoint = point_1.Point.getMidpoint(line.start, line.end);\n        var minRadius = point_1.Point.getDistance(midPoint, line.start);\n        if (radius < minRadius) {\n            radius = point_1.Point.getDistance(midPoint, line.start);\n        }\n        var perpendicular = straightLine.perpendicular;\n        var distance = Math.sqrt(radius * radius - minRadius * minRadius);\n        circleCenter = {\n            x: -perpendicular.x * distance + midPoint.x,\n            y: -perpendicular.y * distance + midPoint.y,\n        };\n        // Store the circle center as an extra control point in case the value is needed\n        // (which it often is)\n        line.controlPoints[1] = circleCenter;\n    }\n    var direction1 = point_1.Point.getDirection(circleCenter, line.start);\n    var theta1 = Math.atan2(direction1.y, direction1.x);\n    var direction2 = point_1.Point.getDirection(circleCenter, line.end);\n    var theta2 = Math.atan2(direction2.y, direction2.x);\n    if (theta2 < theta1)\n        theta2 += Math.PI * 2;\n    var dTheta = (theta2 - theta1) / line.resolution;\n    var segments = [];\n    // CCW, from end to start\n    for (var i = 0, end = line.resolution + 1; i < end; ++i) {\n        segments.push({\n            x: Math.cos(theta1 + (dTheta * i)) * radius + circleCenter.x,\n            y: Math.sin(theta1 + (dTheta * i)) * radius + circleCenter.y,\n        });\n    }\n    if (line.cachedSegments) {\n        line.cachedSegments = segments;\n    }\n    return segments;\n}\n/**\n * Makes the segments for a line that is straight, thus only 1 segments is needed\n * and will be generated.\n *\n * @param {CurvedLine<any>} line\n * @returns {IPoint[]}\n */\nfunction makeStraightSegments(line) {\n    return [line.start, line.end];\n}\n/** A quick lookup for a proper segment creating method for a curved line  */\nvar pickSegmentMethod = (_a = {},\n    _a[CurveType.Bezier] = [\n        null,\n        makeBezier2Segments,\n        makeBezier3Segments,\n    ],\n    _a[CurveType.CircularCW] = [\n        null,\n        makeCircularCWSegments,\n        makeCircularCWSegments,\n    ],\n    _a[CurveType.CircularCCW] = [\n        null,\n        makeCircularCCWSegments,\n        makeCircularCCWSegments,\n    ],\n    _a[CurveType.Straight] = [\n        makeStraightSegments,\n    ],\n    _a);\n/** A quick lookup for a proper distance calculating method for a curved line  */\nvar pickDistanceMethod = (_b = {},\n    _b[CurveType.Bezier] = bezierDistance,\n    _b[CurveType.CircularCW] = circularDistance,\n    _b[CurveType.CircularCCW] = circularDistance,\n    _b[CurveType.Straight] = straightDistance,\n    _b);\n/**\n * Defines an object which illustrates a curved line. Curved lines can be formed in many\n * ways but most often from two end points and some provided control points.\n *\n * @export\n * @class CurvedLine\n * @extends {Bounds<T>}\n * @template T An associated data type with this object. Use <never> if no data type is ever associated\n */\nvar CurvedLine = /** @class */ (function (_super) {\n    __extends(CurvedLine, _super);\n    /**\n     * Generates a primitive that describes a curved line, which is defined by the lines end points, type, and control points\n     *\n     * @param {ICurvedLineOptions} options The configuration options of this curved line\n     */\n    function CurvedLine(options) {\n        var _this = this;\n        var minX = Number.MAX_VALUE, maxX = -Number.MAX_VALUE, minY = Number.MAX_VALUE, maxY = -Number.MAX_VALUE;\n        _this = _super.call(this, minX, maxX, maxY, minY) || this;\n        // Apply the relevant properties to the curve\n        _this.cachesSegments = options.cacheSegments || false;\n        _this.type = options.type;\n        _this.resolution = options.resolution || 20;\n        // Set the metrics for this curved line\n        _this.setPoints(options.start, options.end, options.controlPoints);\n        // Set the method that will be used for calculating distance from a point\n        _this.distanceMethod = pickDistanceMethod[options.type];\n        return _this;\n    }\n    Object.defineProperty(CurvedLine.prototype, \"values\", {\n        get: function () {\n            return {\n                controlPoints: this.controlPoints,\n                end: this.end,\n                start: this.start,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Calculates the nearest distance from the provided point to this curved line\n     *\n     * @param {IPoint} point The point to test the distance from\n     *\n     * @returns {number} The calculated nearest distance from this curve to the point\n     */\n    CurvedLine.prototype.distanceTo = function (point) {\n        return this.distanceMethod(this, point);\n    };\n    /**\n     * Picks the closest line in the list to a given point\n     *\n     * @param {CurvedLine<any>[]} lines The lines to compare\n     * @param {IPoint} p The point to compare against\n     *\n     * @return {Line} The nearest line to the point\n     */\n    CurvedLine.getClosest = function (lines, point) {\n        var closestLine;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        lines.forEach(function (line) {\n            distance = line.distanceTo(point);\n            if (distance < closestDistance) {\n                closestLine = line;\n                closestDistance = distance;\n            }\n        });\n        return closestLine;\n    };\n    /**\n     * This returns the line strip that represents the curve. A line strip is specifically a group of points\n     * that forms line segments by taking the current point as one end and the previous point as the second end\n     * thus, you would start at index 1 and loop to the end to generate all of the lines composing this single\n     * line.\n     *\n     * @return {IPoint[]} All of the points in the line strip\n     */\n    CurvedLine.prototype.getLineStrip = function () {\n        return this.segmentMethod(this);\n    };\n    /**\n     * Adjusts the relevant points that defines the curve and recalculates all items necessary\n     *\n     * @param {IPoint} start\n     * @param {IPoint} end\n     * @param {IPoint[]} controlPoints\n     * @param {boolean} preventRebounding If set, this will prevent the bounds from being recalculated\n     */\n    CurvedLine.prototype.setPoints = function (start, end, controlPoints) {\n        // Apply the points\n        this.start = start;\n        this.end = end;\n        if (controlPoints.length === 0)\n            debug('start: %o, end:%o', start, end);\n        // Get the available segment methods for the given type\n        var segmentMethods = pickSegmentMethod[this.type];\n        // If we adjust the control points we need to re-evaluate the type of segment creation method we use\n        if (controlPoints) {\n            this.controlPoints = controlPoints;\n            // Get the number of control points we want to base the curve off of\n            var numControlPoints = controlPoints.length;\n            // If we have more control points than the methods available, then we use the greatest method available to best\n            // Handle as many control points as possible\n            if (numControlPoints > segmentMethods.length) {\n                numControlPoints = segmentMethods.length - 1;\n            }\n            // Set the method that will be used for generating segments\n            this.segmentMethod = segmentMethods[numControlPoints];\n            // Make sure the input wasn't bad\n            if (!this.segmentMethod) {\n                throw new Error('An Invalid number of control points was provided to a curved line. You must have at LEAST 1 control point. Or 0 for a straight line');\n            }\n            if (this.type === CurveType.Bezier) {\n                this.encapsulatePoints(controlPoints);\n            }\n            else if (this.type === CurveType.CircularCCW || this.type === CurveType.CircularCW) {\n                this.encapsulatePoints(this.getLineStrip());\n            }\n        }\n        this.encapsulatePoint(start);\n        this.encapsulatePoint(end);\n        // Invalidate caches if they exist\n        this.cachedSegments = null;\n    };\n    return CurvedLine;\n}(bounds_1.Bounds));\nexports.CurvedLine = CurvedLine;\nvar _a, _b;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/curved-line.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"./bounds\");\nvar UID = 0;\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * Generate a new Circle object\n     *\n     * @param x The center of the circle\n     * @param y The center of the circle\n     * @param r The radius of the circle\n     * @param d A data object to associate with the circle\n     */\n    function Circle(options) {\n        var _this = _super.call(this, 0, 0, 0, 0) || this;\n        /** a UID of the circle */\n        _this._id = ++UID;\n        /** Radius of the circle */\n        _this._radius = 0;\n        /** X coord of the center of the circle */\n        _this._centerX = 0;\n        /** Y coord of the center of the circle */\n        _this._centerY = 0;\n        _this._centerX = options.centerX;\n        _this._centerY = options.centerY;\n        _this._radius = options.radius;\n        _this.updateBounds();\n        return _this;\n    }\n    Object.defineProperty(Circle.prototype, \"values\", {\n        get: function () {\n            return {\n                radius: this._radius,\n                x: this._centerX,\n                y: this._centerY,\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"radius\", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (val) {\n            this._radius = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (val) {\n            this._centerX = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Circle.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (val) {\n            this._centerY = val;\n            this.updateBounds();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Tests if the specified bounds is inside this circle\n     *\n     * @param b The bounds to test against\n     */\n    Circle.prototype.boundsInside = function (b) {\n        var r2 = this._radius * this._radius;\n        var dx = b.x - this._centerX;\n        var dy = b.y - this._centerY;\n        var dy2 = dy * dy;\n        var dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.right - this._centerX;\n        dx2 = dx * dx;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dy = b.bottom - this._centerY;\n        dy2 = dy * dy;\n        if ((dx2 + dy2) > r2) {\n            return false;\n        }\n        dx = b.x - this._centerX;\n        dx2 = dx * dx;\n        return (dx2 + dy2) < r2;\n    };\n    /**\n     * Calculates the distance to a provided point\n     *\n     * @param {IPoint} p The point to calculate the distance of the middle of the\n     *                   circle to\n     * @param {boolean} notSquared Flag true to prevent the Math.sqrt operation, leaving\n     *                             the result as distance^2\n     *\n     * @return {number} The distance from mid circle to the point\n     */\n    Circle.prototype.distanceTo = function (p, notSquared) {\n        var dx = this._centerX - p.x;\n        var dy = this._centerY - p.y;\n        if (notSquared) {\n            return dx * dx + dy * dy;\n        }\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    /**\n     * Retrieves the closest circle to a provided point\n     *\n     * @param {Array} circles The circles to see who is the nearest\n     * @param {IPoint} p The point to compare the circles against for nearness\n     *\n     * @return {Circle} The nearest circle\n     */\n    Circle.getClosest = function (circles, p) {\n        var closestCircle;\n        var closestDistance = Number.MAX_VALUE;\n        var distance = 0;\n        circles.forEach(function (circle) {\n            distance = circle.distanceTo(p, true);\n            if (distance < closestDistance) {\n                closestCircle = circle;\n                closestDistance = distance;\n            }\n        });\n        return closestCircle;\n    };\n    /**\n     * Tests if this circle is colliding with the specified circle\n     *\n     * @param c The circle to test against\n     *\n     * @return {boolean} True if colliding\n     */\n    Circle.prototype.hitCircle = function (c) {\n        var totalDistance = c._radius + this._radius;\n        totalDistance *= totalDistance;\n        return this.distanceTo({ x: c._centerX, y: c._centerY }, true) < totalDistance;\n    };\n    /**\n     * @override\n     * This makes it so the test of a point tests based on a Circle shape\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.hitPoint = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * If there are multiple metrics to update for the circle, this is the most\n     * efficient way to do that as it will update it's bounds only once.\n     *\n     * @param x\n     * @param y\n     * @param r\n     */\n    Circle.prototype.position = function (x, y, r) {\n        this._centerX = x;\n        this._centerY = y;\n        this._radius = r;\n        this.updateBounds();\n    };\n    /**\n     * @override\n     * Tests if a point is inside the circle\n     *\n     * @param p The point to test if inside the circle\n     *\n     * @return True if the point is inside\n     */\n    Circle.prototype.pointInside = function (p) {\n        var r2 = this._radius * this._radius;\n        var dx = p.x - this._centerX;\n        var dy = p.y - this._centerY;\n        return (dx * dx + dy * dy) < r2;\n    };\n    /**\n     * When the circle gains different circle metrics, it's Bounds must adjust\n     * accordingly, which is what this method recalculates.\n     */\n    Circle.prototype.updateBounds = function () {\n        var radius = this._radius;\n        this.x = this._centerX - radius;\n        this.y = this._centerY - radius;\n        this.height = radius * 2;\n        this.width = radius * 2;\n    };\n    /**\n     * Pretty print the metrics of this circle\n     */\n    Circle.prototype.toString = function () {\n        return \"[Circle {x: \" + this._centerX + \", y: \" + this._centerY + \", r: \" + this._radius + \"}]\";\n    };\n    return Circle;\n}(bounds_1.Bounds));\nexports.Circle = Circle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/circle.ts\n// module id = 22\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"../../primitives/line\");\n/**\n * Defines a line that can be drawn\n */\nvar LineShape = /** @class */ (function (_super) {\n    __extends(LineShape, _super);\n    /**\n     * Generate a new line that can be drawn\n     */\n    function LineShape(options) {\n        var _this = _super.call(this, options.p1, options.p2) || this;\n        _this.depth = options.depth || 0.0;\n        _this.endColor = options.endColor;\n        _this.startColor = options.startColor;\n        _this.thickness = options.thickness || 1.0;\n        return _this;\n    }\n    /**\n     * Clones this instance of the line shape and creates a new instance of a line shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this line shape\n     */\n    LineShape.prototype.clone = function (newProperties) {\n        return Object.assign(new LineShape(this), newProperties);\n    };\n    return LineShape;\n}(line_1.Line));\nexports.LineShape = LineShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/line-shape.ts\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar shape_buffer_cache_1 = require(\"./shape-buffer-cache\");\n/** This is a part of the identifier that is used to retrieve a multibuffer's storage */\nvar multiBufferSelectionPrefix = '__mb__';\n/** This is to ensure each multibuffer gets it's own unique selection identifier */\nvar multiBufferSelectionKeyUID = 0;\nfunction getIDProp(item) {\n    return item.id;\n}\nfunction evenRoundRobinBufferAdd(item, buffers) {\n    var smallest = buffers[0].buffer.length;\n    var found = buffers[0];\n    // Look for the next buffer that has the smallest length\n    // To fill it up\n    buffers.some(function (tracker) {\n        if (tracker.buffer.length < smallest) {\n            found = tracker;\n            return true;\n        }\n        return false;\n    });\n    found.buffer.push(item);\n    return [found];\n}\nfunction noop() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // NO-OP\n}\nfunction echoBuffer(item, buffer, buffers) {\n    return [buffer];\n}\n/**\n * This class helps facilitate breaking up a potentially large shape buffer into multiple buffers.\n */\nvar MultiShapeBufferCache = /** @class */ (function (_super) {\n    __extends(MultiShapeBufferCache, _super);\n    /**\n     * Makes a new multi shape buffer for minimizing changes\n     *\n     * @param numBuffers The number of buffers this multibuffer will manage\n     */\n    function MultiShapeBufferCache(numBuffers, methods) {\n        var _this = _super.call(this) || this;\n        /** The number of buffers this multi buffer manages */\n        _this.numBuffers = 0;\n        /** UID for storing the data for this buffer in the selection */\n        _this.selectionUID = multiBufferSelectionPrefix + (++multiBufferSelectionKeyUID);\n        /**\n         * The method used to add to the buffers. This is changeable so one can implement geometric or\n         * logical adds for invalidation. This returns a list of buffers that will be invalidated from\n         * the operation. The first buffer returned in the invalidation is the strongly associated buffer\n         * to the item injected. This first buffer is the most likely buffer the item is injected into.\n         */\n        _this.addMethod = evenRoundRobinBufferAdd;\n        /**\n         * Gives an implentor opportunity to define the way an is is specified for a given item. It\n         * defaults to searching for an 'id' property on the item.\n         */\n        _this.idMethod = getIDProp;\n        /**\n         * The method that is called right after the initial buffers get constructed. This is changeable\n         * so monitors can.\n         */\n        _this.initMethod = noop;\n        /**\n         * The method that is called right before a shape is removed from a buffer.\n         * This let's the\n         */\n        _this.removeMethod = echoBuffer;\n        /**\n         * The method that is called when an item is updated. This gives a monitor a chance to invalidate\n         * a number of buffers.\n         */\n        _this.updateMethod = echoBuffer;\n        // Store the number of buffers that are created when the buffers are initialized\n        _this.numBuffers = numBuffers;\n        // Set the hook methods if any are specified\n        if (methods) {\n            _this.addMethod = methods.add || _this.addMethod;\n            _this.idMethod = methods.id || _this.idMethod;\n            _this.initMethod = methods.init || _this.initMethod;\n            _this.removeMethod = methods.remove || _this.removeMethod;\n            _this.updateMethod = methods.update || _this.updateMethod;\n        }\n        return _this;\n    }\n    /**\n     * Adds a shape to a buffer and invalidates it\n     *\n     * @param shape The shape to add to a buffer\n     */\n    MultiShapeBufferCache.prototype.addShape = function (shape) {\n        // Perform the custom add opearation\n        var buffers = this.addMethod(shape, this.store.allBuffers);\n        // Stores the shape for lookup via id\n        this.store.idToItem.set(this.idMethod(shape), shape);\n        // Stores the shape for lookup to buffer. We count the\n        // First dirty buffer as the buffer the item is the closest to\n        // Association.\n        this.store.itemToBuffer.set(shape, buffers[0]);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * Sees if there is a shape associated with this id\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.containsId = function (id) {\n        return Boolean(this.store.idToItem.get(id));\n    };\n    /**\n     * Sees if this shape has been added to this buffer or not\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.containsShape = function (shape) {\n        // Check if this multibuffer has the shape or no\n        return Boolean(this.store.itemToBuffer.get(shape));\n    };\n    /**\n     * This flags a list of buffers as dirty\n     *\n     * @param buffers\n     */\n    MultiShapeBufferCache.prototype.flagBuffersDirty = function (buffers) {\n        // Flag provided buffers as dirty\n        if (buffers) {\n            // This flags the indicated buffers as dirty\n            buffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n        else {\n            this.store.allBuffers.forEach(function (buffer) { return buffer.isDirty = true; });\n        }\n    };\n    /**\n     * @override\n     * This is called with triggers all of the updates necessary.\n     * We add in our buffer update and invalidation to this process here.\n     *\n     * @param args\n     */\n    MultiShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        // Run the generation which will trigger cache building and modding\n        _super.prototype.generate.apply(this, arguments);\n        // We now invalidate any buffers that have been flagged\n        this.processDirtyBuffers();\n    };\n    /**\n     * @override\n     * This retrieves the multibuffer for this shape buffer\n     */\n    MultiShapeBufferCache.prototype.getBuffer = function () {\n        console.warn('A multishape buffer should have getBuffers called instead');\n        return [];\n    };\n    /**\n     * Get all of the buffers.\n     * WARNING: do NOT modify the output values in any way.\n     *\n     * @return {T[][]} All of the buffers\n     */\n    MultiShapeBufferCache.prototype.getBuffers = function () {\n        if (this.store) {\n            return this.store.allBuffers.map(function (tracker) { return tracker.buffer; });\n        }\n        return [];\n    };\n    /**\n     * Returns the number of buffers this MultiShapeBuffer is managing.\n     */\n    MultiShapeBufferCache.prototype.getNumBuffers = function () {\n        return this.store.allBuffers.length;\n    };\n    /**\n     * Retrieves a shape by the given id. Is undefined if the id is not recognized.\n     *\n     * @param id\n     */\n    MultiShapeBufferCache.prototype.getShapeById = function (id) {\n        return this.store.idToItem.get(id);\n    };\n    /**\n     * This makes all buffers a part of a new array pointer thus making sure\n     * they will be committed to the gpu.\n     */\n    MultiShapeBufferCache.prototype.processDirtyBuffers = function () {\n        this.store.allBuffers.forEach(function (tracker) {\n            if (tracker.isDirty) {\n                tracker.isDirty = false;\n                tracker.buffer = [].concat(tracker.buffer);\n            }\n        });\n    };\n    /**\n     * This retrieves the storage inside the selection. If it doesn't exist,\n     * then the storage is created.\n     *\n     * @param selection\n     */\n    MultiShapeBufferCache.prototype.getStorage = function (selection) {\n        // Get the storage from the selection\n        var storage = (selection.getSelection(this.selectionUID) || [])[0];\n        // If the storage is not stored in the selection, then we create a storage and update the selection with that storage\n        if (!storage) {\n            storage = {\n                allBuffers: [],\n                idToItem: new Map(),\n                itemToBuffer: new Map(),\n            };\n            // Generate the buffers indicated\n            for (var i = 0; i < this.numBuffers; ++i) {\n                storage.allBuffers.push({\n                    buffer: [],\n                    isDirty: false,\n                });\n            }\n            // Initialize anything that may be monitoring the buffers\n            this.initMethod(storage.allBuffers);\n            // Add the storage to the selection\n            selection.select(this.selectionUID, storage);\n        }\n        // Make sure our internal pointer to the storage is set correctly\n        return (this.store = storage);\n    };\n    /**\n     * Removes a shape from the buffer it is a part of.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.removeShape = function (shape) {\n        // This is the buffer associated with the shape\n        var buffer = this.store.itemToBuffer.get(shape);\n        // Get the buffers invalidated by the remove\n        var buffers = this.removeMethod(shape, buffer, this.store.allBuffers);\n        // Clear the shape out from the buffer\n        buffer.buffer.splice(buffer.buffer.indexOf(shape), 1);\n        // Delete the item from the id lookup\n        this.store.idToItem.delete(this.idMethod(shape));\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    /**\n     * This is called to indicate an update to an item has occurred.\n     *\n     * @param shape\n     */\n    MultiShapeBufferCache.prototype.updateShape = function (shape) {\n        // Flag each element that needs updating\n        var buffers = this.updateMethod(shape, this.store.itemToBuffer.get(shape), this.store.allBuffers);\n        // Flag all of the touched buffers as dirty\n        this.flagBuffersDirty(buffers);\n    };\n    return MultiShapeBufferCache;\n}(shape_buffer_cache_1.ShapeBufferCache));\nexports.MultiShapeBufferCache = MultiShapeBufferCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/multi-shape-buffer-cache.ts\n// module id = 24\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar ShapeBufferCache = /** @class */ (function () {\n    function ShapeBufferCache() {\n        this.buffer = [];\n        this.bustCache = true;\n    }\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    ShapeBufferCache.prototype.generate = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this.bustCache) {\n            this.buildCache.apply(this, args);\n            this.bustCache = false;\n        }\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    ShapeBufferCache.prototype.buildCache = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Get the buffer the cache has generated\n     */\n    ShapeBufferCache.prototype.getBuffer = function () {\n        return this.buffer;\n    };\n    return ShapeBufferCache;\n}());\nexports.ShapeBufferCache = ShapeBufferCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/shape-buffer-cache.ts\n// module id = 25\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./webgl-surface/webgl-surface\"));\n__export(require(\"./webgl-surface/buffers\"));\n__export(require(\"./webgl-surface/drawing\"));\n__export(require(\"./webgl-surface/primitives\"));\n__export(require(\"./webgl-surface/util\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 26\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar React = require(\"react\");\nvar three_1 = require(\"three\");\nvar atlas_manager_1 = require(\"./drawing/texture/atlas-manager\");\nvar atlas_texture_1 = require(\"./drawing/texture/atlas-texture\");\nvar bounds_1 = require(\"./primitives/bounds\");\nvar frame_info_1 = require(\"./util/frame-info\");\nvar mouse_1 = require(\"./util/mouse\");\nvar quad_tree_1 = require(\"./util/quad-tree\");\nvar webgl_stat_1 = require(\"./util/webgl-stat\");\nvar debug = require('debug')('webgl-surface:GPU');\nvar debugCam = require('debug')('webgl-surface:Camera');\nvar debugLabels = require('debug')('webgl-surface:Labels');\nvar debugColors = require('debug')('webgl-surface:Colors');\n/**\n * This enum names the base methods that are passed into the applyPropsMethods\n * method. This allows subclasses to easily pick the property setting methods they need\n * from the base\n */\nvar BaseApplyPropsMethods;\n(function (BaseApplyPropsMethods) {\n    /** Initializes any context that needs to be set up before the props are set */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"INITIALIZE\"] = 0] = \"INITIALIZE\";\n    /** Moment when any buffer changes should be applied */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"BUFFERCHANGES\"] = 1] = \"BUFFERCHANGES\";\n    /** Initializes camera properties to facilitate smoothe start up */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"CAMERA\"] = 2] = \"CAMERA\";\n    /** Generates the labels as images within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"LABELS\"] = 3] = \"LABELS\";\n    /** Generates the colors within the atlas manager */\n    BaseApplyPropsMethods[BaseApplyPropsMethods[\"COLORS\"] = 4] = \"COLORS\";\n})(BaseApplyPropsMethods = exports.BaseApplyPropsMethods || (exports.BaseApplyPropsMethods = {}));\n/**\n * This enum names the base methods that are passed into the animatedMethods\n * method. This allows subsclasses to easily pick the animated methods they need\n * from the base\n */\nvar BaseAnimatedMethods;\n(function (BaseAnimatedMethods) {\n    /** Sets up the base context needed to execute most methods */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"CONTEXT\"] = 0] = \"CONTEXT\";\n    /** Sets up the inertia method for inertial panning */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"INERTIA\"] = 1] = \"INERTIA\";\n    /** Animates the postion of the camera to a destination */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"POSITION\"] = 2] = \"POSITION\";\n    /** Zooms the camera based on a point of focus */\n    BaseAnimatedMethods[BaseAnimatedMethods[\"ZOOM\"] = 3] = \"ZOOM\";\n})(BaseAnimatedMethods = exports.BaseAnimatedMethods || (exports.BaseAnimatedMethods = {}));\nfunction isAnimatedWithOptions(value) {\n    if (value.options) {\n        return true;\n    }\n    return false;\n}\nfunction isAnimated(value) {\n    if (!value.options) {\n        return true;\n    }\n    return false;\n}\n/** This is the smallest increment the zoom can make. Anything less and nothing will happen */\nvar MIN_ZOOM_INCREMENT = 0.001;\nvar BYTE_MAX = 0xFF;\nvar BACKGROUND_COLOR = new three_1.Color().setRGB(38 / BYTE_MAX, 50 / BYTE_MAX, 78 / BYTE_MAX);\n// --[ CONSTANTS ]-------------------------------------------\n// Make a container vector for performing operations within\nvar vector = new three_1.Vector3();\n// --[ SHADERS ]-------------------------------------------\n/**\n * Equivalent of Math.sign, but faster, and works in all browsers\n *\n * @param {number} value The number to determine the sign\n *\n * @return {number} Returns zero if a sign can not be determined, -1 for a negative, 1 for a positive\n */\nfunction sign(value) {\n    if (!value) {\n        return 0;\n    }\n    if (value > 0) {\n        return 1;\n    }\n    if (value < 0) {\n        return -1;\n    }\n    return 0;\n}\n/**\n * The base component for the communications view\n */\nvar WebGLSurface = /** @class */ (function (_super) {\n    __extends(WebGLSurface, _super);\n    function WebGLSurface() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** This is the atlas manager for managing images and labels rendered as textures */\n        _this.atlasManager = new atlas_manager_1.AtlasManager(2048, 2048);\n        /** Tracks the names of the atlas' generated */\n        _this.atlasNames = {\n            colors: 'colors',\n            labels: 'labels',\n        };\n        /**\n         * List of methods that execute within the animation loop. Makes adding and removing these methods\n         * simpler to manage, as well as gives a clear and optimized way of overriding existing methods\n         * or reordering their execution\n         */\n        _this.animatedMethodList = [];\n        /**\n         * If this is set to true during an animated method's lifecycle, then all subsequent animated methods\n         * will not be executed for the current frame. Upon reaching the end of the frame, the break will reset\n         * and the animated methods will attempt executing again\n         */\n        _this.animatedMethodBreak = false;\n        /**\n         * The camera that 'looks' at our world and gives us the ability to convert\n         * screen coordinates to world coordinates, and vice versa\n         */\n        _this.camera = new three_1.OrthographicCamera(0, 0, 0, 0, 0, 0);\n        /**\n         * While this number is positive it will be decremented every frame.\n         * While positive, mouse interactions will not occur. This utilizes frame ticks\n         * as SOME values and numbers settle per frame, not necessarily within timelapses.\n         * More often than not, there will only be a need for 1-2 frames of mouse disable to\n         * allow the camera to be positioned in a correct location before screen to world projections\n         * start taking place.\n         */\n        _this.disableMouseInteraction = 0;\n        /** Used to aid in mouse interactions */\n        _this.distance = 0;\n        _this.sizeCamera = null;\n        /** Keep track of the current zoom so it can be set in requestAnimationFrame */\n        _this.currentZoom = 1;\n        /** Horizontal destination the camera will pan to */\n        _this.destinationX = 0;\n        /** Vertical position the camera will pan to */\n        _this.destinationY = 0;\n        /** The destination zoom level the camera used during panning */\n        _this.destinationZoom = 1;\n        /** Is the camera currently in a panning state */\n        _this.isPanning = false;\n        /** Last known screen position of the mouse */\n        _this.lastMousePosition = { x: 0, y: 0 };\n        /** List of methods to execute when applying props */\n        _this.propsMethodList = [];\n        /** Inertial values for drag panning */\n        _this.inertia = null;\n        _this.inertiaBuild = 1.5;\n        _this.inertiaDecay = .9;\n        _this.inertiaMax = 100;\n        /**\n         * All data is put into this quad tree so we can query spatial regions for\n         * items\n         */\n        _this.quadTree = null;\n        /**\n         * True if the shift key is currently being held\n         *\n         * Panning is affected by whether or not the shift key is being held down, but\n         * I don't know how yet.\n         */\n        _this.shiftIsDown = false;\n        _this.stop = false;\n        /** The current rendered position and zoom */\n        _this.currentX = 0;\n        _this.currentY = 0;\n        _this.targetZoom = 1;\n        /** The (world) position the focus will zoom in and out of */\n        _this.previousZoomToFit = 0;\n        _this.zoomTargetX = 0;\n        _this.zoomTargetY = 0;\n        /** When this is set, the draw loop continues to run. Used by the draw loop to complete animations */\n        _this.animating = false;\n        _this.labels = [];\n        _this.labelsReady = false;\n        /**\n         * This is the latest labels loading identifier, used to determine if the labels\n         * last loaded matches the labels currently needing to be rendered.\n         */\n        _this.labelsCurrentLoadedId = 0;\n        _this.labelsLoadId = 0;\n        /** When this is set to true, the atlas with the colors is now ready to be referenced */\n        _this.colors = [];\n        _this.colorsReady = false;\n        /** Holds the items currently hovered over */\n        _this.currentHoverItems = [];\n        /** Mouse in stage or not */\n        _this.dragOver = true;\n        /** Flag for detecting whether or not webgl is supported at all */\n        /**\n         * This is the update loop that operates at the requestAnimationFrame speed.\n         * This updates the cameras current position and causes changes over time for\n         * any property that has a start and a destination.\n         */\n        _this.animate = function () {\n            if (_this.stop) {\n                return;\n            }\n            frame_info_1.FrameInfo.lastFrameTime = Date.now();\n            frame_info_1.FrameInfo.framesPlayed.set(_this, (frame_info_1.FrameInfo.framesPlayed.get(_this) || 0) + 1);\n            requestAnimationFrame(function () { return _this.animate(); });\n            var response;\n            var doDraw = false;\n            var didBreak = _this.animatedMethodList.some(function (method) {\n                if (isAnimatedWithOptions(method)) {\n                    if (method.options.labelsReady && method.options.colorsReady) {\n                        if (_this.labelsReady && _this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.labelsReady) {\n                        if (_this.labelsReady) {\n                            response = method.method();\n                        }\n                    }\n                    else if (method.options.colorsReady) {\n                        if (_this.colorsReady) {\n                            response = method.method();\n                        }\n                    }\n                }\n                else if (isAnimated(method)) {\n                    response = method();\n                }\n                // Update our draw status based on response\n                if (!doDraw) {\n                    doDraw = response.doDraw;\n                }\n                // Stop the system if needed\n                if (response.stop) {\n                    _this.stop = true;\n                }\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            // We prevent any animation loop execution if we did break\n            if (didBreak) {\n                return;\n            }\n            // Make sure all camera related uniforms are up to date\n            _this.updateCameraUniforms();\n            // Handle the deactivation period of mouse interactions by decrementing it\n            // If it's positive\n            if (_this.disableMouseInteraction > 0) {\n                _this.disableMouseInteraction--;\n            }\n            if (doDraw || _this.forceDraw) {\n                _this.forceDraw = false;\n                _this.emitViewport();\n                _this.draw();\n            }\n        };\n        /**\n         * Applies new props injected into this component.\n         *\n         * Applying new props does not entail that a re-render will happen so we\n         * handle application of props as a separate concept. Here we:\n         *\n         * set up zoom targetting and apply quested zoom levels\n         *\n         * Create our quad tree and associate properties to objects if a new dataset\n         * is provided\n         *\n         * Analyze our dataset for interesting and useful metrics such as max and mins\n         * to aid in visualization normalization\n         *\n         * @param {T} props The new properties for this component\n         */\n        _this.applyProps = function (props) {\n            debug('Applying props');\n            var response;\n            _this.propsMethodList.some(function (method) {\n                response = method(props);\n                // Stop performing\n                if (response.break) {\n                    return true;\n                }\n                return false;\n            });\n            debugCam('current cam', _this.currentX, _this.currentY, _this.destinationX, _this.destinationY);\n            debugCam('Zoom Target: [%o, %o]', _this.zoomTargetX, _this.zoomTargetY);\n            debugCam('Last Mouse: [%o, %o]', _this.lastMousePosition.x, _this.lastMousePosition.y);\n        };\n        /**\n         * This initializes the surface and calls for sub class classes to initialize\n         * their buffers\n         *\n         * @param {HTMLElement} el The DOM element this component is contained in\n         * @param {number} w The width of the rendering\n         * @param {number} h The height of the rendering\n         */\n        _this.init = function (el, w, h) {\n            if (!el || _this.scene) {\n                return;\n            }\n            _this.renderEl = el;\n            if (w === 0 || h === 0) {\n                return;\n            }\n            debug('Initializing GPU objects el: %o width: %o height: %o', el, w, h);\n            // Set up a ctx for our render space\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2.0,\n                width: w,\n                widthHalf: w / 2.0,\n            };\n            // Set up the camera now that the ctx is set up\n            _this.initCamera();\n            // Create a scene so we can add our buffer objects to it\n            // We also add the scene to the window to make threejs tools available\n            window.scene = _this.scene = new three_1.Scene();\n            // Fire our hook for starting up our specific buffer implementation\n            _this.initBuffers();\n            // FINALIZE SET UP\n            // Generate the renderer along with it's properties\n            _this.renderer = new three_1.WebGLRenderer({\n                alpha: _this.props.backgroundColor && (_this.props.backgroundColor.opacity < 1.0),\n                antialias: true,\n                preserveDrawingBuffer: true,\n            });\n            // This sets the pixel ratio to handle differing pixel densities in screens\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            // Applies the background color and establishes whether or not the context supports\n            // Alpha or not\n            if (_this.props.backgroundColor) {\n                _this.renderer.setClearColor(new three_1.Color(_this.props.backgroundColor.r, _this.props.backgroundColor.g, _this.props.backgroundColor.b), _this.props.backgroundColor.opacity);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            // We render shapes. We care not for culling.\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            // Set up DOM interaction with the renderer\n            var container = el;\n            container.appendChild(_this.renderer.domElement);\n            // Get the gl context for queries and advanced operations\n            _this.gl = _this.renderer.domElement.getContext('webgl');\n            _this.makeDraggable(document.getElementById('div'), _this);\n        };\n        /**\n         * Initializes the camera and any contexts associated with it\n         */\n        _this.initCamera = function () {\n            debug('Initializing Camera');\n            // INITIALIZE THE CAMERA\n            var h = _this.ctx.height;\n            var viewSize = h;\n            var w = _this.ctx.width;\n            var aspectRatio = w / h;\n            var viewport = {\n                aspectRatio: aspectRatio,\n                bottom: -viewSize / 2,\n                far: 10000000,\n                left: (-aspectRatio * viewSize) / 2,\n                near: -100,\n                right: (aspectRatio * viewSize) / 2,\n                top: viewSize / 2,\n                viewSize: viewSize,\n            };\n            _this.camera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.sizeCamera = new three_1.OrthographicCamera(viewport.left, viewport.right, viewport.top, viewport.bottom, viewport.near, viewport.far);\n            _this.camera.position.z = 300;\n            _this.sizeCamera.position.set(0, 0, 300);\n        };\n        /**\n         * This is executed when our rendering surface (the canvas) changes in size in any\n         * way. It will make sure our renderer matches the context to prevent scaling\n         * and other deformations.\n         */\n        _this.resizeContext = function () {\n            var w = _this.props.width;\n            var h = _this.props.height;\n            // See if a renderer even exists yet\n            if (!_this.renderer) {\n                return false;\n            }\n            var renderSize = _this.renderer.getSize();\n            // Check if the resize is needed\n            if (renderSize.width === w && renderSize.height === h) {\n                return false;\n            }\n            debug('RENDERER RESIZE');\n            _this.ctx = {\n                height: h,\n                heightHalf: h / 2,\n                width: w,\n                widthHalf: w / 2,\n            };\n            var zoom = _this.camera.zoom;\n            var position = _this.camera.position.clone();\n            _this.initCamera();\n            _this.camera.zoom = zoom;\n            _this.camera.position.set(position.x, position.y, position.z);\n            _this.camera.updateProjectionMatrix();\n            _this.renderer.setPixelRatio(window.devicePixelRatio);\n            _this.renderer.setSize(w, h);\n            _this.renderer.setFaceCulling(three_1.CullFaceNone);\n            if (_this.props.backgroundColor) {\n                var color = _this.props.backgroundColor;\n                _this.renderer.setClearColor(new three_1.Color(color.r, color.g, color.b), color.opacity < 1.0 ? color.opacity : undefined);\n            }\n            else {\n                _this.renderer.setClearColor(BACKGROUND_COLOR);\n            }\n            return true;\n        };\n        /**\n         * This method handles emitting the viewport and the current visible elements\n         * to the subclass that needs detailed information regarding the viewport.\n         */\n        _this.emitViewport = function () {\n            var tl = _this.screenToWorld(0, 0);\n            var br = _this.screenToWorld(_this.ctx.width, _this.ctx.height);\n            _this.camera.updateMatrixWorld(true);\n            var visible = _this.quadTree.query(new bounds_1.Bounds(tl.x, br.x, tl.y, br.y));\n            _this.onViewport(visible, _this.projection, _this.ctx);\n        };\n        /**\n         * Handles mouse interactions when the mouse is pressed on the canvas. This\n         * engages panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseDown = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = true;\n            _this.distance = 0;\n            _this.onMouseDown();\n        };\n        /**\n         * Handles mouse interactions when the mouse is release or left the canvas. This\n         * stops panning.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseOut = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            _this.distance = 0;\n            _this.onMouseOut();\n        };\n        /**\n         * Handles mouse interactions when the mouse is released on the canvas. This\n         * stops panning and engages click events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseUp = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            _this.isPanning = false;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            // Handle mouse interaction\n            if (_this.distance < 5) {\n                var hitInside = [];\n                // Circle Interaction\n                var hitItems = _this.quadTree.query(world);\n                for (var _i = 0, hitItems_1 = hitItems; _i < hitItems_1.length; _i++) {\n                    var item = hitItems_1[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                    }\n                }\n                // Tell the listener that the user clicked on some items\n                if (hitInside.length) {\n                    _this.onMouseUp(e, hitInside, mouse, world, _this.projection);\n                }\n                else {\n                    _this.onMouseUp(e, null, mouse, world, _this.projection);\n                }\n            }\n        };\n        /**\n         * Handles mouse interactions when the mouse is moving on the canvas. This\n         * causes panning and hover events.\n         *\n         * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React\n         */\n        _this.handleMouseMove = function (e) {\n            // Quick quit if mouse interactions are disabled\n            if (_this.disableMouseInteraction > 0) {\n                return;\n            }\n            var onMouse = _this.props.onMouse;\n            var zoom = _this.props.zoom;\n            var mouse = mouse_1.eventElementPosition(e);\n            var world = _this.screenToWorld(mouse.x, mouse.y);\n            _this.distance++;\n            debug('mouse X %o Y %o', mouse.x, mouse.y);\n            // Handle panning\n            if (_this.isPanning) {\n                debug('down and moving ~~');\n                var xDistance = (mouse.x - _this.lastMousePosition.x) / _this.targetZoom;\n                var yDistance = -(mouse.y - _this.lastMousePosition.y) / _this.targetZoom;\n                // Execute the hook to allow subclasses\n                var pan = _this.willPan(xDistance, yDistance);\n                xDistance = pan.x;\n                yDistance = pan.y;\n                _this.destinationX -= xDistance;\n                _this.destinationY -= yDistance;\n                _this.inertia = _this.inertia || { x: 0, y: 0 };\n                if (sign(xDistance) !== sign(_this.inertia.x)) {\n                    _this.inertia.x = 0;\n                }\n                if (sign(yDistance) !== sign(_this.inertia.y)) {\n                    _this.inertia.y = 0;\n                }\n                _this.inertia.x = xDistance * _this.inertiaBuild;\n                _this.inertia.y = yDistance * _this.inertiaBuild;\n                var maxInertia = _this.inertiaMax / zoom;\n                var mag = Math.sqrt(_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y);\n                // Make sure the magnitude of the inertia is less than our max allowed\n                if (mag > maxInertia) {\n                    // Since it's greater, let's confine the inertia's magnitude to the max magnitude\n                    // By normalizing the intertia vector and multilying it by the max\n                    _this.inertia.x = (_this.inertia.x / mag) * maxInertia;\n                    _this.inertia.y = (_this.inertia.y / mag) * maxInertia;\n                }\n            }\n            if (_this.quadTree && !_this.isPanning) {\n                // Empty the last hovered items to populate a new list\n                var currentHoverItems = [];\n                // Handle mouse interaction with items\n                // Interaction with circles\n                var hitItems = _this.quadTree.query(world);\n                var hitInside = [];\n                for (var _i = 0, hitItems_2 = hitItems; _i < hitItems_2.length; _i++) {\n                    var item = hitItems_2[_i];\n                    // Fine tuning for interaction\n                    if (item.pointInside(world)) {\n                        hitInside.push(item);\n                        currentHoverItems.push(item);\n                    }\n                }\n                // Inform of all items hit or hovered\n                _this.onMouseHover(hitInside, mouse, world, _this.projection);\n                // Diff the currently hovered items with the old ones to see what is\n                // No longer hit\n                var left = [];\n                for (var _a = 0, _b = _this.currentHoverItems; _a < _b.length; _a++) {\n                    var item = _b[_a];\n                    if (currentHoverItems.indexOf(item) < 0) {\n                        left.push(item);\n                    }\n                }\n                // Inform of all items no longer hovered\n                _this.onMouseLeave(left, mouse, world, _this.projection);\n                _this.currentHoverItems = currentHoverItems;\n            }\n            if (onMouse) {\n                _this.onMouse(mouse, world, _this.isPanning);\n            }\n            _this.lastMousePosition = mouse;\n        };\n        /**\n         * We make the ref application be a declared function so react does not find the need to execute the\n         * application numerous times for a detected changed method\n         *\n         * @param {HTMLElement} n This is the canvas element from the dom\n         */\n        _this.applyRef = function (n) {\n            _this.init(n, _this.props.width, _this.props.height);\n            _this.applyProps(_this.props);\n        };\n        return _this;\n    }\n    /**\n     * This is a hook so subclasses can contribute animated methods to the animation loop and organize the base methods\n     * as desired.\n     *\n     * @param {AnimatedMethodLookup} baseAnimatedMethods The base animated methods referenceable by name\n     * @param {AnimatedMethod[]} orderedBaseAnimatedMethods The base animated methods in their default order for ease of use\n     *\n     * @return {AnimatedMethods[]} The list of animated methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.animatedMethods = function (baseAnimatedMethods, orderedBaseAnimatedMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBaseAnimatedMethods;\n    };\n    /**\n     * This generates the base animated methods lookup.\n     * We do not make these methods a part of the class as this is the base class\n     * We want the start up methods to be inconsequential to sub classes, thus allowing\n     * us to override, sort, or replace the initial methods and have the method get garbage\n     * collected and no longer a part of the object. It is recommended to make the sub classes\n     * actually point to class methods for better clarity\n     *\n     * @return {ANimatedMethodLookup} The base animated methods in a lookup\n     */\n    WebGLSurface.prototype.animatedMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            // Context changes and early checks\n            _a[BaseAnimatedMethods.CONTEXT] = function () {\n                var response = {\n                    break: false,\n                    doDraw: false,\n                };\n                if (_this.resizeContext()) {\n                    response.doDraw = true;\n                }\n                // Quadtree MUST be present to do proper computations\n                if (!_this.quadTree) {\n                    response.break = true;\n                }\n                return response;\n            },\n            // Apply inertia\n            _a[BaseAnimatedMethods.INERTIA] = function () {\n                if (!_this.isPanning) {\n                    if (_this.inertia) {\n                        // Disabled inertia for now\n                        // This.destinationX -= this.inertia.x\n                        // This.destinationY -= this.inertia.y\n                        _this.inertia.x *= _this.inertiaDecay;\n                        _this.inertia.y *= _this.inertiaDecay;\n                        if (_this.inertia.x * _this.inertia.x + _this.inertia.y * _this.inertia.y < 1) {\n                            _this.inertia = null;\n                        }\n                    }\n                }\n                // A non response\n                return {\n                    doDraw: false,\n                };\n            },\n            // Apply position\n            _a[BaseAnimatedMethods.POSITION] = function () {\n                // If values are transitioned rather than immediately applied, this is\n                // The value you would want the minimum change to be before cutting off\n                // The transition\n                // Const minAdjust = 1 / this.props.zoom\n                // If there is change in X apply the new position to the old\n                // This is where animated values were originally placed and can be placed\n                // Again if a transition is desired\n                var response = {\n                    doDraw: (_this.currentX !== _this.destinationX) || (_this.currentY !== _this.destinationY),\n                };\n                _this.currentX = _this.destinationX;\n                _this.currentY = _this.destinationY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            // Apply zooming\n            _a[BaseAnimatedMethods.ZOOM] = function () {\n                var response = {\n                    doDraw: false,\n                };\n                // Apply Zoom\n                // Const zoomToFitH = this.ctx.width / Math.max(this.quadTree.bounds.width, this.props.viewport.width);\n                // Const zoomToFitV = this.ctx.height / Math.max(this.quadTree.bounds.height, this.props.viewport.height);\n                // Const zoomToFit = Math.min(zoomToFitH, zoomToFitV);\n                var zoomToFit = 1;\n                var destZoom = _this.destinationZoom * zoomToFit;\n                var dZoom = Math.abs(destZoom - _this.targetZoom);\n                var minDZoom = MIN_ZOOM_INCREMENT;\n                var zoomRate = 3;\n                if (dZoom > minDZoom) {\n                    _this.targetZoom = _this.targetZoom + ((destZoom - _this.targetZoom) / zoomRate);\n                    response.doDraw = true;\n                }\n                else if (dZoom !== 0) {\n                    _this.targetZoom = destZoom;\n                    response.doDraw = true;\n                }\n                // Get the zoom target metrics before zooming\n                var zoomTargetX = _this.zoomTargetX;\n                var zoomTargetY = _this.zoomTargetY;\n                var screenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Update the camera zoom level\n                _this.zoomCamera(_this.targetZoom);\n                // After we have zoomed we see how much our target location moved on screen\n                var newScreenZoomTarget = _this.worldToScreen(zoomTargetX, zoomTargetY);\n                // Now we move our screen by the moved delta to keep it exactly where it was before hand\n                var zoomDX = -(newScreenZoomTarget.x - screenZoomTarget.x) / _this.targetZoom;\n                var zoomDY = (newScreenZoomTarget.y - screenZoomTarget.y) / _this.targetZoom;\n                _this.currentX -= zoomDX;\n                _this.currentY -= zoomDY;\n                _this.destinationX -= zoomDX;\n                _this.destinationY -= zoomDY;\n                _this.positionCamera(_this.currentX, _this.currentY);\n                return response;\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for subclasses to be able to apply buffer changes that rely\n     * on colors rendered into the atlas after the system has prepped the colors for render.\n     */\n    WebGLSurface.prototype.applyColorBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * This is a hook for subclasses to be able to apply label buffer changes after the system has\n     * prepped the labels for render.\n     */\n    WebGLSurface.prototype.applyLabelBufferChanges = function (props) {\n        // Note: For subclasses\n    };\n    /**\n     * @override\n     * This is a hook so subclasses can contribute property application methods to the applyProps process and organize the base methods\n     * as desired.\n     *\n     * @param {ApplyPropsMethodLookup<T>} basePropsMethods The base props methods referenceable by name\n     * @param {ApplyPropsMethod<T>[]} orderedBasePropsMethods The base animated methods in their default order for ease of use\n     *\n     * @return {ApplyPropsMethod<T>[]} The list of property application methods in the order they are expected to be executed\n     */\n    WebGLSurface.prototype.applyPropsMethods = function (basePropsMethods, orderedBasePropsMethods) {\n        // Default functionality is to use the simple preordered list\n        return orderedBasePropsMethods;\n    };\n    /**\n     * This is a hook so subclasses can contribute methods to the applying props procedure and organize the base methods\n     * as desired.\n     *\n     * @return {ApplyPropsMethodLookup<T>} The base apply props method that are indexed for ease of reference\n     */\n    WebGLSurface.prototype.applyPropsMethodsBase = function () {\n        var _this = this;\n        return _a = {},\n            _a[BaseApplyPropsMethods.INITIALIZE] = function (props) {\n                var backgroundColor = props.backgroundColor, height = props.height, width = props.width;\n                _this.init(_this.renderEl, width, height);\n                if (!_this.renderEl || width === 0 || height === 0) {\n                    return {\n                        break: true,\n                    };\n                }\n                // Get the target for zooming\n                if (_this.camera) {\n                    var world = _this.screenToWorld(_this.lastMousePosition.x, _this.lastMousePosition.y);\n                    _this.zoomTargetX = world.x;\n                    _this.zoomTargetY = world.y;\n                }\n                if (_this.renderer && backgroundColor) {\n                    var oldColor = _this.props.backgroundColor || {\n                        b: BACKGROUND_COLOR.b,\n                        g: BACKGROUND_COLOR.g,\n                        opacity: 1.0,\n                        r: BACKGROUND_COLOR.r,\n                    };\n                    var same = oldColor.r === backgroundColor.r &&\n                        oldColor.g === backgroundColor.g &&\n                        oldColor.b === backgroundColor.b &&\n                        oldColor.opacity === backgroundColor.opacity;\n                    if (!same) {\n                        _this.renderer.setClearColor(new three_1.Color(backgroundColor.r, backgroundColor.g, backgroundColor.b), \n                        // Only if a transparent background is specified should we\n                        // Allow the parameter. We avoid the parameter to ensure\n                        // Transparent mode it not activated unless absolutely necessary\n                        backgroundColor.opacity < 1 ? backgroundColor.opacity : undefined);\n                    }\n                }\n                debug('props', props);\n                return {};\n            },\n            _a[BaseApplyPropsMethods.LABELS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.labels && props.labels !== _this.labels) {\n                    debugLabels('Labels are being comitted to an Atlas %o', props.labels);\n                    // Flag the labels as incapable of rendering\n                    _this.labelsReady = false;\n                    _this.labelsLoadId++;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.labels = props.labels;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.labels)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.labels);\n                    }\n                    var textures = props.labels.map(function (label) { return new atlas_texture_1.AtlasTexture(null, label); });\n                    debugLabels('Creating the atlas for labels based on these textures %o', textures);\n                    _this.atlasManager.createAtlas(_this.atlasNames.labels, textures)\n                        .then(function () {\n                        debugLabels('Labels rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.labels));\n                        _this.forceDraw = true;\n                        _this.labelsCurrentLoadedId++;\n                        // If we are done loading AND we match up with the current load id, then labels\n                        // For the latest labels update are indeed ready for display\n                        if (_this.labelsCurrentLoadedId === _this.labelsLoadId) {\n                            _this.labelsReady = true;\n                        }\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.COLORS] = function (props) {\n                var response = {};\n                // If we have a new labels reference we must regenerate the labels in our image lookup\n                if (props.colors && props.colors !== _this.colors) {\n                    debugColors('Colors are being comitted to an Atlas %o', props.colors);\n                    // Flag the labels as incapable of rendering\n                    _this.colorsReady = false;\n                    // Store the set of labels we are rendering so that they do not get re-generated\n                    // In the atlas rapidly.\n                    _this.colors = props.colors;\n                    if (_this.atlasManager.getAtlasTexture(_this.atlasNames.colors)) {\n                        _this.atlasManager.destroyAtlas(_this.atlasNames.colors);\n                    }\n                    debugColors('Creating the atlas for colors based on these colors %o', _this.colors);\n                    _this.atlasManager.createAtlas(_this.atlasNames.colors, null, _this.colors)\n                        .then(function () {\n                        debugColors('Colors rasterized within the atlas: %o', _this.atlasManager.getAtlasTexture(_this.atlasNames.colors));\n                        _this.forceDraw = true;\n                        _this.colorsReady = true;\n                        // Reapply the props so any buffers that were not updating can update now\n                        _this.applyProps(_this.props);\n                    });\n                }\n                return response;\n            },\n            _a[BaseApplyPropsMethods.BUFFERCHANGES] = function (props) {\n                // Call the hook to allow sub componentry to have a place to update it's buffers\n                _this.applyBufferChanges(props);\n                // We call the label buffering when the labels are ready to render.\n                // Labels now utilize the color atlas as well, thus requiring colors\n                // To be loaded\n                if (_this.labelsReady && _this.colorsReady) {\n                    debugLabels('labels changed %o', props);\n                    _this.applyLabelBufferChanges(props);\n                }\n                // For resources that only need the color atlas to be ready\n                if (_this.colorsReady) {\n                    _this.applyColorBufferChanges(props);\n                }\n                return {};\n            },\n            _a[BaseApplyPropsMethods.CAMERA] = function (props) {\n                _this.destinationZoom = props.zoom;\n                // On initialization this should start with some base camera metrics\n                if (props.viewport && props.viewport !== _this.appliedViewport && _this.quadTree) {\n                    debugCam('Applying viewport to camera: %o World Space Bounds: %o Screen context: %o', props.viewport, _this.quadTree.bounds, { width: props.width, height: props.height });\n                    // Position the camera over the mid of the specified viewport\n                    var mid = props.viewport.mid;\n                    _this.currentX = _this.destinationX = mid.x;\n                    _this.currentY = _this.destinationY = mid.y;\n                    // Calculate the zoom level when the input zoom is at 1\n                    var zoomAtOne = 1;\n                    // Calculate the zoom needed for the viewport\n                    var zoomToFitViewH = props.width / props.viewport.width;\n                    var zoomToFitViewV = props.height / props.viewport.height;\n                    var zoomToFit = Math.min(zoomToFitViewH, zoomToFitViewV);\n                    // This adjusts the destination zxoom by a tiny amount so the view will redraw\n                    var microAdjustment = 1.001;\n                    // Make our destination zoom a zoom that will fit the dimensions of the viewport\n                    // Relative to the zoom at one level\n                    _this.destinationZoom = zoomToFit / zoomAtOne;\n                    _this.targetZoom = (_this.destinationZoom * zoomAtOne) * microAdjustment;\n                    // Make sure any zooming that happens occurs over the middle of the initial viewport\n                    _this.zoomTargetX = mid.x;\n                    _this.zoomTargetY = mid.y;\n                    // Make sure mouse position doesn't mess with the zooming focus either\n                    _this.lastMousePosition.x = props.width / 2.0;\n                    _this.lastMousePosition.y = props.height / 2.0;\n                    // Apply the values immediately to the camera\n                    _this.positionCamera(_this.currentX, _this.currentY);\n                    _this.zoomCamera(_this.targetZoom);\n                    _this.updateCameraUniforms();\n                    // We request the calculated zoom level so adjustments on the input can be made\n                    if (props.onZoomRequest) {\n                        props.onZoomRequest(_this.destinationZoom);\n                        debugCam('Requesting zoom level', _this.destinationZoom);\n                    }\n                    // Let's disable mouse interactions for a little bit until the camera has settled into place\n                    var framesToDisable = 10;\n                    _this.disableMouseInteraction = framesToDisable;\n                    _this.appliedViewport = props.viewport;\n                    debugCam('init cam', _this.currentX, _this.currentY);\n                }\n                // Ensure we have our quad tree available even if it is empty\n                if (!_this.quadTree) {\n                    _this.quadTree = new quad_tree_1.QuadTree(0, 1, 1, 0);\n                }\n                return {};\n            },\n            _a;\n        var _a;\n    };\n    /**\n     * This is a hook for sub components to have a location to update their buffers\n     *\n     * @param {T} props This is the next set of props that are going to be applied to this component\n     */\n    WebGLSurface.prototype.applyBufferChanges = function (props) {\n        // NOTE: This will be implemented by base classes\n    };\n    /**\n     * @override\n     * Start the update loop and register any interesting listeners\n     */\n    WebGLSurface.prototype.componentDidMount = function () {\n        this.animate();\n    };\n    /**\n     * @override\n     * This will set up any unchanging context as well as establish the set of methods\n     * that are to be used within constructed method loops.\n     */\n    WebGLSurface.prototype.componentWillMount = function () {\n        /** Create our context bound projection methods for handing to processes that may need them */\n        this.projection = {\n            screenSizeToWorld: this.screenSizeToWorld.bind(this),\n            screenToWorld: this.screenToWorld.bind(this),\n            worldSizeToScreen: this.worldSizeToScreen.bind(this),\n            worldToScreen: this.worldToScreen.bind(this),\n        };\n        /** Generate our applying props methods to execute within our applyProps process */\n        var basePropsMethods = this.applyPropsMethodsBase();\n        this.propsMethodList = this.applyPropsMethods(basePropsMethods, [\n            basePropsMethods[BaseApplyPropsMethods.INITIALIZE],\n            basePropsMethods[BaseApplyPropsMethods.LABELS],\n            basePropsMethods[BaseApplyPropsMethods.COLORS],\n            basePropsMethods[BaseApplyPropsMethods.BUFFERCHANGES],\n            basePropsMethods[BaseApplyPropsMethods.CAMERA],\n        ]);\n        /** Generate our animated methods to execute within our animation loop */\n        var baseAnimatedMethods = this.animatedMethodsBase();\n        this.animatedMethodList = this.animatedMethods(baseAnimatedMethods, [\n            baseAnimatedMethods[BaseAnimatedMethods.CONTEXT],\n            baseAnimatedMethods[BaseAnimatedMethods.INERTIA],\n            baseAnimatedMethods[BaseAnimatedMethods.POSITION],\n            baseAnimatedMethods[BaseAnimatedMethods.ZOOM],\n        ]);\n    };\n    /**\n     * @override\n     * Simply applies the new injected props\n     *\n     * @param {T} props The new properties to be applied to this component\n     */\n    WebGLSurface.prototype.componentWillReceiveProps = function (props) {\n        this.applyProps(props);\n    };\n    /**\n     * @override\n     * Release listeners and stop update loop\n     */\n    WebGLSurface.prototype.componentWillUnmount = function () {\n        this.stop = true;\n        if (this.quadTree) {\n            this.quadTree.destroy();\n        }\n        this.quadTree = null;\n        this.camera = null;\n        this.sizeCamera = null;\n        this.ctx = null;\n        this.renderEl = null;\n        this.renderer = null;\n        this.scene = null;\n        this.atlasManager.destroyAtlas(this.atlasNames.colors);\n        this.atlasManager.destroyAtlas(this.atlasNames.labels);\n        frame_info_1.FrameInfo.framesPlayed.delete(this);\n    };\n    /**\n     * This is the draw method executed from the animation loop. Everytime, this is\n     * called, the webgl surface will be redrawn.\n     */\n    WebGLSurface.prototype.draw = function () {\n        // Draw the 3D scene\n        this.renderer.render(this.scene, this.camera);\n        if (this.props.onRender && (this.colorsReady || this.colors.length === 0)\n            && (this.labelsReady || this.labels.length === 0)) {\n            var imageData = this.renderer.domElement.toDataURL();\n            this.props.onRender(imageData);\n        }\n    };\n    /**\n     * This is a hook allowing sub classes to have a place to initialize their buffers\n     * and materials etc.\n     */\n    WebGLSurface.prototype.initBuffers = function () {\n        // NOTE: This is to be implemented by subclasses\n    };\n    /**\n     * Hook for subclasses to when the mouse moves. Provides some information\n     * about mouse location and interaction.\n     *\n     * @param {IPoint} mouse Position of the mouse relative to the canvas\n     * @param {IPoint} world Position of the mouse relative to the world space\n     * @param {boolean} isPanning The panning state of the mouse\n     */\n    WebGLSurface.prototype.onMouse = function (mouse, world, isPanning) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse down events\n     */\n    WebGLSurface.prototype.onMouseDown = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse out events\n     */\n    WebGLSurface.prototype.onMouseOut = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to mouse up events and the items that were interacted with in the process\n     *\n     * @param {React.MouseEvent} e The react synthetic event associated with the action\n     * @param {Bounds[]} hitInside The items the mouse interacted with\n     * @param {IPoint} mouse The location of the mouse on the screen\n     * @param {IPoint} world The location of the mouse projected into the world\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseUp = function (e, hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse hovering over an item included in the quadtree\n     *\n     * @param {Bounds[]} hitInside The items hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseHover = function (hitInside, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to the mouse leaving an item included in the quadtree\n     *\n     * @param {Bounds[]} left The items no longer hovered over by the mouse\n     * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas\n     * @param {IPoint} world The location of the mouse projected to the world coordinates\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     */\n    WebGLSurface.prototype.onMouseLeave = function (left, mouse, world, projection) {\n        // NOTE: For subclasses\n    };\n    /**\n     * Hook for subclasses to respond to changes in the viewport and currently visible items\n     *\n     * @param {Bounds[]} visible\n     * @param {IProjection} projection The projection methods to go between the screen and world space\n     * @param {IScreenContext} ctx\n     */\n    WebGLSurface.prototype.onViewport = function (visible, projection, ctx) {\n        // NOTE: For subclasses\n    };\n    WebGLSurface.prototype.makeDraggable = function (element, stage) {\n        element.onmousedown = function (event) {\n            debug('DRAG~');\n            stage.dragOver = false;\n            document.onmousemove = function (event) {\n                debug('Move');\n                var mouseX = event.clientX;\n                var mouseY = event.clientY + window.scrollY;\n                var distanceX = (mouseX - stage.lastMousePosition.x) / stage.targetZoom;\n                var distanceY = (mouseY - stage.lastMousePosition.y) / stage.targetZoom;\n                stage.destinationX -= distanceX;\n                stage.destinationY += distanceY;\n                stage.lastMousePosition.x = mouseX;\n                stage.lastMousePosition.y = mouseY;\n            };\n            document.onmouseup = function () {\n                debug('Up');\n                document.onmousemove = null;\n                stage.isPanning = false;\n                stage.dragOver = true;\n            };\n            document.onmouseover = function () {\n                debug('Over');\n                if (stage.dragOver === false)\n                    stage.isPanning = true;\n            };\n            element.onmouseup = function () {\n                stage.dragOver = true;\n            };\n            // Text will not be selected when it is being dragged\n            element.onselectstart = function () { return false; };\n        };\n    };\n    /**\n     * Places the camera at a given location in world space\n     *\n     * @param {number} x The x-coordinate for the camera in world space\n     * @param {number} y The x-coordinate for the camera in world space\n     */\n    WebGLSurface.prototype.positionCamera = function (x, y) {\n        if (this.camera) {\n            this.camera.position.set(x, y, this.camera.position.z);\n        }\n    };\n    /**\n     * Projects a screen coordinate to a world coordinate\n     *\n     * @param {number} x The x coord within the screen to project into the world\n     * @param {number} y The y coord within the screen to project into the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenToWorld = function (x, y, obj) {\n        // Get the coordinates in normalized screen space\n        vector.set((x / this.ctx.width) * 2 - 1, -(y / this.ctx.height) * 2 + 1, 0.0);\n        // Unproject the normalized space to the world. It will project\n        // The vector to a REALLY far away z coordinate, but it does not matter\n        // Since we are utilizing an orthographic camera (no perspective distortion)\n        vector.unproject(this.camera);\n        obj = obj || { x: 0, y: 0 };\n        obj.x = vector.x;\n        obj.y = vector.y;\n        return obj;\n    };\n    /**\n     * Projects a size on the screen to the size represented in the world\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.screenSizeToWorld = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        obj.height = h / (this.sizeCamera ? this.sizeCamera.zoom : 1);\n        return obj;\n    };\n    /**\n     * Projects a world coordinate to the screen\n     *\n     * @param {number} x The x coord in the world to project to the screen\n     * @param {number} y The y coord in the world to project to the screen\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {IPoint} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldToScreen = function (x, y, obj) {\n        // This projects to NORMALIZED screen space (-1, 1) range for x and y\n        vector.set(x, y, 0);\n        vector.project(this.camera);\n        // Use the window dimensions to denormalize the vector\n        obj = ramda_1.merge(obj || {}, {\n            x: (vector.x * this.ctx.widthHalf) + this.ctx.widthHalf,\n            y: -(vector.y * this.ctx.heightHalf) + this.ctx.heightHalf,\n        });\n        return obj;\n    };\n    /**\n     * Projects a size within the world to how it would appear on the screen\n     *\n     * @param {number} w The size of the width on the screen to project to the world\n     * @param {number} h The size of the height on the screen to project to the world\n     * @param {object} obj An optional object in which the projected dimensions will\n     *                     be injected to\n     *\n     * @return {object} Either a new object with the projected dimensions or the object\n     *                  Insertted as a param that has the properties injected into\n     */\n    WebGLSurface.prototype.worldSizeToScreen = function (w, h, obj) {\n        obj = obj || new bounds_1.Bounds(0, 0, 0, 0);\n        obj.width = w * this.sizeCamera.zoom;\n        obj.height = h * this.sizeCamera.zoom;\n        return obj;\n    };\n    /**\n     * Sets the zoom level the camera will view the world with\n     *\n     * @param {number} zoom The zoom level. Must be > 0\n     */\n    WebGLSurface.prototype.zoomCamera = function (zoom) {\n        this.camera.zoom = zoom;\n        this.sizeCamera.zoom = zoom;\n        this.camera.updateProjectionMatrix();\n        this.sizeCamera.updateProjectionMatrix();\n    };\n    /**\n     * This is a hook allowing a sub class to update uniforms when the camera is changed in\n     * any way\n     */\n    WebGLSurface.prototype.updateCameraUniforms = function () {\n        // NOTE: For subclasses\n    };\n    /**\n     * @override\n     * Only re-render if the dimensions of the component have changed. All other\n     * internal render updates are handled internally\n     *\n     * @param {T} nextProps The next properties injected\n     */\n    WebGLSurface.prototype.shouldComponentUpdate = function (nextProps) {\n        return this.props.width !== nextProps.width || this.props.height !== nextProps.height;\n    };\n    /**\n     * Hook to allow subclasses some control over panning distances\n     *\n     * @param {number} distanceX The distance to pan in the x direction\n     * @param {number} distanceY The distance to pan in the y direction\n     *\n     * @return {Vector3} The vector indicating the direction to pan\n     */\n    WebGLSurface.prototype.willPan = function (distanceX, distanceY) {\n        return new three_1.Vector3(distanceX, distanceY, 0.0);\n    };\n    // -----[ Render ]---------------------------------------------\n    //\n    // In a React app, it's nice to put the render function at the bottom of the\n    // File\n    /**\n     * This should only attempt rendering when the canvas DOM element needs to be resized.\n     * You will note shouldComponentUpdate helps facilitate this.\n     */\n    WebGLSurface.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, width = _a.width, height = _a.height;\n        if (!webgl_stat_1.WebGLStat.WEBGL_SUPPORTED) {\n            return React.createElement(\"div\", null, this.props.children || 'Web GL not supported');\n        }\n        return (React.createElement(\"div\", { id: \"div\", onMouseDown: this.handleMouseDown, onMouseOut: this.handleMouseOut, onMouseUp: this.handleMouseUp, onMouseLeave: this.handleMouseOut, onMouseMove: this.handleMouseMove, onDoubleClick: function (e) {\n                if (_this.props.onDoubleClick) {\n                    _this.props.onDoubleClick(e);\n                }\n            }, style: { position: 'relative', width: width, height: height } },\n            React.createElement(\"div\", { ref: this.applyRef })));\n    };\n    return WebGLSurface;\n}(React.Component));\nexports.WebGLSurface = WebGLSurface;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/webgl-surface.tsx\n// module id = 27\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_28__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 28\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3-color\"\n// module id = 29\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 30\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/debug.js\n// module id = 31\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms/index.js\n// module id = 32\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_33__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bowser\"\n// module id = 33\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./animated/shared-control-curved-line-buffer-ants\"));\n__export(require(\"./animated/shared-control-curved-line-colors-buffer\"));\n__export(require(\"./base-buffer\"));\n__export(require(\"./static/shared-control-curved-line-buffer\"));\n__export(require(\"./static/simple-bezier-line-buffer\"));\n__export(require(\"./static/simple-circle-buffer\"));\n__export(require(\"./static/simple-label-buffer\"));\n__export(require(\"./static/simple-line-buffer\"));\n__export(require(\"./static/simple-straight-line-buffer\"));\n__export(require(\"./static/uniform-instance-arc-buffer\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/index.ts\n// module id = 34\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBufferAnts = /** @class */ (function (_super) {\n    __extends(SharedControlCurvedLineBufferAnts, _super);\n    function SharedControlCurvedLineBufferAnts() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBufferAnts.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'marching',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBufferAnts.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (shapeBuffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\n            var colorRef = shapeBuffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var marchingAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var antLength;\n        var antGap;\n        var antSpeed;\n        var controlPoint;\n        var controlRef;\n        // We can not accurately send very large numbers via float point into the attributes\n        // So we trim down our time sent to the attribute down to a number that is less than\n        // 16,777,217 which means we can only reliably grab the last 7 digits of the date's time\n        var antStartTime = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            // We will not render the curved line with this buffer if the marching ants are not provided\n            if (!curvedLine.marchingAnts) {\n                console.error('Attempted to render a curved line shape with a marching ant buffer but provided no marching ant metrics. This curved line shape will be skipped', curvedLine);\n                return \"continue\";\n            }\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            antGap = curvedLine.marchingAnts.gapLength;\n            antSpeed = curvedLine.marchingAnts.speed;\n            antLength = curvedLine.marchingAnts.strokeLength + curvedLine.marchingAnts.gapLength;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, marching, mpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                marching[mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                marching[++mpos] = antStartTime;\n                marching[++mpos] = antSpeed;\n                marching[++mpos] = antGap;\n                marching[++mpos] = antLength;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                mpos += marchingAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBufferAnts;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBufferAnts = SharedControlCurvedLineBufferAnts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/animated/shared-control-curved-line-buffer-ants.ts\n// module id = 35\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineColorsBuffer = /** @class */ (function (_super) {\n    __extends(SharedControlCurvedLineColorsBuffer, _super);\n    function SharedControlCurvedLineColorsBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'colorPicks',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'timing',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineColorsBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (shapeBuffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var uniforms;\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (shapeBuffer && shapeBuffer.length > 0 && atlasManager) {\n            var colorRef = shapeBuffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var timingAttributeSize = 2;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorStartStop;\n        var colorEnd;\n        var colorEndStop;\n        var alpha;\n        var startTime;\n        var duration;\n        var controlRef;\n        var controlPoint;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorEnd = curvedLine.endColor.base.colorIndex;\n            colorEndStop = curvedLine.endColorStop.base.colorIndex;\n            colorStart = curvedLine.startColor.base.colorIndex;\n            colorStartStop = curvedLine.startColorStop.base.colorIndex;\n            duration = curvedLine.duration;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.currentStart;\n            p2 = curvedLine.currentEnd;\n            startTime = curvedLine.startTime;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colorPicks, cpos, controlPick, ctpos, timing, tpos, normals, npos, endPoints, epos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                controlPick[ctpos] = controlRef;\n                cpos += colorAttributeSize;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[wpos] = halfWidthSize;\n                normals[npos] = 1;\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                tpos += timingAttributeSize;\n                // TR\n                colorPicks[cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[tpos] = startTime;\n                timing[++tpos] = duration;\n                // BR\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // TL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // BL\n                colorPicks[++cpos] = colorStart;\n                colorPicks[++cpos] = colorStartStop;\n                colorPicks[++cpos] = colorEnd;\n                colorPicks[++cpos] = colorEndStop;\n                controlPick[++ctpos] = controlRef;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                timing[++tpos] = startTime;\n                timing[++tpos] = duration;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++ctpos] = controlRef;\n            }, \n            // We force updates for this buffer since it has animated properties\n            // Such as currentStartStop and currentEndStop which calculates\n            // Animations on the CPU side.\n            true);\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineColorsBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineColorsBuffer = SharedControlCurvedLineColorsBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/animated/shared-control-curved-line-colors-buffer.ts\n// module id = 36\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(val) {\n    return Array.isArray(val[0]);\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar SharedControlCurvedLineBuffer = /** @class */ (function (_super) {\n    __extends(SharedControlCurvedLineBuffer, _super);\n    function SharedControlCurvedLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SharedControlCurvedLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'startColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'endColorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'controlPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    SharedControlCurvedLineBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // This is a special case where we need to update our current item dataset to prevent\n        // Re-updates for the same empty shape buffer\n        if (buffer.length === 0) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        var controlPoints = [];\n        var controlReference = new Map();\n        var controlUniform;\n        // As this is a single material, we have to assume that the color atlas\n        // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // Information for one color will be valid for all colors\n        if (buffer.length > 0 && atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            // Update all uniforms for this material to utilize the atlas metrics for\n            // Picking colors\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            // This is the shared control points for all of the vertices\n            controlUniform = uniforms.controlPoints;\n            atlas.needsUpdate = true;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 1;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var colorStart;\n        var colorEnd;\n        var alpha;\n        var controlPoint;\n        var controlRef;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            colorStart = curvedLine.startColor.base;\n            colorEnd = curvedLine.endColor.base;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            controlPoint = curvedLine.controlPoints[controlPointSource];\n            controlRef = controlReference.get(controlPoint);\n            if (controlRef === undefined) {\n                var controlLength = controlPoints.push(controlPoint.x, controlPoint.y);\n                controlRef = controlLength - 2;\n                controlReference.set(controlPoint, controlRef);\n            }\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, startColor, scpos, endColor, ecpos, normals, npos, endPoints, epos, halfWidth, wpos, controlPick, cpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[cpos] = controlRef;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[scpos] = colorStart.colorIndex;\n                endColor[ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                startColor[++scpos] = colorStart.colorIndex;\n                endColor[++ecpos] = colorEnd.colorIndex;\n                controlPick[++cpos] = controlRef;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                scpos += colorAttributeSize;\n                ecpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPick[++cpos] = controlRef;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, buffer_1 = buffer; _i < buffer_1.length; _i++) {\n            var curvedLine = buffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (controlUniform) {\n            controlUniform.value = controlPoints;\n        }\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return needsUpdate;\n    };\n    return SharedControlCurvedLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SharedControlCurvedLineBuffer = SharedControlCurvedLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/shared-control-curved-line-buffer.ts\n// module id = 37\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This ONLY supports a single color\n */\nvar SimpleStaticBezierLineBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticBezierLineBuffer, _super);\n    function SimpleStaticBezierLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticBezierLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [1],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 0, 0],\n                name: 'endPoints',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n            {\n                defaults: [0, 0],\n                name: 'controlPoint',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0],\n                name: 'halfLinewidth',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticBezierLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        // Commit static curved lines\n        var colorAttributeSize = 4;\n        var numVerticesPerSegment = 6;\n        var halfWidthSize = 1;\n        var length = 15;\n        var needsUpdate = false;\n        var p1;\n        var p2;\n        var color;\n        var alpha;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var _loop_1 = function (curvedLine) {\n            alpha = curvedLine.startColor.base.opacity;\n            color = curvedLine.startColor.base.color;\n            halfWidthSize = curvedLine.lineWidth / 2.0;\n            length = curvedLine.resolution;\n            p1 = curvedLine.start;\n            p2 = curvedLine.end;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, length, function (i, positions, ppos, colors, cpos, normals, npos, endPoints, epos, controlPoints, copos, halfWidth, wpos) {\n                // Copy first vertex twice for intro degenerate tri\n                positions[ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[wpos] = halfWidthSize;\n                // Skip over degenerate tris color\n                cpos += colorAttributeSize;\n                normals[npos] = 1;\n                endPoints[epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                // TR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BR\n                positions[++ppos] = (i + 1) / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // TL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = 1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // BL\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // Copy last vertex again for degenerate tri\n                positions[++ppos] = i / length;\n                positions[++ppos] = length;\n                positions[++ppos] = curvedLine.depth;\n                halfWidth[++wpos] = halfWidthSize;\n                // Skip over degenerate tris for color\n                cpos += colorAttributeSize;\n                normals[++npos] = -1;\n                endPoints[++epos] = p1.x;\n                endPoints[++epos] = p1.y;\n                endPoints[++epos] = p2.x;\n                endPoints[++epos] = p2.y;\n                controlPoints[++copos] = curvedLine.controlPoints[0].x;\n                controlPoints[++copos] = curvedLine.controlPoints[0].y;\n            });\n            // If no updating is happening, just quit the loop\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        // Only if updates happened, should this change\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticBezierLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticBezierLineBuffer = SimpleStaticBezierLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-bezier-line-buffer.ts\n// module id = 38\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nvar SimpleStaticCircleBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticCircleBuffer, _super);\n    function SimpleStaticCircleBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticCircleBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'radius',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 1;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Points(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticCircleBuffer.prototype.update = function (shapeBuffer, atlasManager, camera) {\n        if (!shapeBuffer || shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        if (atlasManager) {\n            var colorRef = shapeBuffer[0].outerColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n            if (camera) {\n                uniforms.zoom.value = camera.zoom;\n            }\n        }\n        var needsUpdate = false;\n        var circle;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this.bufferItems, 1, shapeBuffer.length, function (i, positions, ppos, radius, rpos, color, cpos) {\n            circle = shapeBuffer[i];\n            // These are point sprites, so just update a single vertex\n            positions[ppos] = circle._centerX;\n            positions[++ppos] = circle._centerY;\n            positions[++ppos] = circle.depth;\n            radius[rpos] = circle._radius;\n            color[cpos] = circle.outerColor.base.colorIndex;\n        });\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, shapeBuffer.length);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticCircleBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticCircleBuffer = SimpleStaticCircleBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-circle-buffer.ts\n// module id = 39\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticLabelBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticLabelBuffer, _super);\n    function SimpleStaticLabelBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLabelBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                defaults: [0, 0, 1],\n                name: 'texCoord',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0],\n                name: 'size',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n            {\n                defaults: [0, 0],\n                name: 'anchor',\n                size: buffer_util_1.AttributeSize.TWO,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLabelBuffer.prototype.update = function (shapeBuffer, atlasManager, startFade, endFade, labelMaxSize) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        // Make some constants and props for our buffer update loop\n        var numVerticesPerQuad = 6;\n        var label;\n        var texture;\n        var color;\n        var alpha;\n        var anchor;\n        var labelSize;\n        if (atlasManager) {\n            var colorRef = buffer[0].color;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            if (uniforms.colorAtlas.value !== atlas) {\n                uniforms.colorAtlas.value = atlas;\n                uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n                uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n                uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n                atlas.needsUpdate = true;\n            }\n            if (startFade || endFade || labelMaxSize) {\n                material = this.bufferItems.system.material;\n                uniforms = material.uniforms;\n                uniforms.startFade.value = startFade || 0;\n                uniforms.endFade.value = endFade || 0;\n                uniforms.maxLabelSize.value = labelMaxSize || 0;\n            }\n        }\n        var updated = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerQuad, buffer.length, function (i, positions, ppos, colors, cpos, texCoords, tpos, sizes, spos, anchors, apos) {\n            label = buffer[i];\n            texture = label.rasterizedLabel;\n            color = label.color.base;\n            alpha = label.color.base.opacity;\n            anchor = {\n                x: label.getLocation().x + label.getSize().width * Math.cos(label.getRotation()),\n                y: label.getLocation().y + label.getSize().width * Math.sin(label.getRotation()),\n            };\n            labelSize = label.getSize();\n            // Make sure the label is updated with it's latest metrics\n            label.update();\n            // Copy first vertex twice for intro degenerate tri\n            positions[ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[cpos] = color.colorIndex;\n            sizes[spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TR\n            positions[++ppos] = label.TR.x;\n            positions[++ppos] = label.TR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTR.x;\n            texCoords[++tpos] = texture.atlasTR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BR\n            positions[++ppos] = label.BR.x;\n            positions[++ppos] = label.BR.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBR.x;\n            texCoords[++tpos] = texture.atlasBR.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // TL\n            positions[++ppos] = label.TL.x;\n            positions[++ppos] = label.TL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasTL.x;\n            texCoords[++tpos] = texture.atlasTL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // BL\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n            // Copy last vertex again for degenerate tri\n            positions[++ppos] = label.BL.x;\n            positions[++ppos] = label.BL.y;\n            positions[++ppos] = label.depth;\n            texCoords[++tpos] = texture.atlasBL.x;\n            texCoords[++tpos] = texture.atlasBL.y;\n            texCoords[++tpos] = alpha;\n            colors[++cpos] = color.colorIndex;\n            sizes[++spos] = labelSize.width;\n            sizes[++spos] = labelSize.height;\n            anchors[++apos] = anchor.x;\n            anchors[++apos] = anchor.y;\n        });\n        this.bufferItems.geometry.setDrawRange(0, numVerticesPerQuad * buffer.length);\n        // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n        // Come into existance) we must explicitly ensure the current data is set to the actual\n        // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n        if (isCluster(shapeBuffer)) {\n            this.bufferItems.currentData = shapeBuffer;\n        }\n        return updated;\n    };\n    return SimpleStaticLabelBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLabelBuffer = SimpleStaticLabelBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-label-buffer.ts\n// module id = 40\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nvar SimpleStaticLineBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticLineBuffer, _super);\n    function SimpleStaticLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0, 0, 0, 1],\n                name: 'customColor',\n                size: buffer_util_1.AttributeSize.FOUR,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticLineBuffer.prototype.update = function (shapeBuffer) {\n        if (!shapeBuffer) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var colorAttributeSize = 4;\n        var stripPos = 0;\n        buffer_util_1.BufferUtil.beginUpdates();\n        var TR;\n        var BR;\n        var TL;\n        var BL;\n        var color;\n        var alpha;\n        var _loop_1 = function (curvedLine) {\n            var strip = curvedLine.getTriangleStrip();\n            color = curvedLine.startColor.base.color;\n            alpha = curvedLine.startColor.base.opacity;\n            needsUpdate = buffer_util_1.BufferUtil.updateBuffer(shapeBuffer, this_1.bufferItems, numVerticesPerSegment, strip.length / 4, function (i, positions, ppos, colors, cpos) {\n                stripPos = i * 4;\n                TR = strip[stripPos];\n                BR = strip[stripPos + 1];\n                TL = strip[stripPos + 2];\n                BL = strip[stripPos + 3];\n                // 1\n                positions[ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n                // 2\n                positions[++ppos] = TR.x;\n                positions[++ppos] = TR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 3\n                positions[++ppos] = BR.x;\n                positions[++ppos] = BR.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 4\n                positions[++ppos] = TL.x;\n                positions[++ppos] = TL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 5\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                colors[++cpos] = color.r;\n                colors[++cpos] = color.g;\n                colors[++cpos] = color.b;\n                colors[++cpos] = alpha;\n                // 6\n                positions[++ppos] = BL.x;\n                positions[++ppos] = BL.y;\n                positions[++ppos] = curvedLine.depth;\n                cpos += colorAttributeSize;\n            });\n            if (!needsUpdate) {\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, shapeBuffer_1 = shapeBuffer; _i < shapeBuffer_1.length; _i++) {\n            var curvedLine = shapeBuffer_1[_i];\n            var state_1 = _loop_1(curvedLine);\n            if (state_1 === \"break\")\n                break;\n        }\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        else if (shapeBuffer.length === 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticLineBuffer = SimpleStaticLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-line-buffer.ts\n// module id = 41\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ramda_1 = require(\"ramda\");\nvar three_1 = require(\"three\");\nvar point_1 = require(\"../../primitives/point\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\nvar SimpleStaticStraightLineBuffer = /** @class */ (function (_super) {\n    __extends(SimpleStaticStraightLineBuffer, _super);\n    function SimpleStaticStraightLineBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     */\n    SimpleStaticStraightLineBuffer.prototype.init = function (material, unitCount) {\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        this.bufferItems.attributes = [\n            {\n                defaults: [0, 0, 0],\n                name: 'position',\n                size: buffer_util_1.AttributeSize.THREE,\n            },\n            {\n                defaults: [0],\n                name: 'colorPick',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        var verticesPerQuad = 6;\n        var numQuads = unitCount;\n        this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(numQuads * verticesPerQuad, this.bufferItems.attributes);\n        this.bufferItems.system = new three_1.Mesh(this.bufferItems.geometry, material);\n        this.bufferItems.system.frustumCulled = false;\n        this.bufferItems.system.drawMode = three_1.TriangleStripDrawMode;\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param shapeBuffer\n     */\n    SimpleStaticStraightLineBuffer.prototype.update = function (shapeBuffer, atlasManager) {\n        if (!shapeBuffer || shapeBuffer.length <= 0) {\n            this.bufferItems.geometry.setDrawRange(0, 0);\n            return false;\n        }\n        var buffer;\n        if (isCluster(shapeBuffer)) {\n            buffer = ramda_1.flatten(shapeBuffer);\n        }\n        else {\n            buffer = shapeBuffer;\n        }\n        if (atlasManager) {\n            var colorRef = buffer[0].startColor;\n            var colorBase = colorRef.base;\n            var material = this.bufferItems.system.material;\n            var uniforms = material.uniforms;\n            var atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n            uniforms.colorAtlas.value = atlas;\n            uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n            uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n            uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n            atlas.needsUpdate = true;\n        }\n        var needsUpdate = false;\n        var numVerticesPerSegment = 6;\n        var TR = point_1.Point.zero();\n        var BR = point_1.Point.zero();\n        var TL = point_1.Point.zero();\n        var BL = point_1.Point.zero();\n        var startColor = 0;\n        var endColor = 0;\n        var line;\n        needsUpdate = buffer_util_1.BufferUtil.updateBuffer(buffer, this.bufferItems, numVerticesPerSegment, buffer.length, function (i, positions, ppos, color, cpos) {\n            line = buffer[i];\n            startColor = line.startColor.base.colorIndex;\n            endColor = line.endColor.base.colorIndex;\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TR);\n            point_1.Point.add(line.p2, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BR);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, -line.thickness / 2.0), TL);\n            point_1.Point.add(line.p1, point_1.Point.scale(line.perpendicular, line.thickness / 2.0), BL);\n            // 1\n            positions[ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            cpos += 1.0;\n            // 2\n            positions[++ppos] = TR.x;\n            positions[++ppos] = TR.y;\n            positions[++ppos] = line.depth;\n            color[cpos] = endColor;\n            // 3\n            positions[++ppos] = BR.x;\n            positions[++ppos] = BR.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = endColor;\n            // 4\n            positions[++ppos] = TL.x;\n            positions[++ppos] = TL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 5\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n            color[++cpos] = startColor;\n            // 6\n            positions[++ppos] = BL.x;\n            positions[++ppos] = BL.y;\n            positions[++ppos] = line.depth;\n        });\n        var numBatches = buffer_util_1.BufferUtil.endUpdates();\n        if (needsUpdate) {\n            this.bufferItems.geometry.setDrawRange(0, numVerticesPerSegment * numBatches);\n            // Since we have the ability to flatten the shape buffer (thus causing a new array point to\n            // Come into existance) we must explicitly ensure the current data is set to the actual\n            // Shape buffer that came in. This makes clusters only efficient if using a multibuffer cache\n            if (isCluster(shapeBuffer)) {\n                this.bufferItems.currentData = shapeBuffer;\n            }\n        }\n        return needsUpdate;\n    };\n    return SimpleStaticStraightLineBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.SimpleStaticStraightLineBuffer = SimpleStaticStraightLineBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/simple-straight-line-buffer.ts\n// module id = 42\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar buffer_util_1 = require(\"../../util/buffer-util\");\nvar base_buffer_1 = require(\"../base-buffer\");\nvar MAX_RESOLUTION = 100;\nvar VERTICES_PER_SEGMENT = 6;\nvar VERTICES_PER_CURVE = MAX_RESOLUTION * VERTICES_PER_SEGMENT;\nfunction isCluster(value) {\n    if (Array.isArray(value[0]))\n        return true;\n    return false;\n}\n/**\n * This renders a curved line by injecting all attributes needed to render it.\n * This naively includes all possible data in the vertex.\n *\n * This only supports atlas colors.\n */\nvar UniformInstanceArcBuffer = /** @class */ (function (_super) {\n    __extends(UniformInstanceArcBuffer, _super);\n    function UniformInstanceArcBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {UniformInstanceArcBuffer} shared This should be another instance that has already\n     *                                          been initialized. Providing this will greatly improve\n     *                                          performance by causing sharing of relevant resources across\n     *                                          buffers.\n     */\n    UniformInstanceArcBuffer.prototype.init = function (material, unitCount, shared, bufferClass, pointClass) {\n        if (unitCount !== 0) {\n            console.warn('Unit count is used for vertex buffers that are not using uniform instancing', 'The unit count for these types of buffers are automatically calculated', 'To disable this warning please place a ZERO for the unit count parameter');\n        }\n        this.bufferItems = buffer_util_1.BufferUtil.makeBufferItems();\n        // Declare the structure of the uniform data in the instanceData uniform\n        this.bufferItems.uniformAttributes = [\n            {\n                block: 0,\n                name: 'startColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'endColorPick',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'halfLineWidth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 0,\n                name: 'resolution',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 1,\n                name: 'endPoints',\n                size: buffer_util_1.UniformAttributeSize.FOUR,\n            },\n            {\n                block: 2,\n                name: 'depth',\n                size: buffer_util_1.UniformAttributeSize.ONE,\n            },\n            {\n                block: 2,\n                name: 'controlPoint',\n                size: buffer_util_1.UniformAttributeSize.TWO,\n            },\n        ];\n        // Generate the uniform buffer to express the type of data to be placed in our instanceData\n        // Uniform\n        this.bufferItems.uniformBuffer = buffer_util_1.BufferUtil.makeUniformBuffer(this.bufferItems.uniformAttributes);\n        // Initialize the vertex buffer, whether that be sharing resources or generating it's own\n        this.initVertexBuffer(shared);\n        var geo = new bufferClass();\n        var arr = new Float32Array(64);\n        geo.addAttribute('whowhatsit', new three_1.BufferAttribute(arr, 1));\n        geo.setDrawRange(0, 1);\n        console.log(three_1.BufferGeometry === bufferClass);\n        // Generate the mesh based on the shared or generated buffer\n        this.bufferItems.system = new three_1.Points(geo, material);\n        // This.bufferItems.geometry.setDrawRange(0, VERTICES_PER_CURVE);\n        this.bufferItems.system.frustumCulled = false;\n        // This.bufferItems.system.drawMode = TriangleStripDrawMode;\n    };\n    UniformInstanceArcBuffer.prototype.initVertexBuffer = function (shared) {\n        this.bufferItems.attributes = [\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    var segment = Math.floor((vertex % VERTICES_PER_CURVE) / VERTICES_PER_SEGMENT) % MAX_RESOLUTION;\n                    var segmentIndex = vertex % VERTICES_PER_SEGMENT;\n                    buffer[start] = segmentIndex >= 3 ? segment : segment + 1;\n                },\n                defaults: [0],\n                name: 'vertexIndex',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    buffer[start] = MAX_RESOLUTION;\n                },\n                defaults: [0],\n                name: 'totalVertices',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    var segmentIndex = vertex % VERTICES_PER_SEGMENT;\n                    buffer[start] = segmentIndex <= 1 ? 1 : (segmentIndex >= 4 ? -1 : (segmentIndex === 2 ? -1 : 1));\n                },\n                defaults: [0],\n                name: 'normalDirection',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n            {\n                customFill: function (buffer, vertex, start, defaults) {\n                    buffer[start] = Math.floor(vertex / VERTICES_PER_CURVE);\n                },\n                defaults: [0],\n                name: 'instance',\n                size: buffer_util_1.AttributeSize.ONE,\n            },\n        ];\n        // If a buffer with geometry was provided, we share that geometry to significantly\n        // Reduce memory footprint and improve performance\n        if (shared && shared.bufferItems && shared.bufferItems.geometry) {\n            this.bufferItems.geometry = shared.bufferItems.geometry;\n        }\n        else {\n            if (shared && !(shared.bufferItems || shared.bufferItems.geometry)) {\n                console.warn('A UniformInstanceArcBuffer trying to share resources was provided a shared object that did not have the proper elements to share. Shared but lacking:', shared);\n            }\n            var bufferVertexCount = VERTICES_PER_CURVE * this.bufferItems.uniformBuffer.maxInstances;\n            this.bufferItems.geometry = buffer_util_1.BufferUtil.makeBuffer(bufferVertexCount, this.bufferItems.attributes);\n        }\n    };\n    /**\n     * @override\n     * See interface definition\n     *\n     * @param {CurvedLineShape<any>[]} shapeBuffer A buffer of curved line shapes\n     * @param {AtlasManager} atlasManager The Atlas Manager that contains the color atlas\n     *                                    needed for rendering with color picks.\n     */\n    UniformInstanceArcBuffer.prototype.update = function (shapeBuffer, atlasManager, controlPointSource) {\n        // If (!shapeBuffer) {\n        //   This.bufferItems.geometry.setDrawRange(0, 0);\n        //   Return false;\n        // }\n        // // This is a special case where we need to update our current item dataset to prevent\n        // // Re-updates for the same empty shape buffer\n        // If (shapeBuffer.length === 0) {\n        //   This.bufferItems.currentData = shapeBuffer;\n        //   This.bufferItems.geometry.setDrawRange(0, 0);\n        //   Return true;\n        // }\n        // Let buffer: CurvedLineShape<any>[];\n        // If (isCluster(shapeBuffer)) {\n        //   Buffer = flatten<CurvedLineShape<any>>(shapeBuffer);\n        // }\n        // Else {\n        //   Buffer = shapeBuffer;\n        // }\n        // // This let's us know if we're maxing out the instances this buffer can handle\n        // If (buffer.length > this.bufferItems.uniformBuffer.maxInstances) {\n        //   Console.warn(\n        //     'Too many shapes provided for a uniform instancing buffer.',\n        //     'Max supported:',\n        //     This.bufferItems.uniformBuffer.maxInstances,\n        //     'Shapes provided:',\n        //     Buffer.length,\n        //     'This shape buffer should be split across more uniform instancing buffers to render correctly.',\n        //     'Consider using the MultiShapeBufferCache. If this is already in use:',\n        //     'Consider raising the number of buffers it splits across',\n        //   );\n        // }\n        // // As this is a single material, we have to assume that the color atlas\n        // // For our shapes will be the same atlas for all colors. Thus, the atlas\n        // // Information for one color will be valid for all colors\n        // If (atlasManager) {\n        //   Const colorRef: ReferenceColor = buffer[0].startColor;\n        //   Const colorBase = colorRef.base;\n        //   // Update all uniforms for this material to utilize the atlas metrics for\n        //   // Picking colors\n        //   Const material: ShaderMaterial = this.bufferItems.system.material as ShaderMaterial;\n        //   Const uniforms: { [k: string]: IUniform } = material.uniforms;\n        //   Const atlas = atlasManager.getAtlasTexture(colorBase.atlasReferenceID);\n        //   Uniforms.colorAtlas.value = atlas;\n        //   Uniforms.colorsPerRow.value = colorBase.colorsPerRow;\n        //   Uniforms.firstColor.value = [colorBase.firstColor.x, colorBase.firstColor.y];\n        //   Uniforms.nextColor.value = [colorBase.nextColor.x, colorBase.nextColor.y];\n        //   Atlas.needsUpdate = true;\n        // }\n        // Let needsUpdate = false;\n        // // Commit the information to the uniform instancing group\n        // NeedsUpdate = BufferUtil.updateUniformBuffer(\n        //   Buffer, this.bufferItems,\n        //   Math.min(buffer.length, this.bufferItems.uniformBuffer.maxInstances),\n        //   (\n        //     Instance: number,\n        //     StartColor: Vector4,\n        //     EndColor: Vector4,\n        //     HalfLine: Vector4,\n        //     Resolution: Vector4,\n        //     EndPoints: Vector4,\n        //     Depth: Vector4,\n        //     ControlPoint: Vector4,\n        //   ) => {\n        //     Const curve = buffer[instance];\n        //     StartColor.x = curve.startColor.base.colorIndex;\n        //     EndColor.y = curve.endColor.base.colorIndex;\n        //     HalfLine.z = curve.lineWidth / 2.0;\n        //     Resolution.w = curve.resolution;\n        //     EndPoints.x = curve.start.x;\n        //     EndPoints.y = curve.start.y;\n        //     EndPoints.z = curve.end.x;\n        //     EndPoints.w = curve.end.y;\n        //     Depth.x = curve.depth;\n        //     ControlPoint.y = curve.controlPoints[1].x;\n        //     ControlPoint.z = curve.controlPoints[1].y;\n        //   },\n        // ) || needsUpdate;\n        // Console.log('CURVE SHAPE BUFFER', buffer);\n        // Console.log('UNIFORM BUFFER', this.bufferItems.uniformBuffer.buffer);\n        // // Only if updates happened, should this change\n        // If (needsUpdate) {\n        //   Console.log('UPDATED DRAW RANGE', buffer.length * VERTICES_PER_CURVE);\n        //   This.bufferItems.geometry.setDrawRange(0, buffer.length * VERTICES_PER_CURVE);\n        // }\n        // Return needsUpdate;\n        return true;\n    };\n    return UniformInstanceArcBuffer;\n}(base_buffer_1.BaseBuffer));\nexports.UniformInstanceArcBuffer = UniformInstanceArcBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/buffers/static/uniform-instance-arc-buffer.ts\n// module id = 43\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./reference/reference-color\"));\n__export(require(\"./animation/animated-curved-line-shape\"));\n__export(require(\"./shape/circle-shape\"));\n__export(require(\"./shape/curved-line-shape\"));\n__export(require(\"./shape/edge-shape\"));\n__export(require(\"./shape/image-shape\"));\n__export(require(\"./shape/label\"));\n__export(require(\"./shape/line-shape\"));\n__export(require(\"./shape/quad-shape\"));\n__export(require(\"./texture/atlas-color\"));\n__export(require(\"./texture/atlas-manager\"));\n__export(require(\"./texture/atlas-texture\"));\n__export(require(\"./texture/sprite\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/index.ts\n// module id = 44\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This defines a reference to a color that has been rendered to a texture\n * (See AtlasColor). This exposes the only properties that MAY be utilized\n * in a shader to modify the existing values without altering what is rendered\n * on the texture.\n */\nvar ReferenceColor = /** @class */ (function () {\n    /**\n     * Creates an instance of ReferenceColor.\n     *\n     * @param {AtlasColor} base The color to be based off of\n     */\n    function ReferenceColor(base) {\n        this.base = base;\n    }\n    return ReferenceColor;\n}());\nexports.ReferenceColor = ReferenceColor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/reference/reference-color.ts\n// module id = 45\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\nvar easing_1 = require(\"../../util/easing\");\nvar frame_info_1 = require(\"../../util/frame-info\");\nvar interpolation_1 = require(\"../../util/interpolation\");\nvar curved_line_shape_1 = require(\"../shape/curved-line-shape\");\n/**\n * This represents curved lines and what it would take to animate various properties.\n * While this provides helpers to aid in animating the properties, it is up to\n * buffers, shaders and materials to render those changes appropriately.\n */\nvar AnimatedCurvedLineShape = /** @class */ (function (_super) {\n    __extends(AnimatedCurvedLineShape, _super);\n    function AnimatedCurvedLineShape(options) {\n        var _this = _super.call(this, options) || this;\n        /**\n         * This defines the suggested easing for the animation for any of\n         * the values.\n         */\n        _this.easing = easing_1.linear;\n        _this._startColorChange = new three_1.Color(0, 0, 0);\n        _this._endColorChange = new three_1.Color(0, 0, 0);\n        /** The starting end point's destination */\n        _this.startStop = { x: 0, y: 0 };\n        _this.endStop = { x: 0, y: 0 };\n        /**\n         * This calculates the current start color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentStartColor = new three_1.Color(0, 0, 0);\n        /**\n         * This calculates the current end color with the given easing function\n         * based on how much time has lapsed since startTime\n         */\n        _this._currentEndColor = new three_1.Color(0, 0, 0);\n        if (options) {\n            _this.startStop = options.startStop || { x: 0, y: 0 };\n            _this.endStop = options.endStop || { x: 0, y: 0 };\n            if (options.startColorStop) {\n                _this.startColorStop = options.startColorStop;\n            }\n            if (options.endColorStop) {\n                _this.endColorStop = options.endColorStop;\n            }\n        }\n        return _this;\n    }\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"startColorStop\", {\n        get: function () {\n            return this._startColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._startColorStop = value;\n            this._startColorChange.r = newBase.r - startBase.r;\n            this._startColorChange.g = newBase.g - startBase.g;\n            this._startColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"endColorStop\", {\n        get: function () {\n            return this._endColorStop;\n        },\n        set: function (value) {\n            var startBase = this.startColor.base.color;\n            var newBase = value.base.color;\n            this._endColorStop = value;\n            this._endColorChange.r = newBase.r - startBase.r;\n            this._endColorChange.g = newBase.g - startBase.g;\n            this._endColorChange.b = newBase.b - startBase.b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStartColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var startBase = this.startColor.base.color;\n            this._currentStartColor.r = this.easing(time, startBase.r, this._startColorChange.r, this.duration);\n            this._currentStartColor.g = this.easing(time, startBase.g, this._startColorChange.g, this.duration);\n            this._currentStartColor.b = this.easing(time, startBase.b, this._startColorChange.b, this.duration);\n            return this._currentStartColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEndColor\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            var endBase = this.endColor.base.color;\n            this._currentEndColor.r = this.easing(time, endBase.r, this._endColorChange.r, this.duration);\n            this._currentEndColor.g = this.easing(time, endBase.g, this._endColorChange.g, this.duration);\n            this._currentEndColor.b = this.easing(time, endBase.b, this._endColorChange.b, this.duration);\n            return this._currentEndColor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentStart\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            var newStart = interpolation_1.circular(easedTime, this.start, this.startStop, this.controlPoints[1]);\n            return newStart;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedCurvedLineShape.prototype, \"currentEnd\", {\n        get: function () {\n            var time = Math.min(frame_info_1.FrameInfo.lastFrameTime - this.startTime, this.duration);\n            // Since we must use a circular interpolation to calculate the animated position\n            // Of the end point, we must apply the easing to the path the point will take\n            // Which gets applied to the interpolations t value of 0 - 1\n            var easedTime = this.easing(time, 0, 1, this.duration);\n            // Apply the circular interpolation to the points\n            return interpolation_1.circular(easedTime, this.end, this.endStop, this.controlPoints[1]);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AnimatedCurvedLineShape;\n}(curved_line_shape_1.CurvedLineShape));\nexports.AnimatedCurvedLineShape = AnimatedCurvedLineShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/animation/animated-curved-line-shape.ts\n// module id = 46\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar circle_1 = require(\"../../primitives/circle\");\n/**\n * Defines a circular shape that can be drawn\n */\nvar CircleShape = /** @class */ (function (_super) {\n    __extends(CircleShape, _super);\n    /**\n     * Sets the properties of the shape to be drawn\n     *\n     * @param {ICircleShapeOptions} options The options for the shape\n     */\n    function CircleShape(options) {\n        var _this = _super.call(this, options) || this;\n        _this.depth = options.depth || 0;\n        _this.innerColor = options.innerColor;\n        _this.innerRadius = options.innerRadius;\n        _this.outerColor = options.outerColor;\n        return _this;\n    }\n    /**\n     * Clones this instance of the circle shape and creates a new instance of a circle shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {CircleShape} A newly cloned instance of this circleshape\n     */\n    CircleShape.prototype.clone = function (newProperties) {\n        var instance = new CircleShape(this);\n        instance.d = this.d;\n        return instance;\n    };\n    return CircleShape;\n}(circle_1.Circle));\nexports.CircleShape = CircleShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/circle-shape.ts\n// module id = 47\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"../../primitives/line\");\nvar line_shape_1 = require(\"./line-shape\");\n/**\n * This defines an edge that can be drawn.\n * This type of edge is a quad with distorted ends. The quad will represent a\n * line with each end having potentially different sizes thus giving a four sided\n * polygon rather than a parallelogram.\n *\n * The edge shape also doubles up as a simple line shape should it be desired to\n * render differently.\n */\nvar EdgeShape = /** @class */ (function (_super) {\n    __extends(EdgeShape, _super);\n    /**\n     * Constructor with basic parameters to declare an edge\n     *\n     * @param p1 The point the edge begins at\n     * @param p2 The point the edge terminates at\n     * @param d The data associated with the edge\n     * @param p1Col The color at the start point\n     * @param p2Col The color at the end point\n     * @param p1Width The width at the start point. Example: if you specify 4, then\n     *                the start part of the edge will fan out 2 on either side of the\n     *                start point\n     * @param p2Width The width at the end point. Example: if you specify 4, then\n     *                the end part of the edge will fan out 2 on either side of the\n     *                end point\n     */\n    function EdgeShape(options) {\n        var _this = \n        // Set up all of our line shape based metrics\n        _super.call(this, Object.assign(options, {\n            thickness: options.startWidth,\n        })) || this;\n        /** Top left of the quad to generate this edge */\n        _this.tl = { x: 0, y: 0 };\n        /** Bottom left of the quad to generate this edge */\n        _this.bl = { x: 0, y: 0 };\n        /** Top right of the quad to generate this edge */\n        _this.tr = { x: 0, y: 0 };\n        /** Bottom Right of the quad to generate this edge */\n        _this.br = { x: 0, y: 0 };\n        /** The width of the edge at the termination point */\n        _this.endWidth = 1;\n        _this.endWidth = options.endWidth || 1.0;\n        _this.setPoints(options.p1, options.p2);\n        return _this;\n    }\n    /**\n     * Clones this instance of the edge shape and creates a new instance of an edge shape that\n     * is identical to this one. The properties injected can be modifiers after the clone happens\n     *\n     * @param newProperties New properties to override the properties on the new instance\n     *\n     * @return {EdgeShape} A newly cloned instance of this edgeshape\n     */\n    EdgeShape.prototype.clone = function (newProperties) {\n        return Object.assign(new EdgeShape(Object.assign(this, {\n            startWidth: this.thickness,\n        })), newProperties);\n    };\n    /**\n     * Algorithm provided by\n     * https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n     * Adapted to Javascript by Chris @ VoidRay co\n     *\n     * Remember the point must be in the same\n     * coordinate system that the edge is using\n     *\n     * @param {number} point The point to test\n     *\n     * @return {boolean} True if the point is inside the edge\n     */\n    EdgeShape.prototype.pointInside = function (point) {\n        var testx = point.x;\n        var testy = point.y;\n        // This is an algortihm to handle any number of points for a polygon. In this\n        // Case our polygon is simply the points that make this fat edge. Note:\n        // The points MUST be in CW order\n        var points = [this.tl, this.tr, this.br, this.bl];\n        var numberVertices = points.length;\n        var isClockwise = false;\n        for (var i = 0, j = numberVertices - 1; i < numberVertices; j = i++) {\n            if (((points[i].y > testy) !== (points[j].y > testy)) &&\n                (testx < (points[j].x - points[i].x) * (testy - points[i].y) /\n                    (points[j].y - points[i].y) + points[i].x)) {\n                isClockwise = !isClockwise;\n            }\n        }\n        return isClockwise;\n    };\n    /**\n     * @override\n     * This sets the two endpoints for this edge and recalculates the bounds\n     * of the edge accordingly.\n     *\n     * @param {IPoint} p1 The start point\n     * @param {IPoint} p2 The end point\n     */\n    EdgeShape.prototype.setPoints = function (p1, p2) {\n        _super.prototype.setPoints.call(this, p1, p2);\n        if (this.tl) {\n            // Get the distance from the points we will go based on specified widths\n            var p1Dx = this.thickness / 2;\n            var p2Dx = this.endWidth / 2;\n            // Calculate the deltas to get from point to quad edge\n            var p1DeltaX = this.perpendicular.x * p1Dx;\n            var p1DeltaY = this.perpendicular.y * p1Dx;\n            var p2DeltaX = this.perpendicular.x * p2Dx;\n            var p2DeltaY = this.perpendicular.y * p2Dx;\n            // Apply the metrics to our quad points\n            // Start side of the edge\n            this.tl.x = this.p1.x + p1DeltaX;\n            this.tl.y = this.p1.y + p1DeltaY;\n            this.bl.x = this.p1.x - p1DeltaX;\n            this.bl.y = this.p1.y - p1DeltaY;\n            // End side of the edge\n            this.tr.x = this.p2.x + p2DeltaX;\n            this.tr.y = this.p2.y + p2DeltaY;\n            this.br.x = this.p2.x - p2DeltaX;\n            this.br.y = this.p2.y - p2DeltaY;\n            // Create lines for the edges for computations and faster hit detections\n            this.topEdge = new line_1.Line(this.tl, this.tr);\n            this.bottomEdge = new line_1.Line(this.bl, this.br);\n            // Make sure our bounds reflects the entirety of the fat edge\n            this.encapsulatePoints([this.tl, this.tr, this.bl, this.br]);\n        }\n    };\n    return EdgeShape;\n}(line_shape_1.LineShape));\nexports.EdgeShape = EdgeShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/edge-shape.ts\n// module id = 48\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../../primitives/bounds\");\n/**\n * Defines an image that can be rendered by the gpu. This is an axis oriented\n * image only (no rotations)\n */\nvar ImageShape = /** @class */ (function (_super) {\n    __extends(ImageShape, _super);\n    /**\n     * Generates a new ImageShape that can be rendered\n     *\n     * @param {AtlasTexture} image The AtlasTexture to use when rendering this image\n     * @param {number} size This is the size of the longest edge of the image while\n     *                      retaining aspect ratio.\n     */\n    function ImageShape(image, size) {\n        var _this = _super.call(this, 0, 0, size, size) || this;\n        /** This is the level of opacity the image will be rendered with */\n        _this.opacity = 1.0;\n        _this.texture = image;\n        _this.size = size;\n        return _this;\n    }\n    Object.defineProperty(ImageShape.prototype, \"size\", {\n        /**\n         * Returns the largest edge of the image\n         */\n        get: function () {\n            return Math.max(this.width, this.height);\n        },\n        /**\n         * This is the size the image will be rendered within World Space. The size\n         * correlates to the largest edge of the image\n         */\n        set: function (val) {\n            if (this.texture.aspectRatio > 1) {\n                this.width = val;\n                this.height = val / this.texture.aspectRatio;\n            }\n            else {\n                this.width = val * this.texture.aspectRatio;\n                this.height = val;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Centers this image on a provided location\n     *\n     * @param {number} x The x coordinate in world space\n     * @param {number} y The y coordinate in world space\n     */\n    ImageShape.prototype.centerOn = function (x, y) {\n        this.x = x - (this.width / 2.0);\n        this.y = y - (this.height / 2.0);\n    };\n    return ImageShape;\n}(bounds_1.Bounds));\nexports.ImageShape = ImageShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/image-shape.ts\n// module id = 49\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bounds_1 = require(\"../../primitives/bounds\");\nvar QuadShape = /** @class */ (function (_super) {\n    __extends(QuadShape, _super);\n    function QuadShape(bounds, color) {\n        var _this = _super.call(this, bounds.x, bounds.right, bounds.y, bounds.bottom) || this;\n        _this.r = 1.0;\n        _this.g = 0.0;\n        _this.b = 0.0;\n        _this.a = 1.0;\n        return _this;\n    }\n    return QuadShape;\n}(bounds_1.Bounds));\nexports.QuadShape = QuadShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/shape/quad-shape.ts\n// module id = 50\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = require(\"three\");\n/**\n * Defines a color that is located on an atlas\n */\nvar AtlasColor = /** @class */ (function () {\n    /**\n     * Constructor implementation\n     */\n    function AtlasColor(color, g, b, a) {\n        if (a === void 0) { a = 1.0; }\n        // Value between 1 - 0 for the opacity of the color\n        this.opacity = 1.0;\n        // The pixel width and height of the color rendered onto the atlas\n        // This will always be a 2x2 so the color can be sampled in the middle\n        // For a guaranteed pure color regardless of gl sampling states\n        this.pixelWidth = 2;\n        this.pixelHeight = 2;\n        if (color instanceof three_1.Color) {\n            this.color = color.clone();\n            this.opacity = g === undefined ? 1.0 : g;\n        }\n        else {\n            this.color = new three_1.Color(color, g, b);\n            this.opacity = a;\n        }\n    }\n    return AtlasColor;\n}());\nexports.AtlasColor = AtlasColor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/drawing/texture/atlas-color.ts\n// module id = 51\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./bounds\"));\n__export(require(\"./circle\"));\n__export(require(\"./curved-line\"));\n__export(require(\"./line\"));\n__export(require(\"./point\"));\n__export(require(\"./rotateable-quad\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/primitives/index.ts\n// module id = 52\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./animate\"));\n__export(require(\"./animated-shape-buffer-cache\"));\n__export(require(\"./buffer-util\"));\n__export(require(\"./custom-selection\"));\n__export(require(\"./easing\"));\n__export(require(\"./frame-info\"));\n__export(require(\"./get-font-metrics\"));\n__export(require(\"./interpolation\"));\n__export(require(\"./mouse\"));\n__export(require(\"./multi-shape-buffer-cache\"));\n__export(require(\"./pack-node\"));\n__export(require(\"./quad-tree\"));\n__export(require(\"./shape-buffer-cache\"));\n__export(require(\"./webgl-stat\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/index.ts\n// module id = 53\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"PLAY\"] = 0] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 1] = \"STOP\";\n})(PlayState || (PlayState = {}));\nvar Animate = /** @class */ (function () {\n    function Animate() {\n    }\n    Animate.animate = function () {\n        if (Animate.playState === PlayState.PLAY) {\n            requestAnimationFrame(Animate.animate);\n        }\n        this.animating.forEach(function (propToItem) {\n            propToItem.forEach(function (animate) {\n                // TODO\n            });\n        });\n    };\n    Animate.cancel = function (container, prop) {\n        // TODO\n    };\n    Animate.value = function (container, prop, start, end, duration, ease) {\n        // TODO\n    };\n    Animate.point = function (container) {\n        // TODO\n    };\n    Animate.start = function () {\n        // TODO\n    };\n    Animate.stop = function () {\n        // TODO\n    };\n    Animate.playState = PlayState.PLAY;\n    Animate.animating = new Map();\n    return Animate;\n}());\nexports.Animate = Animate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/animate.ts\n// module id = 54\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar multi_shape_buffer_cache_1 = require(\"./multi-shape-buffer-cache\");\nvar PlayState;\n(function (PlayState) {\n    PlayState[PlayState[\"INIT\"] = 0] = \"INIT\";\n    PlayState[PlayState[\"PLAY\"] = 1] = \"PLAY\";\n    PlayState[PlayState[\"STOP\"] = 2] = \"STOP\";\n})(PlayState = exports.PlayState || (exports.PlayState = {}));\n/**\n * This defines an object that helps facilitate parts of or complete shape buffers that\n * need regenerating.\n */\nvar AnimatedShapeBufferCache = /** @class */ (function (_super) {\n    __extends(AnimatedShapeBufferCache, _super);\n    function AnimatedShapeBufferCache() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.playState = PlayState.INIT;\n        _this.buffer = [];\n        _this.bustCache = true;\n        /**\n         * This is the internal control for managing execution of the animate method\n         */\n        _this.doAnimate = function () {\n            if (_this.playState === PlayState.PLAY) {\n                requestAnimationFrame(_this.doAnimate);\n            }\n            _this.animate();\n        };\n        return _this;\n    }\n    /**\n     * This is the method that will execute with the frame rate. Subclasses can\n     * override this to implement animated changes\n     */\n    AnimatedShapeBufferCache.prototype.animate = function () {\n        // Implemented by subclasses\n    };\n    /**\n     * Tells this cache to generate what it needs to. If the cache isn't busted,\n     * it will not regenerate\n     */\n    AnimatedShapeBufferCache.prototype.generate = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Make sure the storage is established before trying to create modifications of any sort\n        this.getStorage(selection);\n        if (this.bustCache) {\n            this.buildCache.apply(this, arguments);\n            this.bustCache = false;\n            if (this.playState === PlayState.INIT) {\n                this.start();\n                requestAnimationFrame(this.doAnimate);\n            }\n        }\n        // We always invalidate and commit all of our buffers for animations\n        this.flagBuffersDirty();\n        // Make sure our buffers are updated so they will commit to vertex buffers\n        this.processDirtyBuffers();\n    };\n    /**\n     * Sub classes will implement this stub to perform what is necessary to produce\n     * a newly updated version of their cache.\n     */\n    AnimatedShapeBufferCache.prototype.buildCache = function (selection) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        // Implemented by sub classes\n    };\n    /**\n     * Begins executing the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.start = function () {\n        this.playState = PlayState.PLAY;\n    };\n    /**\n     * Ceases the animate method every frame\n     */\n    AnimatedShapeBufferCache.prototype.stop = function () {\n        this.playState = PlayState.STOP;\n    };\n    return AnimatedShapeBufferCache;\n}(multi_shape_buffer_cache_1.MultiShapeBufferCache));\nexports.AnimatedShapeBufferCache = AnimatedShapeBufferCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/animated-shape-buffer-cache.ts\n// module id = 55\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Takes a map of the form <T, boolean> and returns an array of the keys,\n * excluding entries who's mapped value is false.\n *\n * @param map The map to convert to a list\n *\n * @return T[] A list of the keys, exluding false mappings\n */\nfunction boolMapToArray(map) {\n    return Array\n        .from(map)\n        .filter(function (item) { return item[1]; })\n        .map(function (item) { return item[0]; });\n}\nexports.boolMapToArray = boolMapToArray;\n/**\n * Defines a selection control for custom types and categories\n */\nvar CustomSelection = /** @class */ (function () {\n    function CustomSelection() {\n        /** This caches the list generation of a selection */\n        this.cachedSelection = new Map();\n        /** Map of the custom categories to the selection state */\n        this.selections = new Map();\n        /** Keeps flags indicating if a selection for a given category has changed or not */\n        this._didSelectionChange = new Map();\n    }\n    /**\n     * Clears out all custom selections for every category\n     */\n    CustomSelection.prototype.clearAllSelections = function () {\n        for (var _i = 0, _a = Array.from(this.selections.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this.clearSelection(key);\n        }\n    };\n    /**\n     * Clears the selection for the category specified\n     *\n     * @param {string} category Name of the category of selection\n     */\n    CustomSelection.prototype.clearSelection = function (category) {\n        // We must have selected items to clear the selection\n        if (this.getSelection(category).length) {\n            this.selections.set(category, null);\n            this.cachedSelection.set(category, null);\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Makes an item no longer flaged as selected within the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to remove from being selected\n     */\n    CustomSelection.prototype.deselect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        // See if the item is selected already, if it is, clear the selection and bust caches\n        if (selectionMap && selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, false);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Checks if a selection from a category has been modified\n     *\n     * @param {string} category The selection category to check\n     */\n    CustomSelection.prototype.didSelectionCategoryChange = function (category) {\n        return this._didSelectionChange.get(category);\n    };\n    /**\n     * Checks if ANY selection has changed\n     *\n     * @return {boolean} True if any selection has changed\n     */\n    CustomSelection.prototype.didSelectionChange = function () {\n        return boolMapToArray(this._didSelectionChange).length > 0;\n    };\n    /**\n     * This indicates that updates have taken place to account for selection\n     * changes.\n     */\n    CustomSelection.prototype.finalizeUpdate = function () {\n        for (var _i = 0, _a = Array.from(this._didSelectionChange.keys()); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this._didSelectionChange.set(key, false);\n        }\n    };\n    /**\n     * This retrieves a list of the items that are selected\n     *\n     * @param category The selection category to check on\n     *\n     * @return {T} Returns a list of items that are currently selected\n     */\n    CustomSelection.prototype.getSelection = function (category) {\n        if (!this.cachedSelection.get(category)) {\n            var theSelection = this.selections.get(category);\n            if (theSelection) {\n                this.cachedSelection.set(category, boolMapToArray(theSelection));\n            }\n            else {\n                this.cachedSelection.set(category, []);\n            }\n        }\n        return this.cachedSelection.get(category);\n    };\n    /**\n     * Specifies an item to flag as selected for the given category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.select = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        if (!selectionMap.get(item)) {\n            // Clear the cache for the selection list\n            this.cachedSelection.set(category, null);\n            // Set the selection\n            selectionMap.set(item, true);\n            // Flag the category of selections as changed\n            this._didSelectionChange.set(category, true);\n        }\n    };\n    /**\n     * Specifies an item to toggle it's selection status for the provided category\n     *\n     * @param category The custom category of the selection\n     * @param item The item to flag as selected\n     */\n    CustomSelection.prototype.toggleSelect = function (category, item) {\n        var selectionMap = this.selections.get(category);\n        if (!selectionMap) {\n            selectionMap = new Map();\n            this.selections.set(category, selectionMap);\n        }\n        // Clear the cache for the selection list\n        this.cachedSelection.set(category, null);\n        // Toggle the selection off if already selected\n        if (selectionMap.get(item)) {\n            this.deselect(category, item);\n        }\n        else {\n            this.select(category, item);\n        }\n        // Flag the category of selections as changed\n        this._didSelectionChange.set(category, true);\n    };\n    return CustomSelection;\n}());\nexports.CustomSelection = CustomSelection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/custom-selection.ts\n// module id = 56\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getFontMetrics(props) {\n    var ctx = props.ctx;\n    var text = props.text;\n    var bboxHeight = props.bboxHeight;\n    var canvasHeight = props.ctx.canvas.height;\n    var baseline = props.baseline || 'alphabetic';\n    var flip = props.flip || false;\n    var drawBaseline = props.drawBaseline || false;\n    var fontFamily = 'Arial, san-serif';\n    var fontSize = 14;\n    if (props.fontFamily) {\n        fontFamily = props.fontFamily;\n    }\n    if (props.fontSize) {\n        fontSize = props.fontSize;\n    }\n    // Setting up the canvas\n    ctx.save(); // Create canvas to use as buffer\n    ctx.font = fontSize + \"px \" + fontFamily;\n    var textWidth = ctx.measureText(text).width;\n    // This keeps font in-screen, measureText().width doesn't\n    // Quite do it in some cases. For instance \"j\", or the letter \"f\"\n    // In the font \"Zapfino\".\n    var offsetx = fontSize * 2;\n    var offsety = fontSize * 2;\n    var cwidth = ctx.canvas.width = Math.round(textWidth + offsetx * 2);\n    var cheight = ctx.canvas.height = canvasHeight ? canvasHeight : Math.round(offsety * 2);\n    if (typeof (baseline) === 'string') {\n        offsety = 0; // Using <canvas> baseline\n        ctx.textBaseline = baseline;\n    }\n    // Ctx.font has to be called twice because resetting the size resets the state\n    if (flip) {\n        ctx.scale(1, -1);\n    }\n    ctx.font = fontSize + \"px \" + fontFamily;\n    ctx.fillText(text, offsetx, (typeof (bboxHeight) === 'number' ? bboxHeight : offsety));\n    // Drawing baseline\n    if (drawBaseline) {\n        ctx.fillRect(0, canvasHeight / 2, ctx.canvas.width, 1);\n    }\n    // Grabbing image data\n    var imageData = ctx.getImageData(0, 0, cwidth, cheight);\n    var data = imageData.data;\n    // Calculating top\n    var top = 0;\n    var pos = data.length;\n    var bottom = 0;\n    var realBottom = 0;\n    var left = 0;\n    var right = 0;\n    while (pos > 0) {\n        if (data[pos + 3]) {\n            pos -= pos % (cwidth * 4); // Back to beginning of the line top = (pos / 4) / cwidth; // calculate pixel position top -= offsety - fontSize; pos = data.length; // exit loop } pos += 4; } // calculating bottom var bottom = 0; var pos = data.length; while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                bottom = (pos / 4) / cwidth;\n                bottom -= offsety - fontSize;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Calculating left\n        left = 0;\n        var col = 0;\n        var row = 0; // Left bounds\n        while (row < cheight && col < cwidth) {\n            var px = data[(row * cwidth * 4) + (col * 4) + 3];\n            if (px) {\n                left = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col++;\n            }\n        }\n        // Calculating right\n        right = 0;\n        col = cwidth;\n        row = 0; // Right bounds\n        while (row < cheight && col > 0) {\n            if (data[(row * cwidth * 4) + (col * 4) + 3]) {\n                right = col - offsetx;\n                row = cheight;\n                col = cwidth;\n            }\n            row++;\n            if (row % cheight === 0) {\n                row = 0;\n                col--;\n            }\n        }\n        // Calculating real-bottom\n        realBottom = 0;\n        pos = data.length;\n        while (pos > 0) {\n            if (data[pos + 3]) {\n                pos -= pos % (cwidth * 4); // Back to beginning of the line\n                realBottom = (pos / 4) / cwidth;\n                pos = 0; // Exit loop\n            }\n            pos -= 4;\n        }\n        // Restoring state\n        ctx.restore();\n    }\n    // Returning raw-metrics\n    return {\n        bottom: realBottom,\n        height: (bottom - top),\n        left: (-left),\n        top: (fontSize - top),\n        width: (right - left),\n    };\n}\nexports.getFontMetrics = getFontMetrics;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webgl-surface/util/get-font-metrics.ts\n// module id = 57\n// module chunks = 0"],"sourceRoot":""}