declare module "voidgl" {
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../chord-chart/generators/outer-ring/outer-ring-generator
//   ../../d3-color
//   ../../webgl-surface/drawing/curved-line-shape
//   ../../webgl-surface/primitives/point
//   ../../webgl-surface/util/shape-buffer-cache
//   ../../webgl-surface/drawing/label
//   ../../webgl-surface/primitives/rotateable-quad
//   ../../chord-chart/shape-data-types/outer-ring-data
//   ../../three
//   ../../webgl-surface/primitives/bounds
//   ../../webgl-surface/util/buffer-util
//   ../../webgl-surface/util/projection
//   ../../webgl-surface/webgl-surface
//   ../../react
//   ../../webgl-surface/util/custom-selection


import { RGBColor } from 'd3-color';






import { HSLColor } from 'd3-color';
import { Mesh } from 'three';




import * as React from 'react';

import { Texture } from 'three';
import { Vector4 } from 'three';
import { BufferGeometry } from 'three';
import { Vector2 } from 'three';
import { OrthographicCamera, Scene, ShaderMaterial, Vector3, WebGLRenderer } from 'three';

export interface ICurveData {
    color: RGBColor;
    controlPoint: IPoint;
    destEndpoint: {};
    endpoint: {};
    p1: IPoint;
    p2: IPoint;
    source: IChord;
}
/**
  * Responsible for generating the static chords in the system
  *
  * @export
  * @class ChordBaseCache
  * @extends {ShapeBufferCache<CurvedLineShape<ICurvedLineData>>}
  */
export class ChordBaseCache extends ShapeBufferCache<CurvedLineShape<IChordData>> {
    generate(data: IData, config: IChordChartConfig, outerRings: OuterRingGenerator, selection: Selection): void;
    buildCache(data: IData, config: IChordChartConfig, outerRings: OuterRingGenerator, selection: Selection): void;
    /**
      * This processes the data to calculate initial needed metrics to make generating
      * shapes simpler.
      */
    preProcessData(data: IData, config: IChordChartConfig): ICurveData[];
}

export class ChordGenerator {
    chordBase: ChordBaseCache;
    chordInteractions: ChordInteractionsCache;
    lastHemisphere: boolean;
    lastData: IData;
    /**
      * Flag which caches need busting
      */
    bustCaches(data: IData, config: IChordChartConfig, outerRings: OuterRingGenerator, selection: Selection): void;
    /**
      * Generates the buffers for static chords in the charts
      */
    generate(data: IData, config: IChordChartConfig, outerRings: OuterRingGenerator, selection: Selection): void;
    /**
      * Get the base buffer
      */
    getBaseBuffer(): CurvedLineShape<IChordData>[];
    getInteractionBuffer(): CurvedLineShape<IChordData>[];
}

/**
  * Responsible for generating the static chords in the system
  */
export class ChordInteractionsCache extends ShapeBufferCache<CurvedLineShape<IChordData>> {
  generate(config: IChordChartConfig, selection: Selection): void;
  buildCache(config: IChordChartConfig, selection: Selection): void;
}

/**
  * Responsible for generating the static labels around the chart
  *
  * @export
  * @class LabelBaseCache
  * @extends {ShapeBufferCache<Label<ICurvedLineData>>}
  */
export class LabelBaseCache extends ShapeBufferCache<Label<IOuterRingData>> {
  generate(data: IData, outerRingGenerator: OuterRingGenerator, config: IChordChartConfig, selection: Selection): void;
  buildCache(data: IData, outerRingGenerator: OuterRingGenerator, config: IChordChartConfig, selection: Selection): void;
  preProcessData(data: IData, outerRings: CurvedLineShape<IOuterRingData>[], config: IChordChartConfig): {
    anchor: AnchorPosition;
    angle: number;
    direction: IPoint;
    name: string;
    point: {
      x: number;
      y: number;
    };
  }[];
}

export class LabelGenerator {
  baseCache: LabelBaseCache;
  allLabels: Label<any>[];
  currentData: IData;
  bustCaches(data: IData, config: IChordChartConfig, selection: Selection): void;
  /** */
  generate(data: IData, config: IChordChartConfig, outerRingGenerator: OuterRingGenerator, selection: Selection): void;
  getBaseBuffer(): Label<IOuterRingData>[];
}

/**
  * Responsible for generating the static outer rings in the system
  */
export class OuterRingBaseCache extends ShapeBufferCache<CurvedLineShape<IOuterRingData>> {
    generate(data: IData, config: IChordChartConfig, selection: Selection): void;
    buildCache(data: IData, config: IChordChartConfig, selection: Selection): void;
    /**
      * This processes the data to calculate initial needed metrics to make generating
      * shapes simpler.
      */
    preProcessData(data: IData, config: IChordChartConfig): {
        color: RGBColor;
        controlPoint: {
            x: number;
            y: number;
        };
        flows: IChord[];
        id: string;
        p1: {
            x: number;
            y: number;
        };
        p2: {
            x: number;
            y: number;
        };
        source: IEndpoint;
    }[];
}

export class OuterRingGenerator {
    outerRingBase: OuterRingBaseCache;
    outerRingInteraction: OuterRingInteractionsCache;
    /** Tracks last data set that was rendered */
    lastData: IChordData;
    lastHemisphere: boolean;
    /**
      * Flag which caches need busting
      */
    bustCaches(data: IChordData, config: IChordChartConfig, selection: Selection): void;
    /**
      * Generates the buffers for static outer rings in the charts
      */
    generate(data: IChordData, config: IChordChartConfig, selection: Selection): void;
    /**
      * Get the base buffer
      */
    getBaseBuffer(): CurvedLineShape<IOuterRingData>[];
    getInteractionBuffer(): CurvedLineShape<IOuterRingData>[];
}

/**
  * Responsible for generating the static OuterRings in the system
  */
export class OuterRingInteractionsCache extends ShapeBufferCache<CurvedLineShape<IOuterRingData>> {
  generate(data: IData, config: IChordChartConfig, selection: Selection): void;
  buildCache(data: IData, config: IChordChartConfig, selection: Selection): void;
}

export enum LabelDirectionEnum {
    LINEAR = 0,
    RADIAL = 1,
}
/**
  * This defines the configuration properties the chord chart uses to alter how
  * it is being rendered.
  */
export interface IChordChartConfig {
    /** This sets the center of the circle */
    center: IPoint;
    /** This sets how far from the initial circle center groupings should be pushed away */
    groupSplitDistance: number;
    /** This sets how the labels are rotated (radiating out or straight) */
    labelDirection: LabelDirectionEnum;
    /** Sets the padding between outer ring segments (in radians) */
    outerRingSegmentPadding: number;
    /** Sets the padding between rows of outer ring segments (in pixels) */
    outerRingSegmentRowPadding: number;
    /** Sets the radius of the inner circle space where chords are drawn */
    radius: number;
    /** Sets the width of an outer ring */
    ringWidth: number;
    /** When true, the top level groupings will be split out by the group split distance */
    splitTopLevelGroups: boolean;
    /** This sets the padding (in radians) of the top level groupings of items */
    topLevelGroupPadding: number;
}
/**
  * This is the base raw data calculated for the chord chart
  */
export interface IData {
    tree?: IEndpoint[];
    endpoints: IEndpoint[];
    flows: IChord[];
    /** Quick look up for an end point by it's id */
    endpointById?: Map<string, IEndpoint>;
    /** Get the top level end point for a given child end point's id */
    topEndPointByEndPointId?: Map<string, IEndpoint>;
    /** Stores the max depth of a given top level end point */
    topEndPointMaxDepth?: Map<IEndpoint, number>;
}
/**
  * This defines the raw data needed for an end point in the chord chart
  */
export interface IEndpoint {
    children?: IEndpoint[];
    id: string;
    name: string;
    startAngle?: number;
    endAngle?: number;
    outgoingCount?: number;
    incomingCount?: number;
    parent: string;
    totalCount?: number;
    _outflowIdx?: number;
    _inflowIdx?: number;
    weight: number;
}
/**
  * This defines the raw data needed to render a chord in the chord chart
  */
export interface IChord {
    srcExpandedTarget?: string;
    srcTarget: string;
    destExpandedTarget?: string;
    dstTarget: string;
    srcIndex?: number;
    dstIndex?: number;
    baseColor?: HSLColor;
}

export interface IChordChartGLProperties extends IWebGLSurfaceProperties {
    /** Special case lines that use specific processes to animate */
    animatedCurvedLines?: CurvedLineShape<any>[];
    /** Lines that change frequently due to interactions */
    interactiveCurvedLines?: CurvedLineShape<any>[];
    interactiveRingLines?: CurvedLineShape<any>[];
    /** Labels that change frequently due to interactions */
    interactiveLabels?: Label<any>[];
    /** Lines that do not change often */
    staticCurvedLines?: CurvedLineShape<any>[];
    /** It is used to seperater from curved lines */
    staticRingLines?: CurvedLineShape<any>[];
    /** Event handlers */
    onMouseHover?(curves: CurvedLineShape<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    onMouseLeave?(curves: CurvedLineShape<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    onMouseUp?(curves: CurvedLineShape<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
}
/**
  * The base component for the communications view
  */
export class ChordChartGL extends WebGLSurface<IChordChartGLProperties, {}> {
    animatedCurvedBufferItems: IBufferItems<CurvedLineShape<any>, Mesh>;
    interactiveCurvedBufferItems: IBufferItems<CurvedLineShape<any>, Mesh>;
    interactiveRingBufferItems: IBufferItems<CurvedLineShape<any>, Mesh>;
    staticCurvedBufferItems: IBufferItems<CurvedLineShape<any>, Mesh>;
    staticRingBufferItems: IBufferItems<CurvedLineShape<any>, Mesh>;
    staticLabelBufferItems: IBufferItems<Label<any>, Mesh>;
    interactiveLabelBufferItems: IBufferItems<Label<any>, Mesh>;
    /** The current dataset that is being rendered by this component */
    animatedCurvedLines: CurvedLineShape<any>[];
    /** The current dataset that is being rendered by this component */
    interactiveCurvedLines: CurvedLineShape<any>[];
    interactiveRingLines: CurvedLineShape<any>[];
    /** The current dataset that is being rendered by this component */
    staticCurvedLineSet: CurvedLineShape<any>[];
    mouseHovered: Map<any, boolean>;
    /**
      * Applies new props injected into this component.
      *
      * @param  props The new properties for this component
      */
    applyBufferChanges(props: IChordChartGLProperties): void;
    /**
      * @override
      *
      * This special hook is called when the labels are ready for rendering
      *
      * @param props The newly applied props being applied to this component
      */
    applyLabelBufferChanges(props: IChordChartGLProperties): void;
    /**
      * This is a hook allowing sub classes to have a place to initialize their buffers
      * and materials etc.
      */
    initBuffers(): void;
    onMouseHover(hitInside: Bounds<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    onMouseLeave(left: Bounds<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    onMouseUp(e: React.MouseEvent<HTMLDivElement>, hitInside: Bounds<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    /**
      * Any uniforms tied to changes in the camera are updated here
      */
    updateCameraUniforms(): void;
}

export interface IChordChartProps {
    onEndPointClick?(curve: CurvedLineShape<any>): void;
    hemiSphere: boolean;
    data: IData;
}
export interface IChordChartState {
    zoom: number;
    data: IData;
}
/**
  * This defines a component that will render some test results. The shapes
  * rendered will be quads or bezier curves. The quads are for sanity and
  * debugging purposes.
  */
export class ChordChart extends React.Component<IChordChartProps, IChordChartState> {
    /** Indicates if this component has fully mounted already or not */
    initialized: boolean;
    /** This is the generator that produces the buffers for our quads */
    chordGenerator: ChordGenerator;
    /** This is the generator that produces the buffers for our labels */
    labelGenerator: LabelGenerator;
    /** This is the generator that produces the buffers for our outer rings */
    outerRingGenerator: OuterRingGenerator;
    /** Selection manager */
    selection: Selection;
    viewport: Bounds<never>;
    state: IChordChartState;
    /**
      * @override
      * We initialize any needed state here
      */
    componentWillMount(): void;
    componentWillReceiveProps(nextProps: any): void;
    componentDidMount(): void;
    handleZoomRequest: (zoom: number) => void;
    handleMouseHover: (selections: any[], mouse: any, world: any, projection: any) => void;
    handleMouseLeave: (selections: any[], mouse: any, world: any, projection: any) => void;
    handleMouseUp: (selections: any[], mouse: any, world: any, projection: any) => void;
    /**
      * @override
      * The react render method
      */
    render(): JSX.Element;
}

export enum SelectionType {
  MOUSEOVER_OUTER_RING = 0,
  MOUSEOVER_CHORD = 1,
  SELECTED_CHORD = 2,
  RELATED_SELECTED_OUTER_SECTIONS = 3,
}
export class Selection extends CustomSelection {
}

export interface IChordData {
  source: IChord;
  outerRings: CurvedLineShape<IOuterRingData>[];
}

export interface IOuterRingData {
  source: IEndpoint;
  chords: CurvedLineShape<any>[];
}

/**
  * Recalculates tree properties startAngle and endAngle for each IEndpoint accounting for nested angles.
  * Angles calculated in radians
  * Not immutable - parents expected to pass in immutable tree object (flows object not modified)
  *
  * @export
  * @param {IEndpoint[]} endpoints - graph endpoint set
  * @returns {IEndpoint[]} endpoint tree - with children[], startAngle, endAngle populated
  */
export function recalculateTree(tree: IEndpoint[], flows: IChord[]): IEndpoint[];
/**
  * Traverses tree structure with provided algorithm path, executing callback function at each node. If callback returns true, traversal is terminated.
  *
  * @export
  * @param {IEndpoint[]} tree - tree of endpoints
  */
export function traverseSubtree(startNode: IEndpoint, callback: Function, traversalType: string): void;
/**
  * Flatten tree to a list of endpoints
  * Immutable
  *
  * @export
  * @param {IEndpoint[]} tree - tree of endpoints
  * @returns {IEndpoint[]} endpoint list - a list of all endpoints
  */
export function flattenTree(tree: IEndpoint[]): IEndpoint[];
/**
  * Filters tree of endpoints down to leaf node set
  * Immutable
  *
  * @export
  * @param {IEndpoint[]} tree - tree of endpoints
  */
export function getTreeLeafNodes(tree: IEndpoint[]): IEndpoint[];
export function getAncestor(node: IEndpoint, tree: IEndpoint[]): IEndpoint;

/**
  * This defines a drawable curved line shape. It contains the information necessary
  * to efficiently render the line.
  *
  * @export
  * @class CurvedLineShape
  * @extends {CurvedLine<T>}
  * @template T An associated data type that can be linked to this shape to make data retrieval from interacting
  *             with the shape easier.
  */
export class CurvedLineShape<T> extends CurvedLine<T> {
    /** When true, this line will cache the segments of the curve as rendered quads */
    cachesQuadSegments: boolean;
    /** If caching is set, then this stores the calculated quads that composes this line */
    cachedQuadSegments: IPoint[];
    /** How thick the line should be */
    lineWidth: number;
    /** Depeth of draw location */
    depth: number;
    r: number;
    g: number;
    b: number;
    a: number;
    /**
      * Applies an rgb color to this curve.
      */
    color: RGBColor;
    /**
      * Retrieves the color of this curve based on 256 value colors
      * @return {RGBColor}
      */
    readonly color256: RGBColor;
    /**
      * Creates an instance of CurvedLineShape.
      *
      * @param {CurveType} type The curve type. Defines
      * @param {IPoint} p1
      * @param {IPoint} p2
      * @param {IPoint[]} controlPoints
      * @param {number} [resolution=20]
      * @param {boolean} [cacheSegments=false]
      */
    constructor(type: CurveType, p1: IPoint, p2: IPoint, controlPoints: IPoint[], color?: RGBColor, resolution?: number, cacheSegments?: boolean);
    /**
      * Returns a new instance of this object that mimicks the properties of this Object
      *
      * @returns {CurvedLineShape<T>} The cloned object
      */
    clone(): CurvedLineShape<T>;
    /**
      * @override
      * See base definition
      */
    distanceTo(point: IPoint): number;
    /**
      * This produces a triangle strip that represents the quads that composes this line. If caching is present,
      * subsequent calls to this method will be much faster unless the cache gets invalidated.
      *
      * @return {IPoint[]} The Triangle Strip of points to create the quads that make each segment of the curve
      */
    getTriangleStrip(): IPoint[];
    /**
      * @override
      * Adjusts the relevant points that defines the curve and recalculates all items necessary
      *
      * @param {IPoint} p1
      * @param {IPoint} p2
      * @param {IPoint[]} controlPoints
      */
    setPoints(p1: IPoint, p2: IPoint, controlPoints?: IPoint[]): void;
}

export class Label<T> extends RotateableQuad<T> {
    color: RGBColor;
    depth: number;
    direction: string;
    font: string;
    fontSize: number;
    fontWeight: number;
    maxWidth: number;
    text: string;
    textAlign: 'start' | 'center' | 'right';
    textBaseline: 'bottom' | 'alphabetic' | 'middle' | 'top' | 'hanging';
    zoomable: boolean;
    /** This contains the texture information that was used to rasterize the label */
    rasterizedLabel: AtlasTexture;
    /**
      * This contains an adjustment to aid in the rasterization process. Getting
      * reliable dimensions for fonts and text can be incredibly challenging,
      * thus, this allows you to offset the rasterization if you get pieces of
      * the label cut off.
      */
    rasterizationOffset: IPoint;
    /**
      * This contains an adjustment to aid in the rasterization process. Getting
      * reliable dimensions for fonts and text can be incredibly challenging,
      * thus, this allows you to pad the rasterization space if you get pieces of
      * the label cut off.
      */
    rasterizationPadding: ISize;
    /**
      * Creates an instance of Label.
      *
      * @param {Partial<Label<T>>} [options={}]
      */
    constructor(options?: Partial<Label<T>>);
    /**
      * Copies all of the properties of a label and makes this label use them
      *
      * @param {Label} label The labels whose properties we wish to copy
      */
    copyLabel(label: Label<T>): void;
    /**
      * Takes all of the current settings and makes a CSS font string
      */
    makeCSSFont(fontSize?: number): string;
    /**
      * Change the position this text is rendered to
      *
      * @param x X world coordinate
      * @param y Y world coordinate
      */
    position(x: number, y: number): void;
    /**
      * Change the text and the calculated bounding box for this label
      */
    setText(lbl: string): void;
}

/**
  * A canvas element wrapper that aids in tracking a canvas element along with
  * content scaling properties.
  *
  * @class Sprite
  */
export class Sprite {
    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;
    scaleX: number;
    scaleY: number;
    /**
      * Retrieves the content scaling of this object
      *
      * @readonly
      *
      * @memberOf Sprite
      */
    getContentScale(): {
        x: number;
        y: number;
    };
    /**
      * Retrieves the size of the content ignoring scaling
      *
      * @readonly
      *
      * @memberOf Sprite
      */
    getContentSize(): {
        height: number;
        width: number;
    };
    /**
      * Retrieves the dimensional width of the content applying scaling
      *
      * @readonly
      *
      * @memberOf Sprite
      */
    getWidth(): number;
    /**
      * Retrieves the dimensional height of the content applying scaling
      *
      * @readonly
      *
      * @memberOf Sprite
      */
    getHeight(): number;
    /**
      * Creates an instance of Sprite.
      *
      * @param w             The width of the context to create
      * @param h             The height of the context to create
      * @param contentScaleX The content scaling of the content
      * @param contentScaleY The content scaling of the content
      *
      * @memberOf Sprite
      */
    constructor(w: number, h: number, contentScaleX: number, contentScaleY: number);
}

/**
  * Defines a manager of atlas', which includes generating the atlas and producing
  * textures defining those pieces of atlas.
  */
export class AtlasManager {
    /** Gives a reference of all of the images loaded for the atlas */
    atlasImages: {
        [key: string]: AtlasTexture[];
    };
    /** Stores the current mapping of the atlas */
    atlasMap: {
        [key: string]: PackNode;
    };
    /** Stores all of the textures that are our atlases */
    atlasTexture: {
        [key: string]: Texture;
    };
    /** Stores Atlas textures dimensions. Every new atlas created will use this as it's width */
    textureWidth: number;
    /** Stores Atlas textures dimensions. Every new atlas created will use this as it's height */
    textureHeight: number;
    /**
      * Generates a new manager for atlas'. This will create and destroy atlas' and
      * ensure they have the correct settings applied. A manager will also aid in
      * packing images into the atlas indicated.
      *
      * @param {number} width The width of all atlas' generated
      * @param {number} height The height of all atlas' generated
      */
    constructor(width: number, height: number);
    /**
      * Atlas' must be created from scratch to update them. In order to properly
      * update an existing one, you must destroy it then recreate it again.
      * This is from not knowing how to update a texture via three js.
      *
      * @param atlasName The unique name of the atlas so it can be retrieved/referenced easily
      * @param images The images with their image path set to be loaded into the atlas.
      *               Images that keep an atlas ID of null indicates the image did not load
      *               correctly
      *
      * @return {Texture} The Threejs texture that is created as our atlas. The images injected
      *                   into the texture will be populated with the atlas'
      */
    createAtlas(atlasName: string, images: AtlasTexture[]): Promise<Texture>;
    /**
      * Disposes of the resources the atlas held and makes the atlas invalid for use
      *
      * @param atlasName
      */
    destroyAtlas(atlasName: string): void;
    /**
      * This loads, packs, and draws the indicated image into the specified canvas
      * using the metrics that exists for the specified atlas.
      *
      * @param image The image who should have it's image path loaded
      * @param atlasName The name of the atlas to make the packing work
      * @param canvas The canvas we will be drawing into to generate the complete image
      *
      * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not
      */
    draw(image: AtlasTexture, atlasName: string, canvas: CanvasRenderingContext2D): Promise<boolean>;
    /**
      * Retrieves the threejs texture for the atlas
      *
      * @param atlasName The identifier of the atlas
      */
    getAtlasTexture(atlasName: string): Texture;
    /**
      * This reads the input path and loads the image specified by the path
      *
      * @param {AtlasTexture} texture This is an atlas texture with the path set
      *
      * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image
      *                                     or null if there was an error
      */
    loadImage(texture: AtlasTexture): Promise<HTMLImageElement | null>;
}

/**
  * Defines a texture that is located on an atlas
  */
export class AtlasTexture {
    imagePath: string;
    label: Label<any>;
    /** Stores the aspect ratio of the image for quick reference */
    aspectRatio: number;
    pixelWidth: number;
    pixelHeight: number;
    atlasReferenceID: string;
    atlasTL: IPoint;
    atlasTR: IPoint;
    atlasBL: IPoint;
    atlasBR: IPoint;
    /**
      * Generates a new atlas texture that points to a specific image resource.
      *
      * @param path The path to the image resource to be loaded into the atlas.
      */
    constructor(path?: string, label?: Label<any>);
}

/**
  * Class to manage the x, y, width, and height of an object
  *
  * @template T This specifies the data type associated with this shape and is accessible
  *             via the property 'd'
  */
export class Bounds<T> {
    /** The total rectangular surface area of this instance */
    readonly area: number;
    /** The bottom coordinate for this instance (y + height) */
    readonly bottom: number;
    height: number;
    item: null;
    /** An x, y coordinate pair representing the center of this object */
    readonly mid: {
        x: number;
        y: number;
    };
    readonly right: number;
    /** A data object for relating this shape to some information */
    d: T;
    width: number;
    x: number;
    y: number;
    /**
      * Create a new instance
      *
      * @param left  The left side (x coordinate) of the instance
      * @param right The right side of the instance
      * @param top The top (y coordinate) of the instance
      * @param bottom The bottom of the instance
      */
    constructor(left: number, right: number, top: number, bottom: number);
    /**
      * Check to see if a given point lies within the bounds of this instance
      *
      * @param point The point to check
      */
    containsPoint(point: IPoint): boolean;
    /**
      * Copies the properties of the bounds specified
      *
      * @param b The bounds whose dimensions we wish to copy
      */
    copyBounds(b: Bounds<any>): void;
    /**
      * Ensure that this object contains the smaller bounds
      *
      * This method will not shrink this class, but only grow it as necessary to
      * fit the destination object
      *
      * @param bounds The bounds to encapsulate
      */
    encapsulate(bounds: Bounds<any>): void;
    /**
      * Ensure that this object contains the provided list of bounds
      *
      * This will never shrink or modify the original area covered by this bounds
      * but will instead stay the same or include the original area plus the specified
      * list of bounds.
      *
      * @param {Bounds<any>[]} bounds The list of bounds objects to encapsulate
      * @param {boolean} sizeToFirst If this is set, the procedure will start by making this bounds
      *                              be a clone of the first bounds object in the list
      */
    encapsulateBounds(bounds: Bounds<any>[], sizeToFirst?: boolean): void;
    /**
      * Grow this class to contain the specified point
      *
      * This method will not shrink this instance. It will only grow it as
      * necessary.
      *
      * @param point The point to encapsulate
      */
    encapsulatePoint(point: IPoint): void;
    /**
      * Efficiently encapsulates a set of points by growing the current dimensions
      * of the bounds until the points are enclosed. This will perform faster than
      * running encapsulatePoint for a list of points.
      *
      * @param points An array of points that Can be of format {x, y} or [x, y]
      *
      * @memberOf Bounds
      */
    encapsulatePoints(points: any[]): void;
    /**
      * Checks to see if another bounds fits in itself.
      *
      * @param {Bounds} inner The bounds to test against
      *
      * @return {number} int 1 is an exact fit, 2 it fits with space, 0 it doesn't fit
      */
    fits(inner: Bounds<T>): number;
    /**
      * Check to see if the provided bounds intersects with this instance
      *
      * @param bounds The bounds to test against this instance
      *
      * @return True if the other object intersects with this instance
      */
    hitBounds(bounds: Bounds<T>): boolean;
    /**
      * Tests if a point is inside this bounds
      *
      * @param p The point to test
      *
      * @return boolean The point to test
      */
    pointInside(p: IPoint): boolean;
    /**
      * Test function to type check the provided value
      *
      * @return True if value is a bounds object
      */
    static isBounds(value: any): value is Bounds<any>;
    /**
      * Check if the provided bounds is completely contained within this instance
      *
      * @param bounds The bounds to test against this instance
      *
      * @return True if the provided bounds is completely contained within this
      * instance
      */
    isInside(bounds: Bounds<T>): boolean;
    /**
      * Generates a Bounds object covering max extents
      *
      * @return {Bounds} bounds covering as wide of a range as possible
      */
    static maxBounds(): Bounds<{}>;
}

/**
  * This enum covers the type of curved lines that can be made. Making a specific curve
  *
  * @export
  * @enum {number}
  */
export enum CurveType {
    /** This will make the curve be generated from interpolating between the end points and provided control points */
    Bezier = 0,
    /**
      * This will draw a curve as though there is a circular arc passing over the two end points. The radius of the
      * circular arc is determined by how far the control point is from the straight line that can be made from the two
      * end points.
      */
    CircularCCW = 1,
    CircularCW = 2,
    /**
      * This ignores the control points altogether and just created a straight line with a single segment that consists
      * of the specified endpoints
      */
    Straight = 3,
}
/**
  * Defines an object which illustrates a curved line. Curved lines can be formed in many
  * ways but most often from two end points and some provided control points.
  *
  * @export
  * @class CurvedLine
  * @extends {Bounds<T>}
  * @template T An associated data type with this object. Use <never> if no data type is ever associated
  */
export class CurvedLine<T> extends Bounds<T> {
    /** Stores the segments that have been calculated. Only gets populated if cachesSegments is true */
    cachedSegments: IPoint[];
    /** Flag to indicate if this line caches its segments. Uses more ram but performs better if true */
    cachesSegments: boolean;
    /**
      * The control points used for calculating the curvature of the line. Circular curves only use a single point
      * to indicate the middle of the circle that the line arcs from.
      */
    controlPoints: IPoint[];
    /** This is the automatically set method that will be used in calculating the distance to a point from this line */
    distanceMethod: (line: CurvedLine<any>, point: IPoint) => number;
    /** This is an end point of the line */
    p1: IPoint;
    /** This is an end point of the line */
    p2: IPoint;
    /** This is how many segments can be used to generate the line. More segments = less performant but prettier */
    resolution: number;
    /** This is the automatically set method used to calculate the segments needed to piece together the curve */
    segmentMethod: (line: CurvedLine<any>) => IPoint[];
    /** This indicates how the curve is formed from the control points. See the enum values for more details. */
    type: CurveType;
    /**
      * Generates a primitive that describes a curved line, which is defined by the lines end points, type, and control points
      *
      * @param {CurveType} type The type of curve. Determines how the control points are utilized
      * @param {IPoint} p1 The start of the curve
      * @param {IPoint} p2 The end of the curve
      * @param {IPoint[]} controlPoints The control points that affects the curvature of the line
      * @param {number} [resolution=20] The number of segments used to compose the line (more segments means prettier but more costly lines)
      * @param {boolean} [cacheSegments=false] Speeds up line calculations for when the line does not change but takes more RAM
      *
      * @memberof CurvedLine
      */
    constructor(type: CurveType, p1: IPoint, p2: IPoint, controlPoints: IPoint[], resolution?: number, cacheSegments?: boolean);
    readonly values: {
        controlPoints: IPoint[];
        p1: IPoint;
        p2: IPoint;
    };
    /**
      * Calculates the nearest distance from the provided point to this curved line
      *
      * @param {IPoint} point The point to test the distance from
      *
      * @returns {number} The calculated nearest distance from this curve to the point
      */
    distanceTo(point: IPoint): number;
    /**
      * Picks the closest line in the list to a given point
      *
      * @param {CurvedLine<any>[]} lines The lines to compare
      * @param {IPoint} p The point to compare against
      *
      * @return {Line} The nearest line to the point
      */
    static getClosest<T>(lines: CurvedLine<T>[], point: IPoint): undefined;
    /**
      * This returns the line strip that represents the curve. A line strip is specifically a group of points
      * that forms line segments by taking the current point as one end and the previous point as the second end
      * thus, you would start at index 1 and loop to the end to generate all of the lines composing this single
      * line.
      *
      * @return {IPoint[]} All of the points in the line strip
      */
    getLineStrip(): IPoint[];
    /**
      * Adjusts the relevant points that defines the curve and recalculates all items necessary
      *
      * @param {IPoint} p1
      * @param {IPoint} p2
      * @param {IPoint[]} controlPoints
      * @param {boolean} preventRebounding If set, this will prevent the bounds from being recalculated
      */
    setPoints(p1: IPoint, p2: IPoint, controlPoints?: IPoint[]): void;
}

/**
  * Represents a line with a given slope
  */
export class Line<T> extends Bounds<T> {
    p1: IPoint;
    p2: IPoint;
    slope: number;
    magnitude: number;
    /** Stores a normalized vector that is perpendicular to this line */
    perpendicular: IPoint;
    /**
      * Creates a new line that passes through the two specified points
      *
      * @param {IPoint} p1 The start point
      * @param {IPoint} p2 The end point
      */
    constructor(p1: IPoint, p2: IPoint);
    /**
      * This calculates the distance to a point from the provided line
      * BUT this ALSO retains the directionality of that distance. So one side of
      * the line will be positive while the other negative
      *
      * @param {IPoint} p The Point to see how far from the line we are
      *
      * @return {number} The calculated distance to the provided point
      */
    directionTo(p: IPoint): number;
    /**
      * This calculates the distance to a point from the provided line
      *
      * @param {IPoint} p The Point to see how far from the line we are
      *
      * @return {number} The calculated distance to the provided point
      */
    distanceTo(p: IPoint): number;
    /**
      * Picks the closest line in the list to a given point
      *
      * @param {Array} lines The lines to compare
      * @param {IPoint} p The point to compare against
      *
      * @return {Line} The nearest line to the point
      */
    static getClosest(lines: Line<any>[], p: IPoint): Line<any>;
    /**
      * This sets the two endpoints for this line and recalculates the bounds
      * of the line accordingly
      *
      * @param {IPoint} p1 The start point
      * @param {IPoint} p2 The end point
      */
    setPoints(p1: IPoint, p2: IPoint): void;
}

/**
  * Defines a 2d point within a coordinate plane
  */
export interface IPoint {
    x: number;
    y: number;
}
/**
  * Contains methods for managing or manipulating points
  *
  * @export
  * @class Point
  */
export class Point {
    /**
      * Adds two points together
      *
      * @static
      * @param {IPoint} p1
      * @param {IPoint} p2
      * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object
      *
      * @return {IPoint} The two points added together
      */
    static add(p1: IPoint, p2: IPoint, out?: IPoint): IPoint;
    /**
      * @static
      * This analyzes a test point against a list of points and determines which of the points is
      * the closest to the test point. If there are equi-distant points in the list, this will return
      * the first found in the list.
      *
      * @param {IPoint} testPoint The point to compare against other points
      * @param {IPoint[]} points The list of points to be compared against
      *
      * @return {IPoint} The closest point to the test point
      */
    static getClosest(testPoint: IPoint, points: IPoint[]): IPoint;
    /**
      * @static
      * This analyzes a test point against a list of points and determines which of the points is
      * the closest to the test point. If there are equi-distant points in the list, this will return
      * the first found in the list.
      *
      * This just returns the index of the found point and not the point itself
      *
      * @param {IPoint} testPoint The point to compare against other points
      * @param {IPoint[]} points The list of points to be compared against
      *
      * @return {number} The index of the closest point to the test point
      */
    static getClosestIndex(testPoint: IPoint, points: IPoint[]): number;
    /**
      * @static
      * This will calculate a direction vector between two points that points toward p2
      *
      * @param {IPoint} p1 The start of the direction
      * @param {IPoint} p2 The direction to point the vector towards
      * @param {boolean} normalize If true, this will make the vector have a magnitude of 1
      *
      * @returns {number}
      */
    static getDirection(p1: IPoint, p2: IPoint, normalize?: boolean): IPoint;
    /**
      * @static
      * Gets the distance between two points
      *
      * @param {IPoint} p1
      * @param {IPoint} p2
      * @param {boolean} squared If set to true, returns the distance * distance (performs faster)
      *
      * @returns {number} The real distance between two points
      */
    static getDistance(p1: IPoint, p2: IPoint, squared?: boolean): number;
    /**
      * @static
      * Gets a point perfectly between two points
      *
      * @param {IPoint} p1
      * @param {IPoint} p2
      *
      * @returns {IPoint} The point between the two provided points
      */
    static getMidpoint(p1: IPoint, p2: IPoint): {
        x: number;
        y: number;
    };
    static make(x: number, y: number): {
        x: number;
        y: number;
    };
    /**
      * Scales a point by a given amount
      *
      * @static
      * @param {IPoint} p1
      * @param {number} s The amount to scale the point by
      * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object
      *
      * @memberof Point
      */
    static scale(p1: IPoint, s: number, out?: IPoint): IPoint;
    /**
      * Makes a new point initialized to {0,0}
      *
      * @static
      * @returns {IPoint} A new point object at {0,0}
      */
    static zero(): IPoint;
}

export enum AnchorPosition {
    BottomLeft = 0,
    BottomRight = 1,
    Custom = 2,
    Middle = 3,
    MiddleBottom = 4,
    MiddleLeft = 5,
    MiddleRight = 6,
    MiddleTop = 7,
    TopLeft = 8,
    TopRight = 9,
}
export class RotateableQuad<T> extends Bounds<T> {
    BL: Vector4;
    BR: Vector4;
    TL: Vector4;
    TR: Vector4;
    /**
      * Generates a quad
      *
      * @param {IPoint} location The location of the quad (it's anchorpoint will be placed here)
      * @param {number} width The width of the quad
      * @param {number} height The height of the quad
      * @param {AnchorPosition} anchor The anchor location of the quad.
      *                                Location and rotation will be relative to this.
      */
    constructor(location: IPoint, size: ISize, rotation: number, anchor?: AnchorPosition);
    /**
      * Get the base size of the quad
      *
      * @returns {ISize} The base size of this quad
      */
    getSize(): ISize;
    /**
      * Sets the specified anchor position on the quad
      *
      * @param {AnchorPosition} anchor This specifies an auto calculated position for the anchor
      * @param {IPoint} custom If specified, will set a custom anchor location rather
      *                        than the calculated version.
      */
    setAnchor(anchor?: AnchorPosition, custom?: IPoint): void;
    /**
      * This sets the location of this quad to a given position where the anchor
      * point will be located on top of the location provided.
      *
      * @param {IPoint} location The location to place the quad
      */
    setLocation(location: IPoint): void;
    /**
      * Sets the rotation of this quad, in radians, rotated around the anchor point.
      *
      * @param {number} rotation The rotation of the quad
      */
    setRotation(rotation: number): void;
    /**
      * Applies the size to the base
      *
      * @param {ISize} size The size of the base quad
      */
    setSize(size: ISize): void;
    /**
      * This re-calculates the transform for this quad and applies the transform to
      * the corners.
      */
    update(): void;
}

/**
  * Defines a 2d size, having only width and height
  */
export interface ISize {
  width: number;
  height: number;
}

export enum AttributeSize {
    ONE = 0,
    TWO = 1,
    THREE = 2,
    FOUR = 3,
}
export interface IAttributeInfo {
    defaults: number[];
    name: string;
    size: AttributeSize;
}
/**
  * These are all of the items needed for rendering and determining if a re-render
  * is necessary
  */
export interface IBufferItems<T, U> {
    attributes: IAttributeInfo[];
    geometry: BufferGeometry;
    system: U;
    currentData: T[];
}
/**
  * This provides methods for handling common buffer tasks such as construction
  * and population.
  */
export class BufferUtil {
    /**
      * This places our updateBuffer into a mode where the updates start at index 0 of the
      * buffer. Subsequent calls will start where the previous call left off. This lets
      * you stream in updates to the buffer rather than just update the entire buffer
      * all at once.
      */
    static beginUpdates(): void;
    /**
      * This stops updates streaming into the buffers and makes it where an update
      * will always just start at the beginning of the buffer.
      */
    static endUpdates(): number;
    /**
      * @static
      * This handles many of the common tasks associated with constructing a new buffer
      * such as applying the name, generating the buffer, and populating default values to
      * that buffer.
      *
      * @param {number} numVertices The number of vertices this buffer will have
      * @param {IAttributeInfo[]} attributes A description of each attribute in the buffer
      *
      * @returns {BufferGeometry} The newly made buffer
      */
    static makeBuffer(numVertices: number, attributes: IAttributeInfo[]): BufferGeometry;
    /**
      * @static
      * This handles many of the common tasks associated with updating a buffer. You specify how many vertices
      * to update in a batch and you specify how many batches are present.
      *
      * Batches are used to represent your full shape object that is being loaded from the cpu:
      *
      * IE- you have a rectangle object you wish to update in your buffer. This takes around 6 vertices typically
      * so you make your vertexBatch 6 and the numBatches the number of quads you need to update in the buffer.
      *
      * You then provide an accessor which aids in pointing to the buffer items that need updating. The accessor has
      * variable arguments depending on the attributes you inject in.
      *
      * If you have attributes like:
      * [
      *  {name: position, size: AttributeSize.Three},
      *  {name: color, size: AttributeSize.Four},
      * ]
      *
      * Then your accessor will be delievered arguments in this form:
      *
      * function(batchIndex: number, positionBuffer: number[], positionIndex: number, colorBuffer: number[], colorIndex: number)
      *
      * NOTE: The params handed in ARE ORDERED BY the attributes injected in
      *
      * You then can update the buffers based on the index information handed alongside each buffer
      *
      * @param {T[]} newData The new data that is going to be injected into the buffer. This must be a NEW REFERENCE of data
      *                      that does NOT match the reference in the bufferItems.currentData. So newData !== bufferItems.currentData
      *                      in order for the update to occur.
      * @param {BufferGeometry} bufferItems The buffer related items used to identify how to update the buffer
      * @param {number} vertexBatch The number of vertices to include per update batch
      * @param {number} numBatches The number of batches to execute
      * @param {Function} updateAccessor The accessor for performing the data update to the buffer
      *
      * @return {boolean} True if the buffer was updated with this call
      */
    static updateBuffer<T, U>(newData: T[], bufferItems: IBufferItems<T, U>, vertexBatch: number, numBatches: number, updateAccessor: Function): boolean;
    /**
      * This makes all of the typical items used in creating and managing a buffer of items rendered to the screen
      *
      * @returns {IBufferItems<T>} An empty object of the particular buffer items needed
      */
    static makeBufferItems<T, U>(): IBufferItems<T, U>;
}

/**
  * Takes a map of the form <T, boolean> and returns an array of the keys,
  * excluding entries who's mapped value is false.
  *
  * @param map The map to convert to a list
  *
  * @return T[] A list of the keys, exluding false mappings
  */
export function boolMapToArray<T>(map: Map<T, boolean>): T[];
/**
  * Defines a selection control for custom types and categories
  */
export class CustomSelection {
    /** This caches the list generation of a selection */
    cachedSelection: Map<string | number, any[]>;
    /** Map of the custom categories to the selection state */
    selections: Map<string | number, Map<any, boolean>>;
    /** Keeps flags indicating if a selection for a given category has changed or not */
    _didSelectionChange: Map<string | number, boolean>;
    /**
      * Clears out all custom selections for every category
      */
    clearAllSelections(): void;
    /**
      * Clears the selection for the category specified
      *
      * @param {string} category Name of the category of selection
      */
    clearSelection(category: string | number): void;
    /**
      * Makes an item no longer flaged as selected within the given category
      *
      * @param category The custom category of the selection
      * @param item The item to remove from being selected
      */
    deselect<T>(category: string | number, item: T): void;
    /**
      * Checks if a selection from a category has been modified
      *
      * @param {string} category The selection category to check
      */
    didSelectionCategoryChange(category: string | number): boolean;
    /**
      * Checks if ANY selection has changed
      *
      * @return {boolean} True if any selection has changed
      */
    didSelectionChange(): boolean;
    /**
      * This indicates that updates have taken place to account for selection
      * changes.
      */
    finalizeUpdate(): void;
    /**
      * This retrieves a list of the items that are selected
      *
      * @param category The selection category to check on
      *
      * @return {T} Returns a list of items that are currently selected
      */
    getSelection<T>(category: string | number): T[];
    /**
      * Specifies an item to flag as selected for the given category
      *
      * @param category The custom category of the selection
      * @param item The item to flag as selected
      */
    select<T>(category: string | number, item: T): void;
    /**
      * Specifies an item to toggle it's selection status for the provided category
      *
      * @param category The custom category of the selection
      * @param item The item to flag as selected
      */
    toggleSelect<T>(category: string | number, item: T): void;
}

/**
  * This calculates a quadratic bezier curve.
  *
  * We use specific bezier curve implementations for low degree curves as it is
  * much much faster to calculate.
  *
  * @param {number} t The 0 - 1 time interval for the part of the curve we desire
  * @param {IPoint} p1 The First end point of the curve
  * @param {IPoint} p2 The second end point of the curve
  * @param {IPoint} c1 The control point of the curve
  *
  * @returns {IPoint} The calculated point on the curve for the provided time interval
  */
export function bezier2(t: number, p1: IPoint, p2: IPoint, c1: IPoint): IPoint;
/**
  * This calculates a cubic bezier curve.
  *
  * We use specific bezier curve implementations for low degree curves as it is
  * much much faster to calculate.
  *
  * @param {number} t The 0 - 1 time interval for the part of the curve we desire
  * @param {IPoint} p1 The First end point of the curve
  * @param {IPoint} p2 The second end point of the curve
  * @param {IPoint} c1 The first control point of the curve
  * @param {IPoint} c2 The second control point of the curve
  *
  * @returns {IPoint} The calculated point on the curve for the provided time interval
  */
export function bezier3(t: number, p1: IPoint, p2: IPoint, c1: IPoint, c2: IPoint): IPoint;

let normalizeWheel: (e: React.WheelEvent<HTMLDivElement>) => Vector2;
/**
  * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).
  */
function eventElementPosition(e: any, relative?: HTMLElement): {
  x: number;
  y: number;
};
export { eventElementPosition, normalizeWheel };

/**
  * Helps us track the bounds of the image being loaded in tied in with the
  * texture it represents
  */
export interface ImageDimensions {
    first: AtlasTexture;
    second: Bounds<never>;
}
/**
  * This is used specifically by the atlas manager to aid in packing
  * in textures within an area. This will guarantee boundaries of textures are
  * not violated and provide proper feedback for where to draw a given image
  */
export class PackNode {
    child: [PackNode, PackNode];
    isLeaf: boolean;
    nodeDimensions: Bounds<never>;
    nodeImage: AtlasTexture;
    constructor(x: number, y: number, width: number, height: number);
    /**
      * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage
      */
    destroy(): void;
    /**
      * Indicates if there is a child
      */
    hasChild(): boolean;
    /**
      * Inserts images into our mapping, fitting them appropriately
      */
    insert(image: ImageDimensions): PackNode;
    /**
      * Removes the image from the mapping and tries to open up as much space as possible.
      *
      * @param {AtlasTexture} image The image to insert into the
      */
    remove(image: AtlasTexture): boolean;
}

/**
  * Defines projection methods used to switch between screen and world spaces
  */
export interface IProjection {
    /**
      * Get a size on the screen projected to the size in the world
      *
      * @param w The width on the screen
      * @param h The height on the screen
      * @param obj An object to inject the values in so a new object is not allocated
      *
      * @return {ISize} The newly created object or the object in the third param
      */
    screenSizeToWorld(w: number, h: number, obj?: ISize): ISize;
    /**
      * Get a position on the screen projected to a coordinate in the world
      *
      * @param x The x position on the screen
      * @param y The y position on the screen
      * @param obj An object to inject the values in so a new object is not allocated
      *
      * @return {IPoint} The newly created object or the object in the third param
      */
    screenToWorld(x: number, y: number, obj?: IPoint): IPoint;
    /**
      * Get a size in the world projected to the size on the screen
      *
      * @param w The width in the world
      * @param h The height in the world
      * @param obj An object to inject the values in so a new object is not allocated
      *
      * @return {ISize} The newly created object or the object in the third param
      */
    worldSizeToScreen(w: number, h: number, obj?: ISize): ISize;
    /**
      * Get a position in the world projected to a coordinate on the screen
      *
      * @param x The x position in the world
      * @param y The y position in the world
      * @param obj An object to inject the values in so a new object is not allocated
      *
      * @return {IPoint} The newly created object or the object in the third param
      */
    worldToScreen(x: number, y: number, obj?: IPoint): IPoint;
}

/**
  * This filters a quad tree query by type
  *
  * @export
  * @template T
  */
export function filterQuery<T extends Bounds<any>>(type: Function[], queryValues: Bounds<any>[]): T[];
/**
  * Allows typing of a callback argument
  */
export interface IVisitFunction<T extends Bounds<any>> {
    /**
      * A callback to use during add or query
      *
      * Called do provide aggregation or filtering like Array.reduce or
      * Array.filter, but in a QuadTree instead.
      *
      * @param node  The node to effect the function upon
      * @param child The child to add to the node
      */
    (node: Node<T>, child?: Bounds<any>): void;
}
/**
  * This is a class used specifically by the quad tree nodes to indicate split space
  * within the quad tree.
  *
  * @class Quadrants
  */
export class Quadrants<T extends Bounds<any>> {
    TL: Node<T>;
    TR: Node<T>;
    BL: Node<T>;
    BR: Node<T>;
    /**
      * Ensures all memory is released for all nodes and all references are removed
      * to potentially high memory consumption items
      *
      * @memberOf Quadrants
      */
    destroy(): void;
    /**
      * Creates an instance of Quadrants.
      *
      * @param bounds The bounds this will create quandrants for
      * @param depth  The child depth of this element
      *
      * @memberOf Quadrants
      */
    constructor(bounds: Bounds<any>, depth: number);
}
/**
  * The quad tree node. This Node will take in a certain population before dividing itself into
  * 4 quadrants which it will attempt to inject it's population into. If a member of the population
  * does not completely get injected into one of the quadrants it remains as a member of this node.
  *
  * @export
  * @class Node
  */
export class Node<T extends Bounds<any>> {
    bounds: Bounds<any>;
    children: T[];
    childrenProps: any[];
    depth: number;
    nodes: Quadrants<T>;
    /**
      * Destroys this node and ensures all child nodes are destroyed as well.
      *
      * @memberOf Node
      */
    destroy(): void;
    /**
      * Creates an instance of Node.
      *
      * @param l     The bounding left wall of the space this node covers
      * @param r     The bounding right wall of the space this node covers
      * @param t     The bounding top wall of the space this node covers
      * @param b     The bounding bottom wall of the space this node covers
      * @param depth The depth within the quad tree this node resides
      *
      * @memberOf Node
      */
    constructor(left: number, right: number, top: number, bottom: number, depth?: number);
    /**
      * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node
      * or into a sub quadrant if this node is split already. If the child is outside the boundaries
      * this quad tree spans (and this is the root node), the quad tree will expand to include
      * the new child.
      *
      * @param child The Bounds type object to inject
      * @param props Properties that can be retrieved with the child object if applicable
      *
      * @returns True if the insertion was successful
      *
      * @memberOf Node
      */
    add(child: T, props: any): boolean;
    /**
      * Adds a list of new children to this quad tree. It performs the same operations as
      * addChild for each child in the list, however, it more efficiently recalculates the
      * bounds necessary to cover the area the children cover.
      *
      * @param children      List of Bounds objects to inject
      * @param childrenProps List of props to associate with each element
      *
      * @memberOf Node
      */
    addAll(children: T[], childrenProps?: any[]): void;
    /**
      * Ensures this quad tree includes the bounds specified in it's spatial coverage.
      * This will cause all children to be re-injected into the tree.
      *
      * @param bounds The bounds to include in the tree's coverage
      *
      * @memberOf Node
      */
    cover(bounds: Bounds<any>): void;
    /**
      * When adding children, this performs the actual action of injecting the child into the tree
      * without the process of seeing if the tree needs a spatial adjustment to account for the child.
      *
      * @param child The Bounds item to inject into the tree
      * @param props The props to remain associated with the child
      *
      * @returns True if the injection was successful
      *
      * @memberOf Node
      */
    doAdd(child: T): boolean;
    /**
      * Collects all children of all the current and sub nodes into a single list.
      *
      * @param list The list we must aggregate children into
      *
      * @return The list specified as the list parameter
      */
    gatherChildren(list: T[]): T[];
    /**
      * Collects all props associated with the children. This array of props will
      * mirror the list retrieved with gatherChildren.
      *
      * @param list
      *
      * @returns The list specified as the list paramter
      *
      * @memberOf Node
      */
    gatherProps(list: any[]): any[];
    /**
      * Entry query for determining query type based on input object
      *
      * @param bounds Can be a Bounds or a Point object
      * @param visit  A callback function that will receive the Node as it is analyzed. This gives
      *               information on a spatial scale, how a query reaches it's target intersections.
      *
      * @return An array of children that intersects with the query
      */
    query(bounds: Bounds<any> | IPoint, visit?: IVisitFunction<T>): T[];
    /**
      * Queries children for intersection with a bounds object
      *
      * @param b     The Bounds to test children against
      * @param list  The list of children to aggregate into the query
      * @param visit A callback function that will receive the Node as it is analyzed. This gives
      *              information on a spatial scale, how a query reaches it's target intersections.
      *
      * @return     Returns the exact same list that was input as the list param
      */
    queryBounds(b: Bounds<any>, list: T[], visit?: IVisitFunction<T>): T[];
    /**
      * Queries children for intersection with a point
      *
      * @param p     The Point to test children against
      * @param list  The list of children to aggregate into the query
      * @param visit A callback function that will receive the Node as it is analyzed. This gives
      *              information on a spatial scale, how a query reaches it's target intersections.
      *
      * @return      Returns the exact same list that was input as the list param
      */
    queryPoint(p: any, list: T[], visit?: IVisitFunction<T>): T[];
    /**
      * Creates four sub quadrants for this node.
      */
    split(): void;
    /**
      * Traverses the quad tree returning every quadrant encountered
      *
      * @param cb A callback that has the parameter (node) which is a quadrant in the tree
      */
    visit(cb: IVisitFunction<T>): void;
}
export class QuadTree<T extends Bounds<any>> extends Node<T> {
}

/**
  * This defines an interface for describing dimensions and information about the
  * screen
  */
export interface IScreenContext {
  /** Width of the screen */
  width: number;
  /** Height of the screen */
  height: number;
  /** Half of the screen */
  widthHalf: number;
  /** Half of the height */
  heightHalf: number;
}

/**
  * This defines an object that helps facilitate parts of or complete shape buffers that
  * need regenerating.
  */
export class ShapeBufferCache<T> {
    buffer: T[];
    bustCache: boolean;
    /**
      * Tells this cache to generate what it needs to. If the cache isn't busted,
      * it will not regenerate
      */
    generate(...args: any[]): void;
    /**
      * Sub classes will implement this stub to perform what is necessary to produce
      * a newly updated version of their cache.
      */
    buildCache(...args: any[]): void;
    /**
      * Get the buffer the cache has generated
      */
    getBuffer(): T[];
}

/**
  * This enum names the base methods that are passed into the applyPropsMethods
  * method. This allows subclasses to easily pick the property setting methods they need
  * from the base
  */
export enum BaseApplyPropsMethods {
    /** Initializes any context that needs to be set up before the props are set */
    INITIALIZE = 0,
    /** Moment when any buffer changes should be applied */
    BUFFERCHANGES = 1,
    /** Initializes camera properties to facilitate smoothe start up */
    CAMERA = 2,
    /** Generates the labels as images within the atlas manager */
    LABELS = 3,
}
/**
  * This enum names the base methods that are passed into the animatedMethods
  * method. This allows subsclasses to easily pick the animated methods they need
  * from the base
  */
export enum BaseAnimatedMethods {
    /** Sets up the base context needed to execute most methods */
    CONTEXT = 0,
    /** Sets up the inertia method for inertial panning */
    INERTIA = 1,
    /** Animates the postion of the camera to a destination */
    POSITION = 2,
    /** Zooms the camera based on a point of focus */
    ZOOM = 3,
}
/**
  * This defines a response an apply props method can return.
  *
  * If this response is empty then it assumes all items are false.
  */
export interface IApplyPropsMethodResponse {
    /**
      * If set to true, the system will not execute any remaining apply props methods for this application of props
      * and will resume executing methods next time props are applied starting from the beginning of the list
      */
    break?: boolean;
}
/**
  * This defines a response that an animated method can return. This will
  * give the method some control over the flow of animated methods.
  *
  * If this response is empty then it assumes all items are false.
  */
export interface IAnimatedMethodResponse {
    /**
      * If set to true, the system will not execute any remaining animated methods for the remainder of the frame
      * and will resume executing methods next frame from the beginning of the animated method list
      */
    break?: boolean;
    /**
      * If this is set to true and returned, it will guarantee a redraw will happen after the animated methods
      * have finished executing
      */
    doDraw?: boolean;
    /**
      * If set to true, the system will cease to animate until some task starts up the loop again by calling
      * animate()
      */
    stop?: boolean;
}
export type AnimatedMethod = () => IAnimatedMethodResponse;
export type AnimatedMethodLookup = {
    [key: number]: AnimatedMethod;
};
export type ApplyPropsMethod<T> = (props: T) => IApplyPropsMethodResponse;
export type ApplyPropsMethodLookup<T> = {
    [key: number]: ApplyPropsMethod<T>;
};
export interface IWebGLSurfaceProperties {
    /** When true, will cause a camera recentering to take place when new base items are injected */
    centerOnNewItems?: boolean;
    /** The forced size of the render surface */
    height?: number;
    /** This will be the view the camera focuses on when the camera is initialized */
    viewport?: Bounds<never>;
    /** All of the labels to be rendered by the system */
    labels?: Label<any>[];
    /** Provides feedback when the surface is double clicked */
    onDoubleClick?(e: React.MouseEvent<Element>): void;
    /** Provides feedback when the mouse has moved */
    onMouse?(screen: IPoint, world: IPoint, isPanning: boolean): void;
    /**
      * This is a handler that handles zoom changes the gpu-chart may request.
      * This includes moments such as initializing the camera to focus on a
      * provided viewport.
      */
    onZoomRequest(zoom: number): void;
    /** The forced size of the render surface */
    width?: number;
    /** The zoom level that the camera should apply */
    zoom: number;
}
/**
  * The base component for the communications view
  */
export class WebGLSurface<T extends IWebGLSurfaceProperties, U> extends React.Component<T, U> {
    /** This is the atlas manager for managing images and labels rendered as textures */
    atlasManager: AtlasManager;
    /** Tracks the names of the atlas' generated */
    atlasNames: {
        labels: string;
    };
    /**
      * List of methods that execute within the animation loop. Makes adding and removing these methods
      * simpler to manage, as well as gives a clear and optimized way of overriding existing methods
      * or reordering their execution
      */
    animatedMethodList: AnimatedMethod[];
    /**
      * If this is set to true during an animated method's lifecycle, then all subsequent animated methods
      * will not be executed for the current frame. Upon reaching the end of the frame, the break will reset
      * and the animated methods will attempt executing again
      */
    animatedMethodBreak: boolean;
    /**
      * This viewport is the last viewport applied to the camera.
      * If the props inject a new viewport, this is updated with that value so
      * that the viewport will only be applied once if it doesn't change again.
      */
    appliedViewport: Bounds<any>;
    /** Used to aid in mouse interactions */
    distance: number;
    /**
      * The camera that 'looks' at our world and gives us the ability to convert
      * screen coordinates to world coordinates, and vice versa
      */
    camera: OrthographicCamera | null;
    /** A camera that is used for projecting sizes to and from the screen to the world */
    circleMaterial: ShaderMaterial;
    ctx: IScreenContext;
    /**
      * While this number is positive it will be decremented every frame.
      * While positive, mouse interactions will not occur. This utilizes frame ticks
      * as SOME values and numbers settle per frame, not necessarily within timelapses.
      * More often than not, there will only be a need for 1-2 frames of mouse disable to
      * allow the camera to be positioned in a correct location before screen to world projections
      * start taking place.
      */
    disableMouseInteraction: number;
    forceDraw: boolean;
    projection: IProjection;
    renderEl: HTMLElement;
    renderer: WebGLRenderer;
    scene: Scene;
    sizeCamera: OrthographicCamera | null;
    /** Keep track of the current zoom so it can be set in requestAnimationFrame */
    currentZoom: number;
    /** Horizontal destination the camera will pan to */
    destinationX: number;
    /** Vertical position the camera will pan to */
    destinationY: number;
    /** The destination zoom level the camera used during panning */
    destinationZoom: number;
    /** Is the camera currently in a panning state */
    isPanning: boolean;
    /** Last known screen position of the mouse */
    lastMousePosition: {
        x: number;
        y: number;
    };
    /** List of methods to execute when applying props */
    propsMethodList: ApplyPropsMethod<T>[];
    /** Inertial values for drag panning */
    inertia: IPoint | null;
    inertiaBuild: number;
    inertiaDecay: number;
    inertiaMax: number;
    /**
      * All data is put into this quad tree so we can query spatial regions for
      * items
      */
    quadTree: QuadTree<Bounds<any>> | null;
    /**
      * True if the shift key is currently being held
      *
      * Panning is affected by whether or not the shift key is being held down, but
      * I don't know how yet.
      */
    shiftIsDown: boolean;
    stop: boolean;
    /** The current rendered position and zoom */
    currentX: number;
    currentY: number;
    targetZoom: number;
    /** The (world) position the focus will zoom in and out of */
    previousZoomToFit: number;
    zoomTargetX: number;
    zoomTargetY: number;
    /** When this is set, the draw loop continues to run. Used by the draw loop to complete animations */
    animating: boolean;
    labels: Label<any>[];
    labelsReady: boolean;
    /** Holds the items currently hovered over */
    currentHoverItems: Bounds<any>[];
    /**
      * This is the update loop that operates at the requestAnimationFrame speed.
      * This updates the cameras current position and causes changes over time for
      * any property that has a start and a destination.
      */
    animate: () => void;
    /**
      * This is a hook so subclasses can contribute animated methods to the animation loop and organize the base methods
      * as desired.
      *
      * @param {AnimatedMethodLookup} baseAnimatedMethods The base animated methods referenceable by name
      * @param {AnimatedMethod[]} orderedBaseAnimatedMethods The base animated methods in their default order for ease of use
      *
      * @return {AnimatedMethods[]} The list of animated methods in the order they are expected to be executed
      */
    animatedMethods(baseAnimatedMethods: AnimatedMethodLookup, orderedBaseAnimatedMethods: AnimatedMethod[]): AnimatedMethod[];
    /**
      * This is a hook for subclasses to be able to apply label buffer changes after the system has
      * prepped the labels for render.
      */
    applyLabelBufferChanges(props: T): void;
    /**
      * Applies new props injected into this component.
      *
      * Applying new props does not entail that a re-render will happen so we
      * handle application of props as a separate concept. Here we:
      *
      * set up zoom targetting and apply quested zoom levels
      *
      * Create our quad tree and associate properties to objects if a new dataset
      * is provided
      *
      * Analyze our dataset for interesting and useful metrics such as max and mins
      * to aid in visualization normalization
      *
      * @param {T} props The new properties for this component
      */
    applyProps: (props: T) => void;
    /**
      * @override
      * This is a hook so subclasses can contribute property application methods to the applyProps process and organize the base methods
      * as desired.
      *
      * @param {ApplyPropsMethodLookup<T>} basePropsMethods The base props methods referenceable by name
      * @param {ApplyPropsMethod<T>[]} orderedBasePropsMethods The base animated methods in their default order for ease of use
      *
      * @return {ApplyPropsMethod<T>[]} The list of property application methods in the order they are expected to be executed
      */
    applyPropsMethods(basePropsMethods: ApplyPropsMethodLookup<T>, orderedBasePropsMethods: ApplyPropsMethod<T>[]): ApplyPropsMethod<T>[];
    /**
      * This is a hook for sub components to have a location to update their buffers
      *
      * @param {T} props This is the next set of props that are going to be applied to this component
      */
    applyBufferChanges(props: T): void;
    /**
      * @override
      * Start the update loop and register any interesting listeners
      */
    componentDidMount(): void;
    /**
      * @override
      * This will set up any unchanging context as well as establish the set of methods
      * that are to be used within constructed method loops.
      */
    componentWillMount(): void;
    /**
      * @override
      * Simply applies the new injected props
      *
      * @param {T} props The new properties to be applied to this component
      */
    componentWillReceiveProps(props: T): void;
    /**
      * @override
      * Release listeners and stop update loop
      */
    componentWillUnmount(): void;
    /**
      * This is the draw method executed from the animation loop. Everytime, this is
      * called, the webgl surface will be redrawn.
      */
    draw: () => void;
    /**
      * This initializes the surface and calls for sub class classes to initialize
      * their buffers
      *
      * @param {HTMLElement} el The DOM element this component is contained in
      * @param {number} w The width of the rendering
      * @param {number} h The height of the rendering
      */
    init: (el: HTMLElement, w: number, h: number) => void;
    /**
      * This is a hook allowing sub classes to have a place to initialize their buffers
      * and materials etc.
      */
    initBuffers(): void;
    /**
      * Initializes the camera and any contexts associated with it
      */
    initCamera: () => void;
    /**
      * This is executed when our rendering surface (the canvas) changes in size in any
      * way. It will make sure our renderer matches the context to prevent scaling
      * and other deformations.
      */
    resizeContext: () => boolean;
    /**
      * This method handles emitting the viewport and the current visible elements
      * to the subclass that needs detailed information regarding the viewport.
      */
    emitViewport: () => void;
    /**
      * Hook for subclasses to when the mouse moves. Provides some information
      * about mouse location and interaction.
      *
      * @param {IPoint} mouse Position of the mouse relative to the canvas
      * @param {IPoint} world Position of the mouse relative to the world space
      * @param {boolean} isPanning The panning state of the mouse
      */
    onMouse(mouse: IPoint, world: IPoint, isPanning: boolean): void;
    /**
      * Hook for subclasses to respond to mouse down events
      */
    onMouseDown(): void;
    /**
      * Hook for subclasses to respond to mouse out events
      */
    onMouseOut(): void;
    /**
      * Hook for subclasses to respond to mouse up events and the items that were interacted with in the process
      *
      * @param {React.MouseEvent} e The react synthetic event associated with the action
      * @param {Bounds[]} hitInside The items the mouse interacted with
      * @param {IPoint} mouse The location of the mouse on the screen
      * @param {IPoint} world The location of the mouse projected into the world
      * @param {IProjection} projection The projection methods to go between the screen and world space
      */
    onMouseUp(e: React.MouseEvent<HTMLDivElement>, hitInside: Bounds<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    /**
      * Hook for subclasses to respond to the mouse hovering over an item included in the quadtree
      *
      * @param {Bounds[]} hitInside The items hovered over by the mouse
      * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas
      * @param {IPoint} world The location of the mouse projected to the world coordinates
      * @param {IProjection} projection The projection methods to go between the screen and world space
      */
    onMouseHover(hitInside: Bounds<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    /**
      * Hook for subclasses to respond to the mouse leaving an item included in the quadtree
      *
      * @param {Bounds[]} left The items no longer hovered over by the mouse
      * @param {IPoint} mouse The location of the mouse on the screen relative to the canvas
      * @param {IPoint} world The location of the mouse projected to the world coordinates
      * @param {IProjection} projection The projection methods to go between the screen and world space
      */
    onMouseLeave(left: Bounds<any>[], mouse: IPoint, world: IPoint, projection: IProjection): void;
    /**
      * Hook for subclasses to respond to changes in the viewport and currently visible items
      *
      * @param {Bounds[]} visible
      * @param {IProjection} projection The projection methods to go between the screen and world space
      * @param {IScreenContext} ctx
      */
    onViewport(visible: Bounds<any>[], projection: IProjection, ctx: IScreenContext): void;
    /**
      * Handles mouse interactions when the mouse is pressed on the canvas. This
      * engages panning.
      *
      * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React
      */
    handleMouseDown: (e: React.MouseEvent<HTMLDivElement>) => void;
    /**
      * Handles mouse interactions when the mouse is release or left the canvas. This
      * stops panning.
      *
      * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React
      */
    handleMouseOut: (e: React.MouseEvent<HTMLDivElement>) => void;
    /**
      * Handles mouse interactions when the mouse is released on the canvas. This
      * stops panning and engages click events.
      *
      * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React
      */
    handleMouseUp: (e: React.MouseEvent<HTMLDivElement>) => void;
    /**
      * Handles mouse interactions when the mouse is moving on the canvas. This
      * causes panning and hover events.
      *
      * @param {React.MouseEvent<HTMLDivElement>} e The mouse event from React
      */
    handleMouseMove: (e: React.MouseEvent<HTMLDivElement>) => void;
    /**
      * Places the camera at a given location in world space
      *
      * @param {number} x The x-coordinate for the camera in world space
      * @param {number} y The x-coordinate for the camera in world space
      */
    positionCamera(x: number, y: number): void;
    /**
      * Projects a screen coordinate to a world coordinate
      *
      * @param {number} x The x coord within the screen to project into the world
      * @param {number} y The y coord within the screen to project into the world
      * @param {object} obj An optional object in which the projected dimensions will
      *                     be injected to
      *
      * @return {object} Either a new object with the projected dimensions or the object
      *                  Insertted as a param that has the properties injected into
      */
    screenToWorld(x: number, y: number, obj?: IPoint): IPoint;
    /**
      * Projects a size on the screen to the size represented in the world
      *
      * @param {number} w The size of the width on the screen to project to the world
      * @param {number} h The size of the height on the screen to project to the world
      * @param {object} obj An optional object in which the projected dimensions will
      *                     be injected to
      *
      * @return {object} Either a new object with the projected dimensions or the object
      *                  Insertted as a param that has the properties injected into
      */
    screenSizeToWorld(w: number, h: number, obj?: ISize): ISize;
    /**
      * Projects a world coordinate to the screen
      *
      * @param {number} x The x coord in the world to project to the screen
      * @param {number} y The y coord in the world to project to the screen
      * @param {object} obj An optional object in which the projected dimensions will
      *                     be injected to
      *
      * @return {IPoint} Either a new object with the projected dimensions or the object
      *                  Insertted as a param that has the properties injected into
      */
    worldToScreen(x: number, y: number, obj?: IPoint): IPoint;
    /**
      * Projects a size within the world to how it would appear on the screen
      *
      * @param {number} w The size of the width on the screen to project to the world
      * @param {number} h The size of the height on the screen to project to the world
      * @param {object} obj An optional object in which the projected dimensions will
      *                     be injected to
      *
      * @return {object} Either a new object with the projected dimensions or the object
      *                  Insertted as a param that has the properties injected into
      */
    worldSizeToScreen(w: number, h: number, obj?: ISize): ISize;
    /**
      * Sets the zoom level the camera will view the world with
      *
      * @param {number} zoom The zoom level. Must be > 0
      */
    zoomCamera(zoom: number): void;
    /**
      * This is a hook allowing a sub class to update uniforms when the camera is changed in
      * any way
      */
    updateCameraUniforms(): void;
    /**
      * We make the ref application be a declared function so react does not find the need to execute the
      * application numerous times for a detected changed method
      *
      * @param {HTMLElement} n This is the canvas element from the dom
      */
    applyRef: (n: HTMLElement) => void;
    /**
      * @override
      * Only re-render if the dimensions of the component have changed. All other
      * internal render updates are handled internally
      *
      * @param {T} nextProps The next properties injected
      */
    shouldComponentUpdate(nextProps: T): boolean;
    /**
      * Hook to allow subclasses some control over panning distances
      *
      * @param {number} distanceX The distance to pan in the x direction
      * @param {number} distanceY The distance to pan in the y direction
      *
      * @return {Vector3} The vector indicating the direction to pan
      */
    willPan(distanceX: number, distanceY: number): Vector3;
    /**
      * This should only attempt rendering when the canvas DOM element needs to be resized.
      * You will note shouldComponentUpdate helps facilitate this.
      */
    render(): JSX.Element;
}


}